CCS PCH C Compiler, Version 5.094d, 1               14-Apr-20 13:35
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\pdelacruz\Downloads\AutomatizacionRobotica\BeepControl\18f4550+enc28j60_RyP.lst

               ROM used:   28780 bytes (88%)
                           Largest free fragment is 3986
               RAM used:   739 (36%) at main() level
                           930 (45%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

0000:  GOTO   6E04
*
0008:  MOVWF  08
000A:  MOVFF  FD8,09
000E:  MOVFF  FE0,0A
0012:  MOVLB  0
0014:  MOVFF  FE9,10
0018:  MOVFF  FEA,0B
001C:  MOVFF  FE1,0C
0020:  MOVFF  FE2,0D
0024:  MOVFF  FD9,0E
0028:  MOVFF  FDA,0F
002C:  MOVFF  FF3,16
0030:  MOVFF  FF4,17
0034:  MOVFF  FFA,18
0038:  MOVFF  FF5,19
003C:  MOVFF  FF6,1A
0040:  MOVFF  FF7,1B
0044:  MOVFF  00,12
0048:  MOVFF  01,13
004C:  MOVFF  02,14
0050:  MOVFF  03,15
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00AE
0060:  MOVFF  12,00
0064:  MOVFF  13,01
0068:  MOVFF  14,02
006C:  MOVFF  15,03
0070:  MOVFF  10,FE9
0074:  MOVFF  0B,FEA
0078:  BSF    0B.7
007A:  MOVFF  0C,FE1
007E:  MOVFF  0D,FE2
0082:  MOVFF  0E,FD9
0086:  MOVFF  0F,FDA
008A:  MOVFF  16,FF3
008E:  MOVFF  17,FF4
0092:  MOVFF  18,FFA
0096:  MOVFF  19,FF5
009A:  MOVFF  1A,FF6
009E:  MOVFF  1B,FF7
00A2:  MOVF   08,W
00A4:  MOVFF  0A,FE0
00A8:  MOVFF  09,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
*
00CE:  DATA 3C,48
00D0:  DATA 54,4D
00D2:  DATA 4C,3E
00D4:  DATA 3C,42
00D6:  DATA 4F,44
00D8:  DATA 59,3E
00DA:  DATA 3C,48
00DC:  DATA 31,3E
00DE:  DATA 34,30
00E0:  DATA 34,20
00E2:  DATA 45,72
00E4:  DATA 72,6F
00E6:  DATA 72,3C
00E8:  DATA 2F,48
00EA:  DATA 31,3E
00EC:  DATA 3C,48
00EE:  DATA 52,3E
00F0:  DATA 3C,50
00F2:  DATA 3E,46
00F4:  DATA 69,6C
00F6:  DATA 65,20
00F8:  DATA 4E,6F
00FA:  DATA 74,20
00FC:  DATA 66,6F
00FE:  DATA 75,6E
0100:  DATA 64,2E
0102:  DATA 3C,2F
0104:  DATA 42,4F
0106:  DATA 44,59
0108:  DATA 3E,3C
010A:  DATA 2F,48
010C:  DATA 54,4D
010E:  DATA 4C,3E
0110:  DATA 00,00
0112:  DATA 3C,48
0114:  DATA 54,4D
0116:  DATA 4C,3E
0118:  DATA 3C,42
011A:  DATA 4F,44
011C:  DATA 59,3E
011E:  DATA 3C,48
0120:  DATA 31,3E
0122:  DATA 35,30
0124:  DATA 30,20
0126:  DATA 45,72
0128:  DATA 72,6F
012A:  DATA 72,3C
012C:  DATA 2F,48
012E:  DATA 31,3E
0130:  DATA 3C,48
0132:  DATA 52,3E
0134:  DATA 3C,50
0136:  DATA 3E,49
0138:  DATA 6E,74
013A:  DATA 65,72
013C:  DATA 6E,61
013E:  DATA 6C,20
0140:  DATA 53,65
0142:  DATA 72,76
0144:  DATA 65,72
0146:  DATA 20,45
0148:  DATA 72,72
014A:  DATA 6F,72
014C:  DATA 3C,2F
014E:  DATA 42,4F
0150:  DATA 44,59
0152:  DATA 3E,3C
0154:  DATA 2F,48
0156:  DATA 54,4D
0158:  DATA 4C,3E
015A:  DATA 00,00
015C:  DATA 48,54
015E:  DATA 54,50
0160:  DATA 2F,31
0162:  DATA 2E,30
0164:  DATA 20,25
0166:  DATA 4C,55
0168:  DATA 20,00
016A:  DATA 4E,6F
016C:  DATA 74,20
016E:  DATA 66,6F
0170:  DATA 75,6E
0172:  DATA 64,00
0174:  DATA 53,65
0176:  DATA 72,76
0178:  DATA 65,72
017A:  DATA 20,45
017C:  DATA 72,72
017E:  DATA 6F,72
0180:  DATA 00,00
0182:  DATA 0D,0A
0184:  DATA 43,6F
0186:  DATA 6E,74
0188:  DATA 65,6E
018A:  DATA 74,2D
018C:  DATA 54,79
018E:  DATA 70,65
0190:  DATA 3A,20
0192:  DATA 00,00
0194:  DATA 74,65
0196:  DATA 78,74
0198:  DATA 2F,68
019A:  DATA 74,6D
019C:  DATA 6C,00
019E:  DATA 0D,0A
01A0:  DATA 0D,0A
01A2:  DATA 00,00
01A4:  DATA 20,0A
01A6:  DATA 3C,48
01A8:  DATA 54,4D
01AA:  DATA 4C,3E
01AC:  DATA 3C,42
01AE:  DATA 4F,44
01B0:  DATA 59,20
01B2:  DATA 42,47
01B4:  DATA 43,4F
01B6:  DATA 4C,4F
01B8:  DATA 52,3D
01BA:  DATA 23,46
01BC:  DATA 46,46
01BE:  DATA 46,46
01C0:  DATA 46,20
01C2:  DATA 54,45
01C4:  DATA 58,54
01C6:  DATA 3D,23
01C8:  DATA 30,30
01CA:  DATA 30,30
01CC:  DATA 30,30
01CE:  DATA 3E,20
01D0:  DATA 0A,20
01D2:  DATA 0A,3C
01D4:  DATA 63,65
01D6:  DATA 6E,74
01D8:  DATA 65,72
01DA:  DATA 3E,3C
01DC:  DATA 48,31
01DE:  DATA 3E,42
01E0:  DATA 65,65
01E2:  DATA 70,43
01E4:  DATA 6F,6E
01E6:  DATA 74,72
01E8:  DATA 6F,6C
01EA:  DATA 20,3C
01EC:  DATA 2F,48
01EE:  DATA 31,3E
01F0:  DATA 3C,2F
01F2:  DATA 63,65
01F4:  DATA 6E,74
01F6:  DATA 65,72
01F8:  DATA 3E,20
01FA:  DATA 0A,3C
01FC:  DATA 42,52
01FE:  DATA 3E,3C
0200:  DATA 63,65
0202:  DATA 6E,74
0204:  DATA 65,72
0206:  DATA 3E,3C
0208:  DATA 48,32
020A:  DATA 3E,44
020C:  DATA 61,73
020E:  DATA 68,62
0210:  DATA 6F,61
0212:  DATA 72,64
0214:  DATA 3C,2F
0216:  DATA 48,32
0218:  DATA 3E,3C
021A:  DATA 2F,43
021C:  DATA 45,4E
021E:  DATA 54,45
0220:  DATA 52,3E
0222:  DATA 20,0A
0224:  DATA 20,0A
0226:  DATA 20,0A
0228:  DATA 3C,46
022A:  DATA 4F,52
022C:  DATA 4D,20
022E:  DATA 4D,45
0230:  DATA 54,48
0232:  DATA 4F,44
0234:  DATA 3D,47
0236:  DATA 45,54
0238:  DATA 3E,20
023A:  DATA 0A,3C
023C:  DATA 50,3E
023E:  DATA 4C,43
0240:  DATA 44,3A
0242:  DATA 20,3C
0244:  DATA 49,4E
0246:  DATA 50,55
0248:  DATA 54,20
024A:  DATA 54,59
024C:  DATA 50,45
024E:  DATA 3D,22
0250:  DATA 74,65
0252:  DATA 78,74
0254:  DATA 22,20
0256:  DATA 4E,41
0258:  DATA 4D,45
025A:  DATA 3D,22
025C:  DATA 6C,63
025E:  DATA 64,22
0260:  DATA 20,73
0262:  DATA 69,7A
0264:  DATA 65,3D
0266:  DATA 32,30
0268:  DATA 20,6D
026A:  DATA 61,78
026C:  DATA 6C,65
026E:  DATA 6E,67
0270:  DATA 74,68
0272:  DATA 3D,31
0274:  DATA 36,3E
0276:  DATA 20,0A
0278:  DATA 3C,69
027A:  DATA 6E,70
027C:  DATA 75,74
027E:  DATA 20,74
0280:  DATA 79,70
0282:  DATA 65,3D
0284:  DATA 22,73
0286:  DATA 75,62
0288:  DATA 6D,69
028A:  DATA 74,22
028C:  DATA 20,76
028E:  DATA 61,6C
0290:  DATA 75,65
0292:  DATA 3D,22
0294:  DATA 45,6E
0296:  DATA 76,69
0298:  DATA 61,72
029A:  DATA 20,74
029C:  DATA 65,78
029E:  DATA 74,6F
02A0:  DATA 22,3E
02A2:  DATA 20,0A
02A4:  DATA 3C,2F
02A6:  DATA 46,4F
02A8:  DATA 52,4D
02AA:  DATA 3E,20
02AC:  DATA 0A,20
02AE:  DATA 0A,3C
02B0:  DATA 46,4F
02B2:  DATA 52,4D
02B4:  DATA 20,4D
02B6:  DATA 45,54
02B8:  DATA 48,4F
02BA:  DATA 44,3D
02BC:  DATA 47,45
02BE:  DATA 54,3E
02C0:  DATA 20,0A
02C2:  DATA 3C,69
02C4:  DATA 6E,70
02C6:  DATA 75,74
02C8:  DATA 20,74
02CA:  DATA 79,70
02CC:  DATA 65,3D
02CE:  DATA 22,73
02D0:  DATA 75,62
02D2:  DATA 6D,69
02D4:  DATA 74,22
02D6:  DATA 20,6E
02D8:  DATA 61,6D
02DA:  DATA 65,3D
02DC:  DATA 22,43
02DE:  DATA 4D,31
02E0:  DATA 22,20
02E2:  DATA 76,61
02E4:  DATA 6C,75
02E6:  DATA 65,3D
02E8:  DATA 22,41
02EA:  DATA 22,3E
02EC:  DATA 20,0A
02EE:  DATA 3C,69
02F0:  DATA 6E,70
02F2:  DATA 75,74
02F4:  DATA 20,74
02F6:  DATA 79,70
02F8:  DATA 65,3D
02FA:  DATA 22,73
02FC:  DATA 75,62
02FE:  DATA 6D,69
0300:  DATA 74,22
0302:  DATA 20,6E
0304:  DATA 61,6D
0306:  DATA 65,3D
0308:  DATA 22,43
030A:  DATA 4D,31
030C:  DATA 22,20
030E:  DATA 76,61
0310:  DATA 6C,75
0312:  DATA 65,3D
0314:  DATA 22,43
0316:  DATA 22,3E
0318:  DATA 20,0A
031A:  DATA 3C,69
031C:  DATA 6E,70
031E:  DATA 75,74
0320:  DATA 20,74
0322:  DATA 79,70
0324:  DATA 65,3D
0326:  DATA 22,73
0328:  DATA 75,62
032A:  DATA 6D,69
032C:  DATA 74,22
032E:  DATA 20,6E
0330:  DATA 61,6D
0332:  DATA 65,3D
0334:  DATA 22,43
0336:  DATA 4D,31
0338:  DATA 22,20
033A:  DATA 76,61
033C:  DATA 6C,75
033E:  DATA 65,3D
0340:  DATA 22,5A
0342:  DATA 22,3E
0344:  DATA 20,0A
0346:  DATA 3C,2F
0348:  DATA 46,4F
034A:  DATA 52,4D
034C:  DATA 3E,20
034E:  DATA 0A,3C
0350:  DATA 46,4F
0352:  DATA 52,4D
0354:  DATA 20,4D
0356:  DATA 45,54
0358:  DATA 48,4F
035A:  DATA 44,3D
035C:  DATA 47,45
035E:  DATA 54,3E
0360:  DATA 20,0A
0362:  DATA 3C,69
0364:  DATA 6E,70
0366:  DATA 75,74
0368:  DATA 20,74
036A:  DATA 79,70
036C:  DATA 65,3D
036E:  DATA 22,73
0370:  DATA 75,62
0372:  DATA 6D,69
0374:  DATA 74,22
0376:  DATA 20,6E
0378:  DATA 61,6D
037A:  DATA 65,3D
037C:  DATA 22,43
037E:  DATA 4D,32
0380:  DATA 22,20
0382:  DATA 76,61
0384:  DATA 6C,75
0386:  DATA 65,3D
0388:  DATA 22,41
038A:  DATA 22,3E
038C:  DATA 20,0A
038E:  DATA 3C,69
0390:  DATA 6E,70
0392:  DATA 75,74
0394:  DATA 20,74
0396:  DATA 79,70
0398:  DATA 65,3D
039A:  DATA 22,73
039C:  DATA 75,62
039E:  DATA 6D,69
03A0:  DATA 74,22
03A2:  DATA 20,6E
03A4:  DATA 61,6D
03A6:  DATA 65,3D
03A8:  DATA 22,43
03AA:  DATA 4D,32
03AC:  DATA 22,20
03AE:  DATA 76,61
03B0:  DATA 6C,75
03B2:  DATA 65,3D
03B4:  DATA 22,43
03B6:  DATA 22,3E
03B8:  DATA 20,0A
03BA:  DATA 3C,69
03BC:  DATA 6E,70
03BE:  DATA 75,74
03C0:  DATA 20,74
03C2:  DATA 79,70
03C4:  DATA 65,3D
03C6:  DATA 22,73
03C8:  DATA 75,62
03CA:  DATA 6D,69
03CC:  DATA 74,22
03CE:  DATA 20,6E
03D0:  DATA 61,6D
03D2:  DATA 65,3D
03D4:  DATA 22,43
03D6:  DATA 4D,32
03D8:  DATA 22,20
03DA:  DATA 76,61
03DC:  DATA 6C,75
03DE:  DATA 65,3D
03E0:  DATA 22,5A
03E2:  DATA 22,3E
03E4:  DATA 20,0A
03E6:  DATA 3C,2F
03E8:  DATA 46,4F
03EA:  DATA 52,4D
03EC:  DATA 3E,20
03EE:  DATA 0A,3C
03F0:  DATA 46,4F
03F2:  DATA 52,4D
03F4:  DATA 20,4D
03F6:  DATA 45,54
03F8:  DATA 48,4F
03FA:  DATA 44,3D
03FC:  DATA 47,45
03FE:  DATA 54,3E
0400:  DATA 20,0A
0402:  DATA 3C,69
0404:  DATA 6E,70
0406:  DATA 75,74
0408:  DATA 20,74
040A:  DATA 79,70
040C:  DATA 65,3D
040E:  DATA 22,73
0410:  DATA 75,62
0412:  DATA 6D,69
0414:  DATA 74,22
0416:  DATA 20,6E
0418:  DATA 61,6D
041A:  DATA 65,3D
041C:  DATA 22,43
041E:  DATA 4D,33
0420:  DATA 22,20
0422:  DATA 76,61
0424:  DATA 6C,75
0426:  DATA 65,3D
0428:  DATA 22,41
042A:  DATA 22,3E
042C:  DATA 20,0A
042E:  DATA 3C,69
0430:  DATA 6E,70
0432:  DATA 75,74
0434:  DATA 20,74
0436:  DATA 79,70
0438:  DATA 65,3D
043A:  DATA 22,73
043C:  DATA 75,62
043E:  DATA 6D,69
0440:  DATA 74,22
0442:  DATA 20,6E
0444:  DATA 61,6D
0446:  DATA 65,3D
0448:  DATA 22,43
044A:  DATA 4D,33
044C:  DATA 22,20
044E:  DATA 76,61
0450:  DATA 6C,75
0452:  DATA 65,3D
0454:  DATA 22,43
0456:  DATA 22,3E
0458:  DATA 20,0A
045A:  DATA 3C,69
045C:  DATA 6E,70
045E:  DATA 75,74
0460:  DATA 20,74
0462:  DATA 79,70
0464:  DATA 65,3D
0466:  DATA 22,73
0468:  DATA 75,62
046A:  DATA 6D,69
046C:  DATA 74,22
046E:  DATA 20,6E
0470:  DATA 61,6D
0472:  DATA 65,3D
0474:  DATA 22,43
0476:  DATA 4D,33
0478:  DATA 22,20
047A:  DATA 76,61
047C:  DATA 6C,75
047E:  DATA 65,3D
0480:  DATA 22,5A
0482:  DATA 22,3E
0484:  DATA 20,0A
0486:  DATA 3C,2F
0488:  DATA 46,4F
048A:  DATA 52,4D
048C:  DATA 3E,20
048E:  DATA 0A,3C
0490:  DATA 2F,42
0492:  DATA 4F,44
0494:  DATA 59,3E
0496:  DATA 3C,2F
0498:  DATA 48,54
049A:  DATA 4D,4C
049C:  DATA 3E,20
049E:  DATA 0A,00
04A0:  DATA 43,00
04A2:  DATA 41,00
04A4:  DATA 5A,00
04A6:  DATA 00,00
04A8:  DATA 0C,55
04AA:  DATA 6E,69
04AC:  DATA 76,65
04AE:  DATA 72,73
04B0:  DATA 69,64
04B2:  DATA 61,64
04B4:  DATA 20,41
04B6:  DATA 50,45
04B8:  DATA 43,00
04BA:  DATA 4C,61
04BC:  DATA 62,6F
04BE:  DATA 72,61
04C0:  DATA 74,6F
04C2:  DATA 72,69
04C4:  DATA 6F,3A
04C6:  DATA 20,25
04C8:  DATA 75,00
04CA:  DATA 4C,61
04CC:  DATA 62,6F
04CE:  DATA 72,61
04D0:  DATA 74,6F
04D2:  DATA 72,69
04D4:  DATA 6F,3A
04D6:  DATA 20,25
04D8:  DATA 75,00
04DA:  DATA 4C,61
04DC:  DATA 62,6F
04DE:  DATA 72,61
04E0:  DATA 74,6F
04E2:  DATA 72,69
04E4:  DATA 6F,3A
04E6:  DATA 20,25
04E8:  DATA 75,00
04EA:  DATA 4C,61
04EC:  DATA 62,6F
04EE:  DATA 72,61
04F0:  DATA 74,6F
04F2:  DATA 72,69
04F4:  DATA 6F,3A
04F6:  DATA 20,25
04F8:  DATA 75,00
*
0706:  TBLRD*+
0708:  MOVF   FF5,F
070A:  BZ    0724
070C:  MOVFF  FF6,2F4
0710:  MOVFF  FF7,2F5
0714:  MOVFF  FF5,326
0718:  RCALL  069A
071A:  MOVFF  2F4,FF6
071E:  MOVFF  2F5,FF7
0722:  BRA    0706
0724:  GOTO   6F16 (RETURN)
0728:  TBLRD*+
072A:  MOVFF  FF6,2F5
072E:  MOVFF  FF7,2F6
0732:  MOVFF  FF5,326
0736:  RCALL  069A
0738:  MOVFF  2F5,FF6
073C:  MOVFF  2F6,FF7
0740:  MOVLB  2
0742:  DECFSZ xF4,F
0744:  BRA    0748
0746:  BRA    074C
0748:  MOVLB  0
074A:  BRA    0728
074C:  MOVLB  0
074E:  RETURN 0
0750:  MOVLB  3
0752:  MOVF   x3E,W
0754:  CLRF   01
0756:  SUBWF  x3D,W
0758:  BC    0760
075A:  MOVFF  33D,00
075E:  BRA    0778
0760:  CLRF   00
0762:  MOVLW  08
0764:  MOVWF  x3F
0766:  RLCF   x3D,F
0768:  RLCF   00,F
076A:  MOVF   x3E,W
076C:  SUBWF  00,W
076E:  BTFSC  FD8.0
0770:  MOVWF  00
0772:  RLCF   01,F
0774:  DECFSZ x3F,F
0776:  BRA    0766
0778:  MOVLB  0
077A:  RETURN 0
077C:  MOVF   01,W
077E:  MOVFF  2F4,33D
0782:  MOVLW  64
0784:  MOVLB  3
0786:  MOVWF  x3E
0788:  MOVLB  0
078A:  RCALL  0750
078C:  MOVFF  00,2F4
0790:  MOVF   01,W
0792:  MOVLW  30
0794:  BNZ   07A6
0796:  MOVLB  2
0798:  BTFSS  xF5.1
079A:  BRA    07B8
079C:  BTFSC  xF5.3
079E:  BRA    07B8
07A0:  BTFSC  xF5.4
07A2:  MOVLW  20
07A4:  BRA    07AE
07A6:  MOVLB  2
07A8:  BCF    xF5.3
07AA:  BCF    xF5.4
07AC:  BSF    xF5.0
07AE:  ADDWF  01,F
07B0:  MOVFF  01,326
07B4:  MOVLB  0
07B6:  RCALL  069A
07B8:  MOVFF  2F4,33D
07BC:  MOVLW  0A
07BE:  MOVLB  3
07C0:  MOVWF  x3E
07C2:  MOVLB  0
07C4:  RCALL  0750
07C6:  MOVFF  00,2F4
07CA:  MOVF   01,W
07CC:  MOVLW  30
07CE:  BNZ   07E0
07D0:  MOVLB  2
07D2:  BTFSC  xF5.3
07D4:  BRA    07EA
07D6:  BTFSS  xF5.0
07D8:  BRA    07EA
07DA:  BTFSC  xF5.4
07DC:  MOVLW  20
07DE:  MOVLB  0
07E0:  ADDWF  01,F
07E2:  MOVFF  01,326
07E6:  RCALL  069A
07E8:  MOVLB  2
07EA:  MOVLW  30
07EC:  ADDWF  xF4,F
07EE:  MOVFF  2F4,326
07F2:  MOVLB  0
07F4:  RCALL  069A
07F6:  RETURN 0
*
0D46:  MOVLB  3
0D48:  CLRF   x62
0D4A:  CLRF   x63
0D4C:  MOVLW  01
0D4E:  MOVWF  x64
0D50:  CLRF   FDA
0D52:  CLRF   FD9
0D54:  MOVLW  03
0D56:  MOVWF  x67
0D58:  MOVLW  5A
0D5A:  MOVWF  x66
0D5C:  MOVLW  03
0D5E:  MOVWF  FEA
0D60:  MOVLW  5E
0D62:  MOVWF  FE9
0D64:  MOVFF  367,FE2
0D68:  MOVFF  366,FE1
0D6C:  MOVFF  364,365
0D70:  BCF    FD8.0
0D72:  MOVF   FE5,W
0D74:  MULWF  FEE
0D76:  MOVF   FF3,W
0D78:  ADDWFC x62,F
0D7A:  MOVF   FF4,W
0D7C:  ADDWFC x63,F
0D7E:  DECFSZ x65,F
0D80:  BRA    0D70
0D82:  MOVFF  362,FDE
0D86:  MOVFF  363,362
0D8A:  CLRF   x63
0D8C:  BTFSC  FD8.0
0D8E:  INCF   x63,F
0D90:  INCF   x66,F
0D92:  BTFSC  FD8.2
0D94:  INCF   x67,F
0D96:  INCF   x64,F
0D98:  MOVF   x64,W
0D9A:  SUBLW  05
0D9C:  BNZ   0D5C
0D9E:  MOVLB  0
0DA0:  RETURN 0
0DA2:  CLRF   01
0DA4:  CLRF   02
0DA6:  CLRF   00
0DA8:  CLRF   03
0DAA:  MOVLB  2
0DAC:  MOVF   xFD,W
0DAE:  BNZ   0DB4
0DB0:  MOVF   xFC,W
0DB2:  BZ    0DE4
0DB4:  MOVLW  10
0DB6:  MOVWF  xFE
0DB8:  BCF    FD8.0
0DBA:  RLCF   xFA,F
0DBC:  RLCF   xFB,F
0DBE:  RLCF   00,F
0DC0:  RLCF   03,F
0DC2:  MOVF   xFD,W
0DC4:  SUBWF  03,W
0DC6:  BNZ   0DCC
0DC8:  MOVF   xFC,W
0DCA:  SUBWF  00,W
0DCC:  BNC   0DDC
0DCE:  MOVF   xFC,W
0DD0:  SUBWF  00,F
0DD2:  BTFSS  FD8.0
0DD4:  DECF   03,F
0DD6:  MOVF   xFD,W
0DD8:  SUBWF  03,F
0DDA:  BSF    FD8.0
0DDC:  RLCF   01,F
0DDE:  RLCF   02,F
0DE0:  DECFSZ xFE,F
0DE2:  BRA    0DB8
0DE4:  MOVLB  0
0DE6:  GOTO   0E50 (RETURN)
*
3DFE:  ADDWF  FE8,W
3E00:  CLRF   FF7
3E02:  RLCF   FF7,F
3E04:  ADDLW  19
3E06:  MOVWF  FF6
3E08:  MOVLW  3E
3E0A:  ADDWFC FF7,F
3E0C:  TBLRD*-
3E0E:  MOVF   FF5,W
3E10:  MOVWF  FFA
3E12:  TBLRD*
3E14:  MOVF   FF5,W
3E16:  MOVWF  FF9
3E18:  DATA 5C,3B
3E1A:  DATA 64,3B
3E1C:  DATA B6,3B
3E1E:  DATA 6C,3C
3E20:  DATA 9A,3C
3E22:  DATA 9A,3C
3E24:  DATA AA,3C
3E26:  DATA BA,3C
3E28:  DATA D0,3C
*
48DA:  MOVFF  FEA,FE2
48DE:  MOVFF  FE9,FE1
48E2:  CLRF   01
48E4:  BSF    00.0
48E6:  TBLRD*+
48E8:  MOVF   FF5,W
48EA:  BTFSS  00.0
48EC:  BRA    48F8
48EE:  SUBWF  FEE,W
48F0:  BNZ   48F8
48F2:  MOVF   FF5,F
48F4:  BNZ   48E6
48F6:  BRA    4912
48F8:  BCF    00.0
48FA:  MOVF   FF5,F
48FC:  BNZ   48E6
48FE:  INCF   01,F
4900:  BSF    00.0
4902:  MOVFF  FE2,FEA
4906:  MOVFF  FE1,FE9
490A:  TBLRD*
490C:  MOVF   FF5,F
490E:  BNZ   48E6
4910:  SETF   01
4912:  GOTO   4B90 (RETURN)
4916:  MOVLB  3
4918:  MOVF   x31,W
491A:  ANDLW  07
491C:  MOVWF  00
491E:  RRCF   x31,W
4920:  MOVWF  01
4922:  RRCF   01,F
4924:  RRCF   01,F
4926:  MOVLW  1F
4928:  ANDWF  01,F
492A:  MOVF   01,W
492C:  ADDWF  x33,W
492E:  MOVWF  FE9
4930:  MOVLW  00
4932:  ADDWFC x34,W
4934:  MOVWF  FEA
4936:  CLRF   01
4938:  INCF   01,F
493A:  INCF   00,F
493C:  BRA    4940
493E:  RLCF   01,F
4940:  DECFSZ 00,F
4942:  BRA    493E
4944:  MOVF   x32,F
4946:  BZ    494E
4948:  MOVF   01,W
494A:  IORWF  FEF,F
494C:  BRA    4954
494E:  COMF   01,F
4950:  MOVF   01,W
4952:  ANDWF  FEF,F
4954:  MOVLB  0
4956:  RETURN 0
4958:  MOVLB  3
495A:  MOVF   x31,W
495C:  ANDLW  07
495E:  MOVWF  00
4960:  RRCF   x31,W
4962:  MOVWF  01
4964:  RRCF   01,F
4966:  RRCF   01,F
4968:  MOVLW  1F
496A:  ANDWF  01,F
496C:  MOVF   01,W
496E:  ADDWF  x32,W
4970:  MOVWF  FE9
4972:  MOVLW  00
4974:  ADDWFC x33,W
4976:  MOVWF  FEA
4978:  MOVFF  FEF,01
497C:  INCF   00,F
497E:  BRA    4982
4980:  RRCF   01,F
4982:  DECFSZ 00,F
4984:  BRA    4980
4986:  MOVLW  01
4988:  ANDWF  01,F
498A:  MOVLB  0
498C:  GOTO   49CA (RETURN)
*
4B52:  MOVF   FEF,F
4B54:  BZ    4B76
4B56:  MOVFF  FEA,325
4B5A:  MOVFF  FE9,324
4B5E:  MOVFF  FEF,326
4B62:  CALL   069A
4B66:  MOVFF  325,FEA
4B6A:  MOVFF  324,FE9
4B6E:  INCF   FE9,F
4B70:  BTFSC  FD8.2
4B72:  INCF   FEA,F
4B74:  BRA    4B52
4B76:  GOTO   4C90 (RETURN)
*
4D40:  MOVLB  3
4D42:  MOVF   x13,W
4D44:  XORWF  x15,W
4D46:  ANDLW  80
4D48:  MOVWF  x17
4D4A:  BTFSS  x13.7
4D4C:  BRA    4D58
4D4E:  COMF   x12,F
4D50:  COMF   x13,F
4D52:  INCF   x12,F
4D54:  BTFSC  FD8.2
4D56:  INCF   x13,F
4D58:  BTFSS  x15.7
4D5A:  BRA    4D66
4D5C:  COMF   x14,F
4D5E:  COMF   x15,F
4D60:  INCF   x14,F
4D62:  BTFSC  FD8.2
4D64:  INCF   x15,F
4D66:  MOVF   x12,W
4D68:  MULWF  x14
4D6A:  MOVFF  FF3,01
4D6E:  MOVFF  FF4,00
4D72:  MULWF  x15
4D74:  MOVF   FF3,W
4D76:  ADDWF  00,F
4D78:  MOVF   x13,W
4D7A:  MULWF  x14
4D7C:  MOVF   FF3,W
4D7E:  ADDWFC 00,W
4D80:  MOVWF  02
4D82:  BTFSS  x17.7
4D84:  BRA    4D90
4D86:  COMF   01,F
4D88:  COMF   02,F
4D8A:  INCF   01,F
4D8C:  BTFSC  FD8.2
4D8E:  INCF   02,F
4D90:  MOVLB  0
4D92:  GOTO   4E70 (RETURN)
*
5336:  TBLRD*+
5338:  MOVFF  FF6,319
533C:  MOVFF  FF7,31A
5340:  MOVFF  FF5,336
5344:  RCALL  5328
5346:  MOVFF  319,FF6
534A:  MOVFF  31A,FF7
534E:  MOVLB  3
5350:  DECFSZ x18,F
5352:  BRA    5356
5354:  BRA    535A
5356:  MOVLB  0
5358:  BRA    5336
535A:  MOVLB  0
535C:  GOTO   5BFA (RETURN)
5360:  MOVFF  FEA,320
5364:  MOVFF  FE9,31F
5368:  MOVLB  3
536A:  SWAPF  x19,W
536C:  IORLW  F0
536E:  MOVWF  x1B
5370:  ADDWF  x1B,F
5372:  ADDLW  E2
5374:  MOVWF  x1C
5376:  ADDLW  32
5378:  MOVWF  x1E
537A:  MOVF   x19,W
537C:  ANDLW  0F
537E:  ADDWF  x1C,F
5380:  ADDWF  x1C,F
5382:  ADDWF  x1E,F
5384:  ADDLW  E9
5386:  MOVWF  x1D
5388:  ADDWF  x1D,F
538A:  ADDWF  x1D,F
538C:  SWAPF  x18,W
538E:  ANDLW  0F
5390:  ADDWF  x1D,F
5392:  ADDWF  x1E,F
5394:  RLCF   x1D,F
5396:  RLCF   x1E,F
5398:  COMF   x1E,F
539A:  RLCF   x1E,F
539C:  MOVF   x18,W
539E:  ANDLW  0F
53A0:  ADDWF  x1E,F
53A2:  RLCF   x1B,F
53A4:  MOVLW  07
53A6:  MOVWF  x1A
53A8:  MOVLW  0A
53AA:  DECF   x1D,F
53AC:  ADDWF  x1E,F
53AE:  BNC   53AA
53B0:  DECF   x1C,F
53B2:  ADDWF  x1D,F
53B4:  BNC   53B0
53B6:  DECF   x1B,F
53B8:  ADDWF  x1C,F
53BA:  BNC   53B6
53BC:  DECF   x1A,F
53BE:  ADDWF  x1B,F
53C0:  BNC   53BC
53C2:  MOVLW  03
53C4:  MOVWF  FEA
53C6:  MOVLW  1A
53C8:  MOVWF  FE9
53CA:  MOVLW  07
53CC:  ANDWF  x1F,W
53CE:  BCF    x1F.6
53D0:  ADDWF  FE9,F
53D2:  MOVLW  00
53D4:  ADDWFC FEA,F
53D6:  MOVF   FE9,W
53D8:  SUBLW  1E
53DA:  BNZ   53E4
53DC:  MOVF   FEA,W
53DE:  SUBLW  03
53E0:  BNZ   53E4
53E2:  BSF    x1F.6
53E4:  MOVF   FEF,W
53E6:  MOVWF  00
53E8:  BNZ   53FA
53EA:  BTFSC  x1F.6
53EC:  BRA    53FA
53EE:  BTFSC  x1F.4
53F0:  BRA    541C
53F2:  BTFSC  x1F.3
53F4:  BRA    53FA
53F6:  MOVLW  20
53F8:  BRA    5400
53FA:  BSF    x1F.3
53FC:  BCF    x1F.4
53FE:  MOVLW  30
5400:  ADDWF  00,F
5402:  MOVFF  FEA,319
5406:  MOVFF  FE9,318
540A:  MOVFF  00,336
540E:  MOVLB  0
5410:  RCALL  5328
5412:  MOVFF  319,FEA
5416:  MOVFF  318,FE9
541A:  MOVLB  3
541C:  MOVF   FEE,W
541E:  BTFSS  x1F.6
5420:  BRA    53D6
5422:  MOVLB  0
5424:  GOTO   5C0A (RETURN)
5428:  TBLRD*+
542A:  MOVF   FF5,F
542C:  BZ    5446
542E:  MOVFF  FF6,318
5432:  MOVFF  FF7,319
5436:  MOVFF  FF5,336
543A:  RCALL  5328
543C:  MOVFF  318,FF6
5440:  MOVFF  319,FF7
5444:  BRA    5428
5446:  RETURN 0
5448:  MOVF   FEF,F
544A:  BZ    546A
544C:  MOVFF  FEA,319
5450:  MOVFF  FE9,318
5454:  MOVFF  FEF,336
5458:  RCALL  5328
545A:  MOVFF  319,FEA
545E:  MOVFF  318,FE9
5462:  INCF   FE9,F
5464:  BTFSC  FD8.2
5466:  INCF   FEA,F
5468:  BRA    5448
546A:  GOTO   5CC0 (RETURN)
*
5616:  MOVFF  33B,01
561A:  MOVFF  33A,00
561E:  TSTFSZ 00
5620:  INCF   01,F
5622:  TBLRD*+
5624:  MOVFF  FF5,FEE
5628:  DECFSZ 00,F
562A:  BRA    5622
562C:  DECFSZ 01,F
562E:  BRA    5622
5630:  CLRF   FF8
5632:  RETURN 0
*
58A0:  MOVFF  79,FEA
58A4:  MOVFF  78,FE9
58A8:  MOVFF  33D,FEF
58AC:  INCF   FE9,F
58AE:  BTFSC  FD8.2
58B0:  INCF   FEA,F
58B2:  CLRF   FEF
58B4:  MOVLB  0
58B6:  INCF   x78,F
58B8:  BTFSC  FD8.2
58BA:  INCF   x79,F
58BC:  RETURN 0
58BE:  MOVLB  3
58C0:  BTFSC  x38.7
58C2:  BRA    58E6
58C4:  MOVLW  0F
58C6:  MOVWF  00
58C8:  SWAPF  x37,W
58CA:  ANDWF  00,F
58CC:  MOVLW  0A
58CE:  SUBWF  00,W
58D0:  BC    58D8
58D2:  MOVLW  30
58D4:  ADDWF  00,F
58D6:  BRA    58DC
58D8:  MOVF   x38,W
58DA:  ADDWF  00,F
58DC:  MOVFF  00,33D
58E0:  MOVLB  0
58E2:  RCALL  58A0
58E4:  MOVLB  3
58E6:  MOVLW  0F
58E8:  ANDWF  x37,F
58EA:  MOVLW  0A
58EC:  SUBWF  x37,W
58EE:  BC    58F4
58F0:  MOVLW  30
58F2:  BRA    58F8
58F4:  BCF    x38.7
58F6:  MOVF   x38,W
58F8:  ADDWF  x37,F
58FA:  MOVFF  337,33D
58FE:  MOVLB  0
5900:  RCALL  58A0
5902:  GOTO   5AB6 (RETURN)
5906:  MOVLW  20
5908:  MOVLB  3
590A:  BTFSS  x38.4
590C:  MOVLW  30
590E:  MOVWF  x39
5910:  MOVFF  337,00
5914:  BTFSS  00.7
5916:  BRA    5928
5918:  COMF   00,F
591A:  INCF   00,F
591C:  MOVFF  00,337
5920:  MOVLW  2D
5922:  MOVWF  x39
5924:  BSF    x38.7
5926:  BSF    x38.0
5928:  MOVF   01,W
592A:  MOVFF  337,33D
592E:  MOVLW  64
5930:  MOVWF  x3E
5932:  MOVLB  0
5934:  CALL   0750
5938:  MOVFF  00,337
593C:  MOVLW  30
593E:  ADDWF  01,W
5940:  MOVLB  3
5942:  MOVWF  x3A
5944:  MOVFF  337,33D
5948:  MOVLW  0A
594A:  MOVWF  x3E
594C:  MOVLB  0
594E:  CALL   0750
5952:  MOVLW  30
5954:  ADDWF  00,W
5956:  MOVLB  3
5958:  MOVWF  x3C
595A:  MOVLW  30
595C:  ADDWF  01,W
595E:  MOVWF  x3B
5960:  MOVFF  339,00
5964:  MOVLW  30
5966:  SUBWF  x3A,W
5968:  BZ    5972
596A:  BSF    x38.1
596C:  BTFSC  x38.7
596E:  BSF    x38.2
5970:  BRA    5996
5972:  MOVFF  339,33A
5976:  MOVLW  20
5978:  MOVWF  x39
597A:  MOVLW  30
597C:  SUBWF  x3B,W
597E:  BZ    5988
5980:  BSF    x38.0
5982:  BTFSC  x38.7
5984:  BSF    x38.1
5986:  BRA    5996
5988:  BTFSS  FD8.2
598A:  BSF    x38.0
598C:  BNZ   5996
598E:  MOVFF  33A,33B
5992:  MOVLW  20
5994:  MOVWF  x3A
5996:  BTFSC  x38.2
5998:  BRA    59A4
599A:  BTFSC  x38.1
599C:  BRA    59AC
599E:  BTFSC  x38.0
59A0:  BRA    59B4
59A2:  BRA    59BC
59A4:  MOVFF  339,33D
59A8:  MOVLB  0
59AA:  RCALL  58A0
59AC:  MOVFF  33A,33D
59B0:  MOVLB  0
59B2:  RCALL  58A0
59B4:  MOVFF  33B,33D
59B8:  MOVLB  0
59BA:  RCALL  58A0
59BC:  MOVFF  33C,33D
59C0:  MOVLB  0
59C2:  RCALL  58A0
59C4:  GOTO   5AEC (RETURN)
*
6DDC:  ADDWF  FE8,W
6DDE:  CLRF   FF7
6DE0:  RLCF   FF7,F
6DE2:  ADDLW  F7
6DE4:  MOVWF  FF6
6DE6:  MOVLW  6D
6DE8:  ADDWFC FF7,F
6DEA:  TBLRD*-
6DEC:  MOVF   FF5,W
6DEE:  MOVWF  FFA
6DF0:  TBLRD*
6DF2:  MOVF   FF5,W
6DF4:  MOVWF  FF9
6DF6:  DATA 54,6C
6DF8:  DATA 54,6C
6DFA:  DATA A6,6C
6DFC:  DATA 2C,6D
6DFE:  DATA 8A,6D
6E00:  DATA 9A,6C
6E02:  DATA 06,6D
.................... 
.................... #list
.................... 
.................... #device ADC=8
.................... #use delay(clock=20000000)
*
04FA:  MOVLW  03
04FC:  MOVWF  FEA
04FE:  MOVLW  2D
0500:  MOVWF  FE9
0502:  MOVF   FEF,W
0504:  BZ    0520
0506:  MOVLW  06
0508:  MOVWF  01
050A:  CLRF   00
050C:  DECFSZ 00,F
050E:  BRA    050C
0510:  DECFSZ 01,F
0512:  BRA    050A
0514:  MOVLW  7B
0516:  MOVWF  00
0518:  DECFSZ 00,F
051A:  BRA    0518
051C:  DECFSZ FEF,F
051E:  BRA    0506
0520:  RETURN 0
*
4990:  MOVLW  03
4992:  MOVLB  3
4994:  SUBWF  x32,F
4996:  BNC   49AC
4998:  MOVLW  03
499A:  MOVWF  FEA
499C:  MOVLW  32
499E:  MOVWF  FE9
49A0:  MOVF   FEF,W
49A2:  BZ    49AC
49A4:  BRA    49A8
49A6:  BRA    49A8
49A8:  DECFSZ FEF,F
49AA:  BRA    49A6
49AC:  MOVLB  0
49AE:  RETURN 0
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,VREGEN,NOPBADEN,WRTB
.................... 
.................... #byte porte = 0xF84
.................... #byte trisc=0x87
.................... #byte portc = 0x07
.................... #byte trisa=0xff
.................... #byte porta=0xff
.................... 
.................... /** Configuración para el uso del stack tcip **/
.................... #define STACK_USE_ICMP        1  //Módulo de respuesta ICMP (ping)
.................... #define STACK_USE_ARP         1  //Para solucionar direccionamiento MAC de las IP
.................... #define STACK_USE_TCP         1  //Para enviar paquetes TCP 
.................... #define STACK_USE_HTTP        1  //Uso de las funciones http del stack.
.................... #define STACK_USE_CCS_PICENS  1  //CCS PICENS (Embedded Ethernet) 18F4620 + ENC28J60
.................... #define STACK_USE_MCPENC      1  //Uso del enc28j60 por el stack (stacktsk.c)
.................... #define STACK_USE_MAC         1  //Uso de la tarjeta de red
.................... #define HTTP_SOCKET 80         //Nº de puerto asociado al socket.
.................... #define ENC_MAC_USE_SPI 1           //Uso del SPI por hardware
.................... #define PIN_ENC_MAC_SO  PIN_B0      //Entrada serie de datos
.................... #define PIN_ENC_MAC_CS  PIN_B2      //Chip select
.................... #define PIN_ENC_MAC_RST PIN_B3      //Reset
.................... #define PIN_ENC_MAC_INT PIN_B4      //Interrupción
.................... #use STANDARD_IO( A )
.................... #define PIN_LED_IN_1   PIN_A4
.................... #define PIN_LED_IN_2   PIN_A5
.................... #define PIN_LED_IN_3   PIN_A6
.................... /******************************************************************************/
.................... 
.................... #define use_portd_lcd TRUE       //Uso del puerto d para control del lcd
.................... #include <lcd.c>    //Carga librería del lcd de 4x20 para familia 18F
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
....................    output_float(LCD_DATA5);
....................    output_float(LCD_DATA6);
....................    output_float(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0xF;
*
0550:  MOVLW  0F
0552:  ANDWF  F95,W
0554:  IORLW  F0
0556:  MOVWF  F95
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
0558:  BSF    F8C.2
....................    delay_cycles(1);
055A:  NOP   
....................    lcd_output_enable(1);
055C:  BSF    F8C.0
....................    delay_cycles(1);
055E:  NOP   
....................    high = lcd_read_nibble();
0560:  RCALL  0544
0562:  MOVFF  01,32E
....................       
....................    lcd_output_enable(0);
0566:  BCF    F8C.0
....................    delay_cycles(1);
0568:  NOP   
....................    lcd_output_enable(1);
056A:  BSF    F8C.0
....................    delay_us(1);
056C:  BRA    056E
056E:  BRA    0570
0570:  NOP   
....................    low = lcd_read_nibble();
0572:  RCALL  0544
0574:  MOVFF  01,32D
....................       
....................    lcd_output_enable(0);
0578:  BCF    F8C.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
057A:  MOVLW  0F
057C:  ANDWF  F95,W
057E:  MOVWF  F95
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
0580:  MOVLB  3
0582:  SWAPF  x2E,W
0584:  MOVWF  00
0586:  MOVLW  F0
0588:  ANDWF  00,F
058A:  MOVF   00,W
058C:  IORWF  x2D,W
058E:  MOVWF  01
0590:  MOVLB  0
0592:  GOTO   05A0 (RETURN)
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
....................    n |= input(LCD_DATA5) << 1;
....................    n |= input(LCD_DATA6) << 2;
....................    n |= input(LCD_DATA7) << 3;
....................    
....................    return(n);
....................   #else
....................    return(lcd.data);
*
0544:  MOVF   F83,W
0546:  MOVWF  00
0548:  SWAPF  00,W
054A:  ANDLW  0F
054C:  MOVWF  01
....................   #endif
054E:  RETURN 0
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
....................    output_bit(LCD_DATA5, bit_test(n, 1));
....................    output_bit(LCD_DATA6, bit_test(n, 2));
....................    output_bit(LCD_DATA7, bit_test(n, 3));
....................   #else      
....................    lcdlat.data = n;
*
0522:  MOVLB  3
0524:  SWAPF  x2E,W
0526:  ANDLW  F0
0528:  MOVWF  00
052A:  MOVLW  0F
052C:  ANDWF  F8C,W
052E:  IORWF  00,W
0530:  MOVWF  F8C
....................   #endif
....................       
....................    delay_cycles(1);
0532:  NOP   
....................    lcd_output_enable(1);
0534:  BSF    F8C.0
....................    delay_us(2);
0536:  MOVLW  03
0538:  MOVWF  00
053A:  DECFSZ 00,F
053C:  BRA    053A
....................    lcd_output_enable(0);
053E:  BCF    F8C.0
0540:  MOVLB  0
0542:  RETURN 0
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
0596:  BCF    F95.0
....................    lcd_rs_tris();
0598:  BCF    F95.1
....................    lcd_rw_tris();
059A:  BCF    F95.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
059C:  BCF    F8C.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
059E:  BRA    0550
05A0:  MOVFF  01,32D
05A4:  MOVLB  3
05A6:  BTFSS  01.7
05A8:  BRA    05AE
05AA:  MOVLB  0
05AC:  BRA    059E
....................    lcd_output_rs(address);
05AE:  BCF    F8C.1
05B0:  BTFSC  x2B.0
05B2:  BSF    F8C.1
....................    delay_cycles(1);
05B4:  NOP   
....................    lcd_output_rw(0);
05B6:  BCF    F8C.2
....................    delay_cycles(1);
05B8:  NOP   
....................    lcd_output_enable(0);
05BA:  BCF    F8C.0
....................    lcd_send_nibble(n >> 4);
05BC:  SWAPF  x2C,W
05BE:  MOVWF  x2D
05C0:  MOVLW  0F
05C2:  ANDWF  x2D,F
05C4:  MOVFF  32D,32E
05C8:  MOVLB  0
05CA:  RCALL  0522
....................    lcd_send_nibble(n & 0xf);
05CC:  MOVLB  3
05CE:  MOVF   x2C,W
05D0:  ANDLW  0F
05D2:  MOVWF  x2D
05D4:  MOVWF  x2E
05D6:  MOVLB  0
05D8:  RCALL  0522
05DA:  RETURN 0
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
05DC:  MOVLW  28
05DE:  MOVLB  2
05E0:  MOVWF  xF5
05E2:  MOVLW  0C
05E4:  MOVWF  xF6
05E6:  MOVLW  01
05E8:  MOVWF  xF7
05EA:  MOVLW  06
05EC:  MOVWF  xF8
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
05EE:  BCF    F8C.0
....................    lcd_output_rs(0);
05F0:  BCF    F8C.1
....................    lcd_output_rw(0);
05F2:  BCF    F8C.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
05F4:  MOVLW  0F
05F6:  ANDWF  F95,W
05F8:  MOVWF  F95
....................   #endif
....................    lcd_enable_tris();
05FA:  BCF    F95.0
....................    lcd_rs_tris();
05FC:  BCF    F95.1
....................    lcd_rw_tris();
05FE:  BCF    F95.2
....................  #endif
....................     
....................    delay_ms(15);
0600:  MOVLW  0F
0602:  MOVLB  3
0604:  MOVWF  x2D
0606:  MOVLB  0
0608:  RCALL  04FA
....................    for(i=1;i<=3;++i)
060A:  MOVLW  01
060C:  MOVLB  2
060E:  MOVWF  xF4
0610:  MOVF   xF4,W
0612:  SUBLW  03
0614:  BNC   0630
....................    {
....................        lcd_send_nibble(3);
0616:  MOVLW  03
0618:  MOVLB  3
061A:  MOVWF  x2E
061C:  MOVLB  0
061E:  RCALL  0522
....................        delay_ms(5);
0620:  MOVLW  05
0622:  MOVLB  3
0624:  MOVWF  x2D
0626:  MOVLB  0
0628:  RCALL  04FA
062A:  MOVLB  2
062C:  INCF   xF4,F
062E:  BRA    0610
....................    }
....................    
....................    lcd_send_nibble(2);
0630:  MOVLW  02
0632:  MOVLB  3
0634:  MOVWF  x2E
0636:  MOVLB  0
0638:  RCALL  0522
....................    delay_ms(5);
063A:  MOVLW  05
063C:  MOVLB  3
063E:  MOVWF  x2D
0640:  MOVLB  0
0642:  RCALL  04FA
....................    for(i=0;i<=3;++i)
0644:  MOVLB  2
0646:  CLRF   xF4
0648:  MOVF   xF4,W
064A:  SUBLW  03
064C:  BNC   066E
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
064E:  CLRF   03
0650:  MOVF   xF4,W
0652:  ADDLW  F5
0654:  MOVWF  FE9
0656:  MOVLW  02
0658:  ADDWFC 03,W
065A:  MOVWF  FEA
065C:  MOVFF  FEF,32C
0660:  MOVLB  3
0662:  CLRF   x2B
0664:  MOVLB  0
0666:  RCALL  0596
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0668:  MOVLB  2
066A:  INCF   xF4,F
066C:  BRA    0648
066E:  MOVLB  0
0670:  GOTO   6F0A (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
0674:  MOVLB  3
0676:  DECFSZ x28,W
0678:  BRA    067C
067A:  BRA    0682
....................       address=LCD_LINE_TWO;
067C:  MOVLW  40
067E:  MOVWF  x29
0680:  BRA    0684
....................    else
....................       address=0;
0682:  CLRF   x29
....................      
....................    address+=x-1;
0684:  MOVLW  01
0686:  SUBWF  x27,W
0688:  ADDWF  x29,F
....................    lcd_send_byte(0,0x80|address);
068A:  MOVF   x29,W
068C:  IORLW  80
068E:  MOVWF  x2A
0690:  CLRF   x2B
0692:  MOVWF  x2C
0694:  MOVLB  0
0696:  RCALL  0596
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0698:  RETURN 0
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
069A:  MOVLB  3
069C:  MOVF   x26,W
069E:  XORLW  07
06A0:  MOVLB  0
06A2:  BZ    06B2
06A4:  XORLW  0B
06A6:  BZ    06C0
06A8:  XORLW  06
06AA:  BZ    06D8
06AC:  XORLW  02
06AE:  BZ    06E8
06B0:  BRA    06F6
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
06B2:  MOVLW  01
06B4:  MOVLB  3
06B6:  MOVWF  x27
06B8:  MOVWF  x28
06BA:  MOVLB  0
06BC:  RCALL  0674
06BE:  BRA    0704
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
06C0:  MOVLB  3
06C2:  CLRF   x2B
06C4:  MOVLW  01
06C6:  MOVWF  x2C
06C8:  MOVLB  0
06CA:  RCALL  0596
....................                      delay_ms(2);
06CC:  MOVLW  02
06CE:  MOVLB  3
06D0:  MOVWF  x2D
06D2:  MOVLB  0
06D4:  RCALL  04FA
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
06D6:  BRA    0704
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
06D8:  MOVLW  01
06DA:  MOVLB  3
06DC:  MOVWF  x27
06DE:  MOVLW  02
06E0:  MOVWF  x28
06E2:  MOVLB  0
06E4:  RCALL  0674
06E6:  BRA    0704
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
06E8:  MOVLB  3
06EA:  CLRF   x2B
06EC:  MOVLW  10
06EE:  MOVWF  x2C
06F0:  MOVLB  0
06F2:  RCALL  0596
06F4:  BRA    0704
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
06F6:  MOVLW  01
06F8:  MOVLB  3
06FA:  MOVWF  x2B
06FC:  MOVFF  326,32C
0700:  MOVLB  0
0702:  RCALL  0596
....................      #endif
....................    }
0704:  RETURN 0
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include "tcpip/stacktsk.c"      //Carga el stack TCP/IP de Microchip 
.................... /*********************************************************************
....................  *
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.c
....................  * Dependencies:    StackTsk.H
....................  *                  ARPTsk.h
....................  *                  MAC.h
....................  *                  IP.h
....................  *                  ICMP.h
....................  *                  Tcp.h
....................  *                  http.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess()
....................  *                                  to include localIP as third param.
....................  *                                  This was done to allow these functions
....................  *                                  to calculate checksum correctly.
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not
....................  *                                  clear statically IP address if link is
....................  *                                  removed and DHCP module is disabled
....................  *                                  at runtime.
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler.
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #case
.................... 
.................... #define STACK_INCLUDE
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... /*********************************************************************
....................  *
....................  *                  PIC18 SFR Definitions
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        pic18.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or later
....................  *
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  ********************************************************************/
.................... #ifndef COMPILER_H
.................... #define COMPILER_H
.................... 
.................... #if !defined(__PCH__)
.................... #error "This version only works with CCS PCH or PCWH"
.................... #endif
.................... 
.................... // ** I/O PORT REGISTERS
.................... 
.................... #byte PORTA    =  0xF80
.................... #byte PORTB    =  0xF81
.................... #byte PORTC    =  0xF82
.................... #byte PORTD    =  0xF83
.................... #byte PORTE    =  0xF84
.................... #byte PORTF    =  0xF85
.................... 
.................... #bit PORTA_RA5 =  0xF80.5
.................... #bit PORTA_RA4 =  0xF80.4
.................... #bit PORTA_RA3 =  0xF80.3
.................... #bit PORTA_RA2 =  0xF80.2
.................... #bit PORTA_RA1 =  0xF80.1
.................... #bit PORTA_RA0 =  0xF80.0
.................... 
.................... #bit PORTB_RB7 =  0xF81.7
.................... #bit PORTB_RB6 =  0xF81.6
.................... #bit PORTB_RB5 =  0xF81.5
.................... #bit PORTB_RB4 =  0xF81.4
.................... #bit PORTB_RB3 =  0xF81.3
.................... #bit PORTB_RB2 =  0xF81.2
.................... #bit PORTB_RB1 =  0xF81.1
.................... #bit PORTB_RB0 =  0xF81.0
.................... 
.................... #bit PORTC_RC7 =  0xF82.7
.................... #bit PORTC_RC6 =  0xF82.6
.................... #bit PORTC_RC5 =  0xF82.5
.................... #bit PORTC_RC4 =  0xF82.4
.................... #bit PORTC_RC3 =  0xF82.3
.................... #bit PORTC_RC2 =  0xF82.2
.................... #bit PORTC_RC1 =  0xF82.1
.................... #bit PORTC_RC0 =  0xF82.0
.................... 
.................... #bit PORTD_RD7 =  0xF83.7
.................... #bit PORTD_RD6 =  0xF83.6
.................... #bit PORTD_RD5 =  0xF83.5
.................... #bit PORTD_RD4 =  0xF83.4
.................... #bit PORTD_RD3 =  0xF83.3
.................... #bit PORTD_RD2 =  0xF83.2
.................... #bit PORTD_RD1 =  0xF83.1
.................... #bit PORTD_RD0 =  0xF83.0
.................... 
.................... #bit PORTE_RE7 =  0xF84.7
.................... #bit PORTE_RE6 =  0xF84.6
.................... #bit PORTE_RE5 =  0xF84.5
.................... #bit PORTE_RE4 =  0xF84.4
.................... #bit PORTE_RE3 =  0xF84.3
.................... #bit PORTE_RE2 =  0xF84.2
.................... #bit PORTE_RE1 =  0xF84.1
.................... #bit PORTE_RE0 =  0xF84.0
.................... 
.................... #bit PORTF_RF7 =  0xF85.7
.................... #bit PORTF_RF6 =  0xF85.6
.................... #bit PORTF_RF5 =  0xF85.5
.................... #bit PORTF_RF4 =  0xF85.4
.................... #bit PORTF_RF3 =  0xF85.3
.................... #bit PORTF_RF2 =  0xF85.2
.................... #bit PORTF_RF1 =  0xF85.1
.................... #bit PORTF_RF0 =  0xF85.0
.................... 
.................... 
.................... // *** TRIS REGISTERS
.................... 
.................... #byte TRISA    =  0xF92
.................... #byte TRISB    =  0xF93
.................... #byte TRISC    =  0xF94
.................... #byte TRISD    =  0xF95
.................... #byte TRISE    =  0xF96
.................... #byte TRISF    =  0xF97
.................... 
.................... #bit TRISA_RA7 =  0xF92.7
.................... #bit TRISA_RA6 =  0xF92.6
.................... #bit TRISA_RA5 =  0xF92.5
.................... #bit TRISA_RA4 =  0xF92.4
.................... #bit TRISA_RA3 =  0xF92.3
.................... #bit TRISA_RA2 =  0xF92.2
.................... #bit TRISA_RA1 =  0xF92.1
.................... #bit TRISA_RA0 =  0xF92.0
.................... 
.................... #bit TRISB_RB7 =  0xF93.7
.................... #bit TRISB_RB6 =  0xF93.6
.................... #bit TRISB_RB5 =  0xF93.5
.................... #bit TRISB_RB4 =  0xF93.4
.................... #bit TRISB_RB3 =  0xF93.3
.................... #bit TRISB_RB2 =  0xF93.2
.................... #bit TRISB_RB1 =  0xF93.1
.................... #bit TRISB_RB0 =  0xF93.0
.................... 
.................... #bit TRISC_RC7 =  0xF94.7
.................... #bit TRISC_RC6 =  0xF94.6
.................... #bit TRISC_RC5 =  0xF94.5
.................... #bit TRISC_RC4 =  0xF94.4
.................... #bit TRISC_RC3 =  0xF94.3
.................... #bit TRISC_RC2 =  0xF94.2
.................... #bit TRISC_RC1 =  0xF94.1
.................... #bit TRISC_RC0 =  0xF94.0
.................... 
.................... #bit TRISD_RD7 =  0xF95.7
.................... #bit TRISD_RD6 =  0xF95.6
.................... #bit TRISD_RD5 =  0xF95.5
.................... #bit TRISD_RD4 =  0xF95.4
.................... #bit TRISD_RD3 =  0xF95.3
.................... #bit TRISD_RD2 =  0xF95.2
.................... #bit TRISD_RD1 =  0xF95.1
.................... #bit TRISD_RD0 =  0xF95.0
.................... 
.................... #bit TRISE_RE7 =  0xF96.7
.................... #bit TRISE_RE6 =  0xF96.6
.................... #bit TRISE_RE5 =  0xF96.5
.................... #bit TRISE_RE4 =  0xF96.4
.................... #bit TRISE_RE3 =  0xF96.3
.................... #bit TRISE_RE2 =  0xF96.2
.................... #bit TRISE_RE1 =  0xF96.1
.................... #bit TRISE_RE0 =  0xF96.0
.................... 
.................... #bit TRISF_RF7 =  0xF97.7
.................... #bit TRISF_RF6 =  0xF97.6
.................... #bit TRISF_RF5 =  0xF97.5
.................... #bit TRISF_RF4 =  0xF97.4
.................... #bit TRISF_RF3 =  0xF97.3
.................... #bit TRISF_RF2 =  0xF97.2
.................... #bit TRISF_RF1 =  0xF97.1
.................... #bit TRISF_RF0 =  0xF97.0
.................... 
.................... 
.................... // *** LAT REGISTERS
.................... #byte LATA    =  0xF89
.................... #byte LATB    =  0xF8A
.................... #byte LATC    =  0xF8B
.................... #byte LATD    =  0xF8C
.................... #byte LATE    =  0xF8D
.................... #byte LATF    =  0xF8E
.................... 
.................... #bit LATA_RA7 =  0xF89.7
.................... #bit LATA_RA6 =  0xF89.6
.................... #bit LATA_RA5 =  0xF89.5
.................... #bit LATA_RA4 =  0xF89.4
.................... #bit LATA_RA3 =  0xF89.3
.................... #bit LATA_RA2 =  0xF89.2
.................... #bit LATA_RA1 =  0xF89.1
.................... #bit LATA_RA0 =  0xF89.0
.................... 
.................... #bit LATB_RB7 =  0xF8A.7
.................... #bit LATB_RB6 =  0xF8A.6
.................... #bit LATB_RB5 =  0xF8A.5
.................... #bit LATB_RB4 =  0xF8A.4
.................... #bit LATB_RB3 =  0xF8A.3
.................... #bit LATB_RB2 =  0xF8A.2
.................... #bit LATB_RB1 =  0xF8A.1
.................... #bit LATB_RB0 =  0xF8A.0
.................... 
.................... #bit LATC_RC7 =  0xF8B.7
.................... #bit LATC_RC6 =  0xF8B.6
.................... #bit LATC_RC5 =  0xF8B.5
.................... #bit LATC_RC4 =  0xF8B.4
.................... #bit LATC_RC3 =  0xF8B.3
.................... #bit LATC_RC2 =  0xF8B.2
.................... #bit LATC_RC1 =  0xF8B.1
.................... #bit LATC_RC0 =  0xF8B.0
.................... 
.................... #bit LATD_RD7 =  0xF8C.7
.................... #bit LATD_RD6 =  0xF8C.6
.................... #bit LATD_RD5 =  0xF8C.5
.................... #bit LATD_RD4 =  0xF8C.4
.................... #bit LATD_RD3 =  0xF8C.3
.................... #bit LATD_RD2 =  0xF8C.2
.................... #bit LATD_RD1 =  0xF8C.1
.................... #bit LATD_RD0 =  0xF8C.0
.................... 
.................... #bit LATE_RE7 =  0xF8D.7
.................... #bit LATE_RE6 =  0xF8D.6
.................... #bit LATE_RE5 =  0xF8D.5
.................... #bit LATE_RE4 =  0xF8D.4
.................... #bit LATE_RE3 =  0xF8D.3
.................... #bit LATE_RE2 =  0xF8D.2
.................... #bit LATE_RE1 =  0xF8D.1
.................... #bit LATE_RE0 =  0xF8D.0
.................... 
.................... #bit LATF_RF7 =  0xF8E.7
.................... #bit LATF_RF6 =  0xF8E.6
.................... #bit LATF_RF5 =  0xF8E.5
.................... #bit LATF_RF4 =  0xF8E.4
.................... #bit LATF_RF3 =  0xF8E.3
.................... #bit LATF_RF2 =  0xF8E.2
.................... #bit LATF_RF1 =  0xF8E.1
.................... #bit LATF_RF0 =  0xF8E.0
.................... 
.................... 
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP
.................... 
.................... #bit  PIE1_TXIE       =  0xF9D.4
.................... #bit  PIE1_RCIE       =  0xF9D.5
.................... #bit  PIR1_TXIF       =  0xF9E.4
.................... #bit  PIR1_RCIF       =  0xF9E.5
.................... #byte TXSTA           =  0xFAC
.................... #byte RCSTA           =  0xFAB
.................... #bit  RCSTA_CREN      =  0xFAB.4
.................... #byte RCREG           =  0xFAE
.................... #byte SPBRG           =  0xFAF
.................... #byte TXREG           =  0xFAD
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                         HARDWARE.H                                ////
.................... ////                                                                   ////
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. ////
.................... ////                                                                   ////
.................... //// These values will probably change with each application.          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// RELEASE HISTORY:                                                  ////
.................... ////                                                                   ////
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT ////
.................... ////                  moved to here.                                   ////
.................... ////                                                                   ////
.................... ////    Jan 09, 2004: Initial Public Release                           ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION
.................... #define ___TCPIP_STACK_CONFIGURATION
.................... 
.................... 
.................... #ifndef STACK_USE_CCS_PICNET
.................... #define STACK_USE_CCS_PICNET  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_CCS_PICENS
.................... #define STACK_USE_CCS_PICENS  FALSE
.................... #endif
.................... 
.................... 
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT.
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED.
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE
.................... 
.................... 
.................... ///DEFAULT HARDCODED IP ADDRESSES.
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM.
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP).
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address.
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        1
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        10
.................... 
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network.
....................    #define MY_DEFAULT_MASK_BYTE4           0x00
.................... 
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks.
....................    #define MY_DEFAULT_GATE_BYTE3           1
....................    #define MY_DEFAULT_GATE_BYTE4           1
.................... 
.................... ///DEFAULT HARDCODED MAC ADDRESS.
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER.
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS.
.................... #define MY_DEFAULT_MAC_BYTE1            0x00
.................... #define MY_DEFAULT_MAC_BYTE2            0x02
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3
.................... #define MY_DEFAULT_MAC_BYTE4            0x04
.................... #define MY_DEFAULT_MAC_BYTE5            0x05
.................... #define MY_DEFAULT_MAC_BYTE6            0x06
.................... 
.................... ///Maximum sockets to be defined.
.................... /// Note that each socket consumes 36 bytes of RAM.
.................... /// If you remove this, a default value will be loaded in stacktsk.h
....................    #ifndef MAX_SOCKETS
....................    #define MAX_SOCKETS                     5
....................    #endif
.................... 
.................... ///Avaialble UDP Socket
.................... /// DCHP takes 1 socket.
.................... /// If you remove this, a default value will be loaded in stacktsk.h
....................    #ifndef MAX_UDP_SOCKETS
....................    #define MAX_UDP_SOCKETS                 2
....................    #endif
.................... 
.................... ///BUFFER SIZE DEFINITIONS
.................... ///
.................... /// For SLIP, there can only be one transmit and one receive buffer.
.................... /// Both buffer must fit in one bank.  If bigger buffer is required,
.................... /// you must manually locate tx and rx buffer in different bank
.................... /// or modify your linker script file to support arrays bigger than
.................... /// 256 bytes.
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE
.................... ///
.................... /// For PPP, there can only be one transmit and one receive buffer.
.................... /// You can receive messages larger than the receive buffer if your
.................... /// routines are fast enough.  You cannot transmit messages larger
.................... /// than the TX buffer.  The larger the buffer you can make, the better.
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE
.................... ///
.................... /// For Ethernet, the Ethernet controler has many buffers that are
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX.
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers.
....................    #if STACK_USE_MAC
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line
....................    #elif STACK_USE_PPP
....................        #define MAC_TX_BUFFER_SIZE          1024
....................        #define MAC_TX_BUFFER_COUNT         1
....................    #elif STACK_USE_SLIP
....................        #define MAC_TX_BUFFER_SIZE          250
....................        #define MAC_TX_BUFFER_COUNT         1
....................    #endif
.................... 
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing
.................... 
.................... #endif
.................... 
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
45D2:  MOVFF  329,32F
45D6:  MOVFF  328,32E
....................    sc2=s2;
45DA:  MOVFF  32B,331
45DE:  MOVFF  32A,330
....................    if(sc2<sc1 && sc1 <sc2 +n)
45E2:  MOVLB  3
45E4:  MOVF   x31,W
45E6:  SUBWF  x2F,W
45E8:  BNC   4662
45EA:  BNZ   45F2
45EC:  MOVF   x2E,W
45EE:  SUBWF  x30,W
45F0:  BC    4662
45F2:  MOVF   x2C,W
45F4:  ADDWF  x30,W
45F6:  MOVWF  01
45F8:  MOVF   x2D,W
45FA:  ADDWFC x31,W
45FC:  MOVWF  03
45FE:  MOVF   x2F,W
4600:  SUBWF  03,W
4602:  BNC   4662
4604:  BNZ   460C
4606:  MOVF   01,W
4608:  SUBWF  x2E,W
460A:  BC    4662
....................       for(sc1+=n,sc2+=n;0<n;--n)
460C:  MOVF   x2C,W
460E:  ADDWF  x2E,F
4610:  MOVF   x2D,W
4612:  ADDWFC x2F,F
4614:  MOVF   x2C,W
4616:  ADDWF  x30,F
4618:  MOVF   x2D,W
461A:  ADDWFC x31,F
461C:  MOVF   x2D,F
461E:  BNZ   4626
4620:  MOVF   x2C,W
4622:  SUBLW  00
4624:  BC    4660
....................          *--sc1=*--sc2;
4626:  MOVF   x2E,W
4628:  BTFSC  FD8.2
462A:  DECF   x2F,F
462C:  DECF   x2E,F
462E:  MOVFF  32F,333
4632:  MOVFF  32E,332
4636:  MOVF   x30,W
4638:  BTFSC  FD8.2
463A:  DECF   x31,F
463C:  DECF   x30,F
463E:  MOVFF  331,FEA
4642:  MOVFF  330,FE9
4646:  MOVFF  FEF,334
464A:  MOVFF  32F,FEA
464E:  MOVFF  32E,FE9
4652:  MOVFF  334,FEF
4656:  MOVF   x2C,W
4658:  BTFSC  FD8.2
465A:  DECF   x2D,F
465C:  DECF   x2C,F
465E:  BRA    461C
4660:  BRA    46A2
....................    else
....................       for(;0<n;--n)
4662:  MOVF   x2D,F
4664:  BNZ   466C
4666:  MOVF   x2C,W
4668:  SUBLW  00
466A:  BC    46A2
....................          *sc1++=*sc2++;
466C:  MOVFF  32F,333
4670:  MOVF   x2E,W
4672:  INCF   x2E,F
4674:  BTFSC  FD8.2
4676:  INCF   x2F,F
4678:  MOVWF  x32
467A:  MOVFF  331,FEA
467E:  MOVF   x30,W
4680:  INCF   x30,F
4682:  BTFSC  FD8.2
4684:  INCF   x31,F
4686:  MOVWF  FE9
4688:  MOVFF  FEF,334
468C:  MOVFF  333,FEA
4690:  MOVFF  332,FE9
4694:  MOVFF  334,FEF
4698:  MOVF   x2C,W
469A:  BTFSC  FD8.2
469C:  DECF   x2D,F
469E:  DECF   x2C,F
46A0:  BRA    4662
....................   return s1;
46A2:  MOVFF  328,01
46A6:  MOVFF  329,02
46AA:  MOVLB  0
46AC:  GOTO   4776 (RETURN)
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
*
59C8:  MOVFF  338,33E
59CC:  MOVFF  337,33D
59D0:  MOVLB  3
59D2:  MOVF   x3B,F
59D4:  BNZ   59DA
59D6:  MOVF   x3C,F
59D8:  BZ    5A20
59DA:  MOVFF  33A,FEA
59DE:  MOVFF  339,FE9
59E2:  MOVF   FEF,F
59E4:  BZ    5A20
....................      *s++ = *s2++;
59E6:  MOVFF  33E,03
59EA:  MOVF   x3D,W
59EC:  INCF   x3D,F
59EE:  BTFSC  FD8.2
59F0:  INCF   x3E,F
59F2:  MOVWF  x3F
59F4:  MOVFF  03,340
59F8:  MOVFF  33A,FEA
59FC:  MOVF   x39,W
59FE:  INCF   x39,F
5A00:  BTFSC  FD8.2
5A02:  INCF   x3A,F
5A04:  MOVWF  FE9
5A06:  MOVFF  FEF,341
5A0A:  MOVFF  03,FEA
5A0E:  MOVFF  33F,FE9
5A12:  MOVFF  341,FEF
5A16:  MOVF   x3B,W
5A18:  BTFSC  FD8.2
5A1A:  DECF   x3C,F
5A1C:  DECF   x3B,F
5A1E:  BRA    59D2
....................   for (; n > 0; n--)
5A20:  MOVF   x3B,F
5A22:  BNZ   5A28
5A24:  MOVF   x3C,F
5A26:  BZ    5A42
....................      *s++ = '\0';
5A28:  MOVFF  33E,FEA
5A2C:  MOVF   x3D,W
5A2E:  INCF   x3D,F
5A30:  BTFSC  FD8.2
5A32:  INCF   x3E,F
5A34:  MOVWF  FE9
5A36:  CLRF   FEF
5A38:  MOVF   x3B,W
5A3A:  BTFSC  FD8.2
5A3C:  DECF   x3C,F
5A3E:  DECF   x3B,F
5A40:  BRA    5A20
.................... 
....................   return(s1);
5A42:  MOVFF  337,01
5A46:  MOVFF  338,02
5A4A:  MOVLB  0
5A4C:  GOTO   5B3A (RETURN)
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
412E:  MOVFF  309,FEA
4132:  MOVLB  3
4134:  MOVFF  308,FE9
4138:  MOVFF  FEF,30C
413C:  MOVFF  30B,FEA
4140:  MOVFF  30A,FE9
4144:  MOVF   FEF,W
4146:  SUBWF  x0C,W
4148:  BNZ   4178
....................       if (*s1 == '\0')
414A:  MOVFF  309,03
414E:  MOVFF  308,FE9
4152:  MOVFF  03,FEA
4156:  MOVF   FEF,F
4158:  BNZ   4160
....................          return(0);
415A:  MOVLW  00
415C:  MOVWF  01
415E:  BRA    41A2
4160:  MOVFF  309,03
4164:  MOVF   x08,W
4166:  INCF   x08,F
4168:  BTFSC  FD8.2
416A:  INCF   x09,F
416C:  INCF   x0A,F
416E:  BTFSC  FD8.2
4170:  INCF   x0B,F
4172:  MOVLB  0
4174:  BRA    412E
4176:  MOVLB  3
....................    return((*s1 < *s2) ? -1: 1);
4178:  MOVFF  309,03
417C:  MOVFF  308,FE9
4180:  MOVFF  03,FEA
4184:  MOVFF  FEF,30C
4188:  MOVFF  30B,03
418C:  MOVFF  30A,FE9
4190:  MOVFF  03,FEA
4194:  MOVF   FEF,W
4196:  SUBWF  x0C,W
4198:  BC    419E
419A:  MOVLW  FF
419C:  BRA    41A0
419E:  MOVLW  01
41A0:  MOVWF  01
41A2:  MOVLB  0
41A4:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
41A6:  MOVFF  359,35C
....................    for(su=s;0<n;++su,--n)
41AA:  MOVFF  358,35E
41AE:  MOVFF  357,35D
41B2:  MOVLB  3
41B4:  MOVF   x5B,F
41B6:  BNZ   41BE
41B8:  MOVF   x5A,W
41BA:  SUBLW  00
41BC:  BC    41E6
....................       if(*su==uc)
41BE:  MOVFF  35E,FEA
41C2:  MOVFF  35D,FE9
41C6:  MOVF   x5C,W
41C8:  SUBWF  FEF,W
41CA:  BNZ   41D6
....................       return su;
41CC:  MOVFF  35D,01
41D0:  MOVFF  35E,02
41D4:  BRA    41EC
41D6:  INCF   x5D,F
41D8:  BTFSC  FD8.2
41DA:  INCF   x5E,F
41DC:  MOVF   x5A,W
41DE:  BTFSC  FD8.2
41E0:  DECF   x5B,F
41E2:  DECF   x5A,F
41E4:  BRA    41B4
....................    return NULL;
41E6:  MOVLW  00
41E8:  MOVWF  01
41EA:  MOVWF  02
41EC:  MOVLB  0
41EE:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
3FD0:  MOVFF  315,319
3FD4:  MOVFF  314,318
3FD8:  MOVFF  319,FEA
3FDC:  MOVLB  3
3FDE:  MOVFF  318,FE9
3FE2:  MOVF   FEF,F
3FE4:  BZ    4036
....................       for (sc2 = s2; *sc2 != 0; sc2++)
3FE6:  MOVFF  317,31B
3FEA:  MOVFF  316,31A
3FEE:  MOVFF  31B,FEA
3FF2:  MOVFF  31A,FE9
3FF6:  MOVF   FEF,F
3FF8:  BZ    402A
....................          if (*sc1 == *sc2)
3FFA:  MOVFF  319,03
3FFE:  MOVFF  318,FE9
4002:  MOVFF  03,FEA
4006:  MOVFF  FEF,31C
400A:  MOVFF  31B,FEA
400E:  MOVFF  31A,FE9
4012:  MOVF   FEF,W
4014:  SUBWF  x1C,W
4016:  BNZ   4022
....................             return(sc1);
4018:  MOVFF  318,01
401C:  MOVFF  319,02
4020:  BRA    403C
4022:  INCF   x1A,F
4024:  BTFSC  FD8.2
4026:  INCF   x1B,F
4028:  BRA    3FEE
402A:  INCF   x18,F
402C:  BTFSC  FD8.2
402E:  INCF   x19,F
4030:  MOVLB  0
4032:  BRA    3FD8
4034:  MOVLB  3
....................    return(0);
4036:  MOVLW  00
4038:  MOVWF  01
403A:  MOVWF  02
403C:  MOVLB  0
403E:  GOTO   40DC (RETURN)
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
3F48:  MOVFF  315,319
3F4C:  MOVFF  314,318
3F50:  MOVFF  319,FEA
3F54:  MOVLB  3
3F56:  MOVFF  318,FE9
3F5A:  MOVF   FEF,F
3F5C:  BZ    3FB8
....................       for (sc2 = s2; ; sc2++)
3F5E:  MOVFF  317,31B
3F62:  MOVFF  316,31A
....................     if (*sc2 == '\0')
3F66:  MOVFF  31B,FEA
3F6A:  MOVFF  31A,FE9
3F6E:  MOVF   FEF,F
3F70:  BNZ   3F88
....................        return(sc1 - s1);
3F72:  MOVF   x14,W
3F74:  SUBWF  x18,W
3F76:  MOVWF  00
3F78:  MOVF   x15,W
3F7A:  SUBWFB x19,W
3F7C:  MOVWF  03
3F7E:  MOVFF  00,01
3F82:  MOVWF  02
3F84:  BRA    3FCA
3F86:  BRA    3FA4
....................          else if (*sc1 == *sc2)
3F88:  MOVFF  319,FEA
3F8C:  MOVFF  318,FE9
3F90:  MOVFF  FEF,31C
3F94:  MOVFF  31B,FEA
3F98:  MOVFF  31A,FE9
3F9C:  MOVF   FEF,W
3F9E:  SUBWF  x1C,W
3FA0:  BNZ   3FA4
....................             break;
3FA2:  BRA    3FAC
3FA4:  INCF   x1A,F
3FA6:  BTFSC  FD8.2
3FA8:  INCF   x1B,F
3FAA:  BRA    3F66
3FAC:  INCF   x18,F
3FAE:  BTFSC  FD8.2
3FB0:  INCF   x19,F
3FB2:  MOVLB  0
3FB4:  BRA    3F50
3FB6:  MOVLB  3
....................    return(sc1 - s1);
3FB8:  MOVF   x14,W
3FBA:  SUBWF  x18,W
3FBC:  MOVWF  00
3FBE:  MOVF   x15,W
3FC0:  SUBWFB x19,W
3FC2:  MOVWF  03
3FC4:  MOVFF  00,01
3FC8:  MOVWF  02
3FCA:  MOVLB  0
3FCC:  GOTO   40AA (RETURN)
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
4042:  MOVFF  338,33A
4046:  MOVFF  337,339
404A:  MOVFF  33A,FEA
404E:  MOVLB  3
4050:  MOVFF  339,FE9
4054:  MOVF   FEF,F
4056:  BZ    4064
4058:  INCF   x39,F
405A:  BTFSC  FD8.2
405C:  INCF   x3A,F
405E:  MOVLB  0
4060:  BRA    404A
4062:  MOVLB  3
....................    return(sc - s);
4064:  MOVF   x37,W
4066:  SUBWF  x39,W
4068:  MOVWF  00
406A:  MOVF   x38,W
406C:  SUBWFB x3A,W
406E:  MOVWF  03
4070:  MOVFF  00,01
4074:  MOVWF  02
4076:  MOVLB  0
4078:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
407A:  MOVLB  3
407C:  MOVF   x0C,W
407E:  IORWF  x0D,W
4080:  BZ    408A
4082:  MOVFF  30D,03
4086:  MOVF   x0C,W
4088:  BRA    4090
408A:  MOVFF  05,03
408E:  MOVF   04,W
4090:  MOVWF  x10
4092:  MOVFF  03,311
....................    beg += strspn(beg, s2);
4096:  MOVFF  311,315
409A:  MOVFF  310,314
409E:  MOVFF  30F,317
40A2:  MOVFF  30E,316
40A6:  MOVLB  0
40A8:  BRA    3F48
40AA:  MOVF   01,W
40AC:  MOVLB  3
40AE:  ADDWF  x10,F
40B0:  MOVF   02,W
40B2:  ADDWFC x11,F
....................    if (*beg == '\0')
40B4:  MOVFF  311,FEA
40B8:  MOVFF  310,FE9
40BC:  MOVF   FEF,F
40BE:  BNZ   40C8
....................       return(0);
40C0:  MOVLW  00
40C2:  MOVWF  01
40C4:  MOVWF  02
40C6:  BRA    412A
....................       
....................    end = strpbrk(beg, s2);
40C8:  MOVFF  311,315
40CC:  MOVFF  310,314
40D0:  MOVFF  30F,317
40D4:  MOVFF  30E,316
40D8:  MOVLB  0
40DA:  BRA    3FD0
40DC:  MOVFF  02,313
40E0:  MOVFF  01,312
....................    if (end != '\0')
40E4:  MOVLB  3
40E6:  MOVF   x12,F
40E8:  BNZ   40EE
40EA:  MOVF   x13,F
40EC:  BZ    4108
....................    {
....................       *end = '\0';
40EE:  MOVFF  313,FEA
40F2:  MOVFF  312,FE9
40F6:  CLRF   FEF
....................       end++;
40F8:  INCF   x12,F
40FA:  BTFSC  FD8.2
40FC:  INCF   x13,F
....................       save = end;
40FE:  MOVFF  313,05
4102:  MOVFF  312,04
....................    }
4106:  BRA    4122
....................    else
....................       save = beg + strlen(beg);
4108:  MOVFF  311,338
410C:  MOVFF  310,337
4110:  MOVLB  0
4112:  RCALL  4042
4114:  MOVF   01,W
4116:  MOVLB  3
4118:  ADDWF  x10,W
411A:  MOVWF  04
411C:  MOVF   02,W
411E:  ADDWFC x11,W
4120:  MOVWF  05
....................    
....................    return(beg);
4122:  MOVFF  310,01
4126:  MOVFF  311,02
412A:  MOVLB  0
412C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
*
4790:  MOVFF  325,FEA
4794:  MOVLB  3
4796:  MOVFF  324,FE9
479A:  MOVFF  FEF,328
479E:  MOVFF  327,FEA
47A2:  MOVFF  326,FE9
47A6:  MOVF   FEF,W
47A8:  SUBWF  x28,W
47AA:  BZ    482C
47AC:  MOVFF  325,FEA
47B0:  MOVFF  324,FE9
47B4:  MOVFF  FEF,328
47B8:  MOVF   x28,W
47BA:  SUBLW  40
47BC:  BC    47C4
47BE:  MOVF   x28,W
47C0:  SUBLW  5A
47C2:  BC    47D0
47C4:  MOVF   x28,W
47C6:  SUBLW  60
47C8:  BC    4856
47CA:  MOVF   x28,W
47CC:  SUBLW  7A
47CE:  BNC   4856
47D0:  MOVFF  327,FEA
47D4:  MOVFF  326,FE9
47D8:  MOVFF  FEF,328
47DC:  MOVF   x28,W
47DE:  SUBLW  40
47E0:  BC    47E8
47E2:  MOVF   x28,W
47E4:  SUBLW  5A
47E6:  BC    47F4
47E8:  MOVF   x28,W
47EA:  SUBLW  60
47EC:  BC    4856
47EE:  MOVF   x28,W
47F0:  SUBLW  7A
47F2:  BNC   4856
47F4:  MOVFF  325,FEA
47F8:  MOVFF  324,FE9
47FC:  MOVFF  FEF,328
4800:  MOVFF  327,FEA
4804:  MOVFF  326,FE9
4808:  MOVLW  20
480A:  ADDWF  FEF,W
480C:  SUBWF  x28,W
480E:  BZ    482C
4810:  MOVFF  327,FEA
4814:  MOVFF  326,FE9
4818:  MOVFF  FEF,328
481C:  MOVFF  325,FEA
4820:  MOVFF  324,FE9
4824:  MOVLW  20
4826:  ADDWF  FEF,W
4828:  SUBWF  x28,W
482A:  BNZ   4856
....................     s1++, s2++)
....................     if (*s1 == '\0')
482C:  MOVFF  325,FEA
4830:  MOVFF  324,FE9
4834:  MOVF   FEF,F
4836:  BNZ   483E
....................        return(0);
4838:  MOVLW  00
483A:  MOVWF  01
483C:  BRA    4880
483E:  MOVFF  325,03
4842:  MOVF   x24,W
4844:  INCF   x24,F
4846:  BTFSC  FD8.2
4848:  INCF   x25,F
484A:  INCF   x26,F
484C:  BTFSC  FD8.2
484E:  INCF   x27,F
4850:  MOVLB  0
4852:  BRA    4790
4854:  MOVLB  3
....................  return((*s1 < *s2) ? -1: 1);
4856:  MOVFF  325,03
485A:  MOVFF  324,FE9
485E:  MOVFF  03,FEA
4862:  MOVFF  FEF,328
4866:  MOVFF  327,03
486A:  MOVFF  326,FE9
486E:  MOVFF  03,FEA
4872:  MOVF   FEF,W
4874:  SUBWF  x28,W
4876:  BC    487C
4878:  MOVLW  FF
487A:  BRA    487E
487C:  MOVLW  01
487E:  MOVWF  01
4880:  MOVLB  0
4882:  RETURN 0
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
4D96:  MOVLB  3
4D98:  CLRF   x10
....................    sign = 0;
4D9A:  CLRF   x0E
....................    base = 10;
4D9C:  MOVLW  0A
4D9E:  MOVWF  x0F
....................    result = 0;
4DA0:  CLRF   x0D
4DA2:  CLRF   x0C
.................... 
....................    if (!s)
4DA4:  MOVF   x0A,W
4DA6:  IORWF  x0B,W
4DA8:  BNZ   4DB2
....................       return 0;
4DAA:  MOVLW  00
4DAC:  MOVWF  01
4DAE:  MOVWF  02
4DB0:  BRA    4F6C
....................    c = s[index++];
4DB2:  MOVF   x10,W
4DB4:  INCF   x10,F
4DB6:  ADDWF  x0A,W
4DB8:  MOVWF  FE9
4DBA:  MOVLW  00
4DBC:  ADDWFC x0B,W
4DBE:  MOVWF  FEA
4DC0:  MOVFF  FEF,311
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
4DC4:  MOVF   x11,W
4DC6:  SUBLW  2D
4DC8:  BNZ   4DE2
....................    {
....................       sign = 1;         // Set the sign to negative
4DCA:  MOVLW  01
4DCC:  MOVWF  x0E
....................       c = s[index++];
4DCE:  MOVF   x10,W
4DD0:  INCF   x10,F
4DD2:  ADDWF  x0A,W
4DD4:  MOVWF  FE9
4DD6:  MOVLW  00
4DD8:  ADDWFC x0B,W
4DDA:  MOVWF  FEA
4DDC:  MOVFF  FEF,311
....................    }
4DE0:  BRA    4DFA
....................    else if (c == '+')
4DE2:  MOVF   x11,W
4DE4:  SUBLW  2B
4DE6:  BNZ   4DFA
....................    {
....................       c = s[index++];
4DE8:  MOVF   x10,W
4DEA:  INCF   x10,F
4DEC:  ADDWF  x0A,W
4DEE:  MOVWF  FE9
4DF0:  MOVLW  00
4DF2:  ADDWFC x0B,W
4DF4:  MOVWF  FEA
4DF6:  MOVFF  FEF,311
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
4DFA:  MOVF   x11,W
4DFC:  SUBLW  2F
4DFE:  BTFSC  FD8.0
4E00:  BRA    4F50
4E02:  MOVF   x11,W
4E04:  SUBLW  39
4E06:  BTFSS  FD8.0
4E08:  BRA    4F50
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
4E0A:  MOVF   x11,W
4E0C:  SUBLW  30
4E0E:  BNZ   4E4C
4E10:  MOVF   x10,W
4E12:  ADDWF  x0A,W
4E14:  MOVWF  FE9
4E16:  MOVLW  00
4E18:  ADDWFC x0B,W
4E1A:  MOVWF  FEA
4E1C:  MOVF   FEF,W
4E1E:  SUBLW  78
4E20:  BZ    4E34
4E22:  MOVF   x10,W
4E24:  ADDWF  x0A,W
4E26:  MOVWF  FE9
4E28:  MOVLW  00
4E2A:  ADDWFC x0B,W
4E2C:  MOVWF  FEA
4E2E:  MOVF   FEF,W
4E30:  SUBLW  58
4E32:  BNZ   4E4C
....................       {
....................          base = 16;
4E34:  MOVLW  10
4E36:  MOVWF  x0F
....................          index++;
4E38:  INCF   x10,F
....................          c = s[index++];
4E3A:  MOVF   x10,W
4E3C:  INCF   x10,F
4E3E:  ADDWF  x0A,W
4E40:  MOVWF  FE9
4E42:  MOVLW  00
4E44:  ADDWFC x0B,W
4E46:  MOVWF  FEA
4E48:  MOVFF  FEF,311
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
4E4C:  MOVF   x0F,W
4E4E:  SUBLW  0A
4E50:  BNZ   4E96
....................       {
....................          while (c >= '0' && c <= '9')
4E52:  MOVF   x11,W
4E54:  SUBLW  2F
4E56:  BC    4E94
4E58:  MOVF   x11,W
4E5A:  SUBLW  39
4E5C:  BNC   4E94
....................          {
....................             result = 10*result + (c - '0');
4E5E:  CLRF   x13
4E60:  MOVLW  0A
4E62:  MOVWF  x12
4E64:  MOVFF  30D,315
4E68:  MOVFF  30C,314
4E6C:  MOVLB  0
4E6E:  BRA    4D40
4E70:  MOVLW  30
4E72:  MOVLB  3
4E74:  SUBWF  x11,W
4E76:  ADDWF  01,W
4E78:  MOVWF  x0C
4E7A:  MOVLW  00
4E7C:  ADDWFC 02,W
4E7E:  MOVWF  x0D
....................             c = s[index++];
4E80:  MOVF   x10,W
4E82:  INCF   x10,F
4E84:  ADDWF  x0A,W
4E86:  MOVWF  FE9
4E88:  MOVLW  00
4E8A:  ADDWFC x0B,W
4E8C:  MOVWF  FEA
4E8E:  MOVFF  FEF,311
4E92:  BRA    4E52
....................          }
....................       }
4E94:  BRA    4F50
....................       else if (base == 16)    // The number is a hexa number
4E96:  MOVF   x0F,W
4E98:  SUBLW  10
4E9A:  BNZ   4F50
....................       {
....................          c = toupper(c);
4E9C:  MOVF   x11,W
4E9E:  SUBLW  60
4EA0:  BC    4EAE
4EA2:  MOVF   x11,W
4EA4:  SUBLW  7A
4EA6:  BNC   4EAE
4EA8:  MOVF   x11,W
4EAA:  ANDLW  DF
4EAC:  BRA    4EB0
4EAE:  MOVF   x11,W
4EB0:  MOVWF  x11
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
4EB2:  MOVF   x11,W
4EB4:  SUBLW  2F
4EB6:  BC    4EBE
4EB8:  MOVF   x11,W
4EBA:  SUBLW  39
4EBC:  BC    4ECA
4EBE:  MOVF   x11,W
4EC0:  SUBLW  40
4EC2:  BC    4F50
4EC4:  MOVF   x11,W
4EC6:  SUBLW  46
4EC8:  BNC   4F50
....................          {
....................             if (c >= '0' && c <= '9')
4ECA:  MOVF   x11,W
4ECC:  SUBLW  2F
4ECE:  BC    4EFE
4ED0:  MOVF   x11,W
4ED2:  SUBLW  39
4ED4:  BNC   4EFE
....................                result = (result << 4) + (c - '0');
4ED6:  RLCF   x0C,W
4ED8:  MOVWF  x12
4EDA:  RLCF   x0D,W
4EDC:  MOVWF  x13
4EDE:  RLCF   x12,F
4EE0:  RLCF   x13,F
4EE2:  RLCF   x12,F
4EE4:  RLCF   x13,F
4EE6:  RLCF   x12,F
4EE8:  RLCF   x13,F
4EEA:  MOVLW  F0
4EEC:  ANDWF  x12,F
4EEE:  MOVLW  30
4EF0:  SUBWF  x11,W
4EF2:  ADDWF  x12,W
4EF4:  MOVWF  x0C
4EF6:  MOVLW  00
4EF8:  ADDWFC x13,W
4EFA:  MOVWF  x0D
4EFC:  BRA    4F26
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
4EFE:  RLCF   x0C,W
4F00:  MOVWF  x12
4F02:  RLCF   x0D,W
4F04:  MOVWF  x13
4F06:  RLCF   x12,F
4F08:  RLCF   x13,F
4F0A:  RLCF   x12,F
4F0C:  RLCF   x13,F
4F0E:  RLCF   x12,F
4F10:  RLCF   x13,F
4F12:  MOVLW  F0
4F14:  ANDWF  x12,F
4F16:  MOVLW  41
4F18:  SUBWF  x11,W
4F1A:  ADDLW  0A
4F1C:  ADDWF  x12,W
4F1E:  MOVWF  x0C
4F20:  MOVLW  00
4F22:  ADDWFC x13,W
4F24:  MOVWF  x0D
.................... 
....................             c = s[index++];c = toupper(c);
4F26:  MOVF   x10,W
4F28:  INCF   x10,F
4F2A:  ADDWF  x0A,W
4F2C:  MOVWF  FE9
4F2E:  MOVLW  00
4F30:  ADDWFC x0B,W
4F32:  MOVWF  FEA
4F34:  MOVFF  FEF,311
4F38:  MOVF   x11,W
4F3A:  SUBLW  60
4F3C:  BC    4F4A
4F3E:  MOVF   x11,W
4F40:  SUBLW  7A
4F42:  BNC   4F4A
4F44:  MOVF   x11,W
4F46:  ANDLW  DF
4F48:  BRA    4F4C
4F4A:  MOVF   x11,W
4F4C:  MOVWF  x11
4F4E:  BRA    4EB2
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
4F50:  MOVF   x0F,W
4F52:  SUBLW  0A
4F54:  BNZ   4F64
4F56:  DECFSZ x0E,W
4F58:  BRA    4F64
....................       result = -result;
4F5A:  COMF   x0C,F
4F5C:  COMF   x0D,F
4F5E:  INCF   x0C,F
4F60:  BTFSC  FD8.2
4F62:  INCF   x0D,F
.................... 
....................    return(result);
4F64:  MOVFF  30C,01
4F68:  MOVFF  30D,02
4F6C:  MOVLB  0
4F6E:  GOTO   64A4 (RETURN)
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
41F0:  MOVLB  3
41F2:  CLRF   x30
41F4:  CLRF   x2F
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
41F6:  MOVLW  30
41F8:  MOVWF  x32
41FA:  MOVLW  31
41FC:  MOVWF  x33
41FE:  MOVLW  32
4200:  MOVWF  x34
4202:  MOVLW  33
4204:  MOVWF  x35
4206:  MOVLW  34
4208:  MOVWF  x36
420A:  MOVLW  35
420C:  MOVWF  x37
420E:  MOVLW  36
4210:  MOVWF  x38
4212:  MOVLW  37
4214:  MOVWF  x39
4216:  MOVLW  38
4218:  MOVWF  x3A
421A:  MOVLW  39
421C:  MOVWF  x3B
421E:  MOVLW  61
4220:  MOVWF  x3C
4222:  MOVLW  62
4224:  MOVWF  x3D
4226:  MOVLW  63
4228:  MOVWF  x3E
422A:  MOVLW  64
422C:  MOVWF  x3F
422E:  MOVLW  65
4230:  MOVWF  x40
4232:  MOVLW  66
4234:  MOVWF  x41
4236:  MOVLW  67
4238:  MOVWF  x42
423A:  MOVLW  68
423C:  MOVWF  x43
423E:  MOVLW  69
4240:  MOVWF  x44
4242:  MOVLW  6A
4244:  MOVWF  x45
4246:  MOVLW  6B
4248:  MOVWF  x46
424A:  MOVLW  6C
424C:  MOVWF  x47
424E:  MOVLW  6D
4250:  MOVWF  x48
4252:  MOVLW  6E
4254:  MOVWF  x49
4256:  MOVLW  6F
4258:  MOVWF  x4A
425A:  MOVLW  70
425C:  MOVWF  x4B
425E:  MOVLW  71
4260:  MOVWF  x4C
4262:  MOVLW  73
4264:  MOVWF  x4D
4266:  MOVLW  74
4268:  MOVWF  x4E
426A:  MOVLW  75
426C:  MOVWF  x4F
426E:  MOVLW  76
4270:  MOVWF  x50
4272:  MOVLW  77
4274:  MOVWF  x51
4276:  MOVLW  78
4278:  MOVWF  x52
427A:  MOVLW  79
427C:  MOVWF  x53
427E:  MOVLW  7A
4280:  MOVWF  x54
4282:  CLRF   x55
....................    for(sc=s;isspace(*sc);++sc);
4284:  MOVFF  325,32A
4288:  MOVFF  324,329
428C:  MOVFF  32A,FEA
4290:  MOVFF  329,FE9
4294:  MOVF   FEF,W
4296:  SUBLW  20
4298:  BNZ   42A2
429A:  INCF   x29,F
429C:  BTFSC  FD8.2
429E:  INCF   x2A,F
42A0:  BRA    428C
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
42A2:  MOVFF  32A,03
42A6:  MOVFF  329,FE9
42AA:  MOVFF  03,FEA
42AE:  MOVF   FEF,W
42B0:  SUBLW  2D
42B2:  BZ    42C2
42B4:  MOVFF  32A,FEA
42B8:  MOVFF  329,FE9
42BC:  MOVF   FEF,W
42BE:  SUBLW  2B
42C0:  BNZ   42D4
42C2:  MOVFF  32A,FEA
42C6:  MOVF   x29,W
42C8:  INCF   x29,F
42CA:  BTFSC  FD8.2
42CC:  INCF   x2A,F
42CE:  MOVWF  FE9
42D0:  MOVF   FEF,W
42D2:  BRA    42D6
42D4:  MOVLW  2B
42D6:  MOVWF  x31
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
42D8:  MOVF   x31,W
42DA:  SUBLW  2D
42DC:  BZ    431A
42DE:  CLRF   03
42E0:  MOVF   x28,W
42E2:  MOVWF  00
42E4:  BTFSC  FE8.7
42E6:  DECF   03,F
42E8:  MOVWF  01
42EA:  BTFSC  03.7
42EC:  BRA    431A
42EE:  CLRF   03
42F0:  MOVF   x28,W
42F2:  MOVWF  00
42F4:  BTFSC  FE8.7
42F6:  DECF   03,F
42F8:  SUBLW  01
42FA:  BNZ   4300
42FC:  MOVF   03,F
42FE:  BZ    431A
4300:  CLRF   03
4302:  MOVF   x28,W
4304:  MOVWF  00
4306:  BTFSC  FE8.7
4308:  DECF   03,F
430A:  MOVWF  01
430C:  BTFSC  03.7
430E:  BRA    431E
4310:  MOVF   03,F
4312:  BNZ   431A
4314:  MOVF   01,W
4316:  SUBLW  24
4318:  BC    431E
....................    goto StrtoulGO;
431A:  BRA    458A
431C:  BRA    443A
.................... 
....................    else if (base)
431E:  MOVF   x28,F
4320:  BZ    43D2
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
4322:  CLRF   03
4324:  MOVF   x28,W
4326:  MOVWF  00
4328:  BTFSC  FE8.7
432A:  DECF   03,F
432C:  SUBLW  10
432E:  BNZ   436E
4330:  MOVF   03,F
4332:  BNZ   436E
4334:  MOVFF  32A,FEA
4338:  MOVFF  329,FE9
433C:  MOVF   FEF,W
433E:  SUBLW  30
4340:  BNZ   436E
4342:  MOVLW  01
4344:  ADDWF  x29,W
4346:  MOVWF  FE9
4348:  MOVLW  00
434A:  ADDWFC x2A,W
434C:  MOVWF  FEA
434E:  MOVF   FEF,W
4350:  SUBLW  78
4352:  BZ    4366
4354:  MOVLW  01
4356:  ADDWF  x29,W
4358:  MOVWF  FE9
435A:  MOVLW  00
435C:  ADDWFC x2A,W
435E:  MOVWF  FEA
4360:  MOVF   FEF,W
4362:  SUBLW  58
4364:  BNZ   436E
....................          sc+=2;
4366:  MOVLW  02
4368:  ADDWF  x29,F
436A:  MOVLW  00
436C:  ADDWFC x2A,F
....................       if(base==8 && *sc =='0')
436E:  CLRF   03
4370:  MOVF   x28,W
4372:  MOVWF  00
4374:  BTFSC  FE8.7
4376:  DECF   03,F
4378:  SUBLW  08
437A:  BNZ   4396
437C:  MOVF   03,F
437E:  BNZ   4396
4380:  MOVFF  32A,FEA
4384:  MOVFF  329,FE9
4388:  MOVF   FEF,W
438A:  SUBLW  30
438C:  BNZ   4396
....................          sc+=1;
438E:  MOVLW  01
4390:  ADDWF  x29,F
4392:  MOVLW  00
4394:  ADDWFC x2A,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
4396:  CLRF   03
4398:  MOVF   x28,W
439A:  MOVWF  00
439C:  BTFSC  FE8.7
439E:  DECF   03,F
43A0:  SUBLW  02
43A2:  BNZ   43D0
43A4:  MOVF   03,F
43A6:  BNZ   43D0
43A8:  MOVFF  32A,FEA
43AC:  MOVFF  329,FE9
43B0:  MOVF   FEF,W
43B2:  SUBLW  30
43B4:  BNZ   43D0
43B6:  MOVLW  01
43B8:  ADDWF  x29,W
43BA:  MOVWF  FE9
43BC:  MOVLW  00
43BE:  ADDWFC x2A,W
43C0:  MOVWF  FEA
43C2:  MOVF   FEF,W
43C4:  SUBLW  62
43C6:  BNZ   43D0
....................          sc+=2;
43C8:  MOVLW  02
43CA:  ADDWF  x29,F
43CC:  MOVLW  00
43CE:  ADDWFC x2A,F
.................... 
....................    }
43D0:  BRA    443A
....................    else if(*sc!='0') // base is 0, find base
43D2:  MOVFF  32A,FEA
43D6:  MOVFF  329,FE9
43DA:  MOVF   FEF,W
43DC:  SUBLW  30
43DE:  BZ    43E6
....................       base=10;
43E0:  MOVLW  0A
43E2:  MOVWF  x28
43E4:  BRA    443A
....................    else if (sc[1]=='x' || sc[1]=='X')
43E6:  MOVLW  01
43E8:  ADDWF  x29,W
43EA:  MOVWF  FE9
43EC:  MOVLW  00
43EE:  ADDWFC x2A,W
43F0:  MOVWF  FEA
43F2:  MOVF   FEF,W
43F4:  SUBLW  78
43F6:  BZ    440A
43F8:  MOVLW  01
43FA:  ADDWF  x29,W
43FC:  MOVWF  FE9
43FE:  MOVLW  00
4400:  ADDWFC x2A,W
4402:  MOVWF  FEA
4404:  MOVF   FEF,W
4406:  SUBLW  58
4408:  BNZ   4418
....................       base =16,sc+=2;
440A:  MOVLW  10
440C:  MOVWF  x28
440E:  MOVLW  02
4410:  ADDWF  x29,F
4412:  MOVLW  00
4414:  ADDWFC x2A,F
4416:  BRA    443A
....................    else if(sc[1]=='b')
4418:  MOVLW  01
441A:  ADDWF  x29,W
441C:  MOVWF  FE9
441E:  MOVLW  00
4420:  ADDWFC x2A,W
4422:  MOVWF  FEA
4424:  MOVF   FEF,W
4426:  SUBLW  62
4428:  BNZ   4436
....................       base=2,sc+=2;
442A:  MOVLW  02
442C:  MOVWF  x28
442E:  ADDWF  x29,F
4430:  MOVLW  00
4432:  ADDWFC x2A,F
4434:  BRA    443A
....................    else
....................       base=8;
4436:  MOVLW  08
4438:  MOVWF  x28
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
443A:  MOVFF  32A,32C
443E:  MOVFF  329,32B
4442:  MOVFF  32A,FEA
4446:  MOVFF  329,FE9
444A:  MOVF   FEF,W
444C:  SUBLW  30
444E:  BNZ   4458
4450:  INCF   x29,F
4452:  BTFSC  FD8.2
4454:  INCF   x2A,F
4456:  BRA    4442
....................    sd=memchr(digits,tolower(*sc),base);
4458:  MOVFF  32A,03
445C:  MOVFF  329,FE9
4460:  MOVFF  03,FEA
4464:  MOVFF  FEF,356
4468:  MOVF   x56,W
446A:  SUBLW  40
446C:  BC    447A
446E:  MOVF   x56,W
4470:  SUBLW  5A
4472:  BNC   447A
4474:  MOVF   x56,W
4476:  IORLW  20
4478:  BRA    447C
447A:  MOVF   x56,W
447C:  MOVWF  x56
447E:  MOVLW  03
4480:  MOVWF  x58
4482:  MOVLW  32
4484:  MOVWF  x57
4486:  MOVFF  356,359
448A:  CLRF   x5B
448C:  MOVFF  328,35A
4490:  BTFSC  x5A.7
4492:  DECF   x5B,F
4494:  MOVLB  0
4496:  RCALL  41A6
4498:  MOVFF  02,32E
449C:  MOVFF  01,32D
....................    for(; sd!=0; )
44A0:  MOVLB  3
44A2:  MOVF   x2D,F
44A4:  BNZ   44AA
44A6:  MOVF   x2E,F
44A8:  BZ    457E
....................    {
....................       x=x*base+(int16)(sd-digits);
44AA:  CLRF   03
44AC:  MOVF   x28,W
44AE:  BTFSC  FE8.7
44B0:  DECF   03,F
44B2:  MOVWF  00
44B4:  MOVFF  03,01
44B8:  CLRF   02
44BA:  CLRF   03
44BC:  BTFSS  01.7
44BE:  BRA    44C4
44C0:  DECF   02,F
44C2:  DECF   03,F
44C4:  MOVFF  03,359
44C8:  MOVFF  02,358
44CC:  MOVFF  01,357
44D0:  MOVFF  00,356
44D4:  CLRF   x5D
44D6:  CLRF   x5C
44D8:  MOVFF  330,35B
44DC:  MOVFF  32F,35A
44E0:  MOVFF  03,361
44E4:  MOVFF  02,360
44E8:  MOVFF  01,35F
44EC:  MOVFF  00,35E
44F0:  MOVLB  0
44F2:  CALL   0D46
44F6:  MOVFF  03,359
44FA:  MOVFF  02,358
44FE:  MOVFF  01,357
4502:  MOVFF  00,356
4506:  MOVLW  32
4508:  MOVLB  3
450A:  SUBWF  x2D,W
450C:  MOVWF  00
450E:  MOVLW  03
4510:  SUBWFB x2E,W
4512:  MOVWF  03
4514:  MOVF   00,W
4516:  ADDWF  x56,W
4518:  MOVWF  00
451A:  MOVF   03,W
451C:  ADDWFC 01,W
451E:  MOVWF  01
4520:  MOVLW  00
4522:  ADDWFC 02,W
4524:  MOVLW  00
4526:  ADDWFC x59,W
4528:  MOVFF  01,330
452C:  MOVFF  00,32F
....................       ++sc;
4530:  INCF   x29,F
4532:  BTFSC  FD8.2
4534:  INCF   x2A,F
....................       sd=memchr(digits,tolower(*sc),base);
4536:  MOVFF  32A,FEA
453A:  MOVFF  329,FE9
453E:  MOVFF  FEF,356
4542:  MOVF   x56,W
4544:  SUBLW  40
4546:  BC    4554
4548:  MOVF   x56,W
454A:  SUBLW  5A
454C:  BNC   4554
454E:  MOVF   x56,W
4550:  IORLW  20
4552:  BRA    4556
4554:  MOVF   x56,W
4556:  MOVWF  x56
4558:  MOVLW  03
455A:  MOVWF  x58
455C:  MOVLW  32
455E:  MOVWF  x57
4560:  MOVFF  356,359
4564:  CLRF   x5B
4566:  MOVFF  328,35A
456A:  BTFSC  x5A.7
456C:  DECF   x5B,F
456E:  MOVLB  0
4570:  RCALL  41A6
4572:  MOVFF  02,32E
4576:  MOVFF  01,32D
457A:  BRA    44A0
457C:  MOVLB  3
....................    }
....................    if(s1==sc)
457E:  MOVF   x29,W
4580:  SUBWF  x2B,W
4582:  BNZ   45AC
4584:  MOVF   x2A,W
4586:  SUBWF  x2C,W
4588:  BNZ   45AC
....................    {
....................    StrtoulGO:
....................       if (endptr)
458A:  MOVLB  3
458C:  MOVF   x26,W
458E:  IORWF  x27,W
4590:  BZ    45A4
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
4592:  MOVFF  327,FEA
4596:  MOVFF  326,FE9
459A:  MOVFF  325,FEC
459E:  MOVF   FED,F
45A0:  MOVFF  324,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
45A4:  MOVLW  00
45A6:  MOVWF  01
45A8:  MOVWF  02
45AA:  BRA    45CC
....................    }
....................    if (endptr)
45AC:  MOVF   x26,W
45AE:  IORWF  x27,W
45B0:  BZ    45C4
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
45B2:  MOVFF  327,FEA
45B6:  MOVFF  326,FE9
45BA:  MOVFF  32A,FEC
45BE:  MOVF   FED,F
45C0:  MOVFF  329,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
45C4:  MOVFF  32F,01
45C8:  MOVFF  330,02
45CC:  MOVLB  0
45CE:  GOTO   4718 (RETURN)
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
*
0DEA:  MOVFF  51,35D
0DEE:  MOVFF  50,35C
0DF2:  MOVFF  4F,35B
0DF6:  MOVFF  4E,35A
0DFA:  MOVLW  41
0DFC:  MOVLB  3
0DFE:  MOVWF  x61
0E00:  MOVLW  C6
0E02:  MOVWF  x60
0E04:  MOVLW  4E
0E06:  MOVWF  x5F
0E08:  MOVLW  6D
0E0A:  MOVWF  x5E
0E0C:  MOVLB  0
0E0E:  RCALL  0D46
0E10:  MOVLW  39
0E12:  MOVLB  2
0E14:  ADDWF  00,W
0E16:  MOVWF  4E
0E18:  MOVLW  30
0E1A:  ADDWFC 01,W
0E1C:  MOVWF  4F
0E1E:  MOVLW  00
0E20:  ADDWFC 02,W
0E22:  MOVWF  50
0E24:  MOVLW  00
0E26:  ADDWFC 03,W
0E28:  MOVWF  51
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
0E2A:  MOVFF  50,00
0E2E:  MOVFF  51,01
0E32:  CLRF   02
0E34:  CLRF   03
0E36:  MOVFF  51,2F9
0E3A:  MOVFF  50,2F8
0E3E:  MOVFF  51,2FB
0E42:  MOVFF  50,2FA
0E46:  MOVLW  7F
0E48:  MOVWF  xFD
0E4A:  SETF   xFC
0E4C:  MOVLB  0
0E4E:  BRA    0DA2
0E50:  MOVFF  00,01
0E54:  MOVFF  03,02
0E58:  GOTO   0F66 (RETURN)
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
*
0D32:  MOVFF  2FA,51
0D36:  MOVFF  2F9,50
0D3A:  MOVFF  2F8,4F
0D3E:  MOVFF  2F7,4E
0D42:  GOTO   0F64 (RETURN)
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.c"
.................... /*********************************************************************
....................  *
....................  *                  Helper Functions for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.C
....................  * Dependencies:    compiler.h
....................  *                  helpers.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid
....................  *                               multi-byte shift operation.
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and
....................  *                        btohexa_low()
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... /*********************************************************************
....................  *
....................  *            ENC28J60 registers/bits
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.h
....................  * Description: 	Include file for ENC28J60 control registers
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder		06/01/04	Original
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a 
....................  *									couple of PHY register structs.
....................  * Howard Schlunder		09/29/04	Matched with data sheet
....................  * Howard Schlunder		01/04/06	Matched with new data sheet
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN
....................  * Howard Schlunder		07/21/06	Several bits removed to match now 
....................  *									reserved bits in rev. B data sheet 
....................  *									(DS39662B)
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef ENC28J60_H
.................... #define ENC28J60_H
.................... 
.................... typedef union {
.................... 	BYTE v[7];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 CollisionCount:4;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 Done:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 PacketDefer:1;
.................... 		int8 ExcessiveDefer:1;
.................... 		int8 MaximumCollisions:1;
.................... 		int8 LateCollision:1;
.................... 		int8 Giant:1;
.................... 		int8 Underrun:1;
.................... 		int16 	 BytesTransmittedOnWire;
.................... 		int8 ControlFrame:1;
.................... 		int8 PAUSEControlFrame:1;
.................... 		int8 BackpressureApplied:1;
.................... 		int8 VLANTaggedFrame:1;
.................... 		int8 Zeros:4;
.................... 	} bits;
.................... } TXSTATUS;
.................... 
.................... typedef union {
.................... 	char v[4];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 PreviouslyIgnored:1;
.................... 		int8 RXDCPreviouslySeen:1;
.................... 		int8 CarrierPreviouslySeen:1;
.................... 		int8 CodeViolation:1;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 ReceiveOk:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 DribbleNibble:1;
.................... 		int8 ControlFrame:1;
.................... 		int8 PauseControlFrame:1;
.................... 		int8 UnsupportedOpcode:1;
.................... 		int8 VLANType:1;
.................... 		int8 Zero:1;
.................... 	} bits;
.................... } RXSTATUS;
.................... 
.................... /******************************************************************************
.................... * Register locations
.................... ******************************************************************************/
.................... // Bank 0 registers --------
.................... #define ERDPTL		0x00
.................... #define ERDPTH		0x01
.................... #define EWRPTL		0x02
.................... #define EWRPTH		0x03
.................... #define ETXSTL		0x04
.................... #define ETXSTH		0x05
.................... #define ETXNDL		0x06
.................... #define ETXNDH		0x07
.................... #define ERXSTL		0x08
.................... #define ERXSTH		0x09
.................... #define ERXNDL		0x0A
.................... #define ERXNDH		0x0B
.................... #define ERXRDPTL	0x0C
.................... #define ERXRDPTH	0x0D
.................... #define ERXWRPTL	0x0E
.................... #define ERXWRPTH	0x0F
.................... #define EDMASTL		0x10
.................... #define EDMASTH		0x11
.................... #define EDMANDL		0x12
.................... #define EDMANDH		0x13
.................... #define EDMADSTL	0x14
.................... #define EDMADSTH	0x15
.................... #define EDMACSL		0x16
.................... #define EDMACSH		0x17
.................... //#define			0x18
.................... //#define			0x19
.................... //#define r			0x1A
.................... #define EIE			0x1B
.................... #define EIR			0x1C
.................... #define ESTAT		0x1D
.................... #define ECON2		0x1E
.................... #define ECON1		0x1F
.................... 
.................... // Bank 1 registers -----
.................... #define EHT0		0x100
.................... #define EHT1		0x101
.................... #define EHT2		0x102
.................... #define EHT3		0x103
.................... #define EHT4		0x104
.................... #define EHT5		0x105
.................... #define EHT6		0x106
.................... #define EHT7		0x107
.................... #define EPMM0		0x108
.................... #define EPMM1		0x109
.................... #define EPMM2		0x10A
.................... #define EPMM3		0x10B
.................... #define EPMM4		0x10C
.................... #define EPMM5		0x10D
.................... #define EPMM6		0x10E
.................... #define EPMM7		0x10F
.................... #define EPMCSL		0x110
.................... #define EPMCSH		0x111
.................... //#define			0x112
.................... //#define			0x113
.................... #define EPMOL		0x114
.................... #define EPMOH		0x115
.................... //#define r			0x116
.................... //#define r			0x117
.................... #define ERXFCON		0x118
.................... #define EPKTCNT		0x119
.................... //#define r			0x11A
.................... //#define EIE		0x11B
.................... //#define EIR		0x11C
.................... //#define ESTAT		0x11D
.................... //#define ECON2		0x11E
.................... //#define ECON1		0x11F
.................... 
.................... // Bank 2 registers -----
.................... #define MACON1		0x200
.................... #define MACON2    0x201
.................... //#define r			0x201
.................... #define MACON3		0x202
.................... #define MACON4		0x203
.................... #define MABBIPG		0x204
.................... //#define			0x205
.................... #define MAIPGL		0x206
.................... #define MAIPGH		0x207
.................... #define MACLCON1	0x208
.................... #define MACLCON2	0x209
.................... #define MAMXFLL		0x20A
.................... #define MAMXFLH		0x20B
.................... //#define r			0x20C
.................... //#define r			0x20D
.................... //#define r			0x20E
.................... //#define			0x20F
.................... //#define r			0x210
.................... //#define r			0x211
.................... #define MICMD		0x212
.................... //#define r			0x213
.................... #define MIREGADR	0x214
.................... //#define r			0x215
.................... #define MIWRL		0x216
.................... #define MIWRH		0x217
.................... #define MIRDL		0x218
.................... #define MIRDH		0x219
.................... //#define r			0x21A
.................... //#define EIE		0x21B
.................... //#define EIR		0x21C
.................... //#define ESTAT		0x21D
.................... //#define ECON2		0x21E
.................... //#define ECON1		0x21F
.................... 
.................... // Bank 3 registers -----
.................... #define MAADR5		0x300
.................... #define MAADR6		0x301
.................... #define MAADR3		0x302
.................... #define MAADR4		0x303
.................... #define MAADR1		0x304
.................... #define MAADR2		0x305
.................... #define EBSTSD		0x306
.................... #define EBSTCON		0x307
.................... #define EBSTCSL		0x308
.................... #define EBSTCSH		0x309
.................... #define MISTAT		0x30A
.................... //#define			0x30B
.................... //#define			0x30C
.................... //#define			0x30D
.................... //#define			0x30E
.................... //#define			0x30F
.................... //#define			0x310
.................... //#define			0x311
.................... #define EREVID		0x312
.................... //#define			0x313
.................... //#define			0x314
.................... #define ECOCON		0x315
.................... //#define 			0x316
.................... #define EFLOCON		0x317
.................... #define EPAUSL		0x318
.................... #define EPAUSH		0x319
.................... //#define r			0x31A
.................... //#define EIE		0x31B
.................... //#define EIR		0x31C
.................... //#define ESTAT		0x31D
.................... //#define ECON2		0x31E
.................... //#define ECON1		0x31F
.................... 
.................... 
.................... 
.................... // Structures
.................... typedef union _REG
.................... {
.................... 	char Val;
.................... 
.................... 	// EIE bits ----------
.................... 	struct {
.................... 		unsigned char RXERIE:1;
.................... 		unsigned char TXERIE:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIE:1;
.................... 		unsigned char LINKIE:1;
.................... 		unsigned char DMAIE:1;
.................... 		unsigned char PKTIE:1;
.................... 		unsigned char INTIE:1;
.................... 	} EIEbits;
.................... 
.................... 	// EIR bits ----------
.................... 	struct {
.................... 		unsigned char RXERIF:1;
.................... 		unsigned char TXERIF:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIF:1;
.................... 		unsigned char LINKIF:1;
.................... 		unsigned char DMAIF:1;
.................... 		unsigned char PKTIF:1;
.................... 		unsigned char blank1:1;
.................... 	} EIRbits;
.................... 
.................... 	// ESTAT bits ---------
.................... 	struct {
.................... 		unsigned char CLKRDY:1;
.................... 		unsigned char TXABRT:1;
.................... 		unsigned char RXBUSY:1;
.................... 		unsigned char blank1:1;
.................... 		unsigned char LATECOL:1;
.................... 		unsigned char blank2:2;
.................... 		unsigned char INTR:1;
.................... 	} ESTATbits;
.................... 
.................... 	// ECON2 bits --------
.................... 	struct {
.................... 		unsigned char blank3:3;
.................... 		unsigned char VRPS:1;
.................... 		unsigned char VRTP:1;
.................... 		unsigned char PWRSV:1;
.................... 		unsigned char PKTDEC:1;
.................... 		unsigned char AUTOINC:1;
.................... 	} ECON2bits;
.................... 
.................... 	// ECON1 bits --------
.................... 	struct {
.................... 		unsigned char BSEL0:1;
.................... 		unsigned char BSEL1:1;
.................... 		unsigned char RXEN:1;
.................... 		unsigned char TXRTS:1;
.................... 		unsigned char CSUMEN:1;
.................... 		unsigned char DMAST:1;
.................... 		unsigned char RXRST:1;
.................... 		unsigned char TXRST:1;
.................... 	} ECON1bits;
.................... 
.................... 	// ERXFCON bits ------
.................... 	struct {
.................... 		unsigned char BCEN:1;
.................... 		unsigned char MCEN:1;
.................... 		unsigned char HTEN:1;
.................... 		unsigned char MPEN:1;
.................... 		unsigned char PMEN:1;
.................... 		unsigned char CRCEN:1;
.................... 		unsigned char ANDOR:1;
.................... 		unsigned char UCEN:1;
.................... 	} ERXFCONbits;
.................... 
.................... 	// MACON1 bits --------
.................... 	struct {
.................... 		unsigned char MARXEN:1;
.................... 		unsigned char PASSALL:1;
.................... 		unsigned char RXPAUS:1;
.................... 		unsigned char TXPAUS:1;
.................... 		unsigned char :4;
.................... 	} MACON1bits;
.................... 
.................... 
.................... 	// MACON3 bits --------
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG0:1;
.................... 		unsigned char PADCFG1:1;
.................... 		unsigned char PADCFG2:1;
.................... 	} MACON3bits;
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG:3;
.................... 	} MACON3bits2;
.................... 
.................... 	// MACON4 bits --------
.................... 	struct {
.................... 		unsigned char :4;
.................... 		unsigned char NOBKOFF:1;
.................... 		unsigned char BPEN:1;
.................... 		unsigned char DEFER:1;
.................... 		unsigned char blank1:1;
.................... 	} MACON4bits;
.................... 
.................... 	// MICMD bits ---------
.................... 	struct {
.................... 		unsigned char MIIRD:1;
.................... 		unsigned char MIISCAN:1;
.................... 		unsigned char blank6:6;
.................... 	} MICMDbits;
.................... 
.................... 	// EBSTCON bits -----
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL0:1;
.................... 		unsigned char TMSEL1:1;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV0:1;
.................... 		unsigned char PSV1:1;
.................... 		unsigned char PSV2:1;
.................... 	} EBSTCONbits;
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL:2;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV:3;
.................... 	} EBSTCONbits2;
.................... 
.................... 	// MISTAT bits --------
.................... 	struct {
.................... 		unsigned char BUSY:1;
.................... 		unsigned char SCAN:1;
.................... 		unsigned char NVALID:1;
.................... 		unsigned char blank5:5;
.................... 	} MISTATbits;
.................... 
.................... 	// ECOCON bits -------
.................... 	struct {
.................... 		unsigned char COCON0:1;
.................... 		unsigned char COCON1:1;
.................... 		unsigned char COCON2:1;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits;
.................... 	struct {
.................... 		unsigned char COCON:3;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits2;
.................... 
.................... 	// EFLOCON bits -----
.................... 	struct {
.................... 		unsigned char FCEN0:1;
.................... 		unsigned char FCEN1:1;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits;
.................... 	struct {
.................... 		unsigned char FCEN:2;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits2;
.................... } REG;
.................... 
.................... 
.................... /******************************************************************************
.................... * PH Register Locations
.................... ******************************************************************************/
.................... #define PHCON1	0x00
.................... #define PHSTAT1	0x01
.................... #define PHID1	0x02
.................... #define PHID2	0x03
.................... #define PHCON2	0x10
.................... #define PHSTAT2	0x11
.................... #define PHIE	0x12
.................... #define PHIR	0x13
.................... #define PHLCON	0x14
.................... 
.................... 
.................... typedef union {
.................... 	int16 Val;
.................... 	WORD_VAL VAL;
.................... 
.................... 	// PHCON1 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 PDPXMD:1;
.................... 		int8 blank2:2;
.................... 		int8 PPWRSV:1;
.................... 		int8 blank22:2;
.................... 		int8 PLOOPBK:1;
.................... 		int8 PRST:1;
.................... 	} PHCON1bits;
.................... 
.................... 	// PHSTAT1 bits --------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 JBSTAT:1;
.................... 		int8 LLSTAT:1;
.................... 		int8 blank5:5;
.................... 		int8 blank3:3;
.................... 		int8 PHDPX:1;
.................... 		int8 PFDPX:1;
.................... 		int8 blank33:3;
.................... 	} PHSTAT1bits;
.................... 
.................... 	// PHID2 bits ----------
.................... 	struct {
.................... 		int8 PREV0:1;
.................... 		int8 PREV1:1;
.................... 		int8 PREV2:1;
.................... 		int8 PREV3:1;
.................... 		int8 PPN0:1;
.................... 		int8 PPN1:1;
.................... 		int8 PPN2:1;
.................... 		int8 PPN3:1;
.................... 		int8 PPN4:1;
.................... 		int8 PPN5:1;
.................... 		int8 PID19:1;
.................... 		int8 PID20:1;
.................... 		int8 PID21:1;
.................... 		int8 PID22:1;
.................... 		int8 PID23:1;
.................... 		int8 PID24:1;
.................... 	} PHID2bits;
.................... 	struct {
.................... 		int8 PREV:4;
.................... 		int8 PPNL:4;
.................... 		int8 PPNH:2;
.................... 		int8 PID:6;
.................... 	} PHID2bits2;
.................... 
.................... 	// PHCON2 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 HDLDIS:1;
.................... 		int8 blank1:1;
.................... 		int8 JABBER:1;
.................... 		int8 blank2:2;
.................... 		int8 TXDIS:1;
.................... 		int8 FRCLNK:1;
.................... 		int8 blank11:1;
.................... 	} PHCON2bits;
.................... 
.................... 	// PHSTAT2 bits --------
.................... 	struct {
.................... 		int8 blank5:5;
.................... 		int8 PLRITY:1;
.................... 		int8 blank2:2;
.................... 		int8 blank11:1;
.................... 		int8 DPXSTAT:1;
.................... 		int8 LSTAT:1;
.................... 		int8 COLSTAT:1;
.................... 		int8 RXSTAT:1;
.................... 		int8 TXSTAT:1;
.................... 		int8 blank22:2;
.................... 	} PHSTAT2bits;
.................... 
.................... 	// PHIE bits -----------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 PGEIE:1;
.................... 		int8 blank2:2;
.................... 		int8 PLNKIE:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIEbits;
.................... 
.................... 	// PHIR bits -----------
.................... 	struct {
.................... 		int8 blank2:2;
.................... 		int8 PGIF:1;
.................... 		int8 blank1:1;
.................... 		int8 PLNKIF:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIRbits;
.................... 
.................... 	// PHLCON bits -------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ0:1;
.................... 		int8 LFRQ1:1;
.................... 		int8 LBCFG0:1;
.................... 		int8 LBCFG1:1;
.................... 		int8 LBCFG2:1;
.................... 		int8 LBCFG3:1;
.................... 		int8 LACFG0:1;
.................... 		int8 LACFG1:1;
.................... 		int8 LACFG2:1;
.................... 		int8 LACFG3:1;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits;
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ:2;
.................... 		int8 LBCFG:4;
.................... 		int8 LACFG:4;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits2;
.................... } PHYREG;
.................... 
.................... 
.................... /******************************************************************************
.................... * Individual Register Bits
.................... ******************************************************************************/
.................... // ETH/MAC/MII bits
.................... 
.................... // EIE bits ----------
.................... #define	EIE_INTIE		(1<<7)
.................... #define	EIE_PKTIE		(1<<6)
.................... #define	EIE_DMAIE		(1<<5)
.................... #define	EIE_LINKIE		(1<<4)
.................... #define	EIE_TXIE		(1<<3)
.................... #define	EIE_TXERIE		(1<<1)
.................... #define	EIE_RXERIE		(1)
.................... 
.................... // EIR bits ----------
.................... #define	EIR_PKTIF		(1<<6)
.................... #define	EIR_DMAIF		(1<<5)
.................... #define	EIR_LINKIF		(1<<4)
.................... #define	EIR_TXIF		(1<<3)
.................... #define	EIR_TXERIF		(1<<1)
.................... #define	EIR_RXERIF		(1)
.................... 
.................... // ESTAT bits ---------
.................... #define	ESTAT_INT		(1<<7)
.................... #define ESTAT_BUFFER	(1<<6)
.................... #define	ESTAT_LATECOL	(1<<4)
.................... #define	ESTAT_RXBUSY	(1<<2)
.................... #define	ESTAT_TXABRT	(1<<1)
.................... #define	ESTAT_CLKRDY	(1)
.................... 
.................... // ECON2 bits --------
.................... #define	ECON2_AUTOINC	(1<<7)
.................... #define	ECON2_PKTDEC	(1<<6)
.................... #define	ECON2_PWRSV		(1<<5)
.................... #define	ECON2_VRPS		(1<<3)
.................... 
.................... // ECON1 bits --------
.................... #define	ECON1_TXRST		(1<<7)
.................... #define	ECON1_RXRST		(1<<6)
.................... #define	ECON1_DMAST		(1<<5)
.................... #define	ECON1_CSUMEN	(1<<4)
.................... #define	ECON1_TXRTS		(1<<3)
.................... #define	ECON1_RXEN		(1<<2)
.................... #define	ECON1_BSEL1		(1<<1)
.................... #define	ECON1_BSEL0		(1)
.................... 
.................... // ERXFCON bits ------
.................... #define	ERXFCON_UCEN	(1<<7)
.................... #define	ERXFCON_ANDOR	(1<<6)
.................... #define	ERXFCON_CRCEN	(1<<5)
.................... #define	ERXFCON_PMEN	(1<<4)
.................... #define	ERXFCON_MPEN	(1<<3)
.................... #define	ERXFCON_HTEN	(1<<2)
.................... #define	ERXFCON_MCEN	(1<<1)
.................... #define	ERXFCON_BCEN	(1)
.................... 
.................... // MACON1 bits --------
.................... #define	MACON1_TXPAUS	(1<<3)
.................... #define	MACON1_RXPAUS	(1<<2)
.................... #define	MACON1_PASSALL	(1<<1)
.................... #define	MACON1_MARXEN	(1)
.................... 
.................... // MACON3 bits --------
.................... #define	MACON3_PADCFG2	(1<<7)
.................... #define	MACON3_PADCFG1	(1<<6)
.................... #define	MACON3_PADCFG0	(1<<5)
.................... #define	MACON3_TXCRCEN	(1<<4)
.................... #define	MACON3_PHDRLEN	(1<<3)
.................... #define	MACON3_HFRMEN	(1<<2)
.................... #define	MACON3_FRMLNEN	(1<<1)
.................... #define	MACON3_FULDPX	(1)
.................... 
.................... // MACON4 bits --------
.................... #define	MACON4_DEFER	(1<<6)
.................... #define	MACON4_BPEN		(1<<5)
.................... #define	MACON4_NOBKOFF	(1<<4)
.................... 
.................... 
.................... // MICMD bits ---------
.................... #define	MICMD_MIISCAN	(1<<1)
.................... #define	MICMD_MIIRD		(1)
.................... 
.................... // EBSTCON bits -----
.................... #define	EBSTCON_PSV2	(1<<7)
.................... #define	EBSTCON_PSV1	(1<<6)
.................... #define	EBSTCON_PSV0	(1<<5)
.................... #define	EBSTCON_PSEL	(1<<4)
.................... #define	EBSTCON_TMSEL1	(1<<3)
.................... #define	EBSTCON_TMSEL0	(1<<2)
.................... #define	EBSTCON_TME		(1<<1)
.................... #define	EBSTCON_BISTST	(1)
.................... 
.................... // MISTAT bits --------
.................... #define	MISTAT_NVALID	(1<<2)
.................... #define	MISTAT_SCAN		(1<<1)
.................... #define	MISTAT_BUSY		(1)
.................... 
.................... // ECOCON bits -------
.................... #define	ECOCON_COCON2	(1<<2)
.................... #define	ECOCON_COCON1	(1<<1)
.................... #define	ECOCON_COCON0	(1)
.................... 
.................... // EFLOCON bits -----
.................... #define	EFLOCON_FULDPXS	(1<<2)
.................... #define	EFLOCON_FCEN1	(1<<1)
.................... #define	EFLOCON_FCEN0	(1)
.................... 
.................... 
.................... 
.................... // PHY bits
.................... 
.................... // PHCON1 bits ----------
.................... #define	PHCON1_PRST		(1ul<<15)
.................... #define	PHCON1_PLOOPBK	(1ul<<14)
.................... #define	PHCON1_PPWRSV	(1ul<<11)
.................... #define	PHCON1_PDPXMD	(1ul<<8)
.................... 
.................... // PHSTAT1 bits --------
.................... #define	PHSTAT1_PFDPX	(1ul<<12)
.................... #define	PHSTAT1_PHDPX	(1ul<<11)
.................... #define	PHSTAT1_LLSTAT	(1ul<<2)
.................... #define	PHSTAT1_JBSTAT	(1ul<<1)
.................... 
.................... // PHID2 bits --------
.................... #define	PHID2_PID24		(1ul<<15)
.................... #define	PHID2_PID23		(1ul<<14)
.................... #define	PHID2_PID22		(1ul<<13)
.................... #define	PHID2_PID21		(1ul<<12)
.................... #define	PHID2_PID20		(1ul<<11)
.................... #define	PHID2_PID19		(1ul<<10)
.................... #define	PHID2_PPN5		(1ul<<9)
.................... #define	PHID2_PPN4		(1ul<<8)
.................... #define	PHID2_PPN3		(1ul<<7)
.................... #define	PHID2_PPN2		(1ul<<6)
.................... #define	PHID2_PPN1		(1ul<<5)
.................... #define	PHID2_PPN0		(1ul<<4)
.................... #define	PHID2_PREV3		(1ul<<3)
.................... #define	PHID2_PREV2		(1ul<<2)
.................... #define	PHID2_PREV1		(1ul<<1)
.................... #define	PHID2_PREV0		(1ul)
.................... 
.................... // PHCON2 bits ----------
.................... #define	PHCON2_FRCLNK	(1ul<<14)
.................... #define	PHCON2_TXDIS	(1ul<<13)
.................... #define	PHCON2_JABBER	(1ul<<10)
.................... #define	PHCON2_HDLDIS	(1ul<<8)
.................... 
.................... // PHSTAT2 bits --------
.................... #define	PHSTAT2_TXSTAT	(1ul<<13)
.................... #define	PHSTAT2_RXSTAT	(1ul<<12)
.................... #define	PHSTAT2_COLSTAT	(1ul<<11)
.................... #define	PHSTAT2_LSTAT	(1ul<<10)
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9)
.................... #define	PHSTAT2_PLRITY	(1ul<<5)
.................... 
.................... // PHIE bits -----------
.................... #define	PHIE_PLNKIE		(1ul<<4)
.................... #define	PHIE_PGEIE		(1ul<<1)
.................... 
.................... // PHIR bits -----------
.................... #define	PHIR_PLNKIF		(1ul<<4)
.................... #define	PHIR_PGIF		(1ul<<2)
.................... 
.................... // PHLCON bits -------
.................... #define	PHLCON_LACFG3	(1ul<<11)
.................... #define	PHLCON_LACFG2	(1ul<<10)
.................... #define	PHLCON_LACFG1	(1ul<<9)
.................... #define	PHLCON_LACFG0	(1ul<<8)
.................... #define	PHLCON_LBCFG3	(1ul<<7)
.................... #define	PHLCON_LBCFG2	(1ul<<6)
.................... #define	PHLCON_LBCFG1	(1ul<<5)
.................... #define	PHLCON_LBCFG0	(1ul<<4)
.................... #define	PHLCON_LFRQ1	(1ul<<3)
.................... #define	PHLCON_LFRQ0	(1ul<<2)
.................... #define	PHLCON_STRCH	(1ul<<1)
.................... 
.................... #endif
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars)
.................... *
.................... * PreCondition:    None
.................... *
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or
.................... *                  'a'-'f'
.................... *
.................... * Output:          The resulting packed byte: 0x00-0xFF
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:         None
.................... ********************************************************************/
.................... BYTE hexatob(WORD_VAL AsciiChars)
.................... {
....................    // Convert lowercase to uppercase
....................    if(AsciiChars.v[1] > 'F')
....................       AsciiChars.v[1] -= 'a'-'A';
....................    if(AsciiChars.v[0] > 'F')
....................       AsciiChars.v[0] -= 'a'-'A';
.................... 
....................    // Convert 0-9, A-F to 0x0-0xF
....................    if(AsciiChars.v[1] > '9')
....................       AsciiChars.v[1] -= 'A' - 10;
....................    else
....................       AsciiChars.v[1] -= '0';
.................... 
....................    if(AsciiChars.v[0] > '9')
....................       AsciiChars.v[0] -= 'A' - 10;
....................    else
....................       AsciiChars.v[0] -= '0';
.................... 
....................    // Concatenate
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        BYTE btohexa_high(BYTE b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           One byte ranged 0x00-0xFF
....................  *
....................  * Output:          An ascii byte (always uppercase) between '0'-'9'
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of
....................  *               the input byte.
....................  *               ex: b = 0xAE, btohexa_high() returns 'A'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:         None
....................  ********************************************************************/
.................... BYTE btohexa_high(BYTE b)
.................... {
....................    b >>= 4;
....................    return (b>0x9) ? b+'A'-10:b+'0';
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        BYTE btohexa_low(BYTE b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           One byte ranged 0x00-0xFF
....................  *
....................  * Output:          An ascii byte (always uppercase) between '0'-'9'
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of
....................  *               the input byte.
....................  *               ex: b = 0xAE, btohexa_low() returns 'E'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:         None
....................  ********************************************************************/
.................... BYTE btohexa_low(BYTE b)
.................... {
....................    b &= 0x0F;
....................    return (b>9) ? b+'A'-10:b+'0';
.................... }
.................... 
.................... WORD swaps(WORD_VAL v)
.................... {
....................     WORD_VAL new;
.................... 
....................     new.v[0]=v.v[1];
*
11CC:  MOVFF  3A9,3AA
....................     new.v[1]=v.v[0];
11D0:  MOVFF  3A8,3AB
.................... 
....................     return(new.Val);
11D4:  MOVLB  3
11D6:  MOVFF  3AA,01
11DA:  MOVFF  3AB,02
11DE:  MOVLB  0
11E0:  RETURN 0
.................... }
.................... 
.................... DWORD swapl(DWORD_VAL v)
.................... {
....................     DWORD_VAL new;
.................... 
....................     new.v[0]=v.v[3];
*
20B6:  MOVFF  394,395
....................     new.v[1]=v.v[2];
20BA:  MOVFF  393,396
....................     new.v[2]=v.v[1];
20BE:  MOVFF  392,397
....................     new.v[3]=v.v[0];
20C2:  MOVFF  391,398
.................... 
....................     return(new.Val);
20C6:  MOVFF  395,00
20CA:  MOVFF  396,01
20CE:  MOVFF  397,02
20D2:  MOVFF  398,03
20D6:  RETURN 0
.................... }
.................... 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count)
.................... {
....................    WORD i;
....................    WORD *val;
.................... 
....................    union
....................    {
....................       DWORD Val;
....................       struct
....................       {
....................          WORD_VAL LSB;
....................          WORD_VAL MSB;
....................       } words;
....................    } tempSum, sum;
.................... 
....................    sum.Val = 0;
*
1E2A:  MOVLB  3
1E2C:  CLRF   x9A
1E2E:  CLRF   x99
1E30:  CLRF   x98
1E32:  CLRF   x97
.................... 
....................    i = count >> 1;
1E34:  BCF    FD8.0
1E36:  RRCF   x8E,W
1E38:  MOVWF  x90
1E3A:  RRCF   x8D,W
1E3C:  MOVWF  x8F
....................    val = (WORD *)buffer;
1E3E:  MOVFF  38C,392
1E42:  MOVFF  38B,391
.................... 
....................    while( i-- )
1E46:  MOVFF  390,03
1E4A:  MOVF   x8F,W
1E4C:  BTFSC  FD8.2
1E4E:  DECF   x90,F
1E50:  DECF   x8F,F
1E52:  IORWF  03,W
1E54:  BZ    1E7C
....................       sum.Val += *val++;
1E56:  MOVFF  392,FEA
1E5A:  MOVFF  391,FE9
1E5E:  MOVLW  02
1E60:  ADDWF  x91,F
1E62:  BTFSC  FD8.0
1E64:  INCF   x92,F
1E66:  MOVFF  FEC,03
1E6A:  MOVF   FED,F
1E6C:  MOVF   FEF,W
1E6E:  ADDWF  x97,F
1E70:  MOVF   03,W
1E72:  ADDWFC x98,F
1E74:  MOVLW  00
1E76:  ADDWFC x99,F
1E78:  ADDWFC x9A,F
1E7A:  BRA    1E46
.................... 
....................    if ( count & 1 )
1E7C:  MOVF   x8D,W
1E7E:  ANDLW  01
1E80:  MOVWF  00
1E82:  CLRF   03
1E84:  MOVF   00,W
1E86:  IORWF  03,W
1E88:  BZ    1E9E
....................       sum.Val += *(BYTE *)val;
1E8A:  MOVFF  392,FEA
1E8E:  MOVFF  391,FE9
1E92:  MOVF   FEF,W
1E94:  ADDWF  x97,F
1E96:  MOVLW  00
1E98:  ADDWFC x98,F
1E9A:  ADDWFC x99,F
1E9C:  ADDWFC x9A,F
.................... 
....................    tempSum.Val = sum.Val;
1E9E:  MOVFF  39A,396
1EA2:  MOVFF  399,395
1EA6:  MOVFF  398,394
1EAA:  MOVFF  397,393
.................... 
....................    while( (i = tempSum.words.MSB.Val) != 0u )
1EAE:  MOVFF  396,390
1EB2:  MOVFF  395,38F
1EB6:  MOVF   x8F,F
1EB8:  BNZ   1EBE
1EBA:  MOVF   x90,F
1EBC:  BZ    1F04
....................    {
....................       sum.words.MSB.Val = 0;
1EBE:  CLRF   x9A
1EC0:  CLRF   x99
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i;
1EC2:  CLRF   x9E
1EC4:  CLRF   x9D
1EC6:  MOVFF  398,39C
1ECA:  MOVFF  397,39B
1ECE:  MOVFF  38F,00
1ED2:  MOVFF  390,01
1ED6:  CLRF   02
1ED8:  CLRF   03
1EDA:  MOVF   00,W
1EDC:  ADDWF  x97,W
1EDE:  MOVWF  x97
1EE0:  MOVF   01,W
1EE2:  ADDWFC x98,W
1EE4:  MOVWF  x98
1EE6:  MOVF   02,W
1EE8:  ADDWFC x9D,W
1EEA:  MOVWF  x99
1EEC:  MOVF   03,W
1EEE:  ADDWFC x9E,W
1EF0:  MOVWF  x9A
....................       tempSum.Val = sum.Val;
1EF2:  MOVFF  39A,396
1EF6:  MOVFF  399,395
1EFA:  MOVFF  398,394
1EFE:  MOVFF  397,393
1F02:  BRA    1EAE
....................    }
.................... 
....................    return (~sum.words.LSB.Val);
1F04:  MOVFF  398,03
1F08:  COMF   03,F
1F0A:  MOVF   x97,W
1F0C:  XORLW  FF
1F0E:  MOVWF  01
1F10:  MOVFF  03,02
1F14:  MOVLB  0
1F16:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        WORD CalcIPBufferChecksum(WORD len)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  MAC buffer pointer set to starting of buffer
....................  *
....................  * Input:           len     - Total number of bytes to calculate
....................  *                          checksum for.
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs checksum calculation in
....................  *                  MAC buffer itself.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #if !defined(MCHP_MAC)
.................... WORD CalcIPBufferChecksum(WORD len)
.................... {
....................     BOOL lbMSB;
....................     WORD_VAL checkSum;
....................     BYTE Checkbyte;
.................... 
....................     lbMSB = TRUE;
....................     checkSum.Val = 0;
.................... 
....................     while( len-- )
....................     {
....................         Checkbyte = MACGet();
.................... 
....................         if ( !lbMSB )
....................         {
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte)
....................             {
....................                 if ( ++checkSum.v[1] == 0 )
....................                     checkSum.v[0]++;
....................             }
....................         }
....................         else
....................         {
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte)
....................             {
....................                 if ( ++checkSum.v[0] == 0 )
....................                     checkSum.v[1]++;
....................             }
....................         }
.................... 
....................         lbMSB = !lbMSB;
....................     }
.................... 
....................     checkSum.v[1] = ~checkSum.v[1];
....................     checkSum.v[0] = ~checkSum.v[0];
....................     return checkSum.Val;
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void delay_s(int8 s) {
....................    while(s) {
....................       restart_wdt();
....................       delay_ms(1000);
....................       s--;
....................    }
.................... }
.................... 
.................... #include "tcpip/tick.c"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.c
....................  * Dependencies:    stackTSK.h
....................  *                  Tick.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt
....................  ********************************************************************/
.................... 
.................... #define TICK_INCLUDE
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... TICKTYPE TickCount = 0;  //increment every 100ms
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void)
.................... {
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16);
*
083C:  MOVLW  83
083E:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER);
0840:  MOVLW  85
0842:  MOVWF  FD7
0844:  MOVLW  ED
0846:  MOVWF  FD6
.................... 
....................     enable_interrupts(INT_TIMER0);
0848:  BSF    FF2.5
....................     enable_interrupts(GLOBAL);
084A:  MOVLW  C0
084C:  IORWF  FF2,F
084E:  GOTO   10F4 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void)
.................... {
....................     int16 ret;
....................     disable_interrupts(INT_TIMER0);
*
248A:  BCF    FF2.5
....................     ret=TickCount;
248C:  MOVFF  53,347
2490:  MOVFF  52,346
....................     enable_interrupts(INT_TIMER0);
2494:  BSF    FF2.5
....................     return ret;
2496:  MOVLB  3
2498:  MOVFF  346,01
249C:  MOVFF  347,02
24A0:  MOVLB  0
24A2:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... int8 second_counter=0;  //increment this every 1s
.................... int8 second_counter_intermediate=0;
.................... 
.................... #if STACK_USE_PPP
....................  int8 ppp_second_counter=0;
....................  int8 ppp_second_counter_intermediate=0;
.................... #endif
.................... 
.................... #int_timer0
.................... void Tick_Isr(void)
.................... {
....................         TickCount++;    //increment this every 100ms
*
00AE:  INCF   52,F
00B0:  BTFSC  FD8.2
00B2:  INCF   53,F
.................... 
....................         second_counter_intermediate++;
00B4:  INCF   55,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) {
00B6:  MOVF   55,W
00B8:  SUBLW  09
00BA:  BC    00C0
....................             second_counter++; //increment this ever 1s
00BC:  INCF   54,F
....................             second_counter_intermediate=0;
00BE:  CLRF   55
....................         }
.................... 
.................... 
....................        #if STACK_USE_PPP
....................         ppp_second_counter_intermediate++;
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) {
....................             ppp_second_counter_intermediate=0;
....................             ppp_second_counter++;
....................         }
....................        #endif
.................... 
.................... 
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms
00C0:  MOVLW  85
00C2:  MOVWF  FD7
00C4:  MOVLW  ED
00C6:  MOVWF  FD6
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //#define debug_stack  debug_printf
.................... #define debug_stack
.................... 
.................... #if STACK_USE_MAC
....................    #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
....................    #if STACK_USE_MCPENC
....................     #include "tcpip/enc28j60.c"
.................... /*********************************************************************
....................  *
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.c
....................  * Dependencies:    ENC28J60.h
....................  *                    MAC.h
....................  *                    string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                    Delay.h
....................  * Processor:       PIC18
....................  * Complier:        MCC18 v3.00 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date         Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder      6/28/04   Original
....................  * Howard Schlunder      10/8/04   Cleanup
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds
....................  * Howard Schlunder      1/09/06   Added comments and minor mods
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP
....................  * Darren Rook          7/11/06  CCS Port
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
.................... ********************************************************************/
.................... #define THIS_IS_MAC_LAYER
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/StackTsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/Helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/MAC.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ENC28J60.h"
.................... /*********************************************************************
....................  *
....................  *            ENC28J60 registers/bits
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.h
....................  * Description: 	Include file for ENC28J60 control registers
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder		06/01/04	Original
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a 
....................  *									couple of PHY register structs.
....................  * Howard Schlunder		09/29/04	Matched with data sheet
....................  * Howard Schlunder		01/04/06	Matched with new data sheet
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN
....................  * Howard Schlunder		07/21/06	Several bits removed to match now 
....................  *									reserved bits in rev. B data sheet 
....................  *									(DS39662B)
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef ENC28J60_H
.................... #define ENC28J60_H
.................... 
.................... typedef union {
.................... 	BYTE v[7];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 CollisionCount:4;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 Done:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 PacketDefer:1;
.................... 		int8 ExcessiveDefer:1;
.................... 		int8 MaximumCollisions:1;
.................... 		int8 LateCollision:1;
.................... 		int8 Giant:1;
.................... 		int8 Underrun:1;
.................... 		int16 	 BytesTransmittedOnWire;
.................... 		int8 ControlFrame:1;
.................... 		int8 PAUSEControlFrame:1;
.................... 		int8 BackpressureApplied:1;
.................... 		int8 VLANTaggedFrame:1;
.................... 		int8 Zeros:4;
.................... 	} bits;
.................... } TXSTATUS;
.................... 
.................... typedef union {
.................... 	char v[4];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 PreviouslyIgnored:1;
.................... 		int8 RXDCPreviouslySeen:1;
.................... 		int8 CarrierPreviouslySeen:1;
.................... 		int8 CodeViolation:1;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 ReceiveOk:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 DribbleNibble:1;
.................... 		int8 ControlFrame:1;
.................... 		int8 PauseControlFrame:1;
.................... 		int8 UnsupportedOpcode:1;
.................... 		int8 VLANType:1;
.................... 		int8 Zero:1;
.................... 	} bits;
.................... } RXSTATUS;
.................... 
.................... /******************************************************************************
.................... * Register locations
.................... ******************************************************************************/
.................... // Bank 0 registers --------
.................... #define ERDPTL		0x00
.................... #define ERDPTH		0x01
.................... #define EWRPTL		0x02
.................... #define EWRPTH		0x03
.................... #define ETXSTL		0x04
.................... #define ETXSTH		0x05
.................... #define ETXNDL		0x06
.................... #define ETXNDH		0x07
.................... #define ERXSTL		0x08
.................... #define ERXSTH		0x09
.................... #define ERXNDL		0x0A
.................... #define ERXNDH		0x0B
.................... #define ERXRDPTL	0x0C
.................... #define ERXRDPTH	0x0D
.................... #define ERXWRPTL	0x0E
.................... #define ERXWRPTH	0x0F
.................... #define EDMASTL		0x10
.................... #define EDMASTH		0x11
.................... #define EDMANDL		0x12
.................... #define EDMANDH		0x13
.................... #define EDMADSTL	0x14
.................... #define EDMADSTH	0x15
.................... #define EDMACSL		0x16
.................... #define EDMACSH		0x17
.................... //#define			0x18
.................... //#define			0x19
.................... //#define r			0x1A
.................... #define EIE			0x1B
.................... #define EIR			0x1C
.................... #define ESTAT		0x1D
.................... #define ECON2		0x1E
.................... #define ECON1		0x1F
.................... 
.................... // Bank 1 registers -----
.................... #define EHT0		0x100
.................... #define EHT1		0x101
.................... #define EHT2		0x102
.................... #define EHT3		0x103
.................... #define EHT4		0x104
.................... #define EHT5		0x105
.................... #define EHT6		0x106
.................... #define EHT7		0x107
.................... #define EPMM0		0x108
.................... #define EPMM1		0x109
.................... #define EPMM2		0x10A
.................... #define EPMM3		0x10B
.................... #define EPMM4		0x10C
.................... #define EPMM5		0x10D
.................... #define EPMM6		0x10E
.................... #define EPMM7		0x10F
.................... #define EPMCSL		0x110
.................... #define EPMCSH		0x111
.................... //#define			0x112
.................... //#define			0x113
.................... #define EPMOL		0x114
.................... #define EPMOH		0x115
.................... //#define r			0x116
.................... //#define r			0x117
.................... #define ERXFCON		0x118
.................... #define EPKTCNT		0x119
.................... //#define r			0x11A
.................... //#define EIE		0x11B
.................... //#define EIR		0x11C
.................... //#define ESTAT		0x11D
.................... //#define ECON2		0x11E
.................... //#define ECON1		0x11F
.................... 
.................... // Bank 2 registers -----
.................... #define MACON1		0x200
.................... #define MACON2    0x201
.................... //#define r			0x201
.................... #define MACON3		0x202
.................... #define MACON4		0x203
.................... #define MABBIPG		0x204
.................... //#define			0x205
.................... #define MAIPGL		0x206
.................... #define MAIPGH		0x207
.................... #define MACLCON1	0x208
.................... #define MACLCON2	0x209
.................... #define MAMXFLL		0x20A
.................... #define MAMXFLH		0x20B
.................... //#define r			0x20C
.................... //#define r			0x20D
.................... //#define r			0x20E
.................... //#define			0x20F
.................... //#define r			0x210
.................... //#define r			0x211
.................... #define MICMD		0x212
.................... //#define r			0x213
.................... #define MIREGADR	0x214
.................... //#define r			0x215
.................... #define MIWRL		0x216
.................... #define MIWRH		0x217
.................... #define MIRDL		0x218
.................... #define MIRDH		0x219
.................... //#define r			0x21A
.................... //#define EIE		0x21B
.................... //#define EIR		0x21C
.................... //#define ESTAT		0x21D
.................... //#define ECON2		0x21E
.................... //#define ECON1		0x21F
.................... 
.................... // Bank 3 registers -----
.................... #define MAADR5		0x300
.................... #define MAADR6		0x301
.................... #define MAADR3		0x302
.................... #define MAADR4		0x303
.................... #define MAADR1		0x304
.................... #define MAADR2		0x305
.................... #define EBSTSD		0x306
.................... #define EBSTCON		0x307
.................... #define EBSTCSL		0x308
.................... #define EBSTCSH		0x309
.................... #define MISTAT		0x30A
.................... //#define			0x30B
.................... //#define			0x30C
.................... //#define			0x30D
.................... //#define			0x30E
.................... //#define			0x30F
.................... //#define			0x310
.................... //#define			0x311
.................... #define EREVID		0x312
.................... //#define			0x313
.................... //#define			0x314
.................... #define ECOCON		0x315
.................... //#define 			0x316
.................... #define EFLOCON		0x317
.................... #define EPAUSL		0x318
.................... #define EPAUSH		0x319
.................... //#define r			0x31A
.................... //#define EIE		0x31B
.................... //#define EIR		0x31C
.................... //#define ESTAT		0x31D
.................... //#define ECON2		0x31E
.................... //#define ECON1		0x31F
.................... 
.................... 
.................... 
.................... // Structures
.................... typedef union _REG
.................... {
.................... 	char Val;
.................... 
.................... 	// EIE bits ----------
.................... 	struct {
.................... 		unsigned char RXERIE:1;
.................... 		unsigned char TXERIE:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIE:1;
.................... 		unsigned char LINKIE:1;
.................... 		unsigned char DMAIE:1;
.................... 		unsigned char PKTIE:1;
.................... 		unsigned char INTIE:1;
.................... 	} EIEbits;
.................... 
.................... 	// EIR bits ----------
.................... 	struct {
.................... 		unsigned char RXERIF:1;
.................... 		unsigned char TXERIF:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIF:1;
.................... 		unsigned char LINKIF:1;
.................... 		unsigned char DMAIF:1;
.................... 		unsigned char PKTIF:1;
.................... 		unsigned char blank1:1;
.................... 	} EIRbits;
.................... 
.................... 	// ESTAT bits ---------
.................... 	struct {
.................... 		unsigned char CLKRDY:1;
.................... 		unsigned char TXABRT:1;
.................... 		unsigned char RXBUSY:1;
.................... 		unsigned char blank1:1;
.................... 		unsigned char LATECOL:1;
.................... 		unsigned char blank2:2;
.................... 		unsigned char INTR:1;
.................... 	} ESTATbits;
.................... 
.................... 	// ECON2 bits --------
.................... 	struct {
.................... 		unsigned char blank3:3;
.................... 		unsigned char VRPS:1;
.................... 		unsigned char VRTP:1;
.................... 		unsigned char PWRSV:1;
.................... 		unsigned char PKTDEC:1;
.................... 		unsigned char AUTOINC:1;
.................... 	} ECON2bits;
.................... 
.................... 	// ECON1 bits --------
.................... 	struct {
.................... 		unsigned char BSEL0:1;
.................... 		unsigned char BSEL1:1;
.................... 		unsigned char RXEN:1;
.................... 		unsigned char TXRTS:1;
.................... 		unsigned char CSUMEN:1;
.................... 		unsigned char DMAST:1;
.................... 		unsigned char RXRST:1;
.................... 		unsigned char TXRST:1;
.................... 	} ECON1bits;
.................... 
.................... 	// ERXFCON bits ------
.................... 	struct {
.................... 		unsigned char BCEN:1;
.................... 		unsigned char MCEN:1;
.................... 		unsigned char HTEN:1;
.................... 		unsigned char MPEN:1;
.................... 		unsigned char PMEN:1;
.................... 		unsigned char CRCEN:1;
.................... 		unsigned char ANDOR:1;
.................... 		unsigned char UCEN:1;
.................... 	} ERXFCONbits;
.................... 
.................... 	// MACON1 bits --------
.................... 	struct {
.................... 		unsigned char MARXEN:1;
.................... 		unsigned char PASSALL:1;
.................... 		unsigned char RXPAUS:1;
.................... 		unsigned char TXPAUS:1;
.................... 		unsigned char :4;
.................... 	} MACON1bits;
.................... 
.................... 
.................... 	// MACON3 bits --------
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG0:1;
.................... 		unsigned char PADCFG1:1;
.................... 		unsigned char PADCFG2:1;
.................... 	} MACON3bits;
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG:3;
.................... 	} MACON3bits2;
.................... 
.................... 	// MACON4 bits --------
.................... 	struct {
.................... 		unsigned char :4;
.................... 		unsigned char NOBKOFF:1;
.................... 		unsigned char BPEN:1;
.................... 		unsigned char DEFER:1;
.................... 		unsigned char blank1:1;
.................... 	} MACON4bits;
.................... 
.................... 	// MICMD bits ---------
.................... 	struct {
.................... 		unsigned char MIIRD:1;
.................... 		unsigned char MIISCAN:1;
.................... 		unsigned char blank6:6;
.................... 	} MICMDbits;
.................... 
.................... 	// EBSTCON bits -----
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL0:1;
.................... 		unsigned char TMSEL1:1;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV0:1;
.................... 		unsigned char PSV1:1;
.................... 		unsigned char PSV2:1;
.................... 	} EBSTCONbits;
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL:2;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV:3;
.................... 	} EBSTCONbits2;
.................... 
.................... 	// MISTAT bits --------
.................... 	struct {
.................... 		unsigned char BUSY:1;
.................... 		unsigned char SCAN:1;
.................... 		unsigned char NVALID:1;
.................... 		unsigned char blank5:5;
.................... 	} MISTATbits;
.................... 
.................... 	// ECOCON bits -------
.................... 	struct {
.................... 		unsigned char COCON0:1;
.................... 		unsigned char COCON1:1;
.................... 		unsigned char COCON2:1;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits;
.................... 	struct {
.................... 		unsigned char COCON:3;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits2;
.................... 
.................... 	// EFLOCON bits -----
.................... 	struct {
.................... 		unsigned char FCEN0:1;
.................... 		unsigned char FCEN1:1;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits;
.................... 	struct {
.................... 		unsigned char FCEN:2;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits2;
.................... } REG;
.................... 
.................... 
.................... /******************************************************************************
.................... * PH Register Locations
.................... ******************************************************************************/
.................... #define PHCON1	0x00
.................... #define PHSTAT1	0x01
.................... #define PHID1	0x02
.................... #define PHID2	0x03
.................... #define PHCON2	0x10
.................... #define PHSTAT2	0x11
.................... #define PHIE	0x12
.................... #define PHIR	0x13
.................... #define PHLCON	0x14
.................... 
.................... 
.................... typedef union {
.................... 	int16 Val;
.................... 	WORD_VAL VAL;
.................... 
.................... 	// PHCON1 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 PDPXMD:1;
.................... 		int8 blank2:2;
.................... 		int8 PPWRSV:1;
.................... 		int8 blank22:2;
.................... 		int8 PLOOPBK:1;
.................... 		int8 PRST:1;
.................... 	} PHCON1bits;
.................... 
.................... 	// PHSTAT1 bits --------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 JBSTAT:1;
.................... 		int8 LLSTAT:1;
.................... 		int8 blank5:5;
.................... 		int8 blank3:3;
.................... 		int8 PHDPX:1;
.................... 		int8 PFDPX:1;
.................... 		int8 blank33:3;
.................... 	} PHSTAT1bits;
.................... 
.................... 	// PHID2 bits ----------
.................... 	struct {
.................... 		int8 PREV0:1;
.................... 		int8 PREV1:1;
.................... 		int8 PREV2:1;
.................... 		int8 PREV3:1;
.................... 		int8 PPN0:1;
.................... 		int8 PPN1:1;
.................... 		int8 PPN2:1;
.................... 		int8 PPN3:1;
.................... 		int8 PPN4:1;
.................... 		int8 PPN5:1;
.................... 		int8 PID19:1;
.................... 		int8 PID20:1;
.................... 		int8 PID21:1;
.................... 		int8 PID22:1;
.................... 		int8 PID23:1;
.................... 		int8 PID24:1;
.................... 	} PHID2bits;
.................... 	struct {
.................... 		int8 PREV:4;
.................... 		int8 PPNL:4;
.................... 		int8 PPNH:2;
.................... 		int8 PID:6;
.................... 	} PHID2bits2;
.................... 
.................... 	// PHCON2 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 HDLDIS:1;
.................... 		int8 blank1:1;
.................... 		int8 JABBER:1;
.................... 		int8 blank2:2;
.................... 		int8 TXDIS:1;
.................... 		int8 FRCLNK:1;
.................... 		int8 blank11:1;
.................... 	} PHCON2bits;
.................... 
.................... 	// PHSTAT2 bits --------
.................... 	struct {
.................... 		int8 blank5:5;
.................... 		int8 PLRITY:1;
.................... 		int8 blank2:2;
.................... 		int8 blank11:1;
.................... 		int8 DPXSTAT:1;
.................... 		int8 LSTAT:1;
.................... 		int8 COLSTAT:1;
.................... 		int8 RXSTAT:1;
.................... 		int8 TXSTAT:1;
.................... 		int8 blank22:2;
.................... 	} PHSTAT2bits;
.................... 
.................... 	// PHIE bits -----------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 PGEIE:1;
.................... 		int8 blank2:2;
.................... 		int8 PLNKIE:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIEbits;
.................... 
.................... 	// PHIR bits -----------
.................... 	struct {
.................... 		int8 blank2:2;
.................... 		int8 PGIF:1;
.................... 		int8 blank1:1;
.................... 		int8 PLNKIF:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIRbits;
.................... 
.................... 	// PHLCON bits -------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ0:1;
.................... 		int8 LFRQ1:1;
.................... 		int8 LBCFG0:1;
.................... 		int8 LBCFG1:1;
.................... 		int8 LBCFG2:1;
.................... 		int8 LBCFG3:1;
.................... 		int8 LACFG0:1;
.................... 		int8 LACFG1:1;
.................... 		int8 LACFG2:1;
.................... 		int8 LACFG3:1;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits;
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ:2;
.................... 		int8 LBCFG:4;
.................... 		int8 LACFG:4;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits2;
.................... } PHYREG;
.................... 
.................... 
.................... /******************************************************************************
.................... * Individual Register Bits
.................... ******************************************************************************/
.................... // ETH/MAC/MII bits
.................... 
.................... // EIE bits ----------
.................... #define	EIE_INTIE		(1<<7)
.................... #define	EIE_PKTIE		(1<<6)
.................... #define	EIE_DMAIE		(1<<5)
.................... #define	EIE_LINKIE		(1<<4)
.................... #define	EIE_TXIE		(1<<3)
.................... #define	EIE_TXERIE		(1<<1)
.................... #define	EIE_RXERIE		(1)
.................... 
.................... // EIR bits ----------
.................... #define	EIR_PKTIF		(1<<6)
.................... #define	EIR_DMAIF		(1<<5)
.................... #define	EIR_LINKIF		(1<<4)
.................... #define	EIR_TXIF		(1<<3)
.................... #define	EIR_TXERIF		(1<<1)
.................... #define	EIR_RXERIF		(1)
.................... 
.................... // ESTAT bits ---------
.................... #define	ESTAT_INT		(1<<7)
.................... #define ESTAT_BUFFER	(1<<6)
.................... #define	ESTAT_LATECOL	(1<<4)
.................... #define	ESTAT_RXBUSY	(1<<2)
.................... #define	ESTAT_TXABRT	(1<<1)
.................... #define	ESTAT_CLKRDY	(1)
.................... 
.................... // ECON2 bits --------
.................... #define	ECON2_AUTOINC	(1<<7)
.................... #define	ECON2_PKTDEC	(1<<6)
.................... #define	ECON2_PWRSV		(1<<5)
.................... #define	ECON2_VRPS		(1<<3)
.................... 
.................... // ECON1 bits --------
.................... #define	ECON1_TXRST		(1<<7)
.................... #define	ECON1_RXRST		(1<<6)
.................... #define	ECON1_DMAST		(1<<5)
.................... #define	ECON1_CSUMEN	(1<<4)
.................... #define	ECON1_TXRTS		(1<<3)
.................... #define	ECON1_RXEN		(1<<2)
.................... #define	ECON1_BSEL1		(1<<1)
.................... #define	ECON1_BSEL0		(1)
.................... 
.................... // ERXFCON bits ------
.................... #define	ERXFCON_UCEN	(1<<7)
.................... #define	ERXFCON_ANDOR	(1<<6)
.................... #define	ERXFCON_CRCEN	(1<<5)
.................... #define	ERXFCON_PMEN	(1<<4)
.................... #define	ERXFCON_MPEN	(1<<3)
.................... #define	ERXFCON_HTEN	(1<<2)
.................... #define	ERXFCON_MCEN	(1<<1)
.................... #define	ERXFCON_BCEN	(1)
.................... 
.................... // MACON1 bits --------
.................... #define	MACON1_TXPAUS	(1<<3)
.................... #define	MACON1_RXPAUS	(1<<2)
.................... #define	MACON1_PASSALL	(1<<1)
.................... #define	MACON1_MARXEN	(1)
.................... 
.................... // MACON3 bits --------
.................... #define	MACON3_PADCFG2	(1<<7)
.................... #define	MACON3_PADCFG1	(1<<6)
.................... #define	MACON3_PADCFG0	(1<<5)
.................... #define	MACON3_TXCRCEN	(1<<4)
.................... #define	MACON3_PHDRLEN	(1<<3)
.................... #define	MACON3_HFRMEN	(1<<2)
.................... #define	MACON3_FRMLNEN	(1<<1)
.................... #define	MACON3_FULDPX	(1)
.................... 
.................... // MACON4 bits --------
.................... #define	MACON4_DEFER	(1<<6)
.................... #define	MACON4_BPEN		(1<<5)
.................... #define	MACON4_NOBKOFF	(1<<4)
.................... 
.................... 
.................... // MICMD bits ---------
.................... #define	MICMD_MIISCAN	(1<<1)
.................... #define	MICMD_MIIRD		(1)
.................... 
.................... // EBSTCON bits -----
.................... #define	EBSTCON_PSV2	(1<<7)
.................... #define	EBSTCON_PSV1	(1<<6)
.................... #define	EBSTCON_PSV0	(1<<5)
.................... #define	EBSTCON_PSEL	(1<<4)
.................... #define	EBSTCON_TMSEL1	(1<<3)
.................... #define	EBSTCON_TMSEL0	(1<<2)
.................... #define	EBSTCON_TME		(1<<1)
.................... #define	EBSTCON_BISTST	(1)
.................... 
.................... // MISTAT bits --------
.................... #define	MISTAT_NVALID	(1<<2)
.................... #define	MISTAT_SCAN		(1<<1)
.................... #define	MISTAT_BUSY		(1)
.................... 
.................... // ECOCON bits -------
.................... #define	ECOCON_COCON2	(1<<2)
.................... #define	ECOCON_COCON1	(1<<1)
.................... #define	ECOCON_COCON0	(1)
.................... 
.................... // EFLOCON bits -----
.................... #define	EFLOCON_FULDPXS	(1<<2)
.................... #define	EFLOCON_FCEN1	(1<<1)
.................... #define	EFLOCON_FCEN0	(1)
.................... 
.................... 
.................... 
.................... // PHY bits
.................... 
.................... // PHCON1 bits ----------
.................... #define	PHCON1_PRST		(1ul<<15)
.................... #define	PHCON1_PLOOPBK	(1ul<<14)
.................... #define	PHCON1_PPWRSV	(1ul<<11)
.................... #define	PHCON1_PDPXMD	(1ul<<8)
.................... 
.................... // PHSTAT1 bits --------
.................... #define	PHSTAT1_PFDPX	(1ul<<12)
.................... #define	PHSTAT1_PHDPX	(1ul<<11)
.................... #define	PHSTAT1_LLSTAT	(1ul<<2)
.................... #define	PHSTAT1_JBSTAT	(1ul<<1)
.................... 
.................... // PHID2 bits --------
.................... #define	PHID2_PID24		(1ul<<15)
.................... #define	PHID2_PID23		(1ul<<14)
.................... #define	PHID2_PID22		(1ul<<13)
.................... #define	PHID2_PID21		(1ul<<12)
.................... #define	PHID2_PID20		(1ul<<11)
.................... #define	PHID2_PID19		(1ul<<10)
.................... #define	PHID2_PPN5		(1ul<<9)
.................... #define	PHID2_PPN4		(1ul<<8)
.................... #define	PHID2_PPN3		(1ul<<7)
.................... #define	PHID2_PPN2		(1ul<<6)
.................... #define	PHID2_PPN1		(1ul<<5)
.................... #define	PHID2_PPN0		(1ul<<4)
.................... #define	PHID2_PREV3		(1ul<<3)
.................... #define	PHID2_PREV2		(1ul<<2)
.................... #define	PHID2_PREV1		(1ul<<1)
.................... #define	PHID2_PREV0		(1ul)
.................... 
.................... // PHCON2 bits ----------
.................... #define	PHCON2_FRCLNK	(1ul<<14)
.................... #define	PHCON2_TXDIS	(1ul<<13)
.................... #define	PHCON2_JABBER	(1ul<<10)
.................... #define	PHCON2_HDLDIS	(1ul<<8)
.................... 
.................... // PHSTAT2 bits --------
.................... #define	PHSTAT2_TXSTAT	(1ul<<13)
.................... #define	PHSTAT2_RXSTAT	(1ul<<12)
.................... #define	PHSTAT2_COLSTAT	(1ul<<11)
.................... #define	PHSTAT2_LSTAT	(1ul<<10)
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9)
.................... #define	PHSTAT2_PLRITY	(1ul<<5)
.................... 
.................... // PHIE bits -----------
.................... #define	PHIE_PLNKIE		(1ul<<4)
.................... #define	PHIE_PGEIE		(1ul<<1)
.................... 
.................... // PHIR bits -----------
.................... #define	PHIR_PLNKIF		(1ul<<4)
.................... #define	PHIR_PGIF		(1ul<<2)
.................... 
.................... // PHLCON bits -------
.................... #define	PHLCON_LACFG3	(1ul<<11)
.................... #define	PHLCON_LACFG2	(1ul<<10)
.................... #define	PHLCON_LACFG1	(1ul<<9)
.................... #define	PHLCON_LACFG0	(1ul<<8)
.................... #define	PHLCON_LBCFG3	(1ul<<7)
.................... #define	PHLCON_LBCFG2	(1ul<<6)
.................... #define	PHLCON_LBCFG1	(1ul<<5)
.................... #define	PHLCON_LBCFG0	(1ul<<4)
.................... #define	PHLCON_LFRQ1	(1ul<<3)
.................... #define	PHLCON_LFRQ0	(1ul<<2)
.................... #define	PHLCON_STRCH	(1ul<<1)
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if STACK_USE_SLIP
.................... #error Unexpected module is detected.
.................... #error This file must be linked when SLIP module is not in use.
.................... #endif
.................... 
.................... #define debug_mac
.................... //#define debug_mac debug_printf
.................... 
....................    #ifndef PIN_ENC_MAC_SO
....................       #define PIN_ENC_MAC_SO  PIN_D7   // PIC <<<< ENC
....................       #define PIN_ENC_MAC_SI  PIN_D6   // PIC >>>> ENC
....................       #define PIN_ENC_MAC_CLK PIN_D5
....................       #define PIN_ENC_MAC_CS  PIN_D4
....................       #define PIN_ENC_MAC_RST PIN_D3
....................       #define PIN_ENC_MAC_INT PIN_D2
....................       #define PIN_ENC_MAC_WOL PIN_D1
....................       #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz!
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC
....................       #define mac_enc_spi_tris_init()  *0xF95= (0b10000110);
....................      #endif
.................... 
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs
.................... 
.................... /** D E F I N I T I O N S ****************************************************/
.................... /* Hardware interface to NIC. */
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these
.................... // The following SPI pins are used but are not configurable
.................... //   RC3 is used for the SCK pin and is an output
.................... //   RC4 is used for the SDI pin and is an input
.................... //   RC5 is used for the SDO pin and is an output
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is
.................... //      done using the SPI.
.................... 
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is
.................... // not compatible with most switches/routers.  If a dedicated network is used
.................... // where the duplex of the remote node can be manually configured, you may
.................... // change this configuration.  Otherwise, half duplex should always be used.
.................... #define HALF_DUPLEX
.................... //#define FULL_DUPLEX
.................... //#define LEDB_DUPLEX
.................... 
.................... // Pseudo Functions
.................... #define LOW(a)                (a & 0xFF)
.................... #define HIGH(a)             ((a>>8) & 0xFF)
.................... 
.................... // NIC RAM definitions
.................... #define RAMSIZE   8192ul
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul)))
.................... #define RXSTART   (0ul)                  // Should be an even memory address
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul)
.................... 
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address)
.................... #define   WCR (0b010<<5)         // Write Control Register command
.................... #define BFS (0b100<<5)         // Bit Field Set command
.................... #define   BFC (0b101<<5)         // Bit Field Clear command
.................... #define   RCR (0b000<<5)         // Read Control Register command
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address.
....................                         //   It requires 0x1F, however.
.................... 
.................... #define ETHER_IP   (0x00u)
.................... #define ETHER_ARP   (0x06u)
.................... 
00C8:  BCF    FF2.2
00CA:  GOTO   0060
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u)
.................... 
.................... // A generic structure representing the Ethernet header starting all Ethernet
.................... // frames
.................... typedef struct _ETHER_HEADER
.................... {
....................     MAC_ADDR        DestMACAddr;
....................     MAC_ADDR        SourceMACAddr;
....................     WORD_VAL        Type;
.................... } ETHER_HEADER;
.................... 
.................... // A header appended at the start of all RX frames by the hardware
.................... typedef struct _ENC_PREAMBLE
.................... {
....................     int16         NextPacketPointer;
....................     RXSTATUS      StatusVector;
.................... 
....................     MAC_ADDR        DestMACAddr;
....................     MAC_ADDR        SourceMACAddr;
....................     WORD_VAL        Type;
.................... } ENC_PREAMBLE;
.................... 
.................... typedef struct _DATA_BUFFER
.................... {
....................    WORD_VAL StartAddress;
....................    WORD_VAL EndAddress;
....................    struct
....................    {
....................       unsigned char bFree : 1;
....................       unsigned char bTransmitted : 1;
....................    } Flags;
.................... } DATA_BUFFER;
.................... 
.................... void MACSetDuplex(DUPLEX DuplexState);
.................... 
.................... // Prototypes of functions intended for MAC layer use only.
.................... static void BankSel(WORD Register);
.................... static REG ReadETHReg(BYTE Address);
.................... static REG ReadMACReg(BYTE Address);
.................... static void WriteReg(BYTE Address, BYTE Data);
.................... static void BFCReg(BYTE Address, BYTE Data);
.................... static void BFSReg(BYTE Address, BYTE Data);
.................... static void SendSystemReset(void);
.................... //static void GetRegs(void);
.................... #ifdef MAC_POWER_ON_TEST
.................... static BOOL TestMemory(void);
.................... #endif
.................... 
.................... /* Internal and externally used MAC level variables */
.................... #if MAC_TX_BUFFER_COUNT > 1
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT];
.................... #endif
.................... 
.................... // Internal and externally used MAC level variables.
.................... #if MAC_TX_BUFFER_COUNT > 1
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT];
.................... BUFFER LastTXedBuffer;
.................... #endif
.................... 
.................... 
.................... // Internal MAC level variables and flags.
.................... WORD_VAL NextPacketLocation;
.................... WORD_VAL CurrentPacketLocation;
.................... BOOL WasDiscarded;
.................... BYTE ENCRevID;
.................... 
.................... //ENCSPIInit() added by CCS.
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI
.................... void ENCSPIInit(void)
.................... {
.................... 
....................    #ifdef mac_enc_spi_tris_init
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0;
....................    #endif
.................... 
....................  #if ENC_MAC_USE_SPI
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4);
*
0852:  BCF    FC6.5
0854:  BCF    F94.7
0856:  BSF    F93.0
0858:  BCF    F93.1
085A:  MOVLW  20
085C:  MOVWF  FC6
085E:  MOVLW  40
0860:  MOVWF  FC7
....................  #else
....................    
....................    output_low(PIN_ENC_MAC_CLK);
....................    output_float(PIN_ENC_MAC_SO);
....................  #endif
....................    //
....................    // Set up the SPI module on the PIC for communications with the ENC28J60
....................    //
....................    SPIUnselectEthernet();
0862:  BCF    F93.2
0864:  BSF    F8A.2
.................... 
....................    // Deassert the nRESET pin on the ENC28J60.  The internal
....................    // weak pull on the nRESET pin will get the job done anyway,
....................    // so this isn't necessary, but it may provide extra noise immunity,
....................    // should someone put their finger on the pin or otherwise cause a leakage
....................    // path to ground on this pin.
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1;
0866:  BCF    F93.3
0868:  BSF    F8A.3
086A:  GOTO   0B4C (RETURN)
.................... }
.................... 
.................... //ENCSPIXfer() added by CCS.
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI
.................... char ENCSPIXfer(char c)
.................... {
....................  #if ENC_MAC_USE_SPI
....................    return(spi_read(c));
086E:  MOVF   FC9,W
0870:  MOVFF  3B3,FC9
0874:  RRCF   FC7,W
0876:  BNC   0874
0878:  MOVFF  FC9,01
....................  #else
087C:  RETURN 0
....................    int8 i, in;
....................    for (i=0;i<8;i++) {
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0));
....................       output_high(PIN_ENC_MAC_CLK);
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO));
....................       output_low(PIN_ENC_MAC_CLK);
....................    }
....................    return(in);
....................  #endif
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        void MACInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACInit sets up the PIC's SPI module and all the
....................  *               registers in the ENC28J60 so that normal operation can
....................  *               begin.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACInit(void)
.................... {
....................    BYTE i;
.................... 
....................    ENCSPIInit();
*
0B4A:  BRA    0852
.................... 
....................    // Wait for CLKRDY to become set.
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that
....................    // means the part is in RESET or otherwise our SPI pin is being driven
....................    // incorrectly.  Make sure it is working before proceeding.
....................    do
....................    {
....................       i = ReadETHReg(ESTAT).Val;
0B4C:  MOVLW  1D
0B4E:  MOVLB  3
0B50:  MOVWF  xA8
0B52:  MOVLB  0
0B54:  RCALL  087E
0B56:  MOVFF  01,2F4
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY));
0B5A:  MOVLB  2
0B5C:  BTFSS  xF4.3
0B5E:  BRA    0B64
0B60:  MOVLB  0
0B62:  BRA    0B4C
0B64:  MOVF   xF4,W
0B66:  XORLW  FF
0B68:  ANDLW  01
0B6A:  BTFSC  FD8.2
0B6C:  BRA    0B72
0B6E:  MOVLB  0
0B70:  BRA    0B4C
.................... 
.................... 
.................... #ifdef MAC_POWER_ON_TEST
....................    // Do the memory test and enter a while always trap if a hardware error
....................    // occured.  The LEDA and LEDB pins will be configured to blink
....................    // periodically in an abnormal manner to indicate to the user that the
....................    // error occured.
....................    if( !TestMemory() )
....................    {
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically
....................       while(1);
....................    }
.................... #endif
.................... 
....................    // RESET the entire ENC28J60, clearing all registers
....................    SendSystemReset();
0B72:  MOVLB  0
0B74:  BRA    08A8
....................     delay_ms(1);
0B76:  MOVLW  01
0B78:  MOVLB  3
0B7A:  MOVWF  x2D
0B7C:  MOVLB  0
0B7E:  RCALL  04FA
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
....................     // On Init, all transmit buffers are free.
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ )
....................     {
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8));
....................         TxBuffers[i].Flags.bFree = TRUE;
....................     }
.................... #endif
....................     CurrentTxBuffer = 0;
0B80:  CLRF   06
.................... 
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers
....................    // and the buffer write protect pointer (receive buffer read pointer)
....................    WasDiscarded = TRUE;
0B82:  BSF    5A.0
....................    NextPacketLocation.Val = RXSTART;
0B84:  CLRF   57
0B86:  CLRF   56
....................    WriteReg(ERXSTL, LOW(RXSTART));
0B88:  MOVLW  08
0B8A:  MOVLB  3
0B8C:  MOVWF  xAE
0B8E:  CLRF   xAF
0B90:  MOVLB  0
0B92:  RCALL  08BC
....................    WriteReg(ERXSTH, HIGH(RXSTART));
0B94:  MOVLW  09
0B96:  MOVLB  3
0B98:  MOVWF  xAE
0B9A:  CLRF   xAF
0B9C:  MOVLB  0
0B9E:  RCALL  08BC
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first
0BA0:  MOVLW  0C
0BA2:  MOVLB  3
0BA4:  MOVWF  xAE
0BA6:  MOVLW  F7
0BA8:  MOVWF  xAF
0BAA:  MOVLB  0
0BAC:  RCALL  08BC
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last
0BAE:  MOVLW  0D
0BB0:  MOVLB  3
0BB2:  MOVWF  xAE
0BB4:  MOVLW  1B
0BB6:  MOVWF  xAF
0BB8:  MOVLB  0
0BBA:  RCALL  08BC
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF
....................    WriteReg(ERXNDL, LOW(RXSTOP));
0BBC:  MOVLW  0A
0BBE:  MOVLB  3
0BC0:  MOVWF  xAE
0BC2:  MOVLW  F7
0BC4:  MOVWF  xAF
0BC6:  MOVLB  0
0BC8:  RCALL  08BC
....................    WriteReg(ERXNDH, HIGH(RXSTOP));
0BCA:  MOVLW  0B
0BCC:  MOVLB  3
0BCE:  MOVWF  xAE
0BD0:  MOVLW  1B
0BD2:  MOVWF  xAF
0BD4:  MOVLB  0
0BD6:  RCALL  08BC
.................... #endif
.................... #if TXSTART != 0      // The RESET default ETXST is 0
....................    WriteReg(ETXSTL, LOW(TXSTART));
0BD8:  MOVLW  04
0BDA:  MOVLB  3
0BDC:  MOVWF  xAE
0BDE:  MOVLW  F8
0BE0:  MOVWF  xAF
0BE2:  MOVLB  0
0BE4:  RCALL  08BC
....................    WriteReg(ETXSTH, HIGH(TXSTART));
0BE6:  MOVLW  05
0BE8:  MOVLB  3
0BEA:  MOVWF  xAE
0BEC:  MOVLW  1B
0BEE:  MOVWF  xAF
0BF0:  MOVLB  0
0BF2:  RCALL  08BC
.................... #endif
.................... 
....................    // Enter Bank 1 and configure Receive Filters
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is
....................    // acceptable)
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode
....................    //BankSel(ERXFCON);
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN);
.................... 
....................    // Enter Bank 2 and configure the MAC
....................    BankSel(MACON1);
0BF4:  MOVLW  02
0BF6:  MOVLB  3
0BF8:  MOVWF  xAC
0BFA:  CLRF   xAB
0BFC:  MOVLB  0
0BFE:  RCALL  0916
.................... 
....................    // Enable the receive portion of the MAC
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN);
0C00:  MOVLB  3
0C02:  CLRF   xAE
0C04:  MOVLW  0D
0C06:  MOVWF  xAF
0C08:  MOVLB  0
0C0A:  RCALL  08BC
.................... 
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field.
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN);
0C0C:  MOVLW  02
0C0E:  MOVLB  3
0C10:  MOVWF  xAE
0C12:  MOVLW  32
0C14:  MOVWF  xAF
0C16:  MOVLB  0
0C18:  RCALL  08BC
.................... 
....................     // Allow infinite deferals if the medium is continuously busy
....................     // (do not time out a transmission if the half duplex medium is
....................     // completely saturated with other people's data)
....................     WriteReg((BYTE)MACON4, MACON4_DEFER);
0C1A:  MOVLW  03
0C1C:  MOVLB  3
0C1E:  MOVWF  xAE
0C20:  MOVLW  40
0C22:  MOVWF  xAF
0C24:  MOVLB  0
0C26:  RCALL  08BC
.................... 
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter)
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse
....................    // collisions will occur less often with a larger number.
....................     WriteReg((BYTE)MACLCON2, 63);
0C28:  MOVLW  09
0C2A:  MOVLB  3
0C2C:  MOVWF  xAE
0C2E:  MOVLW  3F
0C30:  MOVWF  xAF
0C32:  MOVLB  0
0C34:  RCALL  08BC
.................... 
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called
....................    // later.
....................    WriteReg((BYTE)MAIPGL, 0x12);
0C36:  MOVLW  06
0C38:  MOVLB  3
0C3A:  MOVWF  xAE
0C3C:  MOVLW  12
0C3E:  MOVWF  xAF
0C40:  MOVLB  0
0C42:  RCALL  08BC
....................    WriteReg((BYTE)MAIPGH, 0x0C);
0C44:  MOVLW  07
0C46:  MOVLB  3
0C48:  MOVWF  xAE
0C4A:  MOVLW  0C
0C4C:  MOVWF  xAF
0C4E:  MOVLB  0
0C50:  RCALL  08BC
.................... 
....................    // Set the maximum packet size which the controller will accept
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC));
0C52:  MOVLW  0A
0C54:  MOVLB  3
0C56:  MOVWF  xAE
0C58:  MOVLW  EE
0C5A:  MOVWF  xAF
0C5C:  MOVLB  0
0C5E:  RCALL  08BC
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC));
0C60:  MOVLW  0B
0C62:  MOVLB  3
0C64:  MOVWF  xAE
0C66:  MOVLW  05
0C68:  MOVWF  xAF
0C6A:  MOVLB  0
0C6C:  RCALL  08BC
.................... 
....................     // Enter Bank 3 and initialize physical MAC address registers
....................    BankSel(MAADR1);
0C6E:  MOVLW  03
0C70:  MOVLB  3
0C72:  MOVWF  xAC
0C74:  MOVLW  04
0C76:  MOVWF  xAB
0C78:  MOVLB  0
0C7A:  RCALL  0916
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]);
0C7C:  MOVLW  04
0C7E:  MOVLB  3
0C80:  MOVWF  xAE
0C82:  MOVFF  21,3AF
0C86:  MOVLB  0
0C88:  RCALL  08BC
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]);
0C8A:  MOVLW  05
0C8C:  MOVLB  3
0C8E:  MOVWF  xAE
0C90:  MOVFF  22,3AF
0C94:  MOVLB  0
0C96:  RCALL  08BC
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]);
0C98:  MOVLW  02
0C9A:  MOVLB  3
0C9C:  MOVWF  xAE
0C9E:  MOVFF  23,3AF
0CA2:  MOVLB  0
0CA4:  RCALL  08BC
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]);
0CA6:  MOVLW  03
0CA8:  MOVLB  3
0CAA:  MOVWF  xAE
0CAC:  MOVFF  24,3AF
0CB0:  MOVLB  0
0CB2:  RCALL  08BC
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]);
0CB4:  MOVLB  3
0CB6:  CLRF   xAE
0CB8:  MOVFF  25,3AF
0CBC:  MOVLB  0
0CBE:  RCALL  08BC
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]);
0CC0:  MOVLW  01
0CC2:  MOVLB  3
0CC4:  MOVWF  xAE
0CC6:  MOVFF  26,3AF
0CCA:  MOVLB  0
0CCC:  RCALL  08BC
.................... 
....................    // Get the Rev ID so that we can implement the correct errata workarounds
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val;
0CCE:  MOVLW  12
0CD0:  MOVLB  3
0CD2:  MOVWF  xA8
0CD4:  MOVLB  0
0CD6:  RCALL  087E
0CD8:  MOVFF  01,5B
.................... 
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a
....................    // side effect.
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS);
0CDC:  MOVLW  10
0CDE:  MOVLB  2
0CE0:  MOVWF  xF9
0CE2:  MOVLW  01
0CE4:  MOVWF  xFB
0CE6:  CLRF   xFA
0CE8:  MOVLB  0
0CEA:  RCALL  097A
.................... 
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity
....................    SetLEDConfig(0x0472);
0CEC:  MOVLW  14
0CEE:  MOVLB  2
0CF0:  MOVWF  xF9
0CF2:  MOVLW  04
0CF4:  MOVWF  xFB
0CF6:  MOVLW  72
0CF8:  MOVWF  xFA
0CFA:  MOVLB  0
0CFC:  RCALL  097A
.................... 
....................    // Set the MAC and PHY into the proper duplex state
.................... #if defined(FULL_DUPLEX)
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected
.................... #elif defined(HALF_DUPLEX)
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected
0CFE:  MOVLB  2
0D00:  CLRF   xF5
0D02:  MOVLB  0
0D04:  BRA    0AA8
.................... #else
....................    // Use the external LEDB polarity to determine weather full or half duplex
....................    // communication mode should be set.
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected
.................... #endif
.................... 
....................    // Enable packet reception
....................    BFSReg(ECON1, ECON1_RXEN);
0D06:  MOVLW  1F
0D08:  MOVLB  3
0D0A:  MOVWF  xB0
0D0C:  MOVLW  04
0D0E:  MOVWF  xB1
0D10:  MOVLB  0
0D12:  RCALL  08F8
0D14:  GOTO   10F6 (RETURN)
.................... }//end MACInit
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACIsLinked(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE: If the PHY reports that a link partner is present
....................  *                    and the link has been up continuously since the last
....................  *                    call to MACIsLinked()
....................  *               FALSE: If the PHY reports no link partner, or the link went
....................  *                     down momentarily since the last call to MACIsLinked()
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACIsLinked(void)
.................... {
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link
....................    // goes down and comes back up before a higher level stack program calls
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next
....................    // call to MACIsLinked() will return TRUE (unless the link goes down
....................    // again).
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT;
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit
....................  *                          FALSE: Check if a TX buffer is free
....................  *
....................  * Output:          TRUE: If no Ethernet transmission is in progress
....................  *               FALSE: If a previous transmission was started, and it has
....................  *                     not completed yet.  While FALSE, the data in the
....................  *                     transmit buffer and the TXST/TXND pointers must not
....................  *                     be changed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the ECON1.TXRTS bit
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACIsTxReady(BOOL HighPriority)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    BUFFER i;
.................... 
....................    if(HighPriority)
.................... #endif
....................    {
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS;
*
2598:  MOVLW  1F
259A:  MOVLB  3
259C:  MOVWF  xA8
259E:  MOVLB  0
25A0:  CALL   087E
25A4:  MOVFF  01,38A
25A8:  MOVLW  00
25AA:  MOVLB  3
25AC:  BTFSC  01.3
25AE:  MOVLW  01
25B0:  XORLW  00
25B2:  BZ    25B8
25B4:  MOVLW  00
25B6:  BRA    25BA
25B8:  MOVLW  01
25BA:  MOVWF  01
....................    }
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
25BC:  MOVLB  0
25BE:  RETURN 0
.................... 
....................    // Check if the current buffer can be modified.  It cannot be modified if
....................    // the TX hardware is currently transmitting it.
....................    if(CurrentTxBuffer == LastTXedBuffer)
....................    {
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS;
....................    }
.................... 
....................    // Check if a buffer is available for a new packet
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++)
....................    {
....................       if(TxBuffers[i].Flags.bFree)
....................       {
....................          return TRUE;
....................       }
....................    }
.................... 
....................    return FALSE;
.................... #endif
.................... }
.................... 
.................... BUFFER MACGetTxBuffer(BOOL HighPriority)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    BUFFER i;
.................... 
....................    if(HighPriority)
.................... #endif
....................    {
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER;
*
14DE:  MOVLW  1F
14E0:  MOVLB  3
14E2:  MOVWF  xA8
14E4:  MOVLB  0
14E6:  CALL   087E
14EA:  MOVFF  01,38A
14EE:  MOVLW  00
14F0:  MOVLB  3
14F2:  BTFSC  01.3
14F4:  MOVLW  01
14F6:  XORLW  00
14F8:  BNZ   14FE
14FA:  MOVLW  00
14FC:  BRA    1500
14FE:  MOVLW  FF
1500:  MOVWF  01
....................    }
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
1502:  MOVLB  0
1504:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for
....................    // high priority messages that don't need to be acknowledged
....................    // before being discarded (TCP control packets, all ICMP
....................    // packets, all UDP packets, etc.)
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++)
....................    {
....................       // If this buffer is free, then mark it as used and return with it
....................       if(TxBuffers[i].Flags.bFree)
....................       {
....................          TxBuffers[i].Flags.bFree = FALSE;
....................          TxBuffers[i].Flags.bTransmitted = FALSE;
....................          return i;
....................       }
....................    }
.................... 
....................    return INVALID_BUFFER;
.................... #endif
.................... }
.................... 
.................... 
.................... void MACDiscardTx(BUFFER buffer)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
*
0004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0]))
....................    {
....................        TxBuffers[buffer].Flags.bFree = TRUE;
....................        CurrentTxBuffer = buffer;
....................    }
.................... #endif
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACDiscardRx(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Marks the last received packet (obtained using
....................  *               MACGetHeader())as being processed and frees the buffer
....................  *               memory associated with it
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACDiscardRx(void)
.................... {
....................    WORD_VAL NewRXRDLocation;
.................... 
....................    // Make sure the current packet was not already discarded
....................    if( WasDiscarded )
*
1100:  BTFSS  5A.0
1102:  BRA    1106
....................       return;
1104:  BRA    116A
....................    WasDiscarded = TRUE;
1106:  BSF    5A.0
.................... 
....................    // Decrement the next packet pointer before writing it into
....................    // the ERXRDPT registers.  This is a silicon errata workaround.
....................    // RX buffer wrapping must be taken into account if the
....................    // NextPacketLocation is precisely RXSTART.
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1;
1108:  MOVLW  01
110A:  SUBWF  56,W
110C:  MOVLB  3
110E:  MOVWF  x46
1110:  MOVLW  00
1112:  SUBWFB 57,W
1114:  MOVWF  x47
.................... #if RXSTART == 0
....................    if(NewRXRDLocation.Val > RXSTOP)
1116:  MOVF   x47,W
1118:  SUBLW  1A
111A:  BC    112E
111C:  XORLW  FF
111E:  BNZ   1126
1120:  MOVF   x46,W
1122:  SUBLW  F7
1124:  BC    112E
.................... #else
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP)
.................... #endif
....................    {
....................       NewRXRDLocation.Val = RXSTOP;
1126:  MOVLW  1B
1128:  MOVWF  x47
112A:  MOVLW  F7
112C:  MOVWF  x46
....................    }
.................... 
....................    // Decrement the RX packet counter register, EPKTCNT
....................    BFSReg(ECON2, ECON2_PKTDEC);
112E:  MOVLW  1E
1130:  MOVWF  xB0
1132:  MOVLW  40
1134:  MOVWF  xB1
1136:  MOVLB  0
1138:  CALL   08F8
.................... 
....................    // Move the receive read pointer to unwrite-protect the memory used by the
....................    // last packet.  The writing order is important: set the low byte first,
....................    // high byte last.
....................    BankSel(ERXRDPTL);
113C:  MOVLB  3
113E:  CLRF   xAC
1140:  MOVLW  0C
1142:  MOVWF  xAB
1144:  MOVLB  0
1146:  CALL   0916
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]);
114A:  MOVLW  0C
114C:  MOVLB  3
114E:  MOVWF  xAE
1150:  MOVFF  346,3AF
1154:  MOVLB  0
1156:  CALL   08BC
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]);
115A:  MOVLW  0D
115C:  MOVLB  3
115E:  MOVWF  xAE
1160:  MOVFF  347,3AF
1164:  MOVLB  0
1166:  CALL   08BC
116A:  RETURN 0
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACGetFreeRxSize(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          A WORD estimate of how much RX buffer space is free at
....................  *               the present time.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACGetFreeRxSize(void)
.................... {
....................    WORD_VAL ReadPT, WritePT;
.................... 
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be
....................    // received at any time, it can change between reading the low and high
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair
....................    // is read.
....................    BankSel(EPKTCNT);
*
25C0:  MOVLW  01
25C2:  MOVLB  3
25C4:  MOVWF  xAC
25C6:  MOVLW  19
25C8:  MOVWF  xAB
25CA:  MOVLB  0
25CC:  CALL   0916
....................    do {
....................       // Save EPKTCNT in a temporary location
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val;
25D0:  MOVLW  19
25D2:  MOVLB  3
25D4:  MOVWF  xA8
25D6:  MOVLB  0
25D8:  CALL   087E
25DC:  MOVFF  01,389
.................... 
....................       BankSel(ERXWRPTL);
25E0:  MOVLB  3
25E2:  CLRF   xAC
25E4:  MOVLW  0E
25E6:  MOVWF  xAB
25E8:  MOVLB  0
25EA:  CALL   0916
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val;
25EE:  MOVLW  0E
25F0:  MOVLB  3
25F2:  MOVWF  xA8
25F4:  MOVLB  0
25F6:  CALL   087E
25FA:  MOVFF  01,38B
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val;
25FE:  MOVLW  0F
2600:  MOVLB  3
2602:  MOVWF  xA8
2604:  MOVLB  0
2606:  CALL   087E
260A:  MOVFF  01,38C
.................... 
....................       BankSel(EPKTCNT);
260E:  MOVLW  01
2610:  MOVLB  3
2612:  MOVWF  xAC
2614:  MOVLW  19
2616:  MOVWF  xAB
2618:  MOVLB  0
261A:  CALL   0916
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]);
261E:  MOVLW  19
2620:  MOVLB  3
2622:  MOVWF  xA8
2624:  MOVLB  0
2626:  CALL   087E
262A:  MOVFF  01,38D
262E:  MOVLB  3
2630:  MOVF   x89,W
2632:  SUBWF  01,W
2634:  BTFSC  FD8.2
2636:  BRA    263C
2638:  MOVLB  0
263A:  BRA    25D0
.................... 
....................    // Determine where the write protection pointer is
....................    BankSel(ERXRDPTL);
263C:  CLRF   xAC
263E:  MOVLW  0C
2640:  MOVWF  xAB
2642:  MOVLB  0
2644:  CALL   0916
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val;
2648:  MOVLW  0C
264A:  MOVLB  3
264C:  MOVWF  xA8
264E:  MOVLB  0
2650:  CALL   087E
2654:  MOVFF  01,389
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val;
2658:  MOVLW  0D
265A:  MOVLB  3
265C:  MOVWF  xA8
265E:  MOVLB  0
2660:  CALL   087E
2664:  MOVFF  01,38A
.................... 
....................    // Calculate the difference between the pointers, taking care to account
....................    // for buffer wrapping conditions
....................    if ( WritePT.Val > ReadPT.Val )
2668:  MOVLB  3
266A:  MOVF   x8A,W
266C:  SUBWF  x8C,W
266E:  BNC   269C
2670:  BNZ   2678
2672:  MOVF   x8B,W
2674:  SUBWF  x89,W
2676:  BC    269C
....................    {
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val);
2678:  MOVF   x89,W
267A:  SUBWF  x8B,W
267C:  MOVWF  00
267E:  MOVF   x8A,W
2680:  SUBWFB x8C,W
2682:  MOVWF  03
2684:  MOVF   00,W
2686:  XORLW  FF
2688:  ADDLW  F8
268A:  MOVWF  00
268C:  MOVLW  1B
268E:  SUBFWB 03,F
2690:  MOVFF  00,01
2694:  MOVFF  03,02
2698:  BRA    26D2
....................    }
269A:  BRA    26D2
....................    else if ( WritePT.Val == ReadPT.Val )
269C:  MOVF   x89,W
269E:  SUBWF  x8B,W
26A0:  BNZ   26B4
26A2:  MOVF   x8A,W
26A4:  SUBWF  x8C,W
26A6:  BNZ   26B4
....................    {
....................       return RXSIZE - 1;
26A8:  MOVLW  F7
26AA:  MOVWF  01
26AC:  MOVLW  1B
26AE:  MOVWF  02
26B0:  BRA    26D2
....................    }
26B2:  BRA    26D2
....................    else
....................     {
....................       return ReadPT.Val - WritePT.Val - 1;
26B4:  MOVF   x8B,W
26B6:  SUBWF  x89,W
26B8:  MOVWF  x8D
26BA:  MOVF   x8C,W
26BC:  SUBWFB x8A,W
26BE:  MOVWF  x8E
26C0:  MOVLW  01
26C2:  SUBWF  x8D,W
26C4:  MOVWF  00
26C6:  MOVLW  00
26C8:  SUBWFB x8E,W
26CA:  MOVWF  03
26CC:  MOVFF  00,01
26D0:  MOVWF  02
....................    }
26D2:  MOVLB  0
26D4:  GOTO   2950 (RETURN)
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           *remote: Location to store the Source MAC address of the
....................  *                      received frame.
....................  *               *type: Location of a BYTE to store the constant
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing
....................  *                     the contents of the Ethernet type field.
....................  *
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The
....................  *                    remote, and type values are updated.
....................  *               FALSE: If a packet was not pending.  remote and type are
....................  *                     not changed.
....................  *
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already
....................  *               been called.
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
.................... {
....................    ENC_PREAMBLE header;
.................... 
....................    // Test if at least one packet has been received and is waiting
....................    BankSel(EPKTCNT);
*
11E2:  MOVLW  01
11E4:  MOVLB  3
11E6:  MOVWF  xAC
11E8:  MOVLW  19
11EA:  MOVWF  xAB
11EC:  MOVLB  0
11EE:  CALL   0916
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0)
11F2:  MOVLW  19
11F4:  MOVLB  3
11F6:  MOVWF  xA8
11F8:  MOVLB  0
11FA:  CALL   087E
11FE:  MOVFF  01,312
1202:  MOVLB  3
1204:  MOVF   x12,F
1206:  BNZ   120E
....................       return FALSE;
1208:  MOVLW  00
120A:  MOVWF  01
120C:  BRA    1342
.................... 
....................    // Make absolutely certain that any previous packet was discarded
....................    if(WasDiscarded == FALSE)
120E:  BTFSC  5A.0
1210:  BRA    121E
....................    {
....................       MACDiscardRx();
1212:  MOVLB  0
1214:  RCALL  1100
....................       return FALSE;
1216:  MOVLW  00
1218:  MOVWF  01
121A:  MOVLB  3
121C:  BRA    1342
....................    }
.................... 
....................    // Save the location of this packet
....................    CurrentPacketLocation.Val = NextPacketLocation.Val;
121E:  MOVFF  57,59
1222:  MOVFF  56,58
.................... 
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet
....................    BankSel(ERDPTL);
1226:  CLRF   xAC
1228:  CLRF   xAB
122A:  MOVLB  0
122C:  CALL   0916
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]);
1230:  MOVLB  3
1232:  CLRF   xAE
1234:  MOVFF  56,3AF
1238:  MOVLB  0
123A:  CALL   08BC
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]);
123E:  MOVLW  01
1240:  MOVLB  3
1242:  MOVWF  xAE
1244:  MOVFF  57,3AF
1248:  MOVLB  0
124A:  CALL   08BC
.................... 
....................    // Obtain the MAC header from the Ethernet buffer
....................    MACGetArray((BYTE*)&header, sizeof(header));
124E:  MOVLW  02
1250:  MOVLB  3
1252:  MOVWF  x13
1254:  MOVLW  FE
1256:  MOVWF  x12
1258:  MOVFF  313,398
125C:  MOVWF  x97
125E:  CLRF   x9A
1260:  MOVLW  14
1262:  MOVWF  x99
1264:  MOVLB  0
1266:  RCALL  116C
.................... 
....................    // The EtherType field, like most items transmitted on the Ethernet medium
....................    // are in big endian.
....................     header.Type.Val = swaps(header.Type.Val);
1268:  MOVFF  311,3A9
126C:  MOVFF  310,3A8
1270:  RCALL  11CC
1272:  MOVFF  02,311
1276:  MOVFF  01,310
.................... 
....................    // Validate the data returned from the ENC28J60.  Random data corruption,
....................    // such as if a single SPI bit error occurs while communicating or a
....................    // momentary power glitch could cause this to occur in rare circumstances.
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 ||
....................       header.StatusVector.bits.Zero ||
....................       header.StatusVector.bits.CRCError ||
....................       header.StatusVector.bits.ByteCount > 1518 ||
....................       !header.StatusVector.bits.ReceiveOk)
127A:  MOVLB  2
127C:  MOVF   xFF,W
127E:  SUBLW  1A
1280:  BC    128C
1282:  XORLW  FF
1284:  BNZ   12D4
1286:  MOVF   xFE,W
1288:  SUBLW  F7
128A:  BNC   12D4
128C:  MOVLW  02
128E:  MOVLB  3
1290:  MOVWF  x13
1292:  MOVLW  FE
1294:  MOVWF  FE9
1296:  MOVFF  313,FEA
129A:  BTFSS  FEF.0
129C:  BRA    12A2
129E:  MOVLB  2
12A0:  BRA    12D4
12A2:  BTFSS  x03.7
12A4:  BRA    12AA
12A6:  MOVLB  2
12A8:  BRA    12D4
12AA:  BTFSS  x02.4
12AC:  BRA    12B2
12AE:  MOVLB  2
12B0:  BRA    12D4
12B2:  MOVF   x01,W
12B4:  SUBLW  04
12B6:  BC    12CE
12B8:  XORLW  FF
12BA:  BTFSC  FD8.2
12BC:  BRA    12C2
12BE:  MOVLB  2
12C0:  BRA    12D4
12C2:  MOVF   x00,W
12C4:  SUBLW  EE
12C6:  BTFSC  FD8.0
12C8:  BRA    12CE
12CA:  MOVLB  2
12CC:  BRA    12D4
12CE:  BTFSC  x02.7
12D0:  BRA    12D8
12D2:  MOVLB  2
....................    {
....................       //Reset();
....................       reset_cpu();
12D4:  RESET
12D6:  MOVLB  3
....................    }
.................... 
....................    // Save the location where the hardware will write the next packet to
....................    NextPacketLocation.Val = header.NextPacketPointer;
12D8:  MOVFF  2FF,57
12DC:  MOVFF  2FE,56
.................... 
....................    // Return the Ethernet frame's Source MAC address field to the caller
....................    // This parameter is useful for replying to requests without requiring an
....................    // ARP cycle.
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote));
12E0:  MOVFF  2FA,01
12E4:  MOVFF  2FB,03
12E8:  MOVFF  01,312
12EC:  MOVLB  3
12EE:  MOVFF  03,313
12F2:  MOVFF  03,FEA
12F6:  MOVFF  01,FE9
12FA:  MOVLW  03
12FC:  MOVWF  FE2
12FE:  MOVLW  0A
1300:  MOVWF  FE1
1302:  MOVLW  06
1304:  MOVWF  01
1306:  MOVFF  FE6,FEE
130A:  DECFSZ 01,F
130C:  BRA    1306
.................... 
....................    // Return a simplified version of the EtherType field to the caller
....................     *type = MAC_UNKNOWN;
130E:  MOVFF  2FD,FEA
1312:  MOVLB  2
1314:  MOVFF  2FC,FE9
1318:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) &&
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) )
131A:  MOVLB  3
131C:  MOVF   x11,W
131E:  SUBLW  08
1320:  BNZ   133C
1322:  MOVF   x10,F
1324:  BZ    132C
1326:  MOVF   x10,W
1328:  SUBLW  06
132A:  BNZ   133C
....................     {
....................        *type = header.Type.v[0];
132C:  MOVFF  2FD,FEA
1330:  MOVLB  2
1332:  MOVFF  2FC,FE9
1336:  MOVFF  310,FEF
133A:  MOVLB  3
....................     }
.................... 
....................     // Mark this packet as discardable
....................     WasDiscarded = FALSE;
133C:  BCF    5A.0
....................    return TRUE;
133E:  MOVLW  01
1340:  MOVWF  01
1342:  MOVLB  0
1344:  GOTO   6C6A (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote,
....................  *                                    BYTE type,
....................  *                                   WORD dataLen)
....................  *
....................  * PreCondition:    MACIsTxReady() must return TRUE.
....................  *
....................  * Input:           *remote: Pointer to memory which contains the destination
....................  *                       MAC address (6 bytes)
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which
....................  *                    value to write into the Ethernet header's type field.
....................  *               dataLen: Length of the Ethernet data payload
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Because of the dataLen parameter, it is probably
....................  *               advantagous to call this function immediately before
....................  *               transmitting a packet rather than initially when the
....................  *               packet is first created.  The order in which the packet
....................  *               is constructed (header first or data first) is not
....................  *               important.
....................  *****************************************************************************/
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen)
.................... {
.................... 
....................    BankSel(EWRPTL);
*
1608:  MOVLB  3
160A:  CLRF   xAC
160C:  MOVLW  02
160E:  MOVWF  xAB
1610:  MOVLB  0
1612:  CALL   0916
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    // Set the SPI write pointer to the beginning of the transmit buffer
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]);
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]);
.................... 
....................    // Calculate where to put the TXND pointer
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val;
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen;
.................... #else
....................    // Set the SPI write pointer to the beginning of the transmit buffer
....................    WriteReg(EWRPTL, LOW(TXSTART));
1616:  MOVLW  02
1618:  MOVLB  3
161A:  MOVWF  xAE
161C:  MOVLW  F8
161E:  MOVWF  xAF
1620:  MOVLB  0
1622:  CALL   08BC
....................    WriteReg(EWRPTH, HIGH(TXSTART));
1626:  MOVLW  03
1628:  MOVLB  3
162A:  MOVWF  xAE
162C:  MOVLW  1B
162E:  MOVWF  xAF
1630:  MOVLB  0
1632:  CALL   08BC
.................... 
....................    // Calculate where to put the TXND pointer
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART;
1636:  MOVLW  06
1638:  MOVLB  3
163A:  ADDWF  xA9,F
163C:  MOVLW  1C
163E:  ADDWFC xAA,F
.................... 
....................    // Write the TXND pointer into the registers, given the dataLen given
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]);
1640:  MOVLW  03
1642:  MOVWF  xAC
1644:  MOVLW  A9
1646:  MOVWF  xAB
1648:  MOVWF  FE9
164A:  MOVFF  3AC,FEA
164E:  MOVFF  FEF,3AF
1652:  MOVLW  06
1654:  MOVWF  xAE
1656:  MOVLB  0
1658:  CALL   08BC
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]);
165C:  MOVLW  03
165E:  MOVLB  3
1660:  MOVWF  xAC
1662:  MOVLW  A9
1664:  MOVWF  xAB
1666:  MOVLW  01
1668:  ADDWF  xAB,W
166A:  MOVWF  FE9
166C:  MOVLW  00
166E:  ADDWFC xAC,W
1670:  MOVWF  FEA
1672:  MOVFF  FEF,3AF
1676:  MOVLW  07
1678:  MOVWF  xAE
167A:  MOVLB  0
167C:  CALL   08BC
.................... #endif
.................... 
.................... 
....................    // Set the per-packet control byte and write the Ethernet destination
....................    // address
....................    MACPut(0x00);   // Use default control configuration
1680:  MOVLB  3
1682:  CLRF   xAC
1684:  MOVLB  0
1686:  RCALL  15A4
....................     MACPutArray((BYTE*)remote, sizeof(*remote));
1688:  MOVFF  3A7,3AE
168C:  MOVFF  3A6,3AD
1690:  MOVLB  3
1692:  CLRF   xB0
1694:  MOVLW  06
1696:  MOVWF  xAF
1698:  MOVLB  0
169A:  RCALL  15C2
.................... 
....................    // Write our MAC address in the Ethernet source field
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
169C:  MOVLB  3
169E:  MOVLW  21
16A0:  MOVWF  xAB
16A2:  CLRF   xAE
16A4:  MOVWF  xAD
16A6:  CLRF   xB0
16A8:  MOVLW  06
16AA:  MOVWF  xAF
16AC:  MOVLB  0
16AE:  RCALL  15C2
.................... 
....................    // Write the appropriate Ethernet Type WORD for the protocol being used
....................     MACPut(0x08);
16B0:  MOVLW  08
16B2:  MOVLB  3
16B4:  MOVWF  xAC
16B6:  MOVLB  0
16B8:  RCALL  15A4
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP);
16BA:  MOVLB  3
16BC:  MOVF   xA8,F
16BE:  BNZ   16C4
16C0:  MOVLW  00
16C2:  BRA    16C6
16C4:  MOVLW  06
16C6:  MOVWF  xAB
16C8:  MOVWF  xAC
16CA:  MOVLB  0
16CC:  RCALL  15A4
16CE:  RETURN 0
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        void MACFlush(void)
....................  *
....................  * PreCondition:    A packet has been created by calling MACPut() and
....................  *               MACPutHeader().
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACFlush causes the current TX packet to be sent out on
....................  *               the Ethernet medium.  The hardware MAC will take control
....................  *               and handle CRC generation, collision retransmission and
....................  *               other details.
....................  *
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE),
....................  *               the packet can be modified and transmitted again by calling
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is
....................  *               called (in the TX data area), the data in the TX buffer
....................  *               will not be corrupted.
....................  *****************************************************************************/
.................... void MACFlush(void)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    // Set the packet start and end address pointers
....................    BankSel(ETXSTL);
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]);
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]);
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]);
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]);
....................    LastTXedBuffer = CurrentTxBuffer;
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE;
.................... #endif
.................... 
....................    // Reset transmit logic if a TX Error has previously occured
....................    // This is a silicon errata workaround
....................    if(ReadETHReg(EIR).EIRbits.TXERIF)
16D0:  MOVLW  1C
16D2:  MOVLB  3
16D4:  MOVWF  xA8
16D6:  MOVLB  0
16D8:  CALL   087E
16DC:  MOVFF  01,395
16E0:  MOVLW  00
16E2:  MOVLB  3
16E4:  BTFSC  01.1
16E6:  MOVLW  01
16E8:  XORLW  00
16EA:  BZ    170C
....................    {
....................       BFSReg(ECON1, ECON1_TXRST);
16EC:  MOVLW  1F
16EE:  MOVWF  xB0
16F0:  MOVLW  80
16F2:  MOVWF  xB1
16F4:  MOVLB  0
16F6:  CALL   08F8
....................       BFCReg(ECON1, ECON1_TXRST);
16FA:  MOVLW  1F
16FC:  MOVLB  3
16FE:  MOVWF  xAD
1700:  MOVLW  80
1702:  MOVWF  xAE
1704:  MOVLB  0
1706:  CALL   08DA
170A:  MOVLB  3
....................    }
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
170C:  MOVLW  1C
170E:  MOVWF  xAD
1710:  MOVLW  0A
1712:  MOVWF  xAE
1714:  MOVLB  0
1716:  CALL   08DA
.................... 
....................    // Start the transmission
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet
....................    // can be modified and transmitted again by calling MACFlush() again.
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be
....................    // corrupted.
....................    BFSReg(ECON1, ECON1_TXRTS);
171A:  MOVLW  1F
171C:  MOVLB  3
171E:  MOVWF  xB0
1720:  MOVLW  08
1722:  MOVWF  xB1
1724:  MOVLB  0
1726:  CALL   08F8
.................... 
....................    // Revision B5 silicon errata workaround
....................    if(ENCRevID == 0x05)
172A:  MOVF   5B,W
172C:  SUBLW  05
172E:  BTFSS  FD8.2
1730:  BRA    18F6
....................    {
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)));
1732:  MOVLW  1C
1734:  MOVLB  3
1736:  MOVWF  xA8
1738:  MOVLB  0
173A:  CALL   087E
173E:  MOVFF  01,395
1742:  MOVLB  3
1744:  MOVF   01,W
1746:  ANDLW  0A
1748:  BTFSS  FD8.2
174A:  BRA    1750
174C:  MOVLB  0
174E:  BRA    1732
....................       if(ReadETHReg(EIR).EIRbits.TXERIF)
1750:  MOVLW  1C
1752:  MOVWF  xA8
1754:  MOVLB  0
1756:  CALL   087E
175A:  MOVFF  01,395
175E:  MOVLW  00
1760:  MOVLB  3
1762:  BTFSC  01.1
1764:  MOVLW  01
1766:  XORLW  00
1768:  BTFSC  FD8.2
176A:  BRA    18F8
....................       {
....................          WORD_VAL ReadPtrSave;
....................          WORD_VAL TXEnd;
....................          TXSTATUS TXStatus;
....................          BYTE i;
.................... 
....................          // Cancel the previous transmission if it has become stuck set
....................          BFCReg(ECON1, ECON1_TXRTS);
176C:  MOVLW  1F
176E:  MOVWF  xAD
1770:  MOVLW  08
1772:  MOVWF  xAE
1774:  MOVLB  0
1776:  CALL   08DA
.................... 
....................          // Save the current read pointer (controlled by application)
....................          BankSel(ERDPTL);
177A:  MOVLB  3
177C:  CLRF   xAC
177E:  CLRF   xAB
1780:  MOVLB  0
1782:  CALL   0916
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val;
1786:  MOVLB  3
1788:  CLRF   xA8
178A:  MOVLB  0
178C:  CALL   087E
1790:  MOVFF  01,389
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val;
1794:  MOVLW  01
1796:  MOVLB  3
1798:  MOVWF  xA8
179A:  MOVLB  0
179C:  CALL   087E
17A0:  MOVFF  01,38A
.................... 
....................          // Get the location of the transmit status vector
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val;
17A4:  MOVLW  06
17A6:  MOVLB  3
17A8:  MOVWF  xA8
17AA:  MOVLB  0
17AC:  CALL   087E
17B0:  MOVFF  01,38B
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val;
17B4:  MOVLW  07
17B6:  MOVLB  3
17B8:  MOVWF  xA8
17BA:  MOVLB  0
17BC:  CALL   087E
17C0:  MOVFF  01,38C
....................          TXEnd.Val++;
17C4:  MOVLB  3
17C6:  INCF   x8B,F
17C8:  BTFSC  FD8.2
17CA:  INCF   x8C,F
.................... 
....................          // Read the transmit status vector
....................          WriteReg(ERDPTL, TXEnd.v[0]);
17CC:  CLRF   xAE
17CE:  MOVFF  38B,3AF
17D2:  MOVLB  0
17D4:  CALL   08BC
....................          WriteReg(ERDPTH, TXEnd.v[1]);
17D8:  MOVLW  01
17DA:  MOVLB  3
17DC:  MOVWF  xAE
17DE:  MOVFF  38C,3AF
17E2:  MOVLB  0
17E4:  CALL   08BC
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus));
17E8:  MOVLW  03
17EA:  MOVLB  3
17EC:  MOVWF  x96
17EE:  MOVLW  8D
17F0:  MOVWF  x95
17F2:  MOVFF  396,398
17F6:  MOVWF  x97
17F8:  CLRF   x9A
17FA:  MOVLW  07
17FC:  MOVWF  x99
17FE:  MOVLB  0
1800:  RCALL  116C
.................... 
....................          // Implement retransmission if a late collision occured (this can
....................          // happen on B5 when certain link pulses arrive at the same time
....................          // as the transmission)
....................          for(i = 0; i < 16; i++)
1802:  MOVLB  3
1804:  CLRF   x94
1806:  MOVF   x94,W
1808:  SUBLW  0F
180A:  BNC   18DA
....................          {
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision)
180C:  MOVLW  1C
180E:  MOVWF  xA8
1810:  MOVLB  0
1812:  CALL   087E
1816:  MOVFF  01,395
181A:  MOVLW  00
181C:  MOVLB  3
181E:  BTFSC  01.1
1820:  MOVLW  01
1822:  XORLW  00
1824:  BZ    18D0
1826:  BTFSS  x90.5
1828:  BRA    18D0
....................             {
....................                // Reset the TX logic
....................                BFSReg(ECON1, ECON1_TXRST);
182A:  MOVLW  1F
182C:  MOVWF  xB0
182E:  MOVLW  80
1830:  MOVWF  xB1
1832:  MOVLB  0
1834:  CALL   08F8
....................                BFCReg(ECON1, ECON1_TXRST);
1838:  MOVLW  1F
183A:  MOVLB  3
183C:  MOVWF  xAD
183E:  MOVLW  80
1840:  MOVWF  xAE
1842:  MOVLB  0
1844:  CALL   08DA
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
1848:  MOVLW  1C
184A:  MOVLB  3
184C:  MOVWF  xAD
184E:  MOVLW  0A
1850:  MOVWF  xAE
1852:  MOVLB  0
1854:  CALL   08DA
.................... 
....................                // Transmit the packet again
....................                BFSReg(ECON1, ECON1_TXRTS);
1858:  MOVLW  1F
185A:  MOVLB  3
185C:  MOVWF  xB0
185E:  MOVLW  08
1860:  MOVWF  xB1
1862:  MOVLB  0
1864:  CALL   08F8
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)));
1868:  MOVLW  1C
186A:  MOVLB  3
186C:  MOVWF  xA8
186E:  MOVLB  0
1870:  CALL   087E
1874:  MOVFF  01,395
1878:  MOVLB  3
187A:  MOVF   01,W
187C:  ANDLW  0A
187E:  BTFSS  FD8.2
1880:  BRA    1886
1882:  MOVLB  0
1884:  BRA    1868
.................... 
....................                // Cancel the previous transmission if it has become stuck set
....................                BFCReg(ECON1, ECON1_TXRTS);
1886:  MOVLW  1F
1888:  MOVWF  xAD
188A:  MOVLW  08
188C:  MOVWF  xAE
188E:  MOVLB  0
1890:  CALL   08DA
.................... 
....................                // Read transmit status vector
....................                WriteReg(ERDPTL, TXEnd.v[0]);
1894:  MOVLB  3
1896:  CLRF   xAE
1898:  MOVFF  38B,3AF
189C:  MOVLB  0
189E:  CALL   08BC
....................                WriteReg(ERDPTH, TXEnd.v[1]);
18A2:  MOVLW  01
18A4:  MOVLB  3
18A6:  MOVWF  xAE
18A8:  MOVFF  38C,3AF
18AC:  MOVLB  0
18AE:  CALL   08BC
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus));
18B2:  MOVLW  03
18B4:  MOVLB  3
18B6:  MOVWF  x96
18B8:  MOVLW  8D
18BA:  MOVWF  x95
18BC:  MOVFF  396,398
18C0:  MOVWF  x97
18C2:  CLRF   x9A
18C4:  MOVLW  07
18C6:  MOVWF  x99
18C8:  MOVLB  0
18CA:  RCALL  116C
....................             }
18CC:  BRA    18D4
18CE:  MOVLB  3
....................             else
....................             {
....................                break;
18D0:  BRA    18DA
18D2:  MOVLB  0
....................             }
18D4:  MOVLB  3
18D6:  INCF   x94,F
18D8:  BRA    1806
....................          }
.................... 
....................          // Restore the current read pointer
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]);
18DA:  CLRF   xAE
18DC:  MOVFF  389,3AF
18E0:  MOVLB  0
18E2:  CALL   08BC
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]);
18E6:  MOVLW  01
18E8:  MOVLB  3
18EA:  MOVWF  xAE
18EC:  MOVFF  38A,3AF
18F0:  MOVLB  0
18F2:  CALL   08BC
18F6:  MOVLB  3
....................       }
....................    }
18F8:  MOVLB  0
18FA:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetRxBuffer(WORD offset)
....................  *
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and
....................  *               getting a TRUE result.
....................  *
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet
....................  *                     header's type field to relocate the SPI read and
....................  *                     write pointers.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SPI read and write pointers are updated.  All calls to
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(),
....................  *               and various other functions will use these new values.
....................  *
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for
....................  *               this function to work correctly.  In other words, do not
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory
....................  *               boundary.
....................  *****************************************************************************/
.................... void MACSetRxBuffer(WORD offset)
.................... {
....................    WORD_VAL ReadPT;
.................... 
....................    // Determine the address of the beginning of the entire packet
....................    // and adjust the address to the desired location
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset;
*
1C02:  MOVLW  14
1C04:  ADDWF  58,W
1C06:  MOVLB  3
1C08:  MOVWF  x2F
1C0A:  MOVLW  00
1C0C:  ADDWFC 59,W
1C0E:  MOVWF  x30
1C10:  MOVF   x2B,W
1C12:  ADDWF  x2F,W
1C14:  MOVWF  x2D
1C16:  MOVF   x2C,W
1C18:  ADDWFC x30,W
1C1A:  MOVWF  x2E
.................... 
....................    // Since the receive buffer is circular, adjust if a wraparound is needed
....................    if ( ReadPT.Val > RXSTOP )
1C1C:  MOVF   x2E,W
1C1E:  SUBLW  1A
1C20:  BC    1C34
1C22:  XORLW  FF
1C24:  BNZ   1C2C
1C26:  MOVF   x2D,W
1C28:  SUBLW  F7
1C2A:  BC    1C34
....................       ReadPT.Val -= RXSIZE;
1C2C:  MOVLW  F8
1C2E:  SUBWF  x2D,F
1C30:  MOVLW  1B
1C32:  SUBWFB x2E,F
.................... 
....................    // Set the SPI read and write pointers to the new calculated value
....................    BankSel(ERDPTL);
1C34:  CLRF   xAC
1C36:  CLRF   xAB
1C38:  MOVLB  0
1C3A:  CALL   0916
....................    WriteReg(ERDPTL, ReadPT.v[0]);
1C3E:  MOVLB  3
1C40:  CLRF   xAE
1C42:  MOVFF  32D,3AF
1C46:  MOVLB  0
1C48:  CALL   08BC
....................    WriteReg(ERDPTH, ReadPT.v[1]);
1C4C:  MOVLW  01
1C4E:  MOVLB  3
1C50:  MOVWF  xAE
1C52:  MOVFF  32E,3AF
1C56:  MOVLB  0
1C58:  CALL   08BC
....................    WriteReg(EWRPTL, ReadPT.v[0]);
1C5C:  MOVLW  02
1C5E:  MOVLB  3
1C60:  MOVWF  xAE
1C62:  MOVFF  32D,3AF
1C66:  MOVLB  0
1C68:  CALL   08BC
....................    WriteReg(EWRPTH, ReadPT.v[1]);
1C6C:  MOVLW  03
1C6E:  MOVLB  3
1C70:  MOVWF  xAE
1C72:  MOVFF  32E,3AF
1C76:  MOVLB  0
1C78:  CALL   08BC
1C7C:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this
....................  *                     parameter is not used.
....................  *               offset: WORD specifying how many bytes beyond the Ethernet
....................  *                     header's type field to relocate the SPI read and
....................  *                     write pointers.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SPI read and write pointers are updated.  All calls to
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(),
....................  *               and various other functions will use these new values.
....................  *
....................  * Note:         None
....................  *****************************************************************************/
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset)
.................... {
....................     CurrentTxBuffer = buffer;
*
1506:  MOVFF  3A2,06
.................... 
....................    // Calculate the proper address.  Since the TX memory area is not circular,
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of
....................    // the per packet control byte which preceeds the packet in the TX memory
....................    // area.
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER);
.................... #else
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER);
150A:  MOVLW  07
150C:  MOVLB  3
150E:  ADDWF  xA3,F
1510:  MOVLW  1C
1512:  ADDWFC xA4,F
.................... #endif
.................... 
....................    // Set the SPI read and write pointers to the new calculated value
....................    BankSel(EWRPTL);
1514:  CLRF   xAC
1516:  MOVLW  02
1518:  MOVWF  xAB
151A:  MOVLB  0
151C:  CALL   0916
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]);
1520:  MOVLW  03
1522:  MOVLB  3
1524:  MOVWF  xA6
1526:  MOVLW  A3
1528:  MOVWF  xA5
152A:  MOVWF  FE9
152C:  MOVFF  3A6,FEA
1530:  MOVFF  FEF,3AF
1534:  CLRF   xAE
1536:  MOVLB  0
1538:  CALL   08BC
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]);
153C:  MOVLW  03
153E:  MOVLB  3
1540:  MOVWF  xA6
1542:  MOVLW  A3
1544:  MOVWF  xA5
1546:  MOVLW  01
1548:  ADDWF  xA5,W
154A:  MOVWF  FE9
154C:  MOVLW  00
154E:  ADDWFC xA6,W
1550:  MOVWF  FEA
1552:  MOVFF  FEF,3AF
1556:  MOVLW  01
1558:  MOVWF  xAE
155A:  MOVLB  0
155C:  CALL   08BC
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]);
1560:  MOVLW  03
1562:  MOVLB  3
1564:  MOVWF  xA6
1566:  MOVLW  A3
1568:  MOVWF  xA5
156A:  MOVWF  FE9
156C:  MOVFF  3A6,FEA
1570:  MOVFF  FEF,3AF
1574:  MOVLW  02
1576:  MOVWF  xAE
1578:  MOVLB  0
157A:  CALL   08BC
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]);
157E:  MOVLW  03
1580:  MOVLB  3
1582:  MOVWF  xA6
1584:  MOVLW  A3
1586:  MOVWF  xA5
1588:  MOVLW  01
158A:  ADDWF  xA5,W
158C:  MOVWF  FE9
158E:  MOVLW  00
1590:  ADDWFC xA6,W
1592:  MOVWF  FEA
1594:  MOVFF  FEF,3AF
1598:  MOVLW  03
159A:  MOVWF  xAE
159C:  MOVLB  0
159E:  CALL   08BC
15A2:  RETURN 0
.................... }
.................... 
.................... 
.................... #if defined(MCHP_MAC)
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate
.................... // checksums.  These two functions have been tested.
.................... /******************************************************************************
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           offset   - Number of bytes beyond the beginning of the
....................  *                     Ethernet data (first byte after the type field)
....................  *                     where the checksum should begin
....................  *               len      - Total number of bytes to include in the checksum
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself using the hardware DMA module
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACCalcRxChecksum(WORD offset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Add the offset requested by firmware plus the Ethernet header
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset;
*
1AFA:  MOVLW  14
1AFC:  ADDWF  58,W
1AFE:  MOVLB  3
1B00:  MOVWF  x59
1B02:  MOVLW  00
1B04:  ADDWFC 59,W
1B06:  MOVWF  x5A
1B08:  MOVF   x53,W
1B0A:  ADDWF  x59,W
1B0C:  MOVWF  x57
1B0E:  MOVF   x54,W
1B10:  ADDWFC x5A,W
1B12:  MOVWF  x58
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
1B14:  MOVF   x58,W
1B16:  SUBLW  1A
1B18:  BC    1B2C
1B1A:  XORLW  FF
1B1C:  BNZ   1B24
1B1E:  MOVF   x57,W
1B20:  SUBLW  F7
1B22:  BC    1B2C
....................    {
....................       temp.Val -= RXSIZE;
1B24:  MOVLW  F8
1B26:  SUBWF  x57,F
1B28:  MOVLW  1B
1B2A:  SUBWFB x58,F
....................    }
.................... 
....................    // Program the start address of the DMA
....................    BankSel(EDMASTL);
1B2C:  CLRF   xAC
1B2E:  MOVLW  10
1B30:  MOVWF  xAB
1B32:  MOVLB  0
1B34:  CALL   0916
....................    WriteReg(EDMASTL, temp.v[0]);
1B38:  MOVLW  10
1B3A:  MOVLB  3
1B3C:  MOVWF  xAE
1B3E:  MOVFF  357,3AF
1B42:  MOVLB  0
1B44:  CALL   08BC
....................    WriteReg(EDMASTH, temp.v[1]);
1B48:  MOVLW  11
1B4A:  MOVLB  3
1B4C:  MOVWF  xAE
1B4E:  MOVFF  358,3AF
1B52:  MOVLB  0
1B54:  CALL   08BC
.................... 
....................    // Calculate the end address, given the start address and len
....................    temp.Val += len-1;
1B58:  MOVLW  01
1B5A:  MOVLB  3
1B5C:  SUBWF  x55,W
1B5E:  MOVWF  00
1B60:  MOVLW  00
1B62:  SUBWFB x56,W
1B64:  MOVWF  03
1B66:  MOVF   00,W
1B68:  ADDWF  x57,F
1B6A:  MOVF   03,W
1B6C:  ADDWFC x58,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
1B6E:  MOVF   x58,W
1B70:  SUBLW  1A
1B72:  BC    1B86
1B74:  XORLW  FF
1B76:  BNZ   1B7E
1B78:  MOVF   x57,W
1B7A:  SUBLW  F7
1B7C:  BC    1B86
....................    {
....................       temp.Val -= RXSIZE;
1B7E:  MOVLW  F8
1B80:  SUBWF  x57,F
1B82:  MOVLW  1B
1B84:  SUBWFB x58,F
....................    }
.................... 
....................    // Program the end address of the DMA
....................    WriteReg(EDMANDL, temp.v[0]);
1B86:  MOVLW  12
1B88:  MOVWF  xAE
1B8A:  MOVFF  357,3AF
1B8E:  MOVLB  0
1B90:  CALL   08BC
....................    WriteReg(EDMANDH, temp.v[1]);
1B94:  MOVLW  13
1B96:  MOVLB  3
1B98:  MOVWF  xAE
1B9A:  MOVFF  358,3AF
1B9E:  MOVLB  0
1BA0:  CALL   08BC
.................... 
....................    // Do the checksum calculation
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
1BA4:  MOVLW  1F
1BA6:  MOVLB  3
1BA8:  MOVWF  xB0
1BAA:  MOVLW  30
1BAC:  MOVWF  xB1
1BAE:  MOVLB  0
1BB0:  CALL   08F8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
1BB4:  MOVLW  1F
1BB6:  MOVLB  3
1BB8:  MOVWF  xA8
1BBA:  MOVLB  0
1BBC:  CALL   087E
1BC0:  MOVFF  01,359
1BC4:  MOVLW  00
1BC6:  MOVLB  3
1BC8:  BTFSC  01.5
1BCA:  MOVLW  01
1BCC:  XORLW  00
1BCE:  BTFSC  FD8.2
1BD0:  BRA    1BD6
1BD2:  MOVLB  0
1BD4:  BRA    1BB4
.................... 
....................    // Swap endianness and return
....................    temp.v[1] = ReadETHReg(EDMACSL).Val;
1BD6:  MOVLW  16
1BD8:  MOVWF  xA8
1BDA:  MOVLB  0
1BDC:  CALL   087E
1BE0:  MOVFF  01,358
....................    temp.v[0] = ReadETHReg(EDMACSH).Val;
1BE4:  MOVLW  17
1BE6:  MOVLB  3
1BE8:  MOVWF  xA8
1BEA:  MOVLB  0
1BEC:  CALL   087E
1BF0:  MOVFF  01,357
....................    return temp.Val;
1BF4:  MOVLB  3
1BF6:  MOVFF  357,01
1BFA:  MOVFF  358,02
1BFE:  MOVLB  0
1C00:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           offset   - Number of bytes beyond the beginning of the
....................  *                     Ethernet data (first byte after the type field)
....................  *                     where the checksum should begin
....................  *               len      - Total number of bytes to include in the checksum
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself using the hardware DMA module
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACCalcTxChecksum(WORD offset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Program the start address of the DMA, after adjusting for the Ethernet
....................    // header
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER)
....................             + offset + 1;   // +1 needed to account for per packet control byte
.................... #else
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER)
....................             + offset + 1;   // +1 needed to account for per packet control byte
*
26D8:  MOVLW  06
26DA:  MOVLB  3
26DC:  ADDWF  xA2,W
26DE:  MOVWF  xA8
26E0:  MOVLW  1C
26E2:  ADDWFC xA3,W
26E4:  MOVWF  xA9
26E6:  MOVLW  01
26E8:  ADDWF  xA8,W
26EA:  MOVWF  xA6
26EC:  MOVLW  00
26EE:  ADDWFC xA9,W
26F0:  MOVWF  xA7
.................... #endif
....................    BankSel(EDMASTL);
26F2:  CLRF   xAC
26F4:  MOVLW  10
26F6:  MOVWF  xAB
26F8:  MOVLB  0
26FA:  CALL   0916
....................    WriteReg(EDMASTL, temp.v[0]);
26FE:  MOVLW  10
2700:  MOVLB  3
2702:  MOVWF  xAE
2704:  MOVFF  3A6,3AF
2708:  MOVLB  0
270A:  CALL   08BC
....................    WriteReg(EDMASTH, temp.v[1]);
270E:  MOVLW  11
2710:  MOVLB  3
2712:  MOVWF  xAE
2714:  MOVFF  3A7,3AF
2718:  MOVLB  0
271A:  CALL   08BC
.................... 
....................    // Program the end address of the DMA.
....................    temp.Val += len-1;
271E:  MOVLW  01
2720:  MOVLB  3
2722:  SUBWF  xA4,W
2724:  MOVWF  00
2726:  MOVLW  00
2728:  SUBWFB xA5,W
272A:  MOVWF  03
272C:  MOVF   00,W
272E:  ADDWF  xA6,F
2730:  MOVF   03,W
2732:  ADDWFC xA7,F
....................    WriteReg(EDMANDL, temp.v[0]);
2734:  MOVLW  12
2736:  MOVWF  xAE
2738:  MOVFF  3A6,3AF
273C:  MOVLB  0
273E:  CALL   08BC
....................    WriteReg(EDMANDH, temp.v[1]);
2742:  MOVLW  13
2744:  MOVLB  3
2746:  MOVWF  xAE
2748:  MOVFF  3A7,3AF
274C:  MOVLB  0
274E:  CALL   08BC
.................... 
....................    // Do the checksum calculation
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
2752:  MOVLW  1F
2754:  MOVLB  3
2756:  MOVWF  xB0
2758:  MOVLW  30
275A:  MOVWF  xB1
275C:  MOVLB  0
275E:  CALL   08F8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
2762:  MOVLW  1F
2764:  MOVLB  3
2766:  MOVWF  xA8
2768:  MOVLB  0
276A:  CALL   087E
276E:  MOVFF  01,3A8
2772:  MOVLW  00
2774:  MOVLB  3
2776:  BTFSC  01.5
2778:  MOVLW  01
277A:  XORLW  00
277C:  BTFSC  FD8.2
277E:  BRA    2784
2780:  MOVLB  0
2782:  BRA    2762
.................... 
....................    // Swap endianness and return
....................    temp.v[1] = ReadETHReg(EDMACSL).Val;
2784:  MOVLW  16
2786:  MOVWF  xA8
2788:  MOVLB  0
278A:  CALL   087E
278E:  MOVFF  01,3A7
....................    temp.v[0] = ReadETHReg(EDMACSH).Val;
2792:  MOVLW  17
2794:  MOVLB  3
2796:  MOVWF  xA8
2798:  MOVLB  0
279A:  CALL   087E
279E:  MOVFF  01,3A6
....................    return temp.Val;
27A2:  MOVLB  3
27A4:  MOVFF  3A6,01
27A8:  MOVFF  3A7,02
27AC:  MOVLB  0
27AE:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD CalcIPBufferChecksum(WORD len)
....................  *
....................  * PreCondition:    Read buffer pointer set to starting of checksum data
....................  *
....................  * Input:           len: Total number of bytes to calculate the checksum over.
....................  *                   The first byte included in the checksum is the byte
....................  *                   pointed to by ERDPT, which is updated by calls to
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc.
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module
....................  *               which can calculate the checksum faster than software, so
....................  *               this function replaces the CaclIPBufferChecksum() function
....................  *               defined in the helpers.c file.  Through the use of
....................  *               preprocessor defines, this replacement is automatic.
....................  *
....................  * Note:            This function works either in the RX buffer area or the TX
....................  *               buffer area.  No validation is done on the len parameter.
....................  *****************************************************************************/
.................... WORD CalcIPBufferChecksum(WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Take care of special cases which the DMA cannot be used for
....................    if(len == 0u)
*
1F44:  MOVLB  3
1F46:  MOVF   x89,F
1F48:  BNZ   1F58
1F4A:  MOVF   x8A,F
1F4C:  BNZ   1F58
....................    {
....................       return 0xFFFF;
1F4E:  MOVLW  FF
1F50:  MOVWF  01
1F52:  MOVWF  02
1F54:  BRA    2098
....................    }
1F56:  BRA    1F86
....................    else if(len == 1u)
1F58:  DECFSZ x89,W
1F5A:  BRA    1F86
1F5C:  MOVF   x8A,F
1F5E:  BNZ   1F86
....................    {
....................       return ~(((WORD)MACGet())<<8);
1F60:  MOVLB  0
1F62:  RCALL  1F18
1F64:  MOVLB  3
1F66:  CLRF   x8E
1F68:  MOVFF  01,38D
1F6C:  MOVFF  01,03
1F70:  MOVLW  00
1F72:  CLRF   00
1F74:  DECF   00,F
1F76:  XORWF  00,F
1F78:  MOVLW  FF
1F7A:  XORWF  03,F
1F7C:  MOVFF  00,01
1F80:  MOVFF  03,02
1F84:  BRA    2098
....................    }
.................... 
.................... 
....................    // Set the DMA starting address to the SPI read pointer value
....................    BankSel(ERDPTL);
1F86:  CLRF   xAC
1F88:  CLRF   xAB
1F8A:  MOVLB  0
1F8C:  CALL   0916
....................    temp.v[0] = ReadETHReg(ERDPTL).Val;
1F90:  MOVLB  3
1F92:  CLRF   xA8
1F94:  MOVLB  0
1F96:  CALL   087E
1F9A:  MOVFF  01,38B
....................    temp.v[1] = ReadETHReg(ERDPTH).Val;
1F9E:  MOVLW  01
1FA0:  MOVLB  3
1FA2:  MOVWF  xA8
1FA4:  MOVLB  0
1FA6:  CALL   087E
1FAA:  MOVFF  01,38C
....................    WriteReg(EDMASTL, temp.v[0]);
1FAE:  MOVLW  10
1FB0:  MOVLB  3
1FB2:  MOVWF  xAE
1FB4:  MOVFF  38B,3AF
1FB8:  MOVLB  0
1FBA:  CALL   08BC
....................    WriteReg(EDMASTH, temp.v[1]);
1FBE:  MOVLW  11
1FC0:  MOVLB  3
1FC2:  MOVWF  xAE
1FC4:  MOVFF  38C,3AF
1FC8:  MOVLB  0
1FCA:  CALL   08BC
.................... 
....................    // See if we are calculating a checksum within the RX buffer (where
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are
....................    // not applied)
.................... #if RXSTART == 0
....................    if(temp.Val <= RXSTOP)
1FCE:  MOVLB  3
1FD0:  MOVF   x8C,W
1FD2:  SUBLW  1B
1FD4:  BNC   200C
1FD6:  BNZ   1FDE
1FD8:  MOVF   x8B,W
1FDA:  SUBLW  F7
1FDC:  BNC   200C
.................... #else
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP)
.................... #endif
....................    {
....................       // Calculate the DMA ending address given the starting address and len
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary.
....................       temp.Val += len-1;
1FDE:  MOVLW  01
1FE0:  SUBWF  x89,W
1FE2:  MOVWF  00
1FE4:  MOVLW  00
1FE6:  SUBWFB x8A,W
1FE8:  MOVWF  03
1FEA:  MOVF   00,W
1FEC:  ADDWF  x8B,F
1FEE:  MOVF   03,W
1FF0:  ADDWFC x8C,F
....................       if(temp.Val > RXSTOP)
1FF2:  MOVF   x8C,W
1FF4:  SUBLW  1A
1FF6:  BC    200A
1FF8:  XORLW  FF
1FFA:  BNZ   2002
1FFC:  MOVF   x8B,W
1FFE:  SUBLW  F7
2000:  BC    200A
....................       {
....................          temp.Val -= RXSIZE;
2002:  MOVLW  F8
2004:  SUBWF  x8B,F
2006:  MOVLW  1B
2008:  SUBWFB x8C,F
....................       }
....................    }
200A:  BRA    2020
....................    else
....................    {
....................       temp.Val += len-1;
200C:  MOVLW  01
200E:  SUBWF  x89,W
2010:  MOVWF  00
2012:  MOVLW  00
2014:  SUBWFB x8A,W
2016:  MOVWF  03
2018:  MOVF   00,W
201A:  ADDWF  x8B,F
201C:  MOVF   03,W
201E:  ADDWFC x8C,F
....................    }
.................... 
....................    // Write the DMA end address
....................    WriteReg(EDMANDL, temp.v[0]);
2020:  MOVLW  12
2022:  MOVWF  xAE
2024:  MOVFF  38B,3AF
2028:  MOVLB  0
202A:  CALL   08BC
....................    WriteReg(EDMANDH, temp.v[1]);
202E:  MOVLW  13
2030:  MOVLB  3
2032:  MOVWF  xAE
2034:  MOVFF  38C,3AF
2038:  MOVLB  0
203A:  CALL   08BC
.................... 
....................    // Begin the DMA checksum calculation and wait until it is finished
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
203E:  MOVLW  1F
2040:  MOVLB  3
2042:  MOVWF  xB0
2044:  MOVLW  30
2046:  MOVWF  xB1
2048:  MOVLB  0
204A:  CALL   08F8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
204E:  MOVLW  1F
2050:  MOVLB  3
2052:  MOVWF  xA8
2054:  MOVLB  0
2056:  CALL   087E
205A:  MOVFF  01,38D
205E:  MOVLW  00
2060:  MOVLB  3
2062:  BTFSC  01.5
2064:  MOVLW  01
2066:  XORLW  00
2068:  BTFSC  FD8.2
206A:  BRA    2070
206C:  MOVLB  0
206E:  BRA    204E
.................... 
....................    // Return the resulting good stuff
....................    temp.v[0] = ReadETHReg(EDMACSL).Val;
2070:  MOVLW  16
2072:  MOVWF  xA8
2074:  MOVLB  0
2076:  CALL   087E
207A:  MOVFF  01,38B
....................    temp.v[1] = ReadETHReg(EDMACSH).Val;
207E:  MOVLW  17
2080:  MOVLB  3
2082:  MOVWF  xA8
2084:  MOVLB  0
2086:  CALL   087E
208A:  MOVFF  01,38C
....................    return temp.Val;
208E:  MOVLB  3
2090:  MOVFF  38B,01
2094:  MOVFF  38C,02
2098:  MOVLB  0
209A:  RETURN 0
.................... }
.................... #endif   // End of MCHP_MAC specific code
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of
....................  *                        destination MAC address) to copy from.
....................  *               TxOffset: Offset in the TX buffer (0=first byte of
....................  *                       destination MAC address) to copy to.
....................  *               len:     Number of bytes to copy
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is
....................  *               set), the hardware will wait until it is finished.  Then,
....................  *               the DMA module will copy the data from the receive buffer
....................  *               to the transmit buffer.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... // Remove this line if your application needs to use this
.................... // function.  This code has NOT been tested.
.................... #if 0
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE);
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
....................       temp.Val -= RXSIZE;
.................... 
....................    BankSel(EDMASTL);
....................    WriteReg(EDMASTL, temp.v[0]);
....................    WriteReg(EDMASTH, temp.v[1]);
.................... 
....................    temp.Val += len-1;
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
....................       temp.Val -= RXSIZE;
.................... 
....................    WriteReg(EDMANDL, temp.v[0]);
....................    WriteReg(EDMANDH, temp.v[1]);
.................... 
....................    TxOffset += TXSTART+1;
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]);
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]);
.................... 
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear
....................    // before starting the copy.
....................    BFCReg(ECON1, ECON1_CSUMEN);
....................    BFSReg(ECON1, ECON1_DMAST);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... }
.................... #endif
.................... 
.................... 
.................... #if defined(MAC_FILTER_BROADCASTS)
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation
.................... // of MAC_FILTER_BROADCASTS.
.................... /******************************************************************************
....................  * Function:        void MACSetPMFilter(BYTE *Pattern,
....................  *                              BYTE *PatternMask,
....................  *                              WORD PatternOffset)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                MACIsTxReady() must return TRUE
....................  *
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which
....................  *                          defines which bytes of the pattern are
....................  *                          important.  At least one bit must be set.
....................  *               PatternOffset: Offset from the beginning of the Ethernet
....................  *                           frame (1st byte of destination address), to
....................  *                           begin comparing with the given pattern.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Contents of the TX buffer space are overwritten
....................  *
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for:
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a
....................  *               subset of the broadcast packets which are normally
....................  *               received will be received.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACSetPMFilter(BYTE *Pattern,
....................                BYTE *PatternMask,
....................                WORD PatternOffset)
.................... {
....................    WORD_VAL i;
....................    BYTE *MaskPtr;
....................    BYTE UnmaskedPatternLen;
.................... 
....................    // Set the SPI write pointer and DMA startting address to the beginning of
....................    // the transmit buffer
....................    BankSel(EWRPTL);
....................    WriteReg(EWRPTL, LOW(TXSTART));
....................    WriteReg(EWRPTH, HIGH(TXSTART));
....................    WriteReg(EDMASTL, LOW(TXSTART));
....................    WriteReg(EDMASTH, HIGH(TXSTART));
.................... 
....................    // Fill the transmit buffer with the pattern to match against.  Only the
....................    // bytes which have a mask bit of 1 are written into the buffer and will
....................    // subsequently be used for checksum computation.
....................    MaskPtr = PatternMask;
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++)
....................    {
....................       if( *MaskPtr & i.v[1] )
....................       {
....................          MACPut(*Pattern);
....................          UnmaskedPatternLen++;
....................       }
....................       Pattern++;
.................... 
....................       i.v[1] <<= 1;
....................       if( i.v[1] == 0u )
....................       {
....................          i.v[1] = 0x01;
....................          MaskPtr++;
....................       }
....................    }
.................... 
....................    // Calculate and set the DMA end address
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1;
....................    WriteReg(EDMANDL, i.v[0]);
....................    WriteReg(EDMANDH, i.v[1]);
.................... 
....................    // Calculate the checksum on the given pattern using the DMA module
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Make certain that the PM filter isn't enabled while it is
....................    // being reconfigured.
....................    BankSel(ERXFCON);
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);
.................... 
....................    // Get the calculated DMA checksum and store it in the PM
....................    // checksum registers
....................    i.v[0] == ReadETHReg(EDMACSL).Val;
....................    i.v[1] == ReadETHReg(EDMACSH).Val;
....................    WriteReg(EPMCSL, i.v[0]);
....................    WriteReg(EPMCSH, i.v[0]);
.................... 
....................    // Set the Pattern Match offset and 8 byte mask
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]);
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]);
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++)
....................    {
....................       WriteReg(i.Val, *PatternMask++);
....................    }
.................... 
....................    // Begin using the new Pattern Match filter instead of the
....................    // broadcast filter
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN);
.................... }//end MACSetPMFilter
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACDisablePMFilter(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive
....................  *               filter (if enabled) and returns to the default filter
....................  *               configuration of: CRC AND (Unicast OR Broadcast).
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACDisablePMFilter(void)
.................... {
....................    BankSel(ERXFCON);
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);
....................    return;
.................... }//end MACDisablePMFilter
.................... #endif // end of MAC_FILTER_BROADCASTS specific code
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BYTE MACGet()
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                ERDPT must point to the place to read from.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Byte read from the ENC28J60's RAM
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and
....................  *               increments ERDPT so MACGet() can be called again.  The
....................  *               increment will follow the receive buffer wrapping boundary.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BYTE MACGet()
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = RBM;
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = 0;            // Send a dummy byte to receive the register
....................                      //   contents.
....................    while(!PIR1_SSPIF);      // Wait until register is received.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... 
....................    return SSPBUF;
.................... */
....................    char c;
.................... 
....................    SPISelectEthernet();
*
1F18:  BCF    F93.2
1F1A:  BCF    F8A.2
....................    ENCSPIXfer(RBM);
1F1C:  MOVLW  3A
1F1E:  MOVLB  3
1F20:  MOVWF  xB3
1F22:  MOVLB  0
1F24:  CALL   086E
....................    c=ENCSPIXfer(0);
1F28:  MOVLB  3
1F2A:  CLRF   xB3
1F2C:  MOVLB  0
1F2E:  CALL   086E
1F32:  MOVFF  01,38D
....................    SPIUnselectEthernet();
1F36:  BCF    F93.2
1F38:  BSF    F8A.2
....................    return(c);
1F3A:  MOVLB  3
1F3C:  MOVFF  38D,01
1F40:  MOVLB  0
1F42:  RETURN 0
.................... }//end MACGet
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                ERDPT must point to the place to read from.
....................  *
....................  * Input:           *val: Pointer to storage location
....................  *               len:  Number of bytes to read from the data buffer.
....................  *
....................  * Output:          Byte(s) of data read from the data buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Burst reads several sequential bytes from the data buffer
....................  *               and places them into local memory.  With SPI burst support,
....................  *               it performs much faster than multiple MACGet() calls.
....................  *               ERDPT is incremented after each byte, following the same
....................  *               rules as MACGet().
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACGetArray(BYTE *val, WORD len)
*
116C:  MOVLB  3
116E:  CLRF   x9C
1170:  CLRF   x9B
.................... {
.................... /*
....................    int16 i;
.................... 
....................    // Start the burst operation
....................    SPISelectEthernet();
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode.
....................    i = 0;
....................    val--;
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    // Read the data
....................    while(i<len)
....................    {
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte
....................       i++;
....................       val++;
....................       while(!PIR1_SSPIF);   // Wait until byte is received.
....................       PIR1_SSPIF = 0;
....................       *val = SSPBUF;
....................    };
.................... 
....................    // Terminate the burst operation
....................    SPIUnselectEthernet();
.................... 
....................    return i;
.................... */
.................... 
....................    int16 i=0;
.................... 
....................    SPISelectEthernet();
1172:  BCF    F93.2
1174:  BCF    F8A.2
....................    ENCSPIXfer(RBM);
1176:  MOVLW  3A
1178:  MOVWF  xB3
117A:  MOVLB  0
117C:  CALL   086E
....................    while(i<len)
1180:  MOVLB  3
1182:  MOVF   x9C,W
1184:  SUBWF  x9A,W
1186:  BNC   11BC
1188:  BNZ   1190
118A:  MOVF   x99,W
118C:  SUBWF  x9B,W
118E:  BC    11BC
....................    {
....................       *val=ENCSPIXfer(0);
1190:  MOVFF  398,39E
1194:  MOVFF  397,39D
1198:  CLRF   xB3
119A:  MOVLB  0
119C:  CALL   086E
11A0:  MOVFF  39E,FEA
11A4:  MOVFF  39D,FE9
11A8:  MOVFF  01,FEF
....................       val++;
11AC:  MOVLB  3
11AE:  INCF   x97,F
11B0:  BTFSC  FD8.2
11B2:  INCF   x98,F
....................       i++;
11B4:  INCF   x9B,F
11B6:  BTFSC  FD8.2
11B8:  INCF   x9C,F
11BA:  BRA    1182
....................    }
....................    SPIUnselectEthernet();
11BC:  BCF    F93.2
11BE:  BSF    F8A.2
.................... 
....................    return(i);
11C0:  MOVFF  39B,01
11C4:  MOVFF  39C,02
11C8:  MOVLB  0
11CA:  RETURN 0
.................... }//end MACGetArray
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPut(BYTE val)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                EWRPT must point to the location to begin writing.
....................  *
....................  * Input:           Byte to write into the ENC28J60 buffer memory
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant
....................  *               (8 bits) and data to write (8 bits) over the SPI.
....................  *               EWRPT is incremented after the write.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACPut(BYTE val)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = WBM;         // Send the opcode and constant.
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = val;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
15A4:  BCF    F93.2
15A6:  BCF    F8A.2
....................    ENCSPIXfer(WBM);
15A8:  MOVLW  7A
15AA:  MOVLB  3
15AC:  MOVWF  xB3
15AE:  MOVLB  0
15B0:  CALL   086E
....................    ENCSPIXfer(val);
15B4:  MOVFF  3AC,3B3
15B8:  CALL   086E
....................    SPIUnselectEthernet();
15BC:  BCF    F93.2
15BE:  BSF    F8A.2
15C0:  RETURN 0
.................... }//end MACPut
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPutArray(BYTE *val, WORD len)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                EWRPT must point to the location to begin writing.
....................  *
....................  * Input:           *val: Pointer to source of bytes to copy.
....................  *               len:  Number of bytes to write to the data buffer.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPutArray writes several sequential bytes to the
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut()
....................  *               calls.  EWRPT is incremented by len.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACPutArray(BYTE *val, WORD len)
.................... {
.................... /*
....................    // Select the chip and send the proper opcode
....................    SPISelectEthernet();
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    // Send the data
....................    while(len)
....................    {
....................       SSPBUF = *val;      // Start sending the byte
....................       val++;            // Increment after writing to SSPBUF to increase speed
....................       len--;            // Decrement after writing to SSPBUF to increase speed
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted
....................       PIR1_SSPIF = 0;
....................    };
.................... 
....................    // Terminate the burst operation
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
15C2:  BCF    F93.2
15C4:  BCF    F8A.2
....................    ENCSPIXfer(WBM);
15C6:  MOVLW  7A
15C8:  MOVLB  3
15CA:  MOVWF  xB3
15CC:  MOVLB  0
15CE:  CALL   086E
....................    while(len--)
15D2:  MOVLB  3
15D4:  MOVFF  3B0,03
15D8:  MOVF   xAF,W
15DA:  BTFSC  FD8.2
15DC:  DECF   xB0,F
15DE:  DECF   xAF,F
15E0:  IORWF  03,W
15E2:  BZ    1600
....................    {
....................       ENCSPIXfer(*val);
15E4:  MOVFF  3AE,FEA
15E8:  MOVFF  3AD,FE9
15EC:  MOVFF  FEF,3B3
15F0:  MOVLB  0
15F2:  CALL   086E
....................       val++;
15F6:  MOVLB  3
15F8:  INCF   xAD,F
15FA:  BTFSC  FD8.2
15FC:  INCF   xAE,F
15FE:  BRA    15D4
....................    }
....................    SPIUnselectEthernet();
1600:  BCF    F93.2
1602:  BSF    F8A.2
1604:  MOVLB  0
1606:  RETURN 0
.................... }//end MACPutArray
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        static void SendSystemReset(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SendSystemReset sends the System Reset SPI command to
....................  *               the Ethernet controller.  It resets all register contents
....................  *               (except for ECOCON) and returns the device to the power
....................  *               on default state.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... static void SendSystemReset(void)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = SR;
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
08A8:  BCF    F93.2
08AA:  BCF    F8A.2
....................    ENCSPIXfer(SR);
08AC:  MOVLB  3
08AE:  SETF   xB3
08B0:  MOVLB  0
08B2:  RCALL  086E
....................    SPIUnselectEthernet();
08B4:  BCF    F93.2
08B6:  BSF    F8A.2
08B8:  GOTO   0B76 (RETURN)
.................... }//end SendSystemReset
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        REG ReadETHReg(BYTE Address)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                to read from.
....................  *
....................  * Input:           5 bit address of the ETH control register to read from.
....................  *                 The top 3 bits must be 0.
....................  *
....................  * Output:          Byte read from the Ethernet controller's ETH register.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over
....................  *               the SPI and then retrives the register contents in the
....................  *               next 8 SPI clocks.
....................  *
....................  * Note:            This routine cannot be used to access MAC/MII or PHY
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that
....................  *               purpose.
....................  *****************************************************************************/
.................... static REG ReadETHReg(BYTE Address)
.................... {
....................    char c;
.................... /*
....................    // Select the chip and send the Read Control Register opcode/address
....................    SPISelectEthernet();
....................    SSPBUF = RCR | Address;
.................... 
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted
....................    PIR1_SSPIF = 0;
....................    SSPBUF = 0;            // Send a dummy byte to receive the register
....................                      //   contents
....................    while(!PIR1_SSPIF);      // Wait until the register is received
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... 
....................    return *((REG*)&SSPBUF);
....................    */
.................... 
....................    SPISelectEthernet();
*
087E:  BCF    F93.2
0880:  BCF    F8A.2
....................    ENCSPIXfer(RCR | Address);
0882:  MOVFF  3A8,3AA
0886:  MOVFF  3A8,3B3
088A:  MOVLB  0
088C:  RCALL  086E
....................    c=ENCSPIXfer(0);
088E:  MOVLB  3
0890:  CLRF   xB3
0892:  MOVLB  0
0894:  RCALL  086E
0896:  MOVFF  01,3A9
....................    SPIUnselectEthernet();
089A:  BCF    F93.2
089C:  BSF    F8A.2
....................    return(c);
089E:  MOVLB  3
08A0:  MOVFF  3A9,01
08A4:  MOVLB  0
08A6:  RETURN 0
.................... }//end ReadETHReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        REG ReadMACReg(BYTE Address)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                to read from.
....................  *
....................  * Input:           5 bit address of the MAC or MII register to read from.
....................  *                 The top 3 bits must be 0.
....................  *
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well
....................  *               as a dummy byte over the SPI and then retrives the
....................  *               register contents in the last 8 SPI clocks.
....................  *
....................  * Note:            This routine cannot be used to access ETH or PHY
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that
....................  *               purpose.
....................  *****************************************************************************/
.................... static REG ReadMACReg(BYTE Address)
.................... {
....................    char c;
.................... /*
....................    SPISelectEthernet();
.................... 
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and
....................                      //   address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    SSPBUF = 0;            // Send a dummy byte
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted
....................    PIR1_SSPIF = 0;
.................... 
....................    SSPBUF = 0;            // Send another dummy byte to receive the register
....................                      //   contents.
....................    while(!PIR1_SSPIF);      // Wait until register is received.
....................    PIR1_SSPIF = 0;
.................... 
....................    SPIUnselectEthernet();
.................... 
....................    return *((REG*)&SSPBUF);
.................... */
....................    SPISelectEthernet();
*
0948:  BCF    F93.2
094A:  BCF    F8A.2
.................... 
....................    ENCSPIXfer(RCR | Address);
094C:  MOVFF  2FC,2FE
0950:  MOVFF  2FC,3B3
0954:  MOVLB  0
0956:  RCALL  086E
....................    ENCSPIXfer(0);
0958:  MOVLB  3
095A:  CLRF   xB3
095C:  MOVLB  0
095E:  RCALL  086E
....................    c=ENCSPIXfer(0);
0960:  MOVLB  3
0962:  CLRF   xB3
0964:  MOVLB  0
0966:  RCALL  086E
0968:  MOVFF  01,2FD
.................... 
....................    SPIUnselectEthernet();
096C:  BCF    F93.2
096E:  BSF    F8A.2
.................... 
....................    return(c);
0970:  MOVLB  2
0972:  MOVFF  2FD,01
0976:  MOVLB  0
0978:  RETURN 0
.................... }//end ReadMACReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        ReadPHYReg
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Address of the PHY register to read from.
....................  *
....................  * Output:          16 bits of data read from the PHY register.
....................  *
....................  * Side Effects:    Alters bank bits to point to Bank 2
....................  *
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in
....................  *               progress, it simply polls the MII BUSY bit wasting time.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... PHYREG ReadPHYReg(BYTE Register)
.................... {
....................    PHYREG Result;
.................... 
....................    // Set the right address and start the register read operation
....................    BankSel(MIREGADR);
*
0A0A:  MOVLW  02
0A0C:  MOVLB  3
0A0E:  MOVWF  xAC
0A10:  MOVLW  14
0A12:  MOVWF  xAB
0A14:  MOVLB  0
0A16:  RCALL  0916
....................    WriteReg(MIREGADR, Register);
0A18:  MOVLW  14
0A1A:  MOVLB  3
0A1C:  MOVWF  xAE
0A1E:  MOVFF  2F9,3AF
0A22:  MOVLB  0
0A24:  RCALL  08BC
....................    WriteReg(MICMD, MICMD_MIIRD);
0A26:  MOVLW  12
0A28:  MOVLB  3
0A2A:  MOVWF  xAE
0A2C:  MOVLW  01
0A2E:  MOVWF  xAF
0A30:  MOVLB  0
0A32:  RCALL  08BC
.................... 
....................    // Loop to wait until the PHY register has been read through the MII
....................    // This requires 10.24us
....................    BankSel(MISTAT);
0A34:  MOVLW  03
0A36:  MOVLB  3
0A38:  MOVWF  xAC
0A3A:  MOVLW  0A
0A3C:  MOVWF  xAB
0A3E:  MOVLB  0
0A40:  RCALL  0916
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY);
0A42:  MOVLW  0A
0A44:  MOVLB  2
0A46:  MOVWF  xFC
0A48:  MOVLB  0
0A4A:  RCALL  0948
0A4C:  MOVFF  01,2FC
0A50:  MOVLW  00
0A52:  MOVLB  2
0A54:  BTFSC  01.0
0A56:  MOVLW  01
0A58:  XORLW  00
0A5A:  BTFSC  FD8.2
0A5C:  BRA    0A62
0A5E:  MOVLB  0
0A60:  BRA    0A42
.................... 
....................    // Stop reading
....................    BankSel(MIREGADR);
0A62:  MOVLW  02
0A64:  MOVLB  3
0A66:  MOVWF  xAC
0A68:  MOVLW  14
0A6A:  MOVWF  xAB
0A6C:  MOVLB  0
0A6E:  RCALL  0916
....................    WriteReg(MICMD, 0x00);
0A70:  MOVLW  12
0A72:  MOVLB  3
0A74:  MOVWF  xAE
0A76:  CLRF   xAF
0A78:  MOVLB  0
0A7A:  RCALL  08BC
.................... 
....................    // Obtain results and return
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val;
0A7C:  MOVLW  18
0A7E:  MOVLB  2
0A80:  MOVWF  xFC
0A82:  MOVLB  0
0A84:  RCALL  0948
0A86:  MOVFF  01,2FA
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val;
0A8A:  MOVLW  19
0A8C:  MOVLB  2
0A8E:  MOVWF  xFC
0A90:  MOVLB  0
0A92:  RCALL  0948
0A94:  MOVFF  01,2FB
....................    return Result;
0A98:  MOVLB  2
0A9A:  MOVFF  2FA,01
0A9E:  MOVFF  2FB,02
0AA2:  MOVLB  0
0AA4:  GOTO   0ABE (RETURN)
.................... }//end ReadPHYReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void WriteReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *               to modify.
....................  *
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify.
....................  *                 The top 3 bits must be 0.
....................  *               Byte to be written into the register.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the
....................  *               SPI and then sends the data to write in the next 8 SPI
....................  *               clocks.
....................  *
....................  * Note:            This routine is almost identical to the BFCReg() and
....................  *               BFSReg() functions.  It is seperate to maximize speed.
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg()
....................  *               can write to any ETH or MAC register.  Writing to PHY
....................  *               registers must be accomplished with WritePHYReg().
....................  *****************************************************************************/
.................... static void WriteReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = WCR | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
08BC:  BCF    F93.2
08BE:  BCF    F8A.2
....................    ENCSPIXfer(WCR | Address);
08C0:  MOVLB  3
08C2:  MOVF   xAE,W
08C4:  IORLW  40
08C6:  MOVWF  xB0
08C8:  MOVWF  xB3
08CA:  MOVLB  0
08CC:  RCALL  086E
....................    ENCSPIXfer(Data);
08CE:  MOVFF  3AF,3B3
08D2:  RCALL  086E
....................    SPIUnselectEthernet();
08D4:  BCF    F93.2
08D6:  BSF    F8A.2
08D8:  RETURN 0
.................... }//end WriteReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void BFCReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                 to modify.
....................  *
....................  * Input:           5 bit address of the register to modify.  The top 3 bits
....................  *                 must be 0.
....................  *               Byte to be used with the Bit Field Clear operation.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the
....................  *               SPI and then sends the data in the next 8 SPI clocks.
....................  *
....................  * Note:            This routine is almost identical to the WriteReg() and
....................  *               BFSReg() functions.  It is separate to maximize speed.
....................  *               BFCReg() must only be used on ETH registers.
....................  *****************************************************************************/
.................... static void BFCReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = BFC | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
08DA:  BCF    F93.2
08DC:  BCF    F8A.2
....................    ENCSPIXfer(BFC | Address);
08DE:  MOVLB  3
08E0:  MOVF   xAD,W
08E2:  IORLW  A0
08E4:  MOVWF  xAF
08E6:  MOVWF  xB3
08E8:  MOVLB  0
08EA:  RCALL  086E
....................    ENCSPIXfer(Data);
08EC:  MOVFF  3AE,3B3
08F0:  RCALL  086E
....................    SPIUnselectEthernet();
08F2:  BCF    F93.2
08F4:  BSF    F8A.2
08F6:  RETURN 0
.................... }//end BFCReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void BFSReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *               to modify.
....................  *
....................  * Input:           5 bit address of the register to modify.  The top 3 bits
....................  *                 must be 0.
....................  *               Byte to be used with the Bit Field Set operation.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the
....................  *               SPI and then sends the data in the next 8 SPI clocks.
....................  *
....................  * Note:            This routine is almost identical to the WriteReg() and
....................  *               BFCReg() functions.  It is separate to maximize speed.
....................  *               BFSReg() must only be used on ETH registers.
....................  *****************************************************************************/
.................... static void BFSReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = BFS | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
08F8:  BCF    F93.2
08FA:  BCF    F8A.2
....................    ENCSPIXfer(BFS | Address);
08FC:  MOVLB  3
08FE:  MOVF   xB0,W
0900:  IORLW  80
0902:  MOVWF  xB2
0904:  MOVWF  xB3
0906:  MOVLB  0
0908:  RCALL  086E
....................    ENCSPIXfer(Data);
090A:  MOVFF  3B1,3B3
090E:  RCALL  086E
....................    SPIUnselectEthernet();
0910:  BCF    F93.2
0912:  BSF    F8A.2
0914:  RETURN 0
.................... }//end BFSReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WritePHYReg
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Address of the PHY register to write to.
....................  *               16 bits of data to write to PHY register.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Alters bank bits to point to Bank 3
....................  *
....................  * Overview:        WritePHYReg performs an MII write operation.  While in
....................  *               progress, it simply polls the MII BUSY bit wasting time.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void WritePHYReg(BYTE Register, WORD Data)
.................... {
....................    // Write the register address
....................    BankSel(MIREGADR);
*
097A:  MOVLW  02
097C:  MOVLB  3
097E:  MOVWF  xAC
0980:  MOVLW  14
0982:  MOVWF  xAB
0984:  MOVLB  0
0986:  RCALL  0916
....................    WriteReg(MIREGADR, Register);
0988:  MOVLW  14
098A:  MOVLB  3
098C:  MOVWF  xAE
098E:  MOVFF  2F9,3AF
0992:  MOVLB  0
0994:  RCALL  08BC
.................... 
....................    // Write the data
....................    // Order is important: write low byte first, high byte last
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]);
0996:  MOVLW  02
0998:  MOVLB  2
099A:  MOVWF  xFD
099C:  MOVLW  FA
099E:  MOVWF  xFC
09A0:  MOVWF  FE9
09A2:  MOVFF  2FD,FEA
09A6:  MOVFF  FEF,3AF
09AA:  MOVLW  16
09AC:  MOVLB  3
09AE:  MOVWF  xAE
09B0:  MOVLB  0
09B2:  RCALL  08BC
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]);
09B4:  MOVLW  02
09B6:  MOVLB  2
09B8:  MOVWF  xFD
09BA:  MOVLW  FA
09BC:  MOVWF  xFC
09BE:  MOVLW  01
09C0:  ADDWF  xFC,W
09C2:  MOVWF  FE9
09C4:  MOVLW  00
09C6:  ADDWFC xFD,W
09C8:  MOVWF  FEA
09CA:  MOVFF  FEF,3AF
09CE:  MOVLW  17
09D0:  MOVLB  3
09D2:  MOVWF  xAE
09D4:  MOVLB  0
09D6:  RCALL  08BC
.................... 
....................    // Wait until the PHY register has been written
....................    BankSel(MISTAT);
09D8:  MOVLW  03
09DA:  MOVLB  3
09DC:  MOVWF  xAC
09DE:  MOVLW  0A
09E0:  MOVWF  xAB
09E2:  MOVLB  0
09E4:  RCALL  0916
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY);
09E6:  MOVLW  0A
09E8:  MOVLB  2
09EA:  MOVWF  xFC
09EC:  MOVLB  0
09EE:  RCALL  0948
09F0:  MOVFF  01,2FC
09F4:  MOVLW  00
09F6:  MOVLB  2
09F8:  BTFSC  01.0
09FA:  MOVLW  01
09FC:  XORLW  00
09FE:  BTFSC  FD8.2
0A00:  BRA    0A06
0A02:  MOVLB  0
0A04:  BRA    09E6
0A06:  MOVLB  0
0A08:  RETURN 0
.................... }//end WritePHYReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BankSel
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Register address with the high byte containing the 2 bank
....................  *                 select 2 bits.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BankSel takes the high byte of a register address and
....................  *               changes the bank select bits in ETHCON1 to match.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... static void BankSel(WORD Register)
.................... {
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0);
*
0916:  MOVLW  1F
0918:  MOVLB  3
091A:  MOVWF  xAD
091C:  MOVLW  03
091E:  MOVWF  xAE
0920:  MOVLB  0
0922:  RCALL  08DA
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]);
0924:  MOVLW  03
0926:  MOVLB  3
0928:  MOVWF  xAE
092A:  MOVLW  AB
092C:  MOVWF  xAD
092E:  MOVLW  01
0930:  ADDWF  xAD,W
0932:  MOVWF  FE9
0934:  MOVLW  00
0936:  ADDWFC xAE,W
0938:  MOVWF  FEA
093A:  MOVFF  FEF,3B1
093E:  MOVLW  1F
0940:  MOVWF  xB0
0942:  MOVLB  0
0944:  RCALL  08F8
0946:  RETURN 0
.................... }//end BankSel
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        static BOOL TestMemory(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if the memory tests have passed
....................  *               FALSE if the BIST has detected a hardware fault
....................  *
....................  * Side Effects:    Alters the state of numerous control registers and all
....................  *               RAM bytes.
....................  *
....................  * Overview:        The internal BIST and DMA modules are used to fill the
....................  *               entire dual port memory and calculate a checksum of the
....................  *               data stored within.  Address and Random fill modes are
....................  *               used.
....................  *
....................  * Note:            For the Random Fill mode, the random number generator is
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer
....................  *               is running, additional confidence that the memory is
....................  *               working can be obtained by calling TestMemory multiple
....................  *               times.
....................  *****************************************************************************/
.................... #if defined(MAC_POWER_ON_TEST)
.................... static BOOL TestMemory(void)
.................... {
....................    #define RANDOM_FILL      0b0000
....................    #define ADDRESS_FILL   0b0100
....................    #define PATTERN_SHIFT   0b1000
.................... 
....................    WORD_VAL DMAChecksum, BISTChecksum;
.................... 
.................... 
....................    // Select Bank 0 and disable anything that could have been in progress
....................    WriteReg(ECON1, 0x00);
.................... 
....................    // Set up necessary pointers for the DMA to calculate over the entire
....................    // memory
....................    WriteReg(EDMASTL, 0x00);
....................    WriteReg(EDMASTH, 0x00);
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u));
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u));
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u));
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u));
.................... 
....................    // Enable Test Mode and do an Address Fill
....................    BankSel(EBSTCON);
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME |
....................                    EBSTCON_BISTST |
....................                    ADDRESS_FILL);
.................... 
.................... 
....................    // Wait for the BIST to complete and disable test mode before
....................    // starting any DMA operations.
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST);
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
.................... 
....................    // Begin reading the memory and calculating a checksum over it
....................    // Block until the checksum is generated
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    BankSel(EDMACSL);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Obtain the resulting DMA checksum and the expected BIST checksum
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val;
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val;
....................    BankSel(EBSTCSL);
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val;
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val;
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
....................    // Compare the results
....................    // 0xF807 should always be generated in Address fill mode
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) )
....................       return FALSE;
.................... 
....................    // Seed the random number generator and begin another Random Fill test
....................    // with the DMA and BIST memory access ports swapped.
.................... #ifdef __C30__
....................    WriteReg((BYTE)EBSTSD, TMR1);
.................... #else
....................    WriteReg((BYTE)EBSTSD, TMR0L);
.................... #endif
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME |
....................                  EBSTCON_PSEL |
....................                  EBSTCON_BISTST |
....................                  RANDOM_FILL);
.................... 
.................... 
....................    // Wait for the BIST to complete and disable test mode since
....................    // we won't be needing it anymore
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST);
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
.................... 
....................    // Begin reading the memory and calculating a checksum over it
....................    // Block until the checksum is generated
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    BankSel(EDMACSL);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Obtain the resulting DMA checksum and the expected BIST checksum
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val;
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val;
....................    BankSel(EBSTCSL);
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val;
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val;
.................... 
....................    return (DMAChecksum.Val == BISTChecksum.Val);
.................... }//end TestMemory
.................... #endif
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Member of DUPLEX enum:
....................  *                  FULL: Set full duplex mode
....................  *                  HALF: Set half duplex mode
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in
....................  *                         PHYCON.  This is controlled by LEDB on RESET.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Changes bank bits to Bank 2.
....................  *
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex
....................  *               operation, sets PHY up for full duplex operation, and
....................  *               reenables RX logic.  The back-to-back inter-packet gap
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap.
....................  *
....................  * Note:            If a packet is being transmitted or received while this
....................  *               function is called, it will be aborted.
....................  *****************************************************************************/
.................... void MACSetDuplex(DUPLEX DuplexState)
.................... {
....................    REG Register;
....................    PHYREG PhyReg;
.................... 
....................    // Disable receive logic and abort any packets currently being transmitted
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN);
*
0AA8:  MOVLW  1F
0AAA:  MOVLB  3
0AAC:  MOVWF  xAD
0AAE:  MOVLW  0C
0AB0:  MOVWF  xAE
0AB2:  MOVLB  0
0AB4:  RCALL  08DA
.................... 
....................    // Set the PHY to the proper duplex mode
....................    PhyReg = ReadPHYReg(PHCON1);
0AB6:  MOVLB  2
0AB8:  CLRF   xF9
0ABA:  MOVLB  0
0ABC:  BRA    0A0A
0ABE:  MOVFF  02,2F8
0AC2:  MOVFF  01,2F7
....................    if(DuplexState == USE_PHY)
0AC6:  MOVLB  2
0AC8:  MOVF   xF5,W
0ACA:  SUBLW  02
0ACC:  BNZ   0AD6
....................    {
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD;
0ACE:  CLRF   xF5
0AD0:  BTFSC  xF8.0
0AD2:  INCF   xF5,F
....................    }
0AD4:  BRA    0AEC
....................    else
....................    {
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState;
0AD6:  BCF    xF8.0
0AD8:  BTFSC  xF5.0
0ADA:  BSF    xF8.0
....................       WritePHYReg(PHCON1, PhyReg.Val);
0ADC:  CLRF   xF9
0ADE:  MOVFF  2F8,2FB
0AE2:  MOVFF  2F7,2FA
0AE6:  MOVLB  0
0AE8:  RCALL  097A
0AEA:  MOVLB  2
....................    }
.................... 
....................    // Set the MAC to the proper duplex mode
....................    BankSel(MACON3);
0AEC:  MOVLW  02
0AEE:  MOVLB  3
0AF0:  MOVWF  xAC
0AF2:  MOVWF  xAB
0AF4:  MOVLB  0
0AF6:  RCALL  0916
....................    Register = ReadMACReg(MACON3);
0AF8:  MOVLW  02
0AFA:  MOVLB  2
0AFC:  MOVWF  xFC
0AFE:  MOVLB  0
0B00:  RCALL  0948
0B02:  MOVFF  01,2F6
....................    Register.MACON3bits.FULDPX = DuplexState;
0B06:  MOVLB  2
0B08:  BCF    xF6.0
0B0A:  BTFSC  xF5.0
0B0C:  BSF    xF6.0
....................    WriteReg(MACON3, Register.Val);
0B0E:  MOVLW  02
0B10:  MOVLB  3
0B12:  MOVWF  xAE
0B14:  MOVFF  2F6,3AF
0B18:  MOVLB  0
0B1A:  RCALL  08BC
.................... 
....................    // Set the back-to-back inter-packet gap time to IEEE specified
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex
....................    // state, so it must be updated in this function.
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12);
0B1C:  MOVLB  2
0B1E:  MOVF   xF5,F
0B20:  BZ    0B26
0B22:  MOVLW  15
0B24:  BRA    0B28
0B26:  MOVLW  12
0B28:  MOVWF  xF9
0B2A:  MOVLW  04
0B2C:  MOVLB  3
0B2E:  MOVWF  xAE
0B30:  MOVFF  2F9,3AF
0B34:  MOVLB  0
0B36:  RCALL  08BC
.................... 
....................    // Reenable receive logic
....................    BFSReg(ECON1, ECON1_RXEN);
0B38:  MOVLW  1F
0B3A:  MOVLB  3
0B3C:  MOVWF  xB0
0B3E:  MOVLW  04
0B40:  MOVWF  xB1
0B42:  MOVLB  0
0B44:  RCALL  08F8
0B46:  GOTO   0D06 (RETURN)
.................... }//end MACSetDuplex
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPowerDown(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In
....................  *               sleep mode, no packets can be transmitted or received.
....................  *               All MAC and PHY registers should not be accessed.
....................  *
....................  * Note:            If a packet is being transmitted while this function is
....................  *                called, this function will block until it is it complete.
....................  *               If anything is being received, it will be completed.
....................  *****************************************************************************/
.................... void MACPowerDown(void)
.................... {
....................    // Disable packet reception
....................    BFCReg(ECON1, ECON1_RXEN);
.................... 
....................    // Make sure any last packet which was in-progress when RXEN was cleared
....................    // is completed
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY);
.................... 
....................    // If a packet is being transmitted, wait for it to finish
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS);
.................... 
....................    // Enter sleep mode
....................    BFSReg(ECON2, ECON2_PWRSV);
.................... }//end MACPowerDown
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPowerUp(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation
....................  *               after a previous call to MACPowerDown().  Calling this
....................  *               function when already powered up will have no effect.
....................  *
....................  * Note:            The first packet transmitted may get lost at the RX end if
....................  *               you don't wait for the link to go up first.  MACIsLinked()
....................  *               can be called to determine if a link is established.
....................  *****************************************************************************/
.................... void MACPowerUp(void)
.................... {
....................    // Leave power down mode
....................    BFCReg(ECON2, ECON2_PWRSV);
.................... 
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This
....................    // delay is required for the PHY module to return to an operational state.
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY);
.................... 
....................    // Enable packet reception
....................    BFSReg(ECON1, ECON1_RXEN);
.................... }//end MACPowerUp
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void SetCLKOUT(BYTE NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low)
....................  *                        0x01: Divide by 1 (25 MHz)
....................  *                        0x02: Divide by 2 (12.5 MHz)
....................  *                        0x03: Divide by 3 (8.333333 MHz)
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default)
....................  *                        0x05: Divide by 8 (3.125 MHz)
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the ECOCON register.
....................  *               The CLKOUT pin will beginning outputting the new frequency
....................  *               immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... void SetCLKOUT(BYTE NewConfig)
.................... {
....................    BankSel(ECOCON);
....................    WriteReg(ECOCON, NewConfig);
.................... }//end SetCLKOUT
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BYTE GetCLKOUT(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low)
....................  *                     0x01: Divide by 1 (25 MHz)
....................  *                     0x02: Divide by 2 (12.5 MHz)
....................  *                     0x03: Divide by 3 (8.333333 MHz)
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default)
....................  *                     0x05: Divide by 8 (3.125 MHz)
....................  *                     0x06: Reserved
....................  *                     0x07: Reserved
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the ECOCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BYTE GetCLKOUT(void)
.................... {
....................    BankSel(ECOCON);
....................    return ReadETHReg(ECOCON).Val;
.................... }//end GetCLKOUT
.................... 
....................    #elif STACK_USE_MCPINC
....................     #include "tcpip/eth97j60.c"
....................    #else
....................     #include "tcpip/rtl8019AS.c"
....................    #endif
.................... #endif
.................... 
.................... #if STACK_USE_PPP
....................    #include "tcpip/modem.c"
....................    #include "tcpip/ppp.c"
....................    #include "tcpip/pppwrap.c"
.................... #endif
.................... 
.................... #if STACK_USE_SLIP
....................    #include "tcpip/slip.c"
.................... #ENDIF
.................... 
.................... #if STACK_USE_UDP
....................    #include "tcpip/udp.h"
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    #include "tcpip/dhcp.h"
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    #include "tcpip/smtp.h"
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    #include "tcpip/http.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///                                                                     ///
.................... ///                              HTTP.H                                 ///
.................... ///                                                                     ///
.................... /// Simple webserver for the Microchip TCP/IP stack.                    ///
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       ///
.................... ///                                                                     ///
.................... /// See HTTP.C for documenation                                         ///
.................... ///                                                                     ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef HTTP_USE_CHUNKS
.................... #define HTTP_USE_CHUNKS   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_CONTENT_TYPE
.................... #define HTTP_USE_CONTENT_TYPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_PORT
.................... #define HTTP_PORT             80
.................... #endif
.................... 
.................... #ifndef HTTP_NUM_SOCKETS
.................... #define HTTP_NUM_SOCKETS      1
.................... #endif
.................... 
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE
.................... #define HTTP_GET_PARAM_MAX_SIZE  254
.................... #endif
.................... 
.................... void HTTP_Init(void);
.................... void HTTP_Task(void);
.................... 
.................... //**** CALLBACKS START ******///
.................... 
.................... /// the following three functions are callbacks and
.................... /// must be written in your main application!!!  see the documentation above
.................... /// for more help.
.................... 
.................... #if HTTP_USE_CONTENT_TYPE
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... #else
....................  int32 http_get_page(char *file_str);
.................... #endif
.................... 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... void http_exec_cgi(int32 file, char *key, char *val);
.................... 
.................... //**** CALLBACKS END ******///
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP2
....................    #include "tcpip/http2.h"
.................... #endif
.................... 
.................... #if STACK_USE_DNS
....................    #include "tcpip/dns.h"
.................... #endif
.................... 
.................... #if STACK_USE_SNMP
....................    #include "tcpip/snmp.h"
.................... #endif
.................... 
.................... #if STACK_USE_MPFS
....................    #include "tcpip/mpfs.h"
.................... #endif
.................... 
.................... #include "tcpip/ip.c"
.................... /*********************************************************************
....................  *
....................  *                  PIC IP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.C
....................  * Dependencies:    string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                  IP.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail)
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // This is left shifted by 4.  Actual value is 0x04.
.................... #define IPv4                (0x40u)
.................... #define IP_VERSION          IPv4
.................... 
.................... #define debug_ip
.................... //#define debug_ip  debug_printf
.................... 
.................... // IHL (Internet Header Length) is # of DWORDs in a header.
.................... // Since, we do not support options, our IP header length will be
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5.
.................... #define IP_IHL              (0x05)
.................... 
.................... #define IP_SERVICE_NW_CTRL  (0x07)
.................... #define IP_SERVICE_IN_CTRL  (0x06)
.................... #define IP_SERVICE_ECP      (0x05)
.................... #define IP_SERVICE_OVR      (0x04)
.................... #define IP_SERVICE_FLASH    (0x03)
.................... #define IP_SERVICE_IMM      (0x02)
.................... #define IP_SERVICE_PRIOR    (0x01)
.................... #define IP_SERVICE_ROUTINE  (0x00)
.................... 
.................... #define IP_SERVICE_N_DELAY  (0x00)
.................... #define IP_SERCICE_L_DELAY  (0x08)
.................... #define IP_SERVICE_N_THRPT  (0x00)
.................... #define IP_SERVICE_H_THRPT  (0x10)
.................... #define IP_SERVICE_N_RELIB  (0x00)
.................... #define IP_SERVICE_H_RELIB  (0x20)
.................... 
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY)
.................... 
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds
.................... 
.................... 
.................... 
.................... 
.................... static WORD _Identifier = 0;
.................... static BYTE IPHeaderLen;
.................... 
.................... static void SwapIPHeader(IP_HEADER* h);
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len)
.................... {
....................     WORD_VAL    CalcChecksum;
....................     IP_HEADER   header;
.................... 
.................... #if !defined(MCHP_MAC)
....................     WORD_VAL    ReceivedChecksum;
....................     WORD        checksums[2];
....................     BYTE        optionsLen;
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791.
....................     BYTE        options[MAX_OPTIONS_LEN];
.................... #endif
.................... 
....................     // Read IP header.
....................     MACGetArray((BYTE*)&header, sizeof(header));
*
1D46:  MOVLW  03
1D48:  MOVLB  3
1D4A:  MOVWF  x19
1D4C:  MOVLW  04
1D4E:  MOVWF  x18
1D50:  MOVFF  319,398
1D54:  MOVWF  x97
1D56:  CLRF   x9A
1D58:  MOVLW  14
1D5A:  MOVWF  x99
1D5C:  MOVLB  0
1D5E:  CALL   116C
.................... 
....................     // Make sure that this is an IPv4 packet.
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION )
1D62:  MOVLB  3
1D64:  MOVF   x04,W
1D66:  ANDLW  F0
1D68:  SUBLW  40
1D6A:  BZ    1D72
....................     	return FALSE;
1D6C:  MOVLW  00
1D6E:  MOVWF  01
1D70:  BRA    1E24
.................... 
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2;
1D72:  MOVF   x04,W
1D74:  ANDLW  0F
1D76:  MOVWF  00
1D78:  RLCF   00,W
1D7A:  MOVWF  5E
1D7C:  RLCF   5E,F
1D7E:  MOVLW  FC
1D80:  ANDWF  5E,F
.................... 
.................... #if defined(MCHP_MAC)
.................... 	// Validate the IP header.  If it is correct, the checksum
.................... 	// will come out to 0x0000 (because the header contains a
.................... 	// precomputed checksum).  A corrupt header will have a
.................... 	// nonzero checksum.
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen);
1D82:  CLRF   x54
1D84:  CLRF   x53
1D86:  CLRF   x56
1D88:  MOVFF  5E,355
1D8C:  MOVLB  0
1D8E:  RCALL  1AFA
1D90:  MOVFF  02,303
1D94:  MOVFF  01,302
.................... 
.................... 	// Seek to the end of the IP header
.................... 	MACSetRxBuffer(IPHeaderLen);
1D98:  MOVLB  3
1D9A:  CLRF   x2C
1D9C:  MOVFF  5E,32B
1DA0:  MOVLB  0
1DA2:  RCALL  1C02
.................... 
....................     if(CalcChecksum.Val)
1DA4:  MOVLB  3
1DA6:  MOVF   x02,W
1DA8:  IORWF  x03,W
1DAA:  BZ    1DB2
.................... #else
.................... 
....................     // Calculate options length in this header, if there is any.
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual
....................     // length is 4 times IHL.
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header);
.................... 
....................     // If there is any option(s), read it so that we can include them
....................     // in checksum calculation.
....................     if ( optionsLen > MAX_OPTIONS_LEN )
....................         return FALSE;
.................... 
....................     if ( optionsLen > 0 )
....................         MACGetArray(options, optionsLen);
.................... 
....................     // Save header checksum; clear it and recalculate it ourselves.
....................     ReceivedChecksum.Val = header.HeaderChecksum;
....................     header.HeaderChecksum = 0;
.................... 
....................     // Calculate checksum of header including options bytes.
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header));
.................... 
....................     // Calculate Options checksum too, if they are present.
....................     if ( optionsLen > 0 )
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen);
....................     else
....................         checksums[1] = 0;
.................... 
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums,
....................                                             2 * sizeof(WORD));
.................... 
....................     // Make sure that checksum is correct
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val )
.................... #endif
....................     {
....................         // Bad packet. The function caller will be notified by means of the FALSE
....................         // return value and it should discard the packet.
....................         return FALSE;
1DAC:  MOVLW  00
1DAE:  MOVWF  01
1DB0:  BRA    1E24
....................     }
.................... 
....................     // Network to host conversion.
....................     SwapIPHeader(&header);
1DB2:  MOVLW  03
1DB4:  MOVWF  xA3
1DB6:  MOVLW  04
1DB8:  MOVWF  xA2
1DBA:  MOVLB  0
1DBC:  RCALL  1C7E
.................... 
....................     // If caller is intrested, return destination IP address
....................     // as seen in this IP header.
....................     if ( localIP )
1DBE:  MOVLB  2
1DC0:  MOVF   xFA,W
1DC2:  IORWF  xFB,W
1DC4:  BZ    1DDE
....................         localIP->Val    = header.DestAddress.Val;
1DC6:  MOVFF  2FA,FE9
1DCA:  MOVFF  2FB,FEA
1DCE:  MOVFF  314,FEF
1DD2:  MOVFF  315,FEC
1DD6:  MOVFF  316,FEC
1DDA:  MOVFF  317,FEC
.................... 
....................     remote->IPAddr.Val  = header.SourceAddress.Val;
1DDE:  MOVLW  06
1DE0:  ADDWF  xFC,W
1DE2:  MOVWF  FE9
1DE4:  MOVLW  00
1DE6:  ADDWFC xFD,W
1DE8:  MOVWF  FEA
1DEA:  MOVFF  310,FEF
1DEE:  MOVFF  311,FEC
1DF2:  MOVFF  312,FEC
1DF6:  MOVFF  313,FEC
....................     *protocol           = header.Protocol;
1DFA:  MOVFF  2FF,FEA
1DFE:  MOVFF  2FE,FE9
1E02:  MOVFF  30D,FEF
.................... #if defined(MCHP_MAC)
....................     *len 				= header.TotalLength - IPHeaderLen;
1E06:  MOVFF  301,FEA
1E0A:  MOVLB  3
1E0C:  MOVFF  300,FE9
1E10:  MOVF   5E,W
1E12:  SUBWF  x06,W
1E14:  MOVWF  00
1E16:  MOVLW  00
1E18:  SUBWFB x07,W
1E1A:  MOVFF  00,FEF
1E1E:  MOVWF  FEC
.................... #else
....................     *len                = header.TotalLength - optionsLen -
....................                             sizeof(header);
.................... #endif
.................... 
....................     return TRUE;
1E20:  MOVLW  01
1E22:  MOVWF  01
1E24:  MOVLB  0
1E26:  GOTO   6CCC (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function: WORD IPPutHeader(NODE_INFO *remote,
....................  *           				  BYTE protocol,
....................  *                			  WORD len)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           *remote     - Destination node address
....................  *                  protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          (WORD)0
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  ********************************************************************/
.................... WORD IPPutHeader(NODE_INFO *remote,
....................                 BYTE protocol,
....................                 WORD    len)
.................... {
....................     IP_HEADER   header;
.................... 
....................     IPHeaderLen = sizeof(IP_HEADER);
*
27B0:  MOVLW  14
27B2:  MOVWF  5E
.................... 
....................     header.VersionIHL       = IP_VERSION | IP_IHL;
27B4:  MOVLW  45
27B6:  MOVLB  3
27B8:  MOVWF  x8E
....................     header.TypeOfService    = IP_SERVICE;
27BA:  CLRF   x8F
....................     header.TotalLength      = sizeof(header) + len;
27BC:  MOVLW  14
27BE:  ADDWF  x8C,W
27C0:  MOVWF  x90
27C2:  MOVLW  00
27C4:  ADDWFC x8D,W
27C6:  MOVWF  x91
....................     header.Identification   = ++_Identifier;
27C8:  INCF   5C,F
27CA:  BTFSC  FD8.2
27CC:  INCF   5D,F
27CE:  MOVFF  5D,393
27D2:  MOVFF  5C,392
....................     header.FragmentInfo     = 0;
27D6:  CLRF   x95
27D8:  CLRF   x94
....................     header.TimeToLive       = MY_IP_TTL;
27DA:  MOVLW  64
27DC:  MOVWF  x96
....................     header.Protocol         = protocol;
27DE:  MOVFF  38B,397
....................     header.HeaderChecksum   = 0;
27E2:  CLRF   x99
27E4:  CLRF   x98
.................... 	header.SourceAddress = AppConfig.MyIPAddr;
27E6:  MOVFF  20,39D
27EA:  MOVFF  1F,39C
27EE:  MOVFF  1E,39B
27F2:  MOVFF  1D,39A
.................... 
....................     header.DestAddress.Val = remote->IPAddr.Val;
27F6:  MOVLW  06
27F8:  ADDWF  x89,W
27FA:  MOVWF  FE9
27FC:  MOVLW  00
27FE:  ADDWFC x8A,W
2800:  MOVWF  FEA
2802:  MOVFF  FEF,39E
2806:  MOVFF  FEC,39F
280A:  MOVFF  FEC,3A0
280E:  MOVFF  FEC,3A1
.................... 
....................     SwapIPHeader(&header);
2812:  MOVLW  03
2814:  MOVWF  xA3
2816:  MOVLW  8E
2818:  MOVWF  xA2
281A:  MOVLB  0
281C:  CALL   1C7E
.................... 
.................... #if !defined(MCHP_MAC)
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header,
....................                                                 sizeof(header));
.................... #endif
.................... 
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len));
2820:  MOVLB  3
2822:  MOVFF  389,01
2826:  MOVFF  38A,03
282A:  MOVFF  01,3A2
282E:  MOVFF  03,3A3
2832:  MOVLW  14
2834:  ADDWF  x8C,W
2836:  MOVWF  xA4
2838:  MOVLW  00
283A:  ADDWFC x8D,W
283C:  MOVWF  xA5
283E:  MOVFF  03,3A7
2842:  MOVFF  01,3A6
2846:  CLRF   xA8
2848:  MOVWF  xAA
284A:  MOVFF  3A4,3A9
284E:  MOVLB  0
2850:  CALL   1608
....................     MACPutArray((BYTE*)&header, sizeof(header));
2854:  MOVLW  03
2856:  MOVLB  3
2858:  MOVWF  xA3
285A:  MOVLW  8E
285C:  MOVWF  xA2
285E:  MOVFF  3A3,3AE
2862:  MOVWF  xAD
2864:  CLRF   xB0
2866:  MOVLW  14
2868:  MOVWF  xAF
286A:  MOVLB  0
286C:  CALL   15C2
.................... 
.................... #if defined(MCHP_MAC)
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header));
2870:  MOVLB  3
2872:  CLRF   xA3
2874:  CLRF   xA2
2876:  CLRF   xA5
2878:  MOVLW  14
287A:  MOVWF  xA4
287C:  MOVLB  0
287E:  RCALL  26D8
2880:  MOVFF  02,399
2884:  MOVFF  01,398
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member
2888:  MOVFF  06,3A2
288C:  MOVLB  3
288E:  CLRF   xA4
2890:  MOVLW  0A
2892:  MOVWF  xA3
2894:  MOVLB  0
2896:  CALL   1506
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2);
289A:  MOVLW  03
289C:  MOVLB  3
289E:  MOVWF  xA3
28A0:  MOVLW  98
28A2:  MOVWF  xA2
28A4:  MOVFF  3A3,3AE
28A8:  MOVWF  xAD
28AA:  CLRF   xB0
28AC:  MOVLW  02
28AE:  MOVWF  xAF
28B0:  MOVLB  0
28B2:  CALL   15C2
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet
28B6:  MOVFF  06,3A2
28BA:  MOVLB  3
28BC:  CLRF   xA4
28BE:  MOVLW  14
28C0:  MOVWF  xA3
28C2:  MOVLB  0
28C4:  CALL   1506
.................... #endif
.................... 
....................     return 0x0;
28C8:  MOVLW  00
28CA:  MOVWF  01
28CC:  MOVWF  02
28CE:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset)
.................... {
.................... 	MACSetRxBuffer(Offset+IPHeaderLen);
*
209C:  MOVF   5E,W
209E:  MOVLB  3
20A0:  ADDWF  x27,W
20A2:  MOVWF  x29
20A4:  MOVLW  00
20A6:  ADDWFC x28,W
20A8:  MOVWF  x2A
20AA:  MOVWF  x2C
20AC:  MOVFF  329,32B
20B0:  MOVLB  0
20B2:  RCALL  1C02
20B4:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... static void SwapIPHeader(IP_HEADER* h)
.................... {
....................     h->TotalLength      = swaps(h->TotalLength);
*
1C7E:  MOVLW  02
1C80:  MOVLB  3
1C82:  ADDWF  xA2,W
1C84:  MOVWF  01
1C86:  MOVLW  00
1C88:  ADDWFC xA3,W
1C8A:  MOVWF  03
1C8C:  MOVFF  01,3A4
1C90:  MOVWF  xA5
1C92:  MOVLW  02
1C94:  ADDWF  xA2,W
1C96:  MOVWF  FE9
1C98:  MOVLW  00
1C9A:  ADDWFC xA3,W
1C9C:  MOVWF  FEA
1C9E:  MOVFF  FEC,3A9
1CA2:  MOVF   FED,F
1CA4:  MOVFF  FEF,3A8
1CA8:  MOVLB  0
1CAA:  CALL   11CC
1CAE:  MOVFF  3A5,FEA
1CB2:  MOVFF  3A4,FE9
1CB6:  MOVFF  02,FEC
1CBA:  MOVF   FED,F
1CBC:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification);
1CC0:  MOVLW  04
1CC2:  MOVLB  3
1CC4:  ADDWF  xA2,W
1CC6:  MOVWF  01
1CC8:  MOVLW  00
1CCA:  ADDWFC xA3,W
1CCC:  MOVWF  03
1CCE:  MOVFF  01,3A4
1CD2:  MOVWF  xA5
1CD4:  MOVLW  04
1CD6:  ADDWF  xA2,W
1CD8:  MOVWF  FE9
1CDA:  MOVLW  00
1CDC:  ADDWFC xA3,W
1CDE:  MOVWF  FEA
1CE0:  MOVFF  FEC,3A9
1CE4:  MOVF   FED,F
1CE6:  MOVFF  FEF,3A8
1CEA:  MOVLB  0
1CEC:  CALL   11CC
1CF0:  MOVFF  3A5,FEA
1CF4:  MOVFF  3A4,FE9
1CF8:  MOVFF  02,FEC
1CFC:  MOVF   FED,F
1CFE:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum);
1D02:  MOVLW  0A
1D04:  MOVLB  3
1D06:  ADDWF  xA2,W
1D08:  MOVWF  01
1D0A:  MOVLW  00
1D0C:  ADDWFC xA3,W
1D0E:  MOVWF  03
1D10:  MOVFF  01,3A4
1D14:  MOVWF  xA5
1D16:  MOVLW  0A
1D18:  ADDWF  xA2,W
1D1A:  MOVWF  FE9
1D1C:  MOVLW  00
1D1E:  ADDWFC xA3,W
1D20:  MOVWF  FEA
1D22:  MOVFF  FEC,3A9
1D26:  MOVF   FED,F
1D28:  MOVFF  FEF,3A8
1D2C:  MOVLB  0
1D2E:  CALL   11CC
1D32:  MOVFF  3A5,FEA
1D36:  MOVFF  3A4,FE9
1D3A:  MOVFF  02,FEC
1D3E:  MOVF   FED,F
1D40:  MOVFF  01,FEF
1D44:  RETURN 0
.................... }
.................... 
.................... 
.................... #if STACK_USE_TCP
....................    #include "tcpip/tcp.c"
.................... /*********************************************************************
....................  *
....................  *                  TCP Module for Microchip TCP/IP Stack
....................  *               Based on RFC 793
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
.................... * FileName:        TCP.C
.................... * Dependencies:    string.h
.................... *                  StackTsk.h
.................... *                  Helpers.h
.................... *                  IP.h
.................... *                  MAC.h
.................... *                  ARP.h
.................... *                  Tick.h
.................... *                  TCP.h
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F
.................... * Complier:        CCS PCH
.................... * Company:         Microchip Technology, Inc.
.................... *
.................... * Software License Agreement
.................... *
.................... * This software is owned by Microchip Technology Inc. ("Microchip")
.................... * and is supplied to you for use exclusively as described in the
.................... * associated software agreement.  This software is protected by
.................... * software and other intellectual property laws.  Any use in
.................... * violation of the software license may subject the user to criminal
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip
.................... * Technology Inc.  All rights reserved.
.................... *
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special,
.................... * incidental, or consequential damages.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug.
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above)
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode.
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case)
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess()
....................  *                              to include localIP as third param.
....................  *                              This was done to allow this function
....................  *                              to calculate checksum correctly.
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix.
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected
....................  *                         discard problem identified by Richard
....................  *                         Shelquist.
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug
....................  *                        when using a Microchip Ethernet controller)
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable()
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check
....................  *                        reported by DouglasPunch on Microchip Forum.
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX
....................  *                        Buffers to be obtained but not
....................  *                        released when many web requests were
....................  *                        received concurrently.
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tcp.h"
.................... /*********************************************************************
....................  *
....................  *                  TCP Module Defs for Microchip TCP/IP Stack
....................  *
....................  *********************************************************************
....................  * FileName:        TCP.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F
....................  * Complier:        CCS PCH
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype.
....................  *                              See TCP.c for more information.
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef TCP_H
.................... #define TCP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef BYTE TCP_SOCKET;
.................... typedef WORD TCP_PORT;
.................... 
.................... #ifndef TCP_NO_WAIT_FOR_ACK
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE
.................... #endif
.................... 
.................... /*
....................  * Maximum number of times a connection be retried before
....................  * closing it down.
....................  */
.................... #define MAX_RETRY_COUNTS    (3)
.................... 
.................... #define INVALID_SOCKET      (0xfe)
.................... #define UNKNOWN_SOCKET      (0xff)
.................... 
.................... #define REMOTE_HOST(s)      (TCB[s].remote)
.................... 
.................... /*
....................  * TCP States as defined by rfc793
....................  */
.................... typedef enum _TCP_STATE
.................... {
....................     TCP_LISTEN = 0,
....................     TCP_SYN_SENT,
....................     TCP_SYN_RECEIVED,
....................     TCP_ESTABLISHED,
....................     TCP_FIN_WAIT_1,
....................     TCP_FIN_WAIT_2,
....................     TCP_CLOSING,
....................     TCP_TIME_WAIT,
.................... 	TCP_CLOSE_WAIT,
....................     TCP_LAST_ACK,
....................     TCP_CLOSED,
.................... } TCP_STATE;
.................... 
.................... /*
....................  * Socket info.
....................  * Union is used to create anonymous structure members.
....................  */
.................... typedef struct _SOCKET_INFO
.................... {
....................     TCP_STATE smState;
.................... 
....................     NODE_INFO remote;
....................     TCP_PORT localPort;
....................     TCP_PORT remotePort;
.................... 
....................     BUFFER TxBuffer;
....................     WORD TxCount;
....................     WORD RxCount;
.................... 	WORD RemoteWindow;
.................... 	
....................     DWORD SND_SEQ;
....................     DWORD SND_ACK;
.................... 
....................     BYTE RetryCount;
....................     TICKTYPE startTick;
....................     TICKTYPE TimeOut;
.................... 
....................     struct
....................     {
....................         int1 bServer        : 1;
....................         int1 bIsPutReady    : 1;
....................         int1 bFirstRead     : 1;
....................         int1 bIsGetReady    : 1;
....................         int1 bIsTxInProgress : 1;
....................         int1 bACKValid : 1;
....................     } Flags;
.................... 
.................... } SOCKET_INFO;
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TCP is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initialize all socket info.
....................  *
....................  * Note:            This function is called only one during lifetime
....................  *                  of the application.
....................  ********************************************************************/
.................... void        TCPInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           port    - A TCP port to be opened.
....................  *
....................  * Output:          Given port is opened and returned on success
....................  *                  INVALID_SOCKET if no more sockets left.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TCP_SOCKET  TCPListen(TCP_PORT port);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote,
....................  *                                      TCP_PORT remotePort)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           remote      - Remote node address info
....................  *                  remotePort  - remote port to be connected.
....................  *
....................  * Output:          A new socket is created, connection request is
....................  *                  sent and socket handle is returned.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket to be checked for connection.
....................  *
....................  * Output:          TRUE    if given socket is connected
....................  *                  FALSE   if given socket is not connected.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            A socket is said to be connected if it is not
....................  *                  in LISTEN and CLOSED mode.  Socket may be in
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket
....................  *                  data.
....................  ********************************************************************/
.................... BOOL        TCPIsConnected(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPDisconnect(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsPutReady(s) == TRUE
....................  *
....................  * Input:           s       - Socket to be disconnected.
....................  *
....................  * Output:          A disconnect request is sent for given socket.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void        TCPDisconnect(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' is free to transmit
....................  *                  FALSE if socket 's' is not free to transmit.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Each socket maintains only transmit buffer.
....................  *                  Hence until a data packet is acknowledeged by
....................  *                  remote node, socket will not be ready for
....................  *                  next transmission.
....................  *                  All control transmission such as Connect,
....................  *                  Disconnect do not consume/reserve any transmit
....................  *                  buffer.
....................  ********************************************************************/
.................... BOOL        TCPIsPutReady(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s       - socket to use
....................  *                  byte    - a data byte to send
....................  *
....................  * Output:          TRUE if given byte was put in transmit buffer
....................  *                  FALSE if transmit buffer is full.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket whose data is to be transmitted.
....................  *
....................  * Output:          All and any data associated with this socket
....................  *                  is marked as ready for transmission.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPFlush(TCP_SOCKET socket);
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' contains any data.
....................  *                  FALSE if socket 's' does not contain any data.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPIsGetReady(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  byte    - Pointer to a byte.
....................  *
....................  * Output:          TRUE if a byte was read.
....................  *                  FALSE if byte was not read.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer,
....................  *                                      WORD count)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  buffer  - Buffer to hold received data.
....................  *                  count   - Buffer length
....................  *
....................  * Output:          Number of bytes loaded into buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket
....................  *
....................  * Output:          TRUE if socket received data was discarded
....................  *                  FALSE if socket received data was already
....................  *                          discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPDiscard(TCP_SOCKET socket);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote,
....................  *                                  IP_ADDR *localIP,
....................  *                                  WORD len)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCP segment is ready in MAC buffer
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  len         - Total length of TCP semgent.
....................  *
....................  * Output:          TRUE if this function has completed its task
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPProcess(NODE_INFO *remote,
....................                        IP_ADDR *localIP,
....................                        WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPTick(void)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Each socket FSM is executed for any timeout
....................  *                  situation.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void        TCPTick(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u)
.................... //#define debug_tcp debug_printf
.................... 
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) -
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER)
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54)
.................... 
.................... // TCP Timeout value to begin with.
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3)
.................... 
.................... // TCP Flags defined in RFC
.................... #define FIN     (0x01)
.................... #define SYN     (0x02)
.................... #define RST     (0x04)
.................... #define PSH     (0x08)
.................... #define ACK     (0x10)
.................... #define URG     (0x20)
.................... 
.................... 
.................... // TCP Header
.................... typedef struct _TCP_HEADER
.................... {
....................     WORD    SourcePort;
....................     WORD    DestPort;
....................     DWORD   SeqNumber;
....................     DWORD   AckNumber;
.................... 
....................     struct
....................     {
....................        BYTE Reserved3:4;
....................        BYTE Val:4;
....................     } DataOffset;
.................... 
.................... 
....................     union
....................     {
....................         struct
....................         {
....................              int1 flagFIN    : 1;
....................              int1 flagSYN    : 1;
....................              int1 flagRST    : 1;
....................              int1 flagPSH    : 1;
....................              int1 flagACK    : 1;
....................              int1 flagURG    : 1;
....................              int1 Reserved2  : 2;
....................         } bits;
....................         BYTE b;
....................     } Flags;
.................... 
....................     WORD    Window;
....................     WORD    Checksum;
....................     WORD    UrgentPointer;
.................... } TCP_HEADER;
.................... 
.................... 
.................... // TCP Options as defined by RFC
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00)
.................... #define TCP_OPTIONS_NO_OP           (0x01)
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02)
.................... typedef struct _TCP_OPTIONS
.................... {
....................     BYTE        Kind;
....................     BYTE        Length;
....................     WORD_VAL    MaxSegSize;
.................... } TCP_OPTIONS;
.................... 
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength))
.................... 
.................... // IP pseudo header as defined by RFC 793
.................... typedef struct _PSEUDO_HEADER
.................... {
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
....................     BYTE Zero;
....................     BYTE Protocol;
....................     WORD TCPLength;
.................... } PSEUDO_HEADER;
.................... 
.................... #define LOCAL_PORT_START_NUMBER (1024)
.................... #define LOCAL_PORT_END_NUMBER   (5000)
.................... 
.................... // Local temp port numbers.
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER;
.................... 
.................... // The TCB array is very large.  With the C18 compiler, one must
.................... // modify the linker script to make an array that spans more than
.................... // one memory bank.  To do this, make the necessary changes to your
.................... // processor's linker script (.lkr).  Here is an example showing
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte
.................... // block used exclusively by the TCB_MEM data section:
.................... // ...
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF
.................... // ...
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b
.................... // ...
.................... //#pragma udata TCB_MEM   //not needed in ccs
.................... SOCKET_INFO TCB[MAX_SOCKETS];
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs
.................... 
.................... static void    HandleTCPSeg(TCP_SOCKET s,
....................                                NODE_INFO *remote,
....................                                TCP_HEADER *h,
....................                                WORD len);
.................... 
.................... static void TransmitTCP(NODE_INFO *remote,
....................                         TCP_PORT localPort,
....................                         TCP_PORT remotePort,
....................                         DWORD tseq,
....................                         DWORD tack,
....................                         BYTE flags,
....................                         BUFFER buff,
....................                         WORD len);
.................... 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h,
....................                                     NODE_INFO *remote);
.................... static void    SwapTCPHeader(TCP_HEADER* header);
.................... static void CloseSocket(SOCKET_INFO* ps);
.................... 
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \
....................                     INVALID_BUFFER, 0)
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPInit(void)
.................... *
.................... * PreCondition:    None
.................... *
.................... * Input:           None
.................... *
.................... * Output:          TCP is initialized.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        Initialize all socket states
.................... *
.................... * Note:            This function is called only once during lifetime
.................... *                  of the application.
.................... ********************************************************************/
.................... int16 TCPInit_RandSeed;
.................... void TCPInit(void)
.................... {
....................     TCP_SOCKET s;
....................     SOCKET_INFO* ps;
.................... 
.................... 
....................     // Initialize all sockets.
....................     for ( s = 0; s < MAX_SOCKETS; s++ )
*
0E5C:  MOVLB  2
0E5E:  CLRF   xF4
0E60:  MOVF   xF4,W
0E62:  SUBLW  04
0E64:  BNC   0F30
....................     {
....................         ps = &TCB[s];
0E66:  MOVF   xF4,W
0E68:  MULLW  24
0E6A:  MOVF   FF3,W
0E6C:  CLRF   03
0E6E:  MOVWF  01
0E70:  MOVLW  01
0E72:  ADDWF  03,F
0E74:  MOVFF  01,2F5
0E78:  MOVFF  03,2F6
.................... 
....................         ps->smState             = TCP_CLOSED;
0E7C:  MOVFF  2F5,FE9
0E80:  MOVFF  2F6,FEA
0E84:  MOVLW  0A
0E86:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE;
0E88:  MOVLW  23
0E8A:  ADDWF  xF5,W
0E8C:  MOVWF  FE9
0E8E:  MOVLW  00
0E90:  ADDWFC xF6,W
0E92:  MOVWF  FEA
0E94:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE;
0E96:  MOVLW  23
0E98:  ADDWF  xF5,W
0E9A:  MOVWF  FE9
0E9C:  MOVLW  00
0E9E:  ADDWFC xF6,W
0EA0:  MOVWF  FEA
0EA2:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE;
0EA4:  MOVLW  23
0EA6:  ADDWF  xF5,W
0EA8:  MOVWF  FE9
0EAA:  MOVLW  00
0EAC:  ADDWFC xF6,W
0EAE:  MOVWF  FEA
0EB0:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE;
0EB2:  MOVLW  23
0EB4:  ADDWF  xF5,W
0EB6:  MOVWF  FE9
0EB8:  MOVLW  00
0EBA:  ADDWFC xF6,W
0EBC:  MOVWF  FEA
0EBE:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE;
0EC0:  MOVLW  23
0EC2:  ADDWF  xF5,W
0EC4:  MOVWF  FE9
0EC6:  MOVLW  00
0EC8:  ADDWFC xF6,W
0ECA:  MOVWF  FEA
0ECC:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER)
0ECE:  MOVLW  0F
0ED0:  ADDWF  xF5,W
0ED2:  MOVWF  FE9
0ED4:  MOVLW  00
0ED6:  ADDWFC xF6,W
0ED8:  MOVWF  FEA
0EDA:  INCFSZ FEF,W
0EDC:  BRA    0EE0
0EDE:  BRA    0F06
....................       {
....................          MACDiscardTx(ps->TxBuffer);
0EE0:  MOVLW  0F
0EE2:  ADDWF  xF5,W
0EE4:  MOVWF  FE9
0EE6:  MOVLW  00
0EE8:  ADDWFC xF6,W
0EEA:  MOVWF  FEA
0EEC:  MOVFF  FEF,347
0EF0:  MOVLB  0
0EF2:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER;
0EF6:  MOVLW  0F
0EF8:  MOVLB  2
0EFA:  ADDWF  xF5,W
0EFC:  MOVWF  FE9
0EFE:  MOVLW  00
0F00:  ADDWFC xF6,W
0F02:  MOVWF  FEA
0F04:  SETF   FEF
....................       }
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL;
0F06:  MOVLW  21
0F08:  ADDWF  xF5,W
0F0A:  MOVWF  FE9
0F0C:  MOVLW  00
0F0E:  ADDWFC xF6,W
0F10:  MOVWF  FEA
0F12:  CLRF   FEC
0F14:  MOVF   FED,F
0F16:  MOVLW  1E
0F18:  MOVWF  FEF
....................       ps->TxCount            = 0;
0F1A:  MOVLW  10
0F1C:  ADDWF  xF5,W
0F1E:  MOVWF  FE9
0F20:  MOVLW  00
0F22:  ADDWFC xF6,W
0F24:  MOVWF  FEA
0F26:  CLRF   FEC
0F28:  MOVF   FED,F
0F2A:  CLRF   FEF
....................    }
.................... 
....................     //_NextPort = LOCAL_PORT_START_NUMBER;
....................     #if getenv("TIMER0")
0F2C:  INCF   xF4,F
0F2E:  BRA    0E60
....................     TCPInit_RandSeed+=get_timer0();
0F30:  MOVF   FD6,W
0F32:  MOVLB  0
0F34:  ADDWF  x61,F
0F36:  MOVF   FD7,W
0F38:  ADDWFC x62,F
....................     #endif
....................     #if getenv("TIMER1")
....................      TCPInit_RandSeed+=get_timer1();
0F3A:  MOVF   FCE,W
0F3C:  ADDWF  x61,F
0F3E:  MOVF   FCF,W
0F40:  ADDWFC x62,F
....................     #endif
....................     #if getenv("TIMER2")
....................      TCPInit_RandSeed+=get_timer2();
0F42:  MOVF   FCC,W
0F44:  ADDWF  x61,F
0F46:  MOVLW  00
0F48:  ADDWFC x62,F
....................     #endif
....................     #if getenv("TIMER3")
....................      TCPInit_RandSeed+=get_timer3();
0F4A:  MOVF   FB2,W
0F4C:  ADDWF  x61,F
0F4E:  MOVF   FB3,W
0F50:  ADDWFC x62,F
....................     #endif
....................     #if getenv("TIMER4")
....................      TCPInit_RandSeed+=get_timer4();
....................     #endif
....................     #if getenv("TIMER5")
....................      TCPInit_RandSeed+=get_timer5();
....................     #endif
....................     srand(TCPInit_RandSeed);
0F52:  MOVLB  2
0F54:  CLRF   xFA
0F56:  CLRF   xF9
0F58:  MOVFF  62,2F8
0F5C:  MOVFF  61,2F7
0F60:  MOVLB  0
0F62:  BRA    0D32
....................     _NextPort=rand();
0F64:  BRA    0DEA
0F66:  MOVFF  02,60
0F6A:  MOVFF  01,5F
....................     _NextPort+=LOCAL_PORT_START_NUMBER;
0F6E:  MOVLW  04
0F70:  ADDWF  x60,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;}
0F72:  MOVF   x60,W
0F74:  SUBLW  12
0F76:  BC    0F8C
0F78:  XORLW  FF
0F7A:  BNZ   0F82
0F7C:  MOVF   5F,W
0F7E:  SUBLW  87
0F80:  BC    0F8C
0F82:  MOVLW  88
0F84:  SUBWF  5F,F
0F86:  MOVLW  13
0F88:  SUBWFB x60,F
0F8A:  BRA    0F72
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;}
0F8C:  MOVF   x60,W
0F8E:  SUBLW  03
0F90:  BNC   0F96
0F92:  MOVLW  04
0F94:  ADDWF  x60,F
0F96:  GOTO   10FA (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           port    - A TCP port to be opened.
.................... *
.................... * Output:          Given port is opened and returned on success
.................... *                  INVALID_SOCKET if no more sockets left.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... TCP_SOCKET TCPListen(TCP_PORT port)
.................... {
....................    TCP_SOCKET s;
....................    SOCKET_INFO* ps;
.................... 
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port);
.................... 
....................    for(s = 0; s < MAX_SOCKETS; s++)
0F9A:  MOVLB  2
0F9C:  CLRF   xF9
0F9E:  MOVF   xF9,W
0FA0:  SUBLW  04
0FA2:  BNC   107A
....................    {
....................       ps = &TCB[s];
0FA4:  MOVF   xF9,W
0FA6:  MULLW  24
0FA8:  MOVF   FF3,W
0FAA:  CLRF   03
0FAC:  MOVWF  01
0FAE:  MOVLW  01
0FB0:  ADDWF  03,F
0FB2:  MOVFF  01,2FA
0FB6:  MOVFF  03,2FB
.................... 
....................       if(ps->smState == TCP_CLOSED)
0FBA:  MOVFF  2FA,FE9
0FBE:  MOVFF  2FB,FEA
0FC2:  MOVF   FEF,W
0FC4:  SUBLW  0A
0FC6:  BNZ   1076
....................       {
....................          // We have a CLOSED socket.
....................          // Initialize it with LISTENing state info.
....................          ps->smState             = TCP_LISTEN;
0FC8:  MOVFF  2FA,FE9
0FCC:  MOVFF  2FB,FEA
0FD0:  CLRF   FEF
....................          ps->localPort           = port;
0FD2:  MOVLW  0B
0FD4:  ADDWF  xFA,W
0FD6:  MOVWF  FE9
0FD8:  MOVLW  00
0FDA:  ADDWFC xFB,W
0FDC:  MOVWF  FEA
0FDE:  MOVFF  2F8,FEC
0FE2:  MOVF   FED,F
0FE4:  MOVFF  2F7,FEF
....................          ps->remotePort          = 0;
0FE8:  MOVLW  0D
0FEA:  ADDWF  xFA,W
0FEC:  MOVWF  FE9
0FEE:  MOVLW  00
0FF0:  ADDWFC xFB,W
0FF2:  MOVWF  FEA
0FF4:  CLRF   FEC
0FF6:  MOVF   FED,F
0FF8:  CLRF   FEF
.................... 
....................          // There is no remote node IP address info yet.
....................          ps->remote.IPAddr.Val   = 0x00;
0FFA:  MOVLW  07
0FFC:  ADDWF  xFA,W
0FFE:  MOVWF  FE9
1000:  MOVLW  00
1002:  ADDWFC xFB,W
1004:  MOVWF  FEA
1006:  CLRF   FEF
1008:  CLRF   FEC
100A:  CLRF   FEC
100C:  CLRF   FEC
.................... 
....................          // If a socket is listened on, it is a SERVER.
....................          ps->Flags.bServer       = TRUE;
100E:  MOVLW  23
1010:  ADDWF  xFA,W
1012:  MOVWF  FE9
1014:  MOVLW  00
1016:  ADDWFC xFB,W
1018:  MOVWF  FEA
101A:  BSF    FEF.0
.................... 
....................          ps->Flags.bIsGetReady   = FALSE;
101C:  MOVLW  23
101E:  ADDWF  xFA,W
1020:  MOVWF  FE9
1022:  MOVLW  00
1024:  ADDWFC xFB,W
1026:  MOVWF  FEA
1028:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER)
102A:  MOVLW  0F
102C:  ADDWF  xFA,W
102E:  MOVWF  FE9
1030:  MOVLW  00
1032:  ADDWFC xFB,W
1034:  MOVWF  FEA
1036:  INCFSZ FEF,W
1038:  BRA    103C
103A:  BRA    1062
....................          {
....................             MACDiscardTx(ps->TxBuffer);
103C:  MOVLW  0F
103E:  ADDWF  xFA,W
1040:  MOVWF  FE9
1042:  MOVLW  00
1044:  ADDWFC xFB,W
1046:  MOVWF  FEA
1048:  MOVFF  FEF,347
104C:  MOVLB  0
104E:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER;
1052:  MOVLW  0F
1054:  MOVLB  2
1056:  ADDWF  xFA,W
1058:  MOVWF  FE9
105A:  MOVLW  00
105C:  ADDWFC xFB,W
105E:  MOVWF  FEA
1060:  SETF   FEF
....................          }
....................          ps->Flags.bIsPutReady   = TRUE;
1062:  MOVLW  23
1064:  ADDWF  xFA,W
1066:  MOVWF  FE9
1068:  MOVLW  00
106A:  ADDWFC xFB,W
106C:  MOVWF  FEA
106E:  BSF    FEF.1
.................... 
....................          debug_tcp("SOCK=%U", s);
.................... 
....................          return s;
1070:  MOVFF  2F9,01
1074:  BRA    107E
....................       }
1076:  INCF   xF9,F
1078:  BRA    0F9E
....................    }
.................... 
....................    debug_tcp("FAIL");
.................... 
....................    return INVALID_SOCKET;
107A:  MOVLW  FE
107C:  MOVWF  01
107E:  MOVLB  0
1080:  GOTO   10AA (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote,
.................... *                                      TCP_PORT remotePort)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           remote      - Remote node address info
.................... *                  remotePort  - remote port to be connected.
.................... *
.................... * Output:          A new socket is created, connection request is
.................... *                  sent and socket handle is returned.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... ********************************************************************/
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort)
.................... {
....................    TCP_SOCKET s;
....................    SOCKET_INFO* ps;
....................    BOOL lbFound;
.................... 
.................... 
....................    lbFound = FALSE;
.................... 
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort);
.................... 
....................    // Find an available socket
....................    for(s = 0; s < MAX_SOCKETS; s++)
....................    {
....................       ps = &TCB[s];
....................       if(ps->smState == TCP_CLOSED)
....................       {
....................          lbFound = TRUE;
....................          break;
....................       }
....................    }
.................... 
....................    // If there is no socket available, return error.
....................    if(!lbFound)
....................       return INVALID_SOCKET;
.................... 
....................    // Each new socket that is opened by this node, gets
....................    // next sequential port number.
....................    ps->localPort = ++_NextPort;
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER)
....................       _NextPort = LOCAL_PORT_START_NUMBER-1;
.................... 
....................    // This is a client socket.
....................    ps->Flags.bServer = FALSE;
.................... 
....................    // This is the port, we are trying to connect to.
....................    ps->remotePort = remotePort;
.................... 
....................    // Each new socket that is opened by this node, will
....................    // start with next the next seqeuence number (essentially random)
....................    ps->SND_SEQ++;
....................    ps->SND_ACK = 0;
.................... 
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote));
.................... 
....................    // Send SYN message.
....................    SendTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       SYN);
.................... 
....................    ps->smState = TCP_SYN_SENT;
....................    ps->SND_SEQ++;
.................... 
....................    // Allow TCPTick() to operate properly
....................    ps->startTick = TickGet();
.................... 
....................    debug_tcp("SOCK=%U", s);
.................... 
....................    return s;
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket to be checked for connection.
....................  *
....................  * Output:          TRUE    if given socket is connected
....................  *                  FALSE   if given socket is not connected.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            A socket is said to be connected if it is not
....................  *                  in LISTEN and CLOSED mode.  Socket may be in
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket
....................  *                  data.
....................  ********************************************************************/
.................... BOOL TCPIsConnected(TCP_SOCKET s)
.................... {
....................     return ( TCB[s].smState == TCP_ESTABLISHED );
*
3E2A:  MOVLB  3
3E2C:  MOVF   x08,W
3E2E:  MULLW  24
3E30:  MOVF   FF3,W
3E32:  CLRF   x0A
3E34:  MOVWF  x09
3E36:  MOVWF  FE9
3E38:  MOVLW  01
3E3A:  ADDWF  x0A,W
3E3C:  MOVWF  FEA
3E3E:  MOVF   FEF,W
3E40:  SUBLW  03
3E42:  BZ    3E48
3E44:  MOVLW  00
3E46:  BRA    3E4A
3E48:  MOVLW  01
3E4A:  MOVWF  01
3E4C:  MOVLB  0
3E4E:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPDisconnect(TCP_SOCKET s)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPIsPutReady(s) == TRUE
.................... *
.................... * Input:           s       - Socket to be disconnected.
.................... *
.................... * Output:          A disconnect request is sent for given socket.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... void TCPDisconnect(TCP_SOCKET s)
.................... {
....................    SOCKET_INFO *ps;
.................... 
....................    ps = &TCB[s];
*
5EA8:  MOVLB  3
5EAA:  MOVF   x08,W
5EAC:  MULLW  24
5EAE:  MOVF   FF3,W
5EB0:  CLRF   03
5EB2:  MOVWF  01
5EB4:  MOVLW  01
5EB6:  ADDWF  03,F
5EB8:  MOVFF  01,309
5EBC:  MOVFF  03,30A
.................... 
....................    // If socket is not connected, may be it is already closed
....................    // or in the process of closing.  Since we have called this
....................    // explicitly, close it forcefully.
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED)
5EC0:  MOVFF  309,FE9
5EC4:  MOVFF  30A,FEA
5EC8:  MOVF   FEF,W
5ECA:  SUBLW  03
5ECC:  BZ    5EEE
5ECE:  MOVFF  309,FE9
5ED2:  MOVFF  30A,FEA
5ED6:  MOVF   FEF,W
5ED8:  SUBLW  02
5EDA:  BZ    5EEE
....................    {
....................       CloseSocket(ps);
5EDC:  MOVFF  30A,345
5EE0:  MOVFF  309,344
5EE4:  MOVLB  0
5EE6:  CALL   24A4
....................       return;
5EEA:  BRA    5FAE
5EEC:  MOVLB  3
....................    }
.................... 
....................    // Discard any outstanding data that is to be read.
....................    TCPDiscard(s);
5EEE:  MOVFF  308,30B
5EF2:  MOVLB  0
5EF4:  CALL   4F72
.................... 
....................    // Send FIN message.
....................    SendTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       FIN | ACK);
5EF8:  MOVLW  01
5EFA:  MOVLB  3
5EFC:  ADDWF  x09,W
5EFE:  MOVWF  01
5F00:  MOVLW  00
5F02:  ADDWFC x0A,W
5F04:  MOVWF  03
5F06:  MOVFF  01,30B
5F0A:  MOVWF  x0C
5F0C:  MOVLW  0B
5F0E:  ADDWF  x09,W
5F10:  MOVWF  FE9
5F12:  MOVLW  00
5F14:  ADDWFC x0A,W
5F16:  MOVWF  FEA
5F18:  MOVFF  FEC,354
5F1C:  MOVF   FED,F
5F1E:  MOVFF  FEF,353
5F22:  MOVLW  0D
5F24:  ADDWF  x09,W
5F26:  MOVWF  FE9
5F28:  MOVLW  00
5F2A:  ADDWFC x0A,W
5F2C:  MOVWF  FEA
5F2E:  MOVFF  FEC,356
5F32:  MOVF   FED,F
5F34:  MOVFF  FEF,355
5F38:  MOVLW  16
5F3A:  ADDWF  x09,W
5F3C:  MOVWF  FE9
5F3E:  MOVLW  00
5F40:  ADDWFC x0A,W
5F42:  MOVWF  FEA
5F44:  MOVFF  FEF,357
5F48:  MOVFF  FEC,358
5F4C:  MOVFF  FEC,359
5F50:  MOVFF  FEC,35A
5F54:  MOVLW  1A
5F56:  ADDWF  x09,W
5F58:  MOVWF  FE9
5F5A:  MOVLW  00
5F5C:  ADDWFC x0A,W
5F5E:  MOVWF  FEA
5F60:  MOVFF  FEF,35B
5F64:  MOVFF  FEC,35C
5F68:  MOVFF  FEC,35D
5F6C:  MOVFF  FEC,35E
5F70:  MOVFF  03,352
5F74:  MOVFF  01,351
5F78:  MOVLW  11
5F7A:  MOVWF  x5F
5F7C:  SETF   x60
5F7E:  CLRF   x62
5F80:  CLRF   x61
5F82:  MOVLB  0
5F84:  CALL   28D0
....................    //DebugPrint(".");
.................... 
....................    ps->SND_SEQ++;
5F88:  MOVLW  16
5F8A:  MOVLB  3
5F8C:  ADDWF  x09,W
5F8E:  MOVWF  FE9
5F90:  MOVLW  00
5F92:  ADDWFC x0A,W
5F94:  MOVWF  FEA
5F96:  MOVLW  01
5F98:  ADDWF  FEE,F
5F9A:  MOVLW  00
5F9C:  ADDWFC FEE,F
5F9E:  ADDWFC FEE,F
5FA0:  ADDWFC FED,F
.................... 
....................    ps->smState = TCP_FIN_WAIT_1;
5FA2:  MOVFF  309,FE9
5FA6:  MOVFF  30A,FEA
5FAA:  MOVLW  04
5FAC:  MOVWF  FEF
5FAE:  MOVLB  0
.................... 
....................    return;
5FB0:  GOTO   6C0C (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           s       - Socket whose data is to be transmitted.
.................... *
.................... * Output:          All and any data associated with this socket
.................... *                  is marked as ready for transmission.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... BOOL TCPFlush(TCP_SOCKET s)
.................... {
....................    SOCKET_INFO *ps;
.................... 
....................    ps = &TCB[s];
*
505C:  MOVLB  3
505E:  MOVF   x3D,W
5060:  MULLW  24
5062:  MOVF   FF3,W
5064:  CLRF   03
5066:  MOVWF  01
5068:  MOVLW  01
506A:  ADDWF  03,F
506C:  MOVFF  01,33E
5070:  MOVFF  03,33F
.................... 
....................    // Make sure that there is TxBuffer assigned to this socket.
....................    if ( ps->TxBuffer == INVALID_BUFFER )
5074:  MOVLW  0F
5076:  ADDWF  x3E,W
5078:  MOVWF  FE9
507A:  MOVLW  00
507C:  ADDWFC x3F,W
507E:  MOVWF  FEA
5080:  INCFSZ FEF,W
5082:  BRA    508A
....................       return FALSE;
5084:  MOVLW  00
5086:  MOVWF  01
5088:  BRA    51E4
.................... 
....................    if ( ps->Flags.bIsPutReady == FALSE )
508A:  MOVLW  23
508C:  ADDWF  x3E,W
508E:  MOVWF  01
5090:  MOVLW  00
5092:  ADDWFC x3F,W
5094:  MOVWF  03
5096:  MOVFF  01,FE9
509A:  MOVWF  FEA
509C:  BTFSC  FEF.1
509E:  BRA    50A6
....................       return FALSE;
50A0:  MOVLW  00
50A2:  MOVWF  01
50A4:  BRA    51E4
.................... 
....................    TransmitTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away
....................       ps->TxBuffer,
....................       ps->TxCount);
50A6:  MOVLW  01
50A8:  ADDWF  x3E,W
50AA:  MOVWF  01
50AC:  MOVLW  00
50AE:  ADDWFC x3F,W
50B0:  MOVWF  03
50B2:  MOVFF  01,340
50B6:  MOVWF  x41
50B8:  MOVLW  0B
50BA:  ADDWF  x3E,W
50BC:  MOVWF  FE9
50BE:  MOVLW  00
50C0:  ADDWFC x3F,W
50C2:  MOVWF  FEA
50C4:  MOVFF  FEC,354
50C8:  MOVF   FED,F
50CA:  MOVFF  FEF,353
50CE:  MOVLW  0D
50D0:  ADDWF  x3E,W
50D2:  MOVWF  FE9
50D4:  MOVLW  00
50D6:  ADDWFC x3F,W
50D8:  MOVWF  FEA
50DA:  MOVFF  FEC,356
50DE:  MOVF   FED,F
50E0:  MOVFF  FEF,355
50E4:  MOVLW  16
50E6:  ADDWF  x3E,W
50E8:  MOVWF  FE9
50EA:  MOVLW  00
50EC:  ADDWFC x3F,W
50EE:  MOVWF  FEA
50F0:  MOVFF  FEF,357
50F4:  MOVFF  FEC,358
50F8:  MOVFF  FEC,359
50FC:  MOVFF  FEC,35A
5100:  MOVLW  1A
5102:  ADDWF  x3E,W
5104:  MOVWF  FE9
5106:  MOVLW  00
5108:  ADDWFC x3F,W
510A:  MOVWF  FEA
510C:  MOVFF  FEF,35B
5110:  MOVFF  FEC,35C
5114:  MOVFF  FEC,35D
5118:  MOVFF  FEC,35E
511C:  MOVLW  0F
511E:  ADDWF  x3E,W
5120:  MOVWF  FE9
5122:  MOVLW  00
5124:  ADDWFC x3F,W
5126:  MOVWF  FEA
5128:  MOVFF  FEF,360
512C:  MOVLW  10
512E:  ADDWF  x3E,W
5130:  MOVWF  FE9
5132:  MOVLW  00
5134:  ADDWFC x3F,W
5136:  MOVWF  FEA
5138:  MOVFF  FEC,362
513C:  MOVF   FED,F
513E:  MOVFF  FEF,361
5142:  MOVFF  03,352
5146:  MOVFF  01,351
514A:  MOVLW  18
514C:  MOVWF  x5F
514E:  MOVLB  0
5150:  CALL   28D0
.................... 
....................    ps->SND_SEQ += (DWORD)ps->TxCount;
5154:  MOVLW  16
5156:  MOVLB  3
5158:  ADDWF  x3E,W
515A:  MOVWF  01
515C:  MOVLW  00
515E:  ADDWFC x3F,W
5160:  MOVWF  03
5162:  MOVFF  01,340
5166:  MOVWF  x41
5168:  MOVWF  FEA
516A:  MOVFF  01,FE9
516E:  MOVFF  FEF,342
5172:  MOVFF  FEC,343
5176:  MOVFF  FEC,344
517A:  MOVFF  FEC,345
517E:  MOVLW  10
5180:  ADDWF  x3E,W
5182:  MOVWF  FE9
5184:  MOVLW  00
5186:  ADDWFC x3F,W
5188:  MOVWF  FEA
518A:  MOVFF  FEC,03
518E:  MOVF   FED,F
5190:  MOVFF  FEF,00
5194:  MOVFF  03,01
5198:  CLRF   02
519A:  CLRF   03
519C:  MOVF   x42,W
519E:  ADDWF  00,F
51A0:  MOVF   x43,W
51A2:  ADDWFC 01,F
51A4:  MOVF   x44,W
51A6:  ADDWFC 02,F
51A8:  MOVF   x45,W
51AA:  ADDWFC 03,F
51AC:  MOVFF  341,FEA
51B0:  MOVFF  340,FE9
51B4:  MOVFF  00,FEF
51B8:  MOVFF  01,FEC
51BC:  MOVFF  02,FEC
51C0:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE;
51C4:  MOVLW  23
51C6:  ADDWF  x3E,W
51C8:  MOVWF  FE9
51CA:  MOVLW  00
51CC:  ADDWFC x3F,W
51CE:  MOVWF  FEA
51D0:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE;
51D2:  MOVLW  23
51D4:  ADDWF  x3E,W
51D6:  MOVWF  FE9
51D8:  MOVLW  00
51DA:  ADDWFC x3F,W
51DC:  MOVWF  FEA
51DE:  BCF    FEF.4
.................... 
.................... #if TCP_NO_WAIT_FOR_ACK
....................    if(ps->TxBuffer != INVALID_BUFFER)
....................    {
....................       MACDiscardTx(ps->TxBuffer);
....................       ps->TxBuffer        = INVALID_BUFFER;
....................    }
....................    ps->Flags.bIsPutReady       = TRUE;
.................... #endif
.................... 
....................    return TRUE;
51E0:  MOVLW  01
51E2:  MOVWF  01
51E4:  MOVLB  0
51E6:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' is free to transmit
....................  *                  FALSE if socket 's' is not free to transmit.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Each socket maintains only transmit buffer.
....................  *                  Hence until a data packet is acknowledeged by
....................  *                  remote node, socket will not be ready for
....................  *                  next transmission.
....................  *                  All control transmission such as Connect,
....................  *                  Disconnect do not consume/reserve any transmit
....................  *                  buffer.
....................  ********************************************************************/
.................... BOOL TCPIsPutReady(TCP_SOCKET s)
.................... {
....................    if(TCB[s].RemoteWindow == 0)
*
4FBE:  MOVLB  3
4FC0:  MOVF   x2B,W
4FC2:  MULLW  24
4FC4:  MOVF   FF3,W
4FC6:  CLRF   x2D
4FC8:  MOVWF  x2C
4FCA:  MOVLW  14
4FCC:  ADDWF  x2C,W
4FCE:  MOVWF  01
4FD0:  MOVLW  00
4FD2:  ADDWFC x2D,W
4FD4:  MOVWF  03
4FD6:  MOVFF  01,FE9
4FDA:  MOVLW  01
4FDC:  ADDWF  03,W
4FDE:  MOVWF  FEA
4FE0:  MOVFF  FEC,32D
4FE4:  MOVF   FED,F
4FE6:  MOVFF  FEF,32C
4FEA:  MOVF   x2C,F
4FEC:  BNZ   4FF8
4FEE:  MOVF   x2D,F
4FF0:  BNZ   4FF8
....................       return FALSE;
4FF2:  MOVLW  00
4FF4:  MOVWF  01
4FF6:  BRA    5050
.................... 
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER )
4FF8:  MOVF   x2B,W
4FFA:  MULLW  24
4FFC:  MOVF   FF3,W
4FFE:  CLRF   x2D
5000:  MOVWF  x2C
5002:  MOVLW  0F
5004:  ADDWF  x2C,W
5006:  MOVWF  01
5008:  MOVLW  00
500A:  ADDWFC x2D,W
500C:  MOVWF  03
500E:  MOVFF  01,FE9
5012:  MOVLW  01
5014:  ADDWF  03,W
5016:  MOVWF  FEA
5018:  INCFSZ FEF,W
501A:  BRA    502C
....................       return IPIsTxReady(FALSE);
501C:  CLRF   x89
501E:  MOVLB  0
5020:  CALL   2598
5024:  MOVF   01,W
5026:  MOVLB  3
5028:  BRA    5050
502A:  BRA    5050
....................    else
....................       return TCB[s].Flags.bIsPutReady;
502C:  MOVF   x2B,W
502E:  MULLW  24
5030:  MOVF   FF3,W
5032:  CLRF   x2D
5034:  MOVWF  x2C
5036:  MOVLW  23
5038:  ADDWF  x2C,F
503A:  MOVLW  00
503C:  ADDWFC x2D,F
503E:  MOVFF  32C,FE9
5042:  MOVLW  01
5044:  ADDWF  x2D,W
5046:  MOVWF  FEA
5048:  MOVLW  00
504A:  BTFSC  FEF.1
504C:  MOVLW  01
504E:  MOVWF  01
5050:  MOVLB  0
5052:  RETURN 0
.................... }
.................... 
.................... 
.................... int16 TCPPutAvailable(TCP_SOCKET s)
.................... {
....................    int16 txCount, txAvail;
.................... 
....................    if (!TCPIsPutReady(s))
*
546E:  MOVFF  326,32B
5472:  RCALL  4FBE
5474:  MOVF   01,F
5476:  BNZ   5480
....................       return(0);
5478:  MOVLW  00
547A:  MOVWF  01
547C:  MOVWF  02
547E:  BRA    555C
.................... 
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER )
5480:  MOVLB  3
5482:  MOVF   x26,W
5484:  MULLW  24
5486:  MOVF   FF3,W
5488:  CLRF   x2C
548A:  MOVWF  x2B
548C:  MOVLW  0F
548E:  ADDWF  x2B,W
5490:  MOVWF  01
5492:  MOVLW  00
5494:  ADDWFC x2C,W
5496:  MOVWF  03
5498:  MOVFF  01,FE9
549C:  MOVLW  01
549E:  ADDWF  03,W
54A0:  MOVWF  FEA
54A2:  INCFSZ FEF,W
54A4:  BRA    54AC
....................       txCount = 0;
54A6:  CLRF   x28
54A8:  CLRF   x27
54AA:  BRA    54D6
....................    else
....................       txCount = TCB[s].TxCount;
54AC:  MOVF   x26,W
54AE:  MULLW  24
54B0:  MOVF   FF3,W
54B2:  CLRF   x2C
54B4:  MOVWF  x2B
54B6:  MOVLW  10
54B8:  ADDWF  x2B,W
54BA:  MOVWF  01
54BC:  MOVLW  00
54BE:  ADDWFC x2C,W
54C0:  MOVWF  03
54C2:  MOVFF  01,FE9
54C6:  MOVLW  01
54C8:  ADDWF  03,W
54CA:  MOVWF  FEA
54CC:  MOVFF  FEC,328
54D0:  MOVF   FED,F
54D2:  MOVFF  FEF,327
.................... 
....................    txAvail = MAX_TCP_DATA_LEN - txCount;
54D6:  MOVLW  CA
54D8:  BSF    FD8.0
54DA:  SUBFWB x27,W
54DC:  MOVWF  x29
54DE:  MOVLW  03
54E0:  SUBFWB x28,W
54E2:  MOVWF  x2A
.................... 
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail;
54E4:  MOVF   x26,W
54E6:  MULLW  24
54E8:  MOVF   FF3,W
54EA:  CLRF   x2C
54EC:  MOVWF  x2B
54EE:  MOVLW  14
54F0:  ADDWF  x2B,W
54F2:  MOVWF  01
54F4:  MOVLW  00
54F6:  ADDWFC x2C,W
54F8:  MOVWF  03
54FA:  MOVFF  01,FE9
54FE:  MOVLW  01
5500:  ADDWF  03,W
5502:  MOVWF  FEA
5504:  MOVFF  FEC,03
5508:  MOVF   FED,F
550A:  MOVFF  FEF,01
550E:  MOVF   03,W
5510:  SUBWF  x2A,W
5512:  BNC   5546
5514:  BNZ   551C
5516:  MOVF   x29,W
5518:  SUBWF  01,W
551A:  BC    5546
551C:  MOVF   x26,W
551E:  MULLW  24
5520:  MOVF   FF3,W
5522:  CLRF   x2C
5524:  MOVWF  x2B
5526:  MOVLW  14
5528:  ADDWF  x2B,W
552A:  MOVWF  01
552C:  MOVLW  00
552E:  ADDWFC x2C,W
5530:  MOVWF  03
5532:  MOVFF  01,FE9
5536:  MOVLW  01
5538:  ADDWF  03,W
553A:  MOVWF  FEA
553C:  MOVFF  FEC,03
5540:  MOVF   FED,F
5542:  MOVF   FEF,W
5544:  BRA    554C
5546:  MOVFF  32A,03
554A:  MOVF   x29,W
554C:  MOVWF  x29
554E:  MOVFF  03,32A
.................... 
....................    return(txAvail);
5552:  MOVFF  329,01
5556:  MOVFF  32A,02
555A:  MOVLB  0
555C:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s      - socket to use
....................  *                  ptr    - Block of data to send over TCP
....................  *                  len    - number of bytes to send over TCP
....................  *
....................  * Output:          Total number of bytes written to TCP.  If this value
....................  *                  is not equal len that means we ran out of space in the
....................  *                  TX buffer -OR- we ran out of space in the remote node's
....................  *                  window.  In either case you will have to continue later.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len)
.................... {
....................    SOCKET_INFO* ps;
....................    WORD n;
.................... 
....................    ps = &TCB[s];
.................... 
....................    // Make sure that the remote node is able to accept our data
....................    if(ps->RemoteWindow == 0)
....................       return 0;
.................... 
....................    if(ps->TxBuffer == INVALID_BUFFER)
....................    {
....................       ps->TxBuffer = MACGetTxBuffer(FALSE);
.................... 
....................       // Check to make sure that we received a TX Buffer
....................       if(ps->TxBuffer == INVALID_BUFFER)
....................          return 0;
.................... 
....................       ps->TxCount = 0;
.................... 
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER));
....................    }
.................... 
....................    n = TCPPutAvailable(s);
.................... 
....................    ps->Flags.bIsTxInProgress = TRUE;
.................... 
....................    while (n--)
....................    {
....................       MACPut(*ptr++);
....................       ps->RemoteWindow -= 1;
....................       ps->TxCount += 1;
....................    }
.................... 
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN)
....................       TCPFlush(s);
.................... 
....................    return(len);
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s      - socket to use
....................  *                  ptr    - Block of data to send over TCP
....................  *                  len    - number of bytes to send over TCP
....................  *
....................  * Output:          Total number of bytes written to TCP.  If this value
....................  *                  is not equal len that means we ran out of space in the
....................  *                  TX buffer and you will have to continue later.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte)
.................... {
....................    SOCKET_INFO* ps;
....................    WORD tempCount;
.................... 
....................    ps = &TCB[s];
*
51E8:  MOVLB  3
51EA:  MOVF   x37,W
51EC:  MULLW  24
51EE:  MOVF   FF3,W
51F0:  CLRF   03
51F2:  MOVWF  01
51F4:  MOVLW  01
51F6:  ADDWF  03,F
51F8:  MOVFF  01,339
51FC:  MOVFF  03,33A
.................... 
....................    // Make sure that the remote node is able to accept our data
....................    if(ps->RemoteWindow == 0)
5200:  MOVLW  14
5202:  ADDWF  x39,W
5204:  MOVWF  FE9
5206:  MOVLW  00
5208:  ADDWFC x3A,W
520A:  MOVWF  FEA
520C:  MOVFF  FEC,33E
5210:  MOVF   FED,F
5212:  MOVFF  FEF,33D
5216:  MOVF   x3D,F
5218:  BNZ   5224
521A:  MOVF   x3E,F
521C:  BNZ   5224
....................       return FALSE;
521E:  MOVLW  00
5220:  MOVWF  01
5222:  BRA    5322
.................... 
....................    if(ps->TxBuffer == INVALID_BUFFER)
5224:  MOVLW  0F
5226:  ADDWF  x39,W
5228:  MOVWF  FE9
522A:  MOVLW  00
522C:  ADDWFC x3A,W
522E:  MOVWF  FEA
5230:  INCFSZ FEF,W
5232:  BRA    52A2
....................    {
....................       ps->TxBuffer = MACGetTxBuffer(FALSE);
5234:  MOVLW  0F
5236:  ADDWF  x39,W
5238:  MOVWF  01
523A:  MOVLW  00
523C:  ADDWFC x3A,W
523E:  MOVWF  03
5240:  MOVFF  01,33D
5244:  MOVWF  x3E
5246:  CLRF   x89
5248:  MOVLB  0
524A:  CALL   14DE
524E:  MOVFF  33E,FEA
5252:  MOVFF  33D,FE9
5256:  MOVFF  01,FEF
.................... 
....................       // Check to make sure that we received a TX Buffer
....................       if(ps->TxBuffer == INVALID_BUFFER)
525A:  MOVLW  0F
525C:  MOVLB  3
525E:  ADDWF  x39,W
5260:  MOVWF  FE9
5262:  MOVLW  00
5264:  ADDWFC x3A,W
5266:  MOVWF  FEA
5268:  INCFSZ FEF,W
526A:  BRA    5272
....................          return FALSE;
526C:  MOVLW  00
526E:  MOVWF  01
5270:  BRA    5322
.................... 
....................       ps->TxCount = 0;
5272:  MOVLW  10
5274:  ADDWF  x39,W
5276:  MOVWF  FE9
5278:  MOVLW  00
527A:  ADDWFC x3A,W
527C:  MOVWF  FEA
527E:  CLRF   FEC
5280:  MOVF   FED,F
5282:  CLRF   FEF
.................... 
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER));
5284:  MOVLW  0F
5286:  ADDWF  x39,W
5288:  MOVWF  FE9
528A:  MOVLW  00
528C:  ADDWFC x3A,W
528E:  MOVWF  FEA
5290:  MOVFF  FEF,3A2
5294:  CLRF   xA4
5296:  MOVLW  28
5298:  MOVWF  xA3
529A:  MOVLB  0
529C:  CALL   1506
52A0:  MOVLB  3
....................    }
.................... 
....................    ps->Flags.bIsTxInProgress = TRUE;
52A2:  MOVLW  23
52A4:  ADDWF  x39,W
52A6:  MOVWF  FE9
52A8:  MOVLW  00
52AA:  ADDWFC x3A,W
52AC:  MOVWF  FEA
52AE:  BSF    FEF.4
.................... 
....................    MACPut(byte);
52B0:  MOVFF  338,3AC
52B4:  MOVLB  0
52B6:  CALL   15A4
....................    ps->RemoteWindow--;
52BA:  MOVLW  14
52BC:  MOVLB  3
52BE:  ADDWF  x39,W
52C0:  MOVWF  FE9
52C2:  MOVLW  00
52C4:  ADDWFC x3A,W
52C6:  MOVWF  FEA
52C8:  MOVLW  FF
52CA:  ADDWF  FEF,F
52CC:  BC    52D2
52CE:  MOVF   FEE,F
52D0:  DECF   FED,F
.................... 
....................    tempCount = ps->TxCount;
52D2:  MOVLW  10
52D4:  ADDWF  x39,W
52D6:  MOVWF  FE9
52D8:  MOVLW  00
52DA:  ADDWFC x3A,W
52DC:  MOVWF  FEA
52DE:  MOVFF  FEC,33C
52E2:  MOVF   FED,F
52E4:  MOVFF  FEF,33B
....................    tempCount++;
52E8:  INCF   x3B,F
52EA:  BTFSC  FD8.2
52EC:  INCF   x3C,F
....................    ps->TxCount = tempCount;
52EE:  MOVLW  10
52F0:  ADDWF  x39,W
52F2:  MOVWF  FE9
52F4:  MOVLW  00
52F6:  ADDWFC x3A,W
52F8:  MOVWF  FEA
52FA:  MOVFF  33C,FEC
52FE:  MOVF   FED,F
5300:  MOVFF  33B,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN)
5304:  MOVF   x3C,W
5306:  SUBLW  02
5308:  BC    531E
530A:  XORLW  FF
530C:  BNZ   5314
530E:  MOVF   x3B,W
5310:  SUBLW  C9
5312:  BC    531E
....................       TCPFlush(s);
5314:  MOVFF  337,33D
5318:  MOVLB  0
531A:  RCALL  505C
531C:  MOVLB  3
.................... 
....................    return TRUE;
531E:  MOVLW  01
5320:  MOVWF  01
5322:  MOVLB  0
5324:  GOTO   5332 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket
....................  *
....................  * Output:          TRUE if socket received data was discarded
....................  *                  FALSE if socket received data was already
....................  *                          discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPDiscard(TCP_SOCKET s)
.................... {
....................     SOCKET_INFO* ps;
.................... 
....................     ps = &TCB[s];
*
4F72:  MOVLB  3
4F74:  MOVF   x0B,W
4F76:  MULLW  24
4F78:  MOVF   FF3,W
4F7A:  CLRF   03
4F7C:  MOVWF  01
4F7E:  MOVLW  01
4F80:  ADDWF  03,F
4F82:  MOVFF  01,30C
4F86:  MOVFF  03,30D
.................... 
....................     // This socket must contain data for it to be discarded.
....................     if ( !ps->Flags.bIsGetReady )
4F8A:  MOVLW  23
4F8C:  ADDWF  x0C,W
4F8E:  MOVWF  FE9
4F90:  MOVLW  00
4F92:  ADDWFC x0D,W
4F94:  MOVWF  FEA
4F96:  BTFSC  FEF.3
4F98:  BRA    4FA0
....................         return FALSE;
4F9A:  MOVLW  00
4F9C:  MOVWF  01
4F9E:  BRA    4FBA
.................... 
....................     MACDiscardRx();
4FA0:  MOVLB  0
4FA2:  CALL   1100
....................     ps->Flags.bIsGetReady = FALSE;
4FA6:  MOVLW  23
4FA8:  MOVLB  3
4FAA:  ADDWF  x0C,W
4FAC:  MOVWF  FE9
4FAE:  MOVLW  00
4FB0:  ADDWFC x0D,W
4FB2:  MOVWF  FEA
4FB4:  BCF    FEF.3
.................... 
....................     return TRUE;
4FB6:  MOVLW  01
4FB8:  MOVWF  01
4FBA:  MOVLB  0
4FBC:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer,
....................  *                                      WORD count)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  buffer  - Buffer to hold received data.
....................  *                  count   - Buffer length
....................  *
....................  * Output:          Number of bytes loaded into buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count)
.................... {
....................     SOCKET_INFO *ps;
.................... 
....................     ps = &TCB[s];
.................... 
....................     if ( ps->Flags.bIsGetReady )
....................     {
....................         if ( ps->Flags.bFirstRead )
....................         {
....................          // Position read pointer to begining of TCP data
....................             IPSetRxBuffer(sizeof(TCP_HEADER));
.................... 
....................             ps->Flags.bFirstRead = FALSE;
....................         }
.................... 
....................         ps->Flags.bIsTxInProgress = TRUE;
.................... 
....................         return MACGetArray(buff, count);
....................     }
....................     else
....................         return 0;
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  byte    - Pointer to a byte.
....................  *
....................  * Output:          TRUE if a byte was read.
....................  *                  FALSE if byte was not read.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data)
.................... {
....................     SOCKET_INFO* ps;
.................... 
....................     ps = &TCB[s];
*
3E7A:  MOVLB  3
3E7C:  MOVF   x08,W
3E7E:  MULLW  24
3E80:  MOVF   FF3,W
3E82:  CLRF   03
3E84:  MOVWF  01
3E86:  MOVLW  01
3E88:  ADDWF  03,F
3E8A:  MOVFF  01,30B
3E8E:  MOVFF  03,30C
.................... 
....................     if ( ps->Flags.bIsGetReady )
3E92:  MOVLW  23
3E94:  ADDWF  x0B,W
3E96:  MOVWF  FE9
3E98:  MOVLW  00
3E9A:  ADDWFC x0C,W
3E9C:  MOVWF  FEA
3E9E:  BTFSS  FEF.3
3EA0:  BRA    3F40
....................     {
....................         if ( ps->Flags.bFirstRead )
3EA2:  MOVLW  23
3EA4:  ADDWF  x0B,W
3EA6:  MOVWF  FE9
3EA8:  MOVLW  00
3EAA:  ADDWFC x0C,W
3EAC:  MOVWF  FEA
3EAE:  BTFSS  FEF.2
3EB0:  BRA    3ECE
....................         {
....................             // Position read pointer to begining of correct
....................             // buffer.
....................             IPSetRxBuffer(sizeof(TCP_HEADER));
3EB2:  CLRF   x28
3EB4:  MOVLW  14
3EB6:  MOVWF  x27
3EB8:  MOVLB  0
3EBA:  CALL   209C
.................... 
....................             ps->Flags.bFirstRead = FALSE;
3EBE:  MOVLW  23
3EC0:  MOVLB  3
3EC2:  ADDWF  x0B,W
3EC4:  MOVWF  FE9
3EC6:  MOVLW  00
3EC8:  ADDWFC x0C,W
3ECA:  MOVWF  FEA
3ECC:  BCF    FEF.2
....................         }
.................... 
....................         if ( ps->RxCount == 0 )
3ECE:  MOVLW  12
3ED0:  ADDWF  x0B,W
3ED2:  MOVWF  FE9
3ED4:  MOVLW  00
3ED6:  ADDWFC x0C,W
3ED8:  MOVWF  FEA
3EDA:  MOVFF  FEC,30E
3EDE:  MOVF   FED,F
3EE0:  MOVFF  FEF,30D
3EE4:  MOVF   x0D,F
3EE6:  BNZ   3F08
3EE8:  MOVF   x0E,F
3EEA:  BNZ   3F08
....................         {
....................             MACDiscardRx();
3EEC:  MOVLB  0
3EEE:  CALL   1100
....................             ps->Flags.bIsGetReady = FALSE;
3EF2:  MOVLW  23
3EF4:  MOVLB  3
3EF6:  ADDWF  x0B,W
3EF8:  MOVWF  FE9
3EFA:  MOVLW  00
3EFC:  ADDWFC x0C,W
3EFE:  MOVWF  FEA
3F00:  BCF    FEF.3
....................             return FALSE;
3F02:  MOVLW  00
3F04:  MOVWF  01
3F06:  BRA    3F44
....................         }
.................... 
....................          ps->RxCount--;
3F08:  MOVLW  12
3F0A:  ADDWF  x0B,W
3F0C:  MOVWF  FE9
3F0E:  MOVLW  00
3F10:  ADDWFC x0C,W
3F12:  MOVWF  FEA
3F14:  MOVLW  FF
3F16:  ADDWF  FEF,F
3F18:  BC    3F1E
3F1A:  MOVF   FEE,F
3F1C:  DECF   FED,F
....................          *data = MACGet();
3F1E:  MOVFF  30A,30E
3F22:  MOVFF  309,30D
3F26:  MOVLB  0
3F28:  CALL   1F18
3F2C:  MOVFF  30E,FEA
3F30:  MOVFF  30D,FE9
3F34:  MOVFF  01,FEF
....................         return TRUE;
3F38:  MOVLW  01
3F3A:  MOVWF  01
3F3C:  MOVLB  3
3F3E:  BRA    3F44
....................     }
....................     return FALSE;
3F40:  MOVLW  00
3F42:  MOVWF  01
3F44:  MOVLB  0
3F46:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' contains any data.
....................  *                  FALSE if socket 's' does not contain any data.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPIsGetReady(TCP_SOCKET s)
.................... {
....................     /*
....................      * A socket is said to be "Get" ready when it has already
....................      * received some data.  Sometime, a socket may be closed,
....................      * but it still may contain data.  Thus in order to ensure
....................      * reuse of a socket, caller must make sure that it reads
....................      * a socket, if is ready.
....................      */
....................     return (TCB[s].Flags.bIsGetReady );
*
3E50:  MOVLB  3
3E52:  MOVF   x08,W
3E54:  MULLW  24
3E56:  MOVF   FF3,W
3E58:  CLRF   x0A
3E5A:  MOVWF  x09
3E5C:  MOVLW  23
3E5E:  ADDWF  x09,F
3E60:  MOVLW  00
3E62:  ADDWFC x0A,F
3E64:  MOVFF  309,FE9
3E68:  MOVLW  01
3E6A:  ADDWF  x0A,W
3E6C:  MOVWF  FEA
3E6E:  MOVLW  00
3E70:  BTFSC  FEF.3
3E72:  MOVLW  01
3E74:  MOVWF  01
3E76:  MOVLB  0
3E78:  RETURN 0
.................... }
.................... 
.................... //// internal functions /////
.................... 
.................... void DebugTCPDisplayState(TCP_STATE st)
.................... {
....................    switch(st)
....................    {
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break;
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break;
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break;
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break;
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break;
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break;
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break;
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break;
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break;
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break;
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break;
....................       default:                debug_tcp("UNKNOWN %U",st); break;
....................    }
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPTick(void)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           None
.................... *
.................... * Output:          Each socket FSM is executed for any timeout
.................... *                  situation.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... void TCPTick(void)
.................... {
....................    TCP_SOCKET s;
....................    TICKTYPE diffTicks;
....................    TICKTYPE tick;
....................    SOCKET_INFO* ps;
....................    DWORD seq;
....................    BYTE flags;
....................    //BYTE debugLastState;
.................... 
....................    flags = 0x00;
*
3936:  MOVLB  3
3938:  CLRF   x05
....................    // Periodically all "not closed" sockets must perform timed operations
....................    for(s = 0; s < MAX_SOCKETS; s++)
393A:  MOVLB  2
393C:  CLRF   xFA
393E:  MOVF   xFA,W
3940:  SUBLW  04
3942:  BTFSS  FD8.0
3944:  BRA    3DF8
....................    {
....................       ps = &TCB[s];
3946:  MOVF   xFA,W
3948:  MULLW  24
394A:  MOVF   FF3,W
394C:  CLRF   03
394E:  MOVWF  01
3950:  MOVLW  01
3952:  ADDWF  03,F
3954:  MOVFF  01,2FF
3958:  MOVFF  03,300
.................... 
....................       //debugLastState = TCB[s].smState;
.................... 
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress )
395C:  MOVLW  23
395E:  ADDWF  xFF,W
3960:  MOVWF  FE9
3962:  MOVLW  00
3964:  MOVLB  3
3966:  ADDWFC x00,W
3968:  MOVWF  FEA
396A:  BTFSC  FEF.3
396C:  BRA    3982
396E:  MOVLW  23
3970:  MOVLB  2
3972:  ADDWF  xFF,W
3974:  MOVWF  FE9
3976:  MOVLW  00
3978:  MOVLB  3
397A:  ADDWFC x00,W
397C:  MOVWF  FEA
397E:  BTFSS  FEF.4
3980:  BRA    3984
....................          continue;
3982:  BRA    3DF2
.................... 
.................... 
....................       // Closed or Passively Listening socket do not care
....................       // about timeout conditions.
....................       if ( (ps->smState == TCP_CLOSED) ||
....................          (ps->smState == TCP_LISTEN &&
....................          ps->Flags.bServer == TRUE) )
3984:  MOVFF  2FF,FE9
3988:  MOVLB  3
398A:  MOVFF  300,FEA
398E:  MOVF   FEF,W
3990:  SUBLW  0A
3992:  BZ    39BC
3994:  MOVFF  2FF,FE9
3998:  MOVLB  3
399A:  MOVFF  300,FEA
399E:  MOVF   FEF,F
39A0:  BNZ   39BE
39A2:  MOVLW  23
39A4:  MOVLB  2
39A6:  ADDWF  xFF,W
39A8:  MOVWF  01
39AA:  MOVLW  00
39AC:  MOVLB  3
39AE:  ADDWFC x00,W
39B0:  MOVWF  03
39B2:  MOVFF  01,FE9
39B6:  MOVWF  FEA
39B8:  BTFSS  FEF.0
39BA:  BRA    39BE
....................          continue;
39BC:  BRA    3DF2
.................... 
....................       //TODO: review this
....................       //DSR ADD 063004
....................         //i do this because if i am a server, i don't want to timeout.
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) )
39BE:  MOVFF  2FF,FE9
39C2:  MOVLB  3
39C4:  MOVFF  300,FEA
39C8:  MOVF   FEF,W
39CA:  SUBLW  03
39CC:  BNZ   39EA
39CE:  MOVLW  23
39D0:  MOVLB  2
39D2:  ADDWF  xFF,W
39D4:  MOVWF  01
39D6:  MOVLW  00
39D8:  MOVLB  3
39DA:  ADDWFC x00,W
39DC:  MOVWF  03
39DE:  MOVFF  01,FE9
39E2:  MOVWF  FEA
39E4:  BTFSS  FEF.0
39E6:  BRA    39EA
....................          continue;
39E8:  BRA    3DF2
.................... 
.................... 
....................       tick = TickGet();
39EA:  MOVLB  0
39EC:  CALL   248A
39F0:  MOVFF  02,2FE
39F4:  MOVFF  01,2FD
.................... 
....................       // Calculate timeout value for this socket.
....................       diffTicks = TickGetDiff(tick, ps->startTick);
39F8:  MOVLW  1F
39FA:  MOVLB  2
39FC:  ADDWF  xFF,W
39FE:  MOVWF  FE9
3A00:  MOVLW  00
3A02:  MOVLB  3
3A04:  ADDWFC x00,W
3A06:  MOVWF  FEA
3A08:  MOVFF  FEC,03
3A0C:  MOVF   FED,F
3A0E:  MOVFF  FEF,01
3A12:  MOVLB  2
3A14:  MOVF   xFE,W
3A16:  SUBWF  03,W
3A18:  BNC   3A22
3A1A:  BNZ   3A26
3A1C:  MOVF   01,W
3A1E:  SUBWF  xFD,W
3A20:  BNC   3A26
3A22:  MOVLW  00
3A24:  BRA    3A28
3A26:  MOVLW  01
3A28:  CLRF   03
3A2A:  IORWF  03,W
3A2C:  BZ    3A70
3A2E:  MOVLW  1F
3A30:  ADDWF  xFF,W
3A32:  MOVWF  FE9
3A34:  MOVLW  00
3A36:  MOVLB  3
3A38:  ADDWFC x00,W
3A3A:  MOVWF  FEA
3A3C:  MOVFF  FEC,03
3A40:  MOVF   FED,F
3A42:  MOVF   FEF,W
3A44:  SUBLW  FF
3A46:  MOVWF  x06
3A48:  MOVLW  FF
3A4A:  SUBFWB 03,W
3A4C:  MOVWF  x07
3A4E:  MOVLB  2
3A50:  MOVF   xFD,W
3A52:  MOVLB  3
3A54:  ADDWF  x06,F
3A56:  MOVLB  2
3A58:  MOVF   xFE,W
3A5A:  MOVLB  3
3A5C:  ADDWFC x07,F
3A5E:  MOVLW  01
3A60:  ADDWF  x06,W
3A62:  MOVWF  01
3A64:  MOVLW  00
3A66:  ADDWFC x07,W
3A68:  MOVWF  03
3A6A:  MOVF   01,W
3A6C:  BRA    3A94
3A6E:  MOVLB  2
3A70:  MOVLW  1F
3A72:  ADDWF  xFF,W
3A74:  MOVWF  FE9
3A76:  MOVLW  00
3A78:  MOVLB  3
3A7A:  ADDWFC x00,W
3A7C:  MOVWF  FEA
3A7E:  MOVFF  FEC,03
3A82:  MOVF   FED,F
3A84:  MOVF   FEF,W
3A86:  MOVLB  2
3A88:  SUBWF  xFD,W
3A8A:  MOVWF  00
3A8C:  MOVF   03,W
3A8E:  SUBWFB xFE,W
3A90:  MOVWF  03
3A92:  MOVF   00,W
3A94:  MOVLB  2
3A96:  MOVWF  xFB
3A98:  MOVFF  03,2FC
.................... 
....................       // If timeout has not occured, do not do anything.
....................       if(diffTicks <= ps->TimeOut)
3A9C:  MOVLW  21
3A9E:  ADDWF  xFF,W
3AA0:  MOVWF  FE9
3AA2:  MOVLW  00
3AA4:  MOVLB  3
3AA6:  ADDWFC x00,W
3AA8:  MOVWF  FEA
3AAA:  MOVFF  FEC,03
3AAE:  MOVF   FED,F
3AB0:  MOVFF  FEF,01
3AB4:  MOVLB  2
3AB6:  MOVF   xFC,W
3AB8:  SUBWF  03,W
3ABA:  BNC   3ACA
3ABC:  BNZ   3AC4
3ABE:  MOVF   xFB,W
3AC0:  SUBWF  01,W
3AC2:  BNC   3ACA
....................          continue;
3AC4:  MOVLB  3
3AC6:  BRA    3DF2
3AC8:  MOVLB  2
.................... 
....................       // Most states require retransmission, so check for transmitter
....................       // availability right here - common for all.
....................       if(!IPIsTxReady(TRUE))
3ACA:  MOVLW  01
3ACC:  MOVLB  3
3ACE:  MOVWF  x89
3AD0:  MOVLB  0
3AD2:  CALL   2598
3AD6:  MOVF   01,F
3AD8:  BNZ   3ADC
....................          return;
3ADA:  BRA    3DF8
.................... 
....................       // Restart timeout reference.
....................       ps->startTick = TickGet();
3ADC:  MOVLW  1F
3ADE:  MOVLB  2
3AE0:  ADDWF  xFF,W
3AE2:  MOVWF  01
3AE4:  MOVLW  00
3AE6:  MOVLB  3
3AE8:  ADDWFC x00,W
3AEA:  MOVWF  03
3AEC:  MOVFF  01,306
3AF0:  MOVWF  x07
3AF2:  MOVLB  0
3AF4:  CALL   248A
3AF8:  MOVFF  307,FEA
3AFC:  MOVFF  306,FE9
3B00:  MOVFF  02,FEC
3B04:  MOVF   FED,F
3B06:  MOVFF  01,FEF
.................... 
....................       // Update timeout value if there is need to wait longer.
....................       ps->TimeOut <<= 1;
3B0A:  MOVLW  21
3B0C:  MOVLB  2
3B0E:  ADDWF  xFF,W
3B10:  MOVWF  FE9
3B12:  MOVLW  00
3B14:  MOVLB  3
3B16:  ADDWFC x00,W
3B18:  MOVWF  FEA
3B1A:  BCF    FD8.0
3B1C:  RLCF   FEF,W
3B1E:  MOVWF  02
3B20:  RLCF   FEC,W
3B22:  MOVWF  03
3B24:  MOVF   02,W
3B26:  MOVF   FED,F
3B28:  MOVWF  FEF
3B2A:  MOVFF  03,FEC
.................... 
....................       // This will be one more attempt.
....................       ps->RetryCount++;
3B2E:  MOVLW  1E
3B30:  MOVLB  2
3B32:  ADDWF  xFF,W
3B34:  MOVWF  FE9
3B36:  MOVLW  00
3B38:  MOVLB  3
3B3A:  ADDWFC x00,W
3B3C:  MOVWF  FEA
3B3E:  INCF   FEF,F
.................... 
....................       // A timeout has occured.  Respond to this timeout condition
....................       // depending on what state this socket is in.
....................       switch(ps->smState)
3B40:  MOVFF  2FF,FE9
3B44:  MOVLB  3
3B46:  MOVFF  300,FEA
3B4A:  MOVLW  01
3B4C:  SUBWF  FEF,W
3B4E:  ADDLW  F7
3B50:  BTFSC  FD8.0
3B52:  BRA    3D00
3B54:  ADDLW  09
3B56:  MOVLB  0
3B58:  GOTO   3DFE
....................       {
....................       case TCP_SYN_SENT:
....................          // Keep sending SYN until we hear from remote node.
....................          // This may be for infinite time, in that case
....................          // caller must detect it and do something.
....................          // Bug Fix: 11/1/02
....................          flags = SYN;
3B5C:  MOVLW  02
3B5E:  MOVLB  3
3B60:  MOVWF  x05
....................          break;
3B62:  BRA    3D00
.................... 
....................       case TCP_SYN_RECEIVED:
....................          // We must receive ACK before timeout expires.
....................          // If not, resend SYN+ACK.
....................          // Abort, if maximum attempts counts are reached.
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3B64:  MOVLW  1E
3B66:  MOVLB  2
3B68:  ADDWF  xFF,W
3B6A:  MOVWF  FE9
3B6C:  MOVLW  00
3B6E:  MOVLB  3
3B70:  ADDWFC x00,W
3B72:  MOVWF  FEA
3B74:  MOVF   FEF,W
3B76:  SUBLW  03
3B78:  BNC   3B80
....................          {
....................             flags = SYN | ACK;
3B7A:  MOVLW  12
3B7C:  MOVWF  x05
....................          }
3B7E:  BRA    3BB4
....................          else
....................          {
....................             if(ps->Flags.bServer)
3B80:  MOVLW  23
3B82:  MOVLB  2
3B84:  ADDWF  xFF,W
3B86:  MOVWF  FE9
3B88:  MOVLW  00
3B8A:  MOVLB  3
3B8C:  ADDWFC x00,W
3B8E:  MOVWF  FEA
3B90:  BTFSS  FEF.0
3B92:  BRA    3BA2
....................             {
....................                ps->smState = TCP_LISTEN;
3B94:  MOVFF  2FF,FE9
3B98:  MOVLB  3
3B9A:  MOVFF  300,FEA
3B9E:  CLRF   FEF
....................             }
3BA0:  BRA    3BB4
....................             else
....................             {
....................                flags = SYN;
3BA2:  MOVLW  02
3BA4:  MOVWF  x05
....................                ps->smState = TCP_SYN_SENT;
3BA6:  MOVFF  2FF,FE9
3BAA:  MOVLB  3
3BAC:  MOVFF  300,FEA
3BB0:  MOVLW  01
3BB2:  MOVWF  FEF
....................             }
....................          }
....................          break;
3BB4:  BRA    3D00
.................... 
....................       case TCP_ESTABLISHED:
.................... #if !TCP_NO_WAIT_FOR_ACK
....................          // Don't let this connection idle for very long time.
....................          // If we did not receive or send any message before timeout
....................          // expires, close this connection.
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3BB6:  MOVLW  1E
3BB8:  MOVLB  2
3BBA:  ADDWF  xFF,W
3BBC:  MOVWF  FE9
3BBE:  MOVLW  00
3BC0:  MOVLB  3
3BC2:  ADDWFC x00,W
3BC4:  MOVWF  FEA
3BC6:  MOVF   FEF,W
3BC8:  SUBLW  03
3BCA:  BNC   3C12
....................          {
....................             if(ps->TxBuffer != INVALID_BUFFER)
3BCC:  MOVLW  0F
3BCE:  MOVLB  2
3BD0:  ADDWF  xFF,W
3BD2:  MOVWF  FE9
3BD4:  MOVLW  00
3BD6:  MOVLB  3
3BD8:  ADDWFC x00,W
3BDA:  MOVWF  FEA
3BDC:  INCFSZ FEF,W
3BDE:  BRA    3BE2
3BE0:  BRA    3C08
....................             {
....................                MACSetTxBuffer(ps->TxBuffer, 0);
3BE2:  MOVLW  0F
3BE4:  MOVLB  2
3BE6:  ADDWF  xFF,W
3BE8:  MOVWF  FE9
3BEA:  MOVLW  00
3BEC:  MOVLB  3
3BEE:  ADDWFC x00,W
3BF0:  MOVWF  FEA
3BF2:  MOVFF  FEF,3A2
3BF6:  CLRF   xA4
3BF8:  CLRF   xA3
3BFA:  MOVLB  0
3BFC:  CALL   1506
....................                MACFlush();
3C00:  CALL   16D0
....................             }
3C04:  BRA    3C0E
3C06:  MOVLB  3
....................             else
....................                flags = ACK;
3C08:  MOVLW  10
3C0A:  MOVWF  x05
3C0C:  MOVLB  0
....................          }
3C0E:  BRA    3C68
3C10:  MOVLB  3
....................          else
....................          {
....................             // Forget about previous transmission.
....................             if(ps->TxBuffer != INVALID_BUFFER)
3C12:  MOVLW  0F
3C14:  MOVLB  2
3C16:  ADDWF  xFF,W
3C18:  MOVWF  FE9
3C1A:  MOVLW  00
3C1C:  MOVLB  3
3C1E:  ADDWFC x00,W
3C20:  MOVWF  FEA
3C22:  INCFSZ FEF,W
3C24:  BRA    3C28
3C26:  BRA    3C54
....................             {
....................                MACDiscardTx(ps->TxBuffer);
3C28:  MOVLW  0F
3C2A:  MOVLB  2
3C2C:  ADDWF  xFF,W
3C2E:  MOVWF  FE9
3C30:  MOVLW  00
3C32:  MOVLB  3
3C34:  ADDWFC x00,W
3C36:  MOVWF  FEA
3C38:  MOVFF  FEF,347
3C3C:  MOVLB  0
3C3E:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER;
3C42:  MOVLW  0F
3C44:  MOVLB  2
3C46:  ADDWF  xFF,W
3C48:  MOVWF  FE9
3C4A:  MOVLW  00
3C4C:  MOVLB  3
3C4E:  ADDWFC x00,W
3C50:  MOVWF  FEA
3C52:  SETF   FEF
....................             }
.................... 
.................... #endif
....................             // Request closure.
....................             flags = FIN | ACK;
3C54:  MOVLW  11
3C56:  MOVWF  x05
....................             //DebugPrint("!");
.................... 
....................             ps->smState = TCP_FIN_WAIT_1;
3C58:  MOVFF  2FF,FE9
3C5C:  MOVLB  3
3C5E:  MOVFF  300,FEA
3C62:  MOVLW  04
3C64:  MOVWF  FEF
3C66:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK
....................          }
.................... #endif
....................          break;
3C68:  MOVLB  3
3C6A:  BRA    3D00
.................... 
....................       case TCP_FIN_WAIT_1:
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3C6C:  MOVLW  1E
3C6E:  MOVLB  2
3C70:  ADDWF  xFF,W
3C72:  MOVWF  FE9
3C74:  MOVLW  00
3C76:  MOVLB  3
3C78:  ADDWFC x00,W
3C7A:  MOVWF  FEA
3C7C:  MOVF   FEF,W
3C7E:  SUBLW  03
3C80:  BNC   3C88
....................          {
....................                // Send another FIN
....................                flags = FIN;
3C82:  MOVLW  01
3C84:  MOVWF  x05
....................          }
3C86:  BRA    3C98
....................          else
....................          {
....................             // Close on our own, we can't seem to communicate
....................             // with the remote node anymore
....................             CloseSocket(ps);
3C88:  MOVFF  300,345
3C8C:  MOVFF  2FF,344
3C90:  MOVLB  0
3C92:  CALL   24A4
3C96:  MOVLB  3
....................          }
....................          break;
3C98:  BRA    3D00
.................... 
....................       case TCP_FIN_WAIT_2:
....................       case TCP_CLOSING:
....................          // Close on our own, we can't seem to communicate
....................          // with the remote node anymore
....................          CloseSocket(ps);
3C9A:  MOVFF  300,345
3C9E:  MOVFF  2FF,344
3CA2:  CALL   24A4
....................          break;
3CA6:  MOVLB  3
3CA8:  BRA    3D00
.................... 
....................       case TCP_TIME_WAIT:
....................          // Wait around for a while (2MSL) and then goto closed state
....................          CloseSocket(ps);
3CAA:  MOVFF  300,345
3CAE:  MOVFF  2FF,344
3CB2:  CALL   24A4
....................          break;
3CB6:  MOVLB  3
3CB8:  BRA    3D00
.................... 
....................       case TCP_CLOSE_WAIT:
....................          flags = FIN;
3CBA:  MOVLW  01
3CBC:  MOVLB  3
3CBE:  MOVWF  x05
....................          ps->smState = TCP_LAST_ACK;
3CC0:  MOVFF  2FF,FE9
3CC4:  MOVLB  3
3CC6:  MOVFF  300,FEA
3CCA:  MOVLW  09
3CCC:  MOVWF  FEF
....................          break;
3CCE:  BRA    3D00
.................... 
....................       case TCP_LAST_ACK:
....................          // Send some more FINs or close anyway
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3CD0:  MOVLW  1E
3CD2:  MOVLB  2
3CD4:  ADDWF  xFF,W
3CD6:  MOVWF  FE9
3CD8:  MOVLW  00
3CDA:  MOVLB  3
3CDC:  ADDWFC x00,W
3CDE:  MOVWF  FEA
3CE0:  MOVF   FEF,W
3CE2:  SUBLW  03
3CE4:  BNC   3CEC
....................             flags = FIN;
3CE6:  MOVLW  01
3CE8:  MOVWF  x05
3CEA:  BRA    3CFC
....................          else
....................             CloseSocket(ps);
3CEC:  MOVFF  300,345
3CF0:  MOVFF  2FF,344
3CF4:  MOVLB  0
3CF6:  CALL   24A4
3CFA:  MOVLB  3
....................          break;
3CFC:  BRA    3D00
3CFE:  MOVLB  3
....................       }
.................... 
.................... 
....................       if(flags)
3D00:  MOVF   x05,F
3D02:  BZ    3DF2
....................       {
....................          if(flags & ACK)
3D04:  BTFSS  x05.4
3D06:  BRA    3D2A
....................             seq = ps->SND_SEQ;
3D08:  MOVLW  16
3D0A:  MOVLB  2
3D0C:  ADDWF  xFF,W
3D0E:  MOVWF  FE9
3D10:  MOVLW  00
3D12:  MOVLB  3
3D14:  ADDWFC x00,W
3D16:  MOVWF  FEA
3D18:  MOVFF  FEF,301
3D1C:  MOVFF  FEC,302
3D20:  MOVFF  FEC,303
3D24:  MOVFF  FEC,304
3D28:  BRA    3D5C
....................          else
....................             seq = ps->SND_SEQ++;
3D2A:  MOVLW  16
3D2C:  MOVLB  2
3D2E:  ADDWF  xFF,W
3D30:  MOVWF  FE9
3D32:  MOVLW  00
3D34:  MOVLB  3
3D36:  ADDWFC x00,W
3D38:  MOVWF  FEA
3D3A:  MOVF   FEE,F
3D3C:  MOVF   FEE,F
3D3E:  MOVF   FEE,F
3D40:  MOVFF  FED,304
3D44:  MOVFF  FED,303
3D48:  MOVFF  FED,302
3D4C:  MOVFF  FEF,301
3D50:  MOVLW  01
3D52:  ADDWF  FEE,F
3D54:  MOVLW  00
3D56:  ADDWFC FEE,F
3D58:  ADDWFC FEE,F
3D5A:  ADDWFC FED,F
.................... 
....................          SendTCP(&ps->remote,
....................             ps->localPort,
....................             ps->remotePort,
....................             seq,
....................             ps->SND_ACK,
....................             flags);
3D5C:  MOVLW  01
3D5E:  MOVLB  2
3D60:  ADDWF  xFF,W
3D62:  MOVWF  01
3D64:  MOVLW  00
3D66:  MOVLB  3
3D68:  ADDWFC x00,W
3D6A:  MOVWF  03
3D6C:  MOVFF  01,306
3D70:  MOVFF  03,307
3D74:  MOVLW  0B
3D76:  MOVLB  2
3D78:  ADDWF  xFF,W
3D7A:  MOVWF  FE9
3D7C:  MOVLW  00
3D7E:  MOVLB  3
3D80:  ADDWFC x00,W
3D82:  MOVWF  FEA
3D84:  MOVFF  FEC,354
3D88:  MOVF   FED,F
3D8A:  MOVFF  FEF,353
3D8E:  MOVLW  0D
3D90:  MOVLB  2
3D92:  ADDWF  xFF,W
3D94:  MOVWF  FE9
3D96:  MOVLW  00
3D98:  MOVLB  3
3D9A:  ADDWFC x00,W
3D9C:  MOVWF  FEA
3D9E:  MOVFF  FEC,356
3DA2:  MOVF   FED,F
3DA4:  MOVFF  FEF,355
3DA8:  MOVLW  1A
3DAA:  MOVLB  2
3DAC:  ADDWF  xFF,W
3DAE:  MOVWF  FE9
3DB0:  MOVLW  00
3DB2:  MOVLB  3
3DB4:  ADDWFC x00,W
3DB6:  MOVWF  FEA
3DB8:  MOVFF  FEF,35B
3DBC:  MOVFF  FEC,35C
3DC0:  MOVFF  FEC,35D
3DC4:  MOVFF  FEC,35E
3DC8:  MOVFF  03,352
3DCC:  MOVFF  306,351
3DD0:  MOVFF  304,35A
3DD4:  MOVFF  303,359
3DD8:  MOVFF  302,358
3DDC:  MOVFF  301,357
3DE0:  MOVFF  305,35F
3DE4:  SETF   x60
3DE6:  CLRF   x62
3DE8:  CLRF   x61
3DEA:  MOVLB  0
3DEC:  CALL   28D0
3DF0:  MOVLB  3
....................       }
3DF2:  MOVLB  2
3DF4:  INCF   xFA,F
3DF6:  BRA    393E
3DF8:  MOVLB  0
.................... 
....................       /*if (debugLastState != ps->smState)
....................       {
....................          debug_tcp("\r\nTCP TICK %u - ", s);
....................          DebugTCPDisplayState(debugLastState);
....................          debug_tcp(" -> ");
....................          DebugTCPDisplayState(ps->smState);
....................       }*/
....................    }
3DFA:  GOTO   6DD4 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote,
.................... *                                  IP_ADDR *localIP,
.................... *                                  WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCP segment is ready in MAC buffer
.................... *
.................... * Input:           remote      - Remote node info
.................... *                  len         - Total length of TCP semgent.
.................... *
.................... * Output:          TRUE if this function has completed its task
.................... *                  FALSE otherwise
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len)
.................... {
....................    TCP_HEADER      TCPHeader;
....................    PSEUDO_HEADER   pseudoHeader;
....................    TCP_SOCKET      socket;
....................    WORD_VAL        checksum1;
....................    WORD_VAL        checksum2;
....................    BYTE            optionsSize;
....................   
....................    // Calculate IP pseudoheader checksum.
....................    pseudoHeader.SourceAddress      = remote->IPAddr;
*
34EC:  MOVLW  06
34EE:  MOVLB  2
34F0:  ADDWF  xFA,W
34F2:  MOVWF  FE9
34F4:  MOVLW  00
34F6:  ADDWFC xFB,W
34F8:  MOVWF  FEA
34FA:  MOVFF  FEF,314
34FE:  MOVFF  FEC,315
3502:  MOVFF  FEC,316
3506:  MOVFF  FEC,317
....................    pseudoHeader.DestAddress        = *localIP;
350A:  MOVFF  2FD,FEA
350E:  MOVFF  2FC,FE9
3512:  MOVFF  FEF,318
3516:  MOVFF  FEC,319
351A:  MOVFF  FEC,31A
351E:  MOVFF  FEC,31B
....................    pseudoHeader.Zero               = 0x0;
3522:  MOVLB  3
3524:  CLRF   x1C
....................    pseudoHeader.Protocol           = IP_PROT_TCP;
3526:  MOVLW  06
3528:  MOVWF  x1D
....................    pseudoHeader.TCPLength          = len;
352A:  MOVFF  2FF,31F
352E:  MOVFF  2FE,31E
.................... 
....................    SwapPseudoTCPHeader(pseudoHeader);
3532:  MOVFF  31F,3A9
3536:  MOVFF  31E,3A8
353A:  MOVLB  0
353C:  CALL   11CC
3540:  MOVFF  02,31F
3544:  MOVFF  01,31E
.................... 
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader,
....................       sizeof(pseudoHeader));
3548:  MOVLW  03
354A:  MOVLB  3
354C:  MOVWF  x27
354E:  MOVLW  14
3550:  MOVWF  x26
3552:  MOVFF  327,38C
3556:  MOVWF  x8B
3558:  CLRF   x8E
355A:  MOVLW  0C
355C:  MOVWF  x8D
355E:  MOVLB  0
3560:  CALL   1E2A
3564:  MOVFF  01,321
3568:  MOVLB  3
356A:  COMF   x21,F
356C:  MOVFF  02,322
3570:  COMF   x22,F
.................... 
.................... 
....................    // Now calculate TCP packet checksum in NIC RAM - should match
....................    // pesudo header checksum
....................    checksum2.Val = CalcIPBufferChecksum(len);
3572:  MOVFF  2FF,38A
3576:  MOVFF  2FE,389
357A:  MOVLB  0
357C:  CALL   1F44
3580:  MOVFF  02,324
3584:  MOVFF  01,323
.................... 
....................    // Compare checksums.  Note that the endianness is different.
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0])
3588:  MOVLB  3
358A:  MOVF   x24,W
358C:  SUBWF  x21,W
358E:  BNZ   3596
3590:  MOVF   x23,W
3592:  SUBWF  x22,W
3594:  BZ    35A4
....................    {
....................       MACDiscardRx();
3596:  MOVLB  0
3598:  CALL   1100
....................       return TRUE;
359C:  MOVLW  01
359E:  MOVWF  01
35A0:  BRA    3684
35A2:  MOVLB  3
....................    }
.................... 
....................    // Retrieve TCP header.
....................    IPSetRxBuffer(0);
35A4:  CLRF   x28
35A6:  CLRF   x27
35A8:  MOVLB  0
35AA:  CALL   209C
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader));
35AE:  MOVLW  03
35B0:  MOVLB  3
35B2:  MOVWF  x27
35B4:  MOVWF  x98
35B6:  CLRF   x97
35B8:  CLRF   x9A
35BA:  MOVLW  14
35BC:  MOVWF  x99
35BE:  MOVLB  0
35C0:  CALL   116C
....................    SwapTCPHeader(&TCPHeader);
35C4:  MOVLW  03
35C6:  MOVLB  3
35C8:  MOVWF  x8A
35CA:  CLRF   x89
35CC:  MOVLB  0
35CE:  CALL   20D8
.................... 
.................... 
....................    // Skip over options and retrieve all data bytes.
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)-
....................       sizeof(TCPHeader));
35D2:  MOVLB  3
35D4:  MOVFF  30C,00
35D8:  SWAPF  00,W
35DA:  ANDLW  0F
35DC:  MOVWF  00
35DE:  RLCF   00,F
35E0:  RLCF   00,F
35E2:  MOVLW  FC
35E4:  ANDWF  00,F
35E6:  MOVF   00,W
35E8:  ADDLW  EC
35EA:  MOVWF  x25
....................    len = len - optionsSize - sizeof(TCPHeader);
35EC:  MOVF   x25,W
35EE:  MOVLB  2
35F0:  SUBWF  xFE,W
35F2:  MOVLB  3
35F4:  MOVWF  x26
35F6:  MOVLW  00
35F8:  MOVLB  2
35FA:  SUBWFB xFF,W
35FC:  MOVLB  3
35FE:  MOVWF  x27
3600:  MOVLW  14
3602:  SUBWF  x26,W
3604:  MOVLB  2
3606:  MOVWF  xFE
3608:  MOVLW  00
360A:  MOVLB  3
360C:  SUBWFB x27,W
360E:  MOVLB  2
3610:  MOVWF  xFF
.................... 
....................    // Position packet read pointer to start of data area.
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2));
3612:  MOVLB  3
3614:  MOVFF  30C,00
3618:  SWAPF  00,W
361A:  ANDLW  0F
361C:  MOVWF  00
361E:  RLCF   00,W
3620:  MOVWF  x26
3622:  RLCF   x26,F
3624:  MOVLW  FC
3626:  ANDWF  x26,F
3628:  CLRF   x28
362A:  MOVFF  326,327
362E:  MOVLB  0
3630:  CALL   209C
.................... 
....................    // Find matching socket.
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote);
3634:  MOVLW  03
3636:  MOVLB  3
3638:  MOVWF  x27
363A:  CLRF   x26
363C:  MOVFF  2FB,329
3640:  MOVFF  2FA,328
3644:  MOVLB  0
3646:  GOTO   22B0
364A:  MOVFF  01,320
....................    if(socket != INVALID_SOCKET)
364E:  MOVLB  3
3650:  MOVF   x20,W
3652:  SUBLW  FE
3654:  BZ    367A
....................    {
....................       HandleTCPSeg(socket, remote, &TCPHeader, len);
3656:  MOVFF  320,326
365A:  MOVFF  2FB,328
365E:  MOVFF  2FA,327
3662:  MOVLW  03
3664:  MOVWF  x2A
3666:  CLRF   x29
3668:  MOVFF  2FF,32C
366C:  MOVFF  2FE,32B
3670:  MOVLB  0
3672:  GOTO   2AF4
....................    }
3676:  BRA    3680
3678:  MOVLB  3
....................    else
....................    {
....................       // If this is an unknown socket, or we don't have any
....................       // listening sockets available, discard it we can't
....................       // process it right now
....................       MACDiscardRx();
367A:  MOVLB  0
367C:  CALL   1100
.................... 
.................... //      // Send a RESET to the remote node is it knows that we
.................... //      // are not available
.................... //      TCPHeader.AckNumber += len;
.................... //      if( TCPHeader.Flags.bits.flagSYN ||
.................... //         TCPHeader.Flags.bits.flagFIN )
.................... //         TCPHeader.AckNumber++;
.................... //
.................... //      SendTCP(remote,
.................... //         TCPHeader.DestPort,
.................... //         TCPHeader.SourcePort,
.................... //         TCPHeader.AckNumber,
.................... //         TCPHeader.SeqNumber,
.................... //         RST);
....................    }
.................... 
....................    return TRUE;
3680:  MOVLW  01
3682:  MOVWF  01
3684:  GOTO   6D24 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        static void TransmitTCP(NODE_INFO* remote
.................... *                                          TCP_PORT localPort,
.................... *                                          TCP_PORT remotePort,
.................... *                                          DWORD seq,
.................... *                                          DWORD ack,
.................... *                                          BYTE flags,
.................... *                                          BUFFER buffer,
.................... *                                          WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPIsPutReady() == TRUE
.................... *
.................... * Input:           remote      - Remote node info
.................... *                  localPort   - Source port number
.................... *                  remotePort  - Destination port number
.................... *                  seq         - Segment sequence number
.................... *                  ack         - Segment acknowledge number
.................... *                  flags       - Segment flags
.................... *                  buffer      - Buffer to which this segment
.................... *                                is to be transmitted
.................... *                  len         - Total data length for this segment.
.................... *
.................... * Output:          A TCP segment is assembled and put to transmit.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... static void TransmitTCP(NODE_INFO *remote,
....................                   TCP_PORT localPort,
....................                   TCP_PORT remotePort,
....................                   DWORD tseq,
....................                   DWORD tack,
....................                   BYTE flags,
....................                   BUFFER buff,
....................                   WORD len)
.................... {
....................    WORD_VAL        checkSum;
....................    TCP_HEADER      header;
....................    TCP_OPTIONS     options;
....................    PSEUDO_HEADER   pseudoHeader;
.................... 
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X",
....................       localPort,
....................       remotePort,
....................       tseq,
....................       tack,
....................       len,
....................       flags
....................    );
.................... 
....................    //  Make sure that this Tx buffer isn't currently being transmitted
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false
*
28D0:  MOVLW  01
28D2:  MOVLB  3
28D4:  MOVWF  x89
28D6:  MOVLB  0
28D8:  RCALL  2598
28DA:  MOVF   01,F
28DC:  BZ    28D0
.................... 
....................    // Obtain an AutoFree buffer if this packet is a control packet
....................    // only (contains no application data in an already allocated
....................    // buffer)
....................    if(buff == INVALID_BUFFER)
28DE:  MOVLB  3
28E0:  INCFSZ x60,W
28E2:  BRA    28F4
....................       buff = MACGetTxBuffer(TRUE);
28E4:  MOVLW  01
28E6:  MOVWF  x89
28E8:  MOVLB  0
28EA:  CALL   14DE
28EE:  MOVFF  01,360
28F2:  MOVLB  3
.................... 
....................    if(buff == INVALID_BUFFER)
28F4:  INCFSZ x60,W
28F6:  BRA    28FA
....................       return;
28F8:  BRA    2AF0
.................... 
....................    IPSetTxBuffer(buff, 0);
28FA:  MOVFF  360,3A2
28FE:  CLRF   xA4
2900:  MOVLW  14
2902:  MOVWF  xA3
2904:  MOVLB  0
2906:  CALL   1506
.................... 
....................    header.SourcePort           = localPort;
290A:  MOVFF  354,366
290E:  MOVFF  353,365
....................    header.DestPort             = remotePort;
2912:  MOVFF  356,368
2916:  MOVFF  355,367
....................    header.SeqNumber            = tseq;
291A:  MOVFF  35A,36C
291E:  MOVFF  359,36B
2922:  MOVFF  358,36A
2926:  MOVFF  357,369
....................    header.AckNumber            = tack;
292A:  MOVFF  35E,370
292E:  MOVFF  35D,36F
2932:  MOVFF  35C,36E
2936:  MOVFF  35B,36D
....................    header.Flags.bits.Reserved2 = 0;
293A:  MOVLW  3F
293C:  MOVLB  3
293E:  ANDWF  x72,W
2940:  MOVWF  x72
....................    header.DataOffset.Reserved3 = 0;
2942:  MOVLW  F0
2944:  ANDWF  x71,W
2946:  MOVWF  x71
....................    header.Flags.b              = flags;
2948:  MOVFF  35F,372
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20)
....................    //                  - ETHERNET header (14 if using NIC) .
....................    header.Window               = MACGetFreeRxSize();
294C:  MOVLB  0
294E:  BRA    25C0
2950:  MOVFF  02,374
2954:  MOVFF  01,373
.................... #if !defined(STACK_USE_SLIP)
....................    /*
....................    * Limit one segment at a time from remote host.
....................    * This limit increases overall throughput as remote host does not
....................    * flood us with packets and later retry with significant delay.
....................    */
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE )
....................       header.Window = MAC_RX_BUFFER_SIZE;
.................... 
....................    else if ( header.Window > 54 )
....................    {
....................       header.Window -= 54;
....................    }
....................    else
....................       header.Window = 0;
.................... #else
....................    if ( header.Window > 40 )
2958:  MOVLB  3
295A:  MOVF   x74,F
295C:  BNZ   2964
295E:  MOVF   x73,W
2960:  SUBLW  28
2962:  BC    296E
....................    {
....................       header.Window -= 40;
2964:  MOVLW  28
2966:  SUBWF  x73,F
2968:  MOVLW  00
296A:  SUBWFB x74,F
....................    }
296C:  BRA    2972
....................    else
....................       header.Window = 0;
296E:  CLRF   x74
2970:  CLRF   x73
.................... #endif
.................... 
....................    header.Checksum             = 0;
2972:  CLRF   x76
2974:  CLRF   x75
....................    header.UrgentPointer        = 0;
2976:  CLRF   x78
2978:  CLRF   x77
.................... 
....................    SwapTCPHeader(&header);
297A:  MOVLW  03
297C:  MOVWF  x8A
297E:  MOVLW  65
2980:  MOVWF  x89
2982:  MOVLB  0
2984:  CALL   20D8
.................... 
....................    len += sizeof(header);
2988:  MOVLW  14
298A:  MOVLB  3
298C:  ADDWF  x61,F
298E:  MOVLW  00
2990:  ADDWFC x62,F
.................... 
....................    if ( flags & SYN )
2992:  BTFSS  x5F.1
2994:  BRA    29B4
....................    {
....................       len += sizeof(options);
2996:  MOVLW  04
2998:  ADDWF  x61,F
299A:  MOVLW  00
299C:  ADDWFC x62,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
299E:  MOVLW  02
29A0:  MOVWF  x79
....................       options.Length = 0x04;
29A2:  MOVLW  04
29A4:  MOVWF  x7A
.................... 
....................       // Load MSS in already swapped order.
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05;
29A6:  MOVWF  x7B
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4;
29A8:  CLRF   x7C
.................... 
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2;
29AA:  MOVLW  0F
29AC:  ANDWF  x71,W
29AE:  IORLW  60
29B0:  MOVWF  x71
....................    }
29B2:  BRA    29BC
....................    else
....................       header.DataOffset.Val   = sizeof(header) >> 2;
29B4:  MOVLW  0F
29B6:  ANDWF  x71,W
29B8:  IORLW  50
29BA:  MOVWF  x71
.................... 
.................... 
....................    // Calculate IP pseudoheader checksum.
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr;
29BC:  MOVFF  20,380
29C0:  MOVFF  1F,37F
29C4:  MOVFF  1E,37E
29C8:  MOVFF  1D,37D
....................    pseudoHeader.DestAddress    = remote->IPAddr;
29CC:  MOVLW  06
29CE:  ADDWF  x51,W
29D0:  MOVWF  FE9
29D2:  MOVLW  00
29D4:  ADDWFC x52,W
29D6:  MOVWF  FEA
29D8:  MOVFF  FEF,381
29DC:  MOVFF  FEC,382
29E0:  MOVFF  FEC,383
29E4:  MOVFF  FEC,384
....................    pseudoHeader.Zero           = 0x0;
29E8:  CLRF   x85
....................    pseudoHeader.Protocol       = IP_PROT_TCP;
29EA:  MOVLW  06
29EC:  MOVWF  x86
....................    pseudoHeader.TCPLength      = len;
29EE:  MOVFF  362,388
29F2:  MOVFF  361,387
.................... 
....................    SwapPseudoTCPHeader(pseudoHeader);
29F6:  MOVFF  388,3A9
29FA:  MOVFF  387,3A8
29FE:  MOVLB  0
2A00:  CALL   11CC
2A04:  MOVFF  02,388
2A08:  MOVFF  01,387
.................... 
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader,
....................       sizeof(pseudoHeader));
2A0C:  MOVLW  03
2A0E:  MOVLB  3
2A10:  MOVWF  x8A
2A12:  MOVLW  7D
2A14:  MOVWF  x89
2A16:  MOVFF  38A,38C
2A1A:  MOVWF  x8B
2A1C:  CLRF   x8E
2A1E:  MOVLW  0C
2A20:  MOVWF  x8D
2A22:  MOVLB  0
2A24:  CALL   1E2A
2A28:  MOVFF  01,375
2A2C:  MOVLB  3
2A2E:  COMF   x75,F
2A30:  MOVFF  02,376
2A34:  COMF   x76,F
....................    checkSum.Val = header.Checksum;
2A36:  MOVFF  376,364
2A3A:  MOVFF  375,363
.................... 
....................    // Write IP header.
....................    IPPutHeader(remote, IP_PROT_TCP, len);
2A3E:  MOVFF  352,38A
2A42:  MOVFF  351,389
2A46:  MOVLW  06
2A48:  MOVWF  x8B
2A4A:  MOVFF  362,38D
2A4E:  MOVFF  361,38C
2A52:  MOVLB  0
2A54:  RCALL  27B0
....................    IPPutArray((BYTE*)&header, sizeof(header));
2A56:  MOVLW  03
2A58:  MOVLB  3
2A5A:  MOVWF  x8A
2A5C:  MOVLW  65
2A5E:  MOVWF  x89
2A60:  MOVFF  38A,3AE
2A64:  MOVWF  xAD
2A66:  CLRF   xB0
2A68:  MOVLW  14
2A6A:  MOVWF  xAF
2A6C:  MOVLB  0
2A6E:  CALL   15C2
.................... 
....................    if ( flags & SYN )
2A72:  MOVLB  3
2A74:  BTFSS  x5F.1
2A76:  BRA    2A94
....................       IPPutArray((BYTE*)&options, sizeof(options));
2A78:  MOVLW  03
2A7A:  MOVWF  x8A
2A7C:  MOVLW  79
2A7E:  MOVWF  x89
2A80:  MOVFF  38A,3AE
2A84:  MOVWF  xAD
2A86:  CLRF   xB0
2A88:  MOVLW  04
2A8A:  MOVWF  xAF
2A8C:  MOVLB  0
2A8E:  CALL   15C2
2A92:  MOVLB  3
.................... 
....................    IPSetTxBuffer(buff, 0);
2A94:  MOVFF  360,3A2
2A98:  CLRF   xA4
2A9A:  MOVLW  14
2A9C:  MOVWF  xA3
2A9E:  MOVLB  0
2AA0:  CALL   1506
.................... 
....................    checkSum.Val = CalcIPBufferChecksum(len);
2AA4:  MOVFF  362,38A
2AA8:  MOVFF  361,389
2AAC:  CALL   1F44
2AB0:  MOVFF  02,364
2AB4:  MOVFF  01,363
.................... 
....................    // Update the checksum.
....................    IPSetTxBuffer(buff, 16);
2AB8:  MOVFF  360,3A2
2ABC:  MOVLB  3
2ABE:  CLRF   xA4
2AC0:  MOVLW  24
2AC2:  MOVWF  xA3
2AC4:  MOVLB  0
2AC6:  CALL   1506
....................    MACPut(checkSum.v[1]);
2ACA:  MOVFF  364,3AC
2ACE:  CALL   15A4
....................    MACPut(checkSum.v[0]);
2AD2:  MOVFF  363,3AC
2AD6:  CALL   15A4
....................    MACSetTxBuffer(buff, 0);
2ADA:  MOVFF  360,3A2
2ADE:  MOVLB  3
2AE0:  CLRF   xA4
2AE2:  CLRF   xA3
2AE4:  MOVLB  0
2AE6:  CALL   1506
.................... 
....................    MACFlush();
2AEA:  CALL   16D0
2AEE:  MOVLB  3
.................... 
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/
....................    // If we send the packet again, the remote node might think that we timed
....................    // out and retransmitted.  It could thus immediately send back an ACK and
....................    // dramatically improve throuput.
....................    //while(!IPIsTxReady(TRUE));
....................    //MACFlush();
.................... #endif
2AF0:  MOVLB  0
2AF2:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h,
....................  *                                      NODE_INFO* remote)
....................  *
....................  * PreCondition:    TCPInit() is already called
....................  *
....................  * Input:           h           - TCP Header to be matched against.
....................  *                  remote      - Node who sent this header.
....................  *
....................  * Output:          A socket that matches with given header and remote
....................  *                  node is searched.
....................  *                  If such socket is found, its index is returned
....................  *                  else INVALID_SOCKET is returned.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote)
.................... {
....................    SOCKET_INFO *ps;
....................    TCP_SOCKET s;
....................    TCP_SOCKET partialMatch;
.................... 
....................    partialMatch = INVALID_SOCKET;
*
22B0:  MOVLW  FE
22B2:  MOVLB  3
22B4:  MOVWF  x2D
.................... 
....................    for ( s = 0; s < MAX_SOCKETS; s++ )
22B6:  CLRF   x2C
22B8:  MOVF   x2C,W
22BA:  SUBLW  04
22BC:  BTFSS  FD8.0
22BE:  BRA    23B2
....................    {
....................       ps = &TCB[s];
22C0:  MOVF   x2C,W
22C2:  MULLW  24
22C4:  MOVF   FF3,W
22C6:  CLRF   03
22C8:  MOVWF  01
22CA:  MOVLW  01
22CC:  ADDWF  03,F
22CE:  MOVFF  01,32A
22D2:  MOVFF  03,32B
.................... 
....................       if ( ps->smState != TCP_CLOSED )
22D6:  MOVFF  32A,FE9
22DA:  MOVFF  32B,FEA
22DE:  MOVF   FEF,W
22E0:  SUBLW  0A
22E2:  BZ    23AE
....................       {
....................          if ( ps->localPort == h->DestPort )
22E4:  MOVLW  0B
22E6:  ADDWF  x2A,W
22E8:  MOVWF  FE9
22EA:  MOVLW  00
22EC:  ADDWFC x2B,W
22EE:  MOVWF  FEA
22F0:  MOVFF  FEC,32F
22F4:  MOVF   FED,F
22F6:  MOVFF  FEF,32E
22FA:  MOVLW  02
22FC:  ADDWF  x26,W
22FE:  MOVWF  FE9
2300:  MOVLW  00
2302:  ADDWFC x27,W
2304:  MOVWF  FEA
2306:  MOVFF  FEC,03
230A:  MOVF   FED,F
230C:  MOVF   FEF,W
230E:  SUBWF  x2E,W
2310:  BNZ   23AE
2312:  MOVF   03,W
2314:  SUBWF  x2F,W
2316:  BNZ   23AE
....................          {
....................             if ( ps->smState == TCP_LISTEN )
2318:  MOVFF  32A,FE9
231C:  MOVFF  32B,FEA
2320:  MOVF   FEF,F
2322:  BNZ   2328
....................                partialMatch = s;
2324:  MOVFF  32C,32D
.................... 
....................             if ( ps->remotePort == h->SourcePort &&
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val )
2328:  MOVLW  0D
232A:  ADDWF  x2A,W
232C:  MOVWF  FE9
232E:  MOVLW  00
2330:  ADDWFC x2B,W
2332:  MOVWF  FEA
2334:  MOVFF  FEC,32F
2338:  MOVF   FED,F
233A:  MOVFF  FEF,32E
233E:  MOVFF  326,FE9
2342:  MOVFF  327,FEA
2346:  MOVFF  FEC,03
234A:  MOVF   FED,F
234C:  MOVF   FEF,W
234E:  SUBWF  x2E,W
2350:  BNZ   23AE
2352:  MOVF   03,W
2354:  SUBWF  x2F,W
2356:  BNZ   23AE
2358:  MOVLW  07
235A:  ADDWF  x2A,W
235C:  MOVWF  FE9
235E:  MOVLW  00
2360:  ADDWFC x2B,W
2362:  MOVWF  FEA
2364:  MOVFF  FEF,32E
2368:  MOVFF  FEC,32F
236C:  MOVFF  FEC,330
2370:  MOVFF  FEC,331
2374:  MOVLW  06
2376:  ADDWF  x28,W
2378:  MOVWF  FE9
237A:  MOVLW  00
237C:  ADDWFC x29,W
237E:  MOVWF  FEA
2380:  MOVFF  FEF,00
2384:  MOVFF  FEC,01
2388:  MOVFF  FEC,02
238C:  MOVFF  FEC,03
2390:  MOVF   00,W
2392:  SUBWF  x2E,W
2394:  BNZ   23AE
2396:  MOVF   01,W
2398:  SUBWF  x2F,W
239A:  BNZ   23AE
239C:  MOVF   02,W
239E:  SUBWF  x30,W
23A0:  BNZ   23AE
23A2:  MOVF   03,W
23A4:  SUBWF  x31,W
23A6:  BNZ   23AE
....................             {
....................                return s;
23A8:  MOVFF  32C,01
23AC:  BRA    2484
....................             }
....................          }
....................       }
23AE:  INCF   x2C,F
23B0:  BRA    22B8
....................    }
.................... 
....................    // We are not listening on this port
....................    if(partialMatch == INVALID_SOCKET)
23B2:  MOVF   x2D,W
23B4:  SUBLW  FE
23B6:  BNZ   23BE
....................       return INVALID_SOCKET;
23B8:  MOVLW  FE
23BA:  MOVWF  01
23BC:  BRA    2484
.................... 
....................    // Copy the remote node IP/MAC address and source TCP port
....................    // number into our TCB and return this socket to the caller
....................    ps = &TCB[partialMatch];
23BE:  MOVF   x2D,W
23C0:  MULLW  24
23C2:  MOVF   FF3,W
23C4:  CLRF   03
23C6:  MOVWF  01
23C8:  MOVLW  01
23CA:  ADDWF  03,F
23CC:  MOVFF  01,32A
23D0:  MOVFF  03,32B
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote));
23D4:  MOVLW  01
23D6:  ADDWF  x2A,W
23D8:  MOVWF  01
23DA:  MOVLW  00
23DC:  ADDWFC x2B,W
23DE:  MOVWF  03
23E0:  MOVFF  01,32E
23E4:  MOVWF  x2F
23E6:  MOVWF  FEA
23E8:  MOVFF  01,FE9
23EC:  MOVFF  329,FE2
23F0:  MOVFF  328,FE1
23F4:  MOVLW  0A
23F6:  MOVWF  01
23F8:  MOVFF  FE6,FEE
23FC:  DECFSZ 01,F
23FE:  BRA    23F8
....................    ps->remotePort          = h->SourcePort;
2400:  MOVLW  0D
2402:  ADDWF  x2A,W
2404:  MOVWF  01
2406:  MOVLW  00
2408:  ADDWFC x2B,W
240A:  MOVFF  326,FE9
240E:  MOVFF  327,FEA
2412:  MOVFF  FEC,03
2416:  MOVF   FED,F
2418:  MOVFF  FEF,330
241C:  MOVWF  FEA
241E:  MOVFF  01,FE9
2422:  MOVFF  03,FEC
2426:  MOVF   FED,F
2428:  MOVFF  330,FEF
....................    ps->Flags.bIsGetReady   = FALSE;
242C:  MOVLW  23
242E:  ADDWF  x2A,W
2430:  MOVWF  FE9
2432:  MOVLW  00
2434:  ADDWFC x2B,W
2436:  MOVWF  FEA
2438:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER)
243A:  MOVLW  0F
243C:  ADDWF  x2A,W
243E:  MOVWF  FE9
2440:  MOVLW  00
2442:  ADDWFC x2B,W
2444:  MOVWF  FEA
2446:  INCFSZ FEF,W
2448:  BRA    244C
244A:  BRA    2472
....................    {
....................       MACDiscardTx(ps->TxBuffer);
244C:  MOVLW  0F
244E:  ADDWF  x2A,W
2450:  MOVWF  FE9
2452:  MOVLW  00
2454:  ADDWFC x2B,W
2456:  MOVWF  FEA
2458:  MOVFF  FEF,347
245C:  MOVLB  0
245E:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER;
2462:  MOVLW  0F
2464:  MOVLB  3
2466:  ADDWF  x2A,W
2468:  MOVWF  FE9
246A:  MOVLW  00
246C:  ADDWFC x2B,W
246E:  MOVWF  FEA
2470:  SETF   FEF
....................    }
....................    ps->Flags.bIsPutReady   = TRUE;
2472:  MOVLW  23
2474:  ADDWF  x2A,W
2476:  MOVWF  FE9
2478:  MOVLW  00
247A:  ADDWFC x2B,W
247C:  MOVWF  FEA
247E:  BSF    FEF.1
.................... 
....................    return partialMatch;
2480:  MOVFF  32D,01
2484:  MOVLB  0
2486:  GOTO   364A (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           header      - TCP Header to be swapped.
....................  *
....................  * Output:          Given header is swapped.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void SwapTCPHeader(TCP_HEADER* header)
.................... {
....................     header->SourcePort      = swaps(header->SourcePort);
*
20D8:  MOVFF  389,01
20DC:  MOVFF  38A,38C
20E0:  MOVFF  01,38B
20E4:  MOVFF  389,FE9
20E8:  MOVFF  38A,FEA
20EC:  MOVFF  FEC,3A9
20F0:  MOVF   FED,F
20F2:  MOVFF  FEF,3A8
20F6:  MOVLB  0
20F8:  CALL   11CC
20FC:  MOVFF  38C,FEA
2100:  MOVFF  38B,FE9
2104:  MOVFF  02,FEC
2108:  MOVF   FED,F
210A:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort);
210E:  MOVLW  02
2110:  MOVLB  3
2112:  ADDWF  x89,W
2114:  MOVWF  01
2116:  MOVLW  00
2118:  ADDWFC x8A,W
211A:  MOVWF  03
211C:  MOVFF  01,38B
2120:  MOVWF  x8C
2122:  MOVLW  02
2124:  ADDWF  x89,W
2126:  MOVWF  FE9
2128:  MOVLW  00
212A:  ADDWFC x8A,W
212C:  MOVWF  FEA
212E:  MOVFF  FEC,3A9
2132:  MOVF   FED,F
2134:  MOVFF  FEF,3A8
2138:  MOVLB  0
213A:  CALL   11CC
213E:  MOVFF  38C,FEA
2142:  MOVFF  38B,FE9
2146:  MOVFF  02,FEC
214A:  MOVF   FED,F
214C:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber);
2150:  MOVLW  04
2152:  MOVLB  3
2154:  ADDWF  x89,W
2156:  MOVWF  01
2158:  MOVLW  00
215A:  ADDWFC x8A,W
215C:  MOVWF  03
215E:  MOVFF  01,38B
2162:  MOVWF  x8C
2164:  MOVLW  04
2166:  ADDWF  x89,W
2168:  MOVWF  FE9
216A:  MOVLW  00
216C:  ADDWFC x8A,W
216E:  MOVWF  FEA
2170:  MOVFF  FEF,391
2174:  MOVFF  FEC,392
2178:  MOVFF  FEC,393
217C:  MOVFF  FEC,394
2180:  MOVLB  0
2182:  RCALL  20B6
2184:  MOVFF  38C,FEA
2188:  MOVFF  38B,FE9
218C:  MOVFF  00,FEF
2190:  MOVFF  01,FEC
2194:  MOVFF  02,FEC
2198:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber);
219C:  MOVLW  08
219E:  MOVLB  3
21A0:  ADDWF  x89,W
21A2:  MOVWF  01
21A4:  MOVLW  00
21A6:  ADDWFC x8A,W
21A8:  MOVWF  03
21AA:  MOVFF  01,38B
21AE:  MOVWF  x8C
21B0:  MOVLW  08
21B2:  ADDWF  x89,W
21B4:  MOVWF  FE9
21B6:  MOVLW  00
21B8:  ADDWFC x8A,W
21BA:  MOVWF  FEA
21BC:  MOVFF  FEF,391
21C0:  MOVFF  FEC,392
21C4:  MOVFF  FEC,393
21C8:  MOVFF  FEC,394
21CC:  MOVLB  0
21CE:  RCALL  20B6
21D0:  MOVFF  38C,FEA
21D4:  MOVFF  38B,FE9
21D8:  MOVFF  00,FEF
21DC:  MOVFF  01,FEC
21E0:  MOVFF  02,FEC
21E4:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window);
21E8:  MOVLW  0E
21EA:  MOVLB  3
21EC:  ADDWF  x89,W
21EE:  MOVWF  01
21F0:  MOVLW  00
21F2:  ADDWFC x8A,W
21F4:  MOVWF  03
21F6:  MOVFF  01,38B
21FA:  MOVWF  x8C
21FC:  MOVLW  0E
21FE:  ADDWF  x89,W
2200:  MOVWF  FE9
2202:  MOVLW  00
2204:  ADDWFC x8A,W
2206:  MOVWF  FEA
2208:  MOVFF  FEC,3A9
220C:  MOVF   FED,F
220E:  MOVFF  FEF,3A8
2212:  MOVLB  0
2214:  CALL   11CC
2218:  MOVFF  38C,FEA
221C:  MOVFF  38B,FE9
2220:  MOVFF  02,FEC
2224:  MOVF   FED,F
2226:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum);
222A:  MOVLW  10
222C:  MOVLB  3
222E:  ADDWF  x89,W
2230:  MOVWF  01
2232:  MOVLW  00
2234:  ADDWFC x8A,W
2236:  MOVWF  03
2238:  MOVFF  01,38B
223C:  MOVWF  x8C
223E:  MOVLW  10
2240:  ADDWF  x89,W
2242:  MOVWF  FE9
2244:  MOVLW  00
2246:  ADDWFC x8A,W
2248:  MOVWF  FEA
224A:  MOVFF  FEC,3A9
224E:  MOVF   FED,F
2250:  MOVFF  FEF,3A8
2254:  MOVLB  0
2256:  CALL   11CC
225A:  MOVFF  38C,FEA
225E:  MOVFF  38B,FE9
2262:  MOVFF  02,FEC
2266:  MOVF   FED,F
2268:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer);
226C:  MOVLW  12
226E:  MOVLB  3
2270:  ADDWF  x89,W
2272:  MOVWF  01
2274:  MOVLW  00
2276:  ADDWFC x8A,W
2278:  MOVWF  03
227A:  MOVFF  01,38B
227E:  MOVWF  x8C
2280:  MOVLW  12
2282:  ADDWF  x89,W
2284:  MOVWF  FE9
2286:  MOVLW  00
2288:  ADDWFC x8A,W
228A:  MOVWF  FEA
228C:  MOVFF  FEC,3A9
2290:  MOVF   FED,F
2292:  MOVFF  FEF,3A8
2296:  MOVLB  0
2298:  CALL   11CC
229C:  MOVFF  38C,FEA
22A0:  MOVFF  38B,FE9
22A4:  MOVFF  02,FEC
22A8:  MOVF   FED,F
22AA:  MOVFF  01,FEF
22AE:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps)
....................  *
....................  * PreCondition:    TCPInit() is already called
....................  *
....................  * Input:           ps  - Pointer to a socket info that is to be
....................  *                          closed.
....................  *
....................  * Output:          Given socket information is reset and any
....................  *                  buffer held by this socket is discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void CloseSocket(SOCKET_INFO* ps)
.................... {
....................    debug_tcp("\r\nTCP SOCKET CLOSED");
.................... 
....................     if ( ps->TxBuffer != INVALID_BUFFER )
*
24A4:  MOVLW  0F
24A6:  MOVLB  3
24A8:  ADDWF  x44,W
24AA:  MOVWF  FE9
24AC:  MOVLW  00
24AE:  ADDWFC x45,W
24B0:  MOVWF  FEA
24B2:  INCFSZ FEF,W
24B4:  BRA    24B8
24B6:  BRA    24EC
....................     {
....................         MACDiscardTx(ps->TxBuffer);
24B8:  MOVLW  0F
24BA:  ADDWF  x44,W
24BC:  MOVWF  FE9
24BE:  MOVLW  00
24C0:  ADDWFC x45,W
24C2:  MOVWF  FEA
24C4:  MOVFF  FEF,347
24C8:  MOVLB  0
24CA:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER;
24CE:  MOVLW  0F
24D0:  MOVLB  3
24D2:  ADDWF  x44,W
24D4:  MOVWF  FE9
24D6:  MOVLW  00
24D8:  ADDWFC x45,W
24DA:  MOVWF  FEA
24DC:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE;
24DE:  MOVLW  23
24E0:  ADDWF  x44,W
24E2:  MOVWF  FE9
24E4:  MOVLW  00
24E6:  ADDWFC x45,W
24E8:  MOVWF  FEA
24EA:  BSF    FEF.1
....................     }
.................... 
....................     ps->remote.IPAddr.Val = 0x00;
24EC:  MOVLW  07
24EE:  ADDWF  x44,W
24F0:  MOVWF  FE9
24F2:  MOVLW  00
24F4:  ADDWFC x45,W
24F6:  MOVWF  FEA
24F8:  CLRF   FEF
24FA:  CLRF   FEC
24FC:  CLRF   FEC
24FE:  CLRF   FEC
....................     ps->remotePort = 0x00;
2500:  MOVLW  0D
2502:  ADDWF  x44,W
2504:  MOVWF  FE9
2506:  MOVLW  00
2508:  ADDWFC x45,W
250A:  MOVWF  FEA
250C:  CLRF   FEC
250E:  MOVF   FED,F
2510:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady )
2512:  MOVLW  23
2514:  ADDWF  x44,W
2516:  MOVWF  FE9
2518:  MOVLW  00
251A:  ADDWFC x45,W
251C:  MOVWF  FEA
251E:  BTFSS  FEF.3
2520:  BRA    252A
....................     {
....................         MACDiscardRx();
2522:  MOVLB  0
2524:  CALL   1100
2528:  MOVLB  3
....................     }
....................     ps->Flags.bIsGetReady       = FALSE;
252A:  MOVLW  23
252C:  ADDWF  x44,W
252E:  MOVWF  FE9
2530:  MOVLW  00
2532:  ADDWFC x45,W
2534:  MOVWF  FEA
2536:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL;
2538:  MOVLW  21
253A:  ADDWF  x44,W
253C:  MOVWF  FE9
253E:  MOVLW  00
2540:  ADDWFC x45,W
2542:  MOVWF  FEA
2544:  CLRF   FEC
2546:  MOVF   FED,F
2548:  MOVLW  1E
254A:  MOVWF  FEF
.................... 
....................     ps->Flags.bIsTxInProgress   = FALSE;
254C:  MOVLW  23
254E:  ADDWF  x44,W
2550:  MOVWF  FE9
2552:  MOVLW  00
2554:  ADDWFC x45,W
2556:  MOVWF  FEA
2558:  BCF    FEF.4
.................... 
....................     if ( ps->Flags.bServer )
255A:  MOVLW  23
255C:  ADDWF  x44,W
255E:  MOVWF  FE9
2560:  MOVLW  00
2562:  ADDWFC x45,W
2564:  MOVWF  FEA
2566:  BTFSS  FEF.0
2568:  BRA    2576
....................     {
....................         ps->smState = TCP_LISTEN;
256A:  MOVFF  344,FE9
256E:  MOVFF  345,FEA
2572:  CLRF   FEF
....................     }
2574:  BRA    2582
....................     else
....................     {
....................         ps->smState = TCP_CLOSED;
2576:  MOVFF  344,FE9
257A:  MOVFF  345,FEA
257E:  MOVLW  0A
2580:  MOVWF  FEF
....................     }
.................... 
....................    ps->TxCount = 0;
2582:  MOVLW  10
2584:  ADDWF  x44,W
2586:  MOVWF  FE9
2588:  MOVLW  00
258A:  ADDWFC x45,W
258C:  MOVWF  FEA
258E:  CLRF   FEC
2590:  MOVF   FED,F
2592:  CLRF   FEF
.................... 
....................     return;
2594:  MOVLB  0
2596:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s,
.................... *                                      NODE_INFO *remote,
.................... *                                      TCP_HEADER* h,
.................... *                                      WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPProcess() is the caller.
.................... *
.................... * Input:           s           - Socket that owns this segment
.................... *                  remote      - Remote node info
.................... *                  h           - TCP Header
.................... *                  len         - Total buffer length.
.................... *
.................... * Output:          TCP FSM is executed on given socket with
.................... *                  given TCP segment.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... static void HandleTCPSeg(TCP_SOCKET s,
....................                    NODE_INFO *remote,
....................                    TCP_HEADER *h,
....................                    WORD len)
.................... {
....................    DWORD ack;
....................    DWORD seq;
....................    DWORD prevAck, prevSeq;
....................    SOCKET_INFO *ps;
....................    BYTE flags;
....................    //BYTE debugLastState;
....................    signed int32 temp;
.................... 
....................    ps = &TCB[s];
*
2AF4:  MOVLB  3
2AF6:  MOVF   x26,W
2AF8:  MULLW  24
2AFA:  MOVF   FF3,W
2AFC:  CLRF   03
2AFE:  MOVWF  01
2B00:  MOVLW  01
2B02:  ADDWF  03,F
2B04:  MOVFF  01,33D
2B08:  MOVFF  03,33E
....................    //debugLastState = TCB[s].smState;
.................... 
....................    flags = 0x00;
2B0C:  CLRF   x3F
.................... 
....................    // Clear timeout info
....................    ps->RetryCount  = 0;
2B0E:  MOVLW  1E
2B10:  ADDWF  x3D,W
2B12:  MOVWF  FE9
2B14:  MOVLW  00
2B16:  ADDWFC x3E,W
2B18:  MOVWF  FEA
2B1A:  CLRF   FEF
....................    ps->startTick   = TickGet();
2B1C:  MOVLW  1F
2B1E:  ADDWF  x3D,W
2B20:  MOVWF  01
2B22:  MOVLW  00
2B24:  ADDWFC x3E,W
2B26:  MOVWF  03
2B28:  MOVFF  01,344
2B2C:  MOVWF  x45
2B2E:  MOVLB  0
2B30:  RCALL  248A
2B32:  MOVFF  345,FEA
2B36:  MOVFF  344,FE9
2B3A:  MOVFF  02,FEC
2B3E:  MOVF   FED,F
2B40:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL;
2B44:  MOVLW  21
2B46:  MOVLB  3
2B48:  ADDWF  x3D,W
2B4A:  MOVWF  FE9
2B4C:  MOVLW  00
2B4E:  ADDWFC x3E,W
2B50:  MOVWF  FEA
2B52:  CLRF   FEC
2B54:  MOVF   FED,F
2B56:  MOVLW  1E
2B58:  MOVWF  FEF
.................... 
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n",
....................       h->SourcePort,
....................       h->DestPort,
....................       h->SeqNumber,
....................       h->AckNumber,
....................       len,
....................       h->Flags
....................    );
.................... 
.................... 
....................    // Reset FSM, if RST is received.
....................    if(h->Flags.bits.flagRST)
2B5A:  MOVLW  0D
2B5C:  ADDWF  x29,W
2B5E:  MOVWF  FE9
2B60:  MOVLW  00
2B62:  ADDWFC x2A,W
2B64:  MOVWF  FEA
2B66:  BTFSS  FEF.2
2B68:  BRA    2B9E
....................    {
....................       MACDiscardRx();
2B6A:  MOVLB  0
2B6C:  CALL   1100
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT;
2B70:  MOVLB  3
2B72:  MOVFF  33D,344
2B76:  MOVFF  33E,345
2B7A:  MOVLW  23
2B7C:  ADDWF  x3D,W
2B7E:  MOVWF  FE9
2B80:  MOVLW  00
2B82:  ADDWFC x3E,W
2B84:  MOVWF  FEA
2B86:  BTFSS  FEF.0
2B88:  BRA    2B8E
2B8A:  MOVLW  00
2B8C:  BRA    2B90
2B8E:  MOVLW  01
2B90:  MOVFF  345,FEA
2B94:  MOVFF  344,FE9
2B98:  MOVWF  FEF
....................       return;
2B9A:  GOTO   34E6
....................    }
.................... 
....................    seq = ps->SND_SEQ;
2B9E:  MOVLW  16
2BA0:  ADDWF  x3D,W
2BA2:  MOVWF  FE9
2BA4:  MOVLW  00
2BA6:  ADDWFC x3E,W
2BA8:  MOVWF  FEA
2BAA:  MOVFF  FEF,331
2BAE:  MOVFF  FEC,332
2BB2:  MOVFF  FEC,333
2BB6:  MOVFF  FEC,334
.................... 
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount;
2BBA:  MOVLW  0E
2BBC:  ADDWF  x29,W
2BBE:  MOVWF  FE9
2BC0:  MOVLW  00
2BC2:  ADDWFC x2A,W
2BC4:  MOVWF  FEA
2BC6:  MOVFF  FEC,345
2BCA:  MOVF   FED,F
2BCC:  MOVFF  FEF,344
2BD0:  CLRF   x46
2BD2:  CLRF   x47
2BD4:  MOVLW  08
2BD6:  ADDWF  x29,W
2BD8:  MOVWF  FE9
2BDA:  MOVLW  00
2BDC:  ADDWFC x2A,W
2BDE:  MOVWF  FEA
2BE0:  MOVFF  FEF,00
2BE4:  MOVFF  FEC,01
2BE8:  MOVFF  FEC,02
2BEC:  MOVFF  FEC,03
2BF0:  MOVF   00,W
2BF2:  SUBWF  x31,W
2BF4:  MOVWF  00
2BF6:  MOVF   01,W
2BF8:  SUBWFB x32,W
2BFA:  MOVWF  01
2BFC:  MOVF   02,W
2BFE:  SUBWFB x33,W
2C00:  MOVWF  02
2C02:  MOVF   03,W
2C04:  SUBWFB x34,W
2C06:  MOVWF  03
2C08:  MOVF   00,W
2C0A:  SUBWF  x44,F
2C0C:  MOVF   01,W
2C0E:  SUBWFB x45,F
2C10:  MOVF   02,W
2C12:  SUBWFB x46,F
2C14:  MOVF   03,W
2C16:  SUBWFB x47,F
2C18:  MOVLW  10
2C1A:  ADDWF  x3D,W
2C1C:  MOVWF  FE9
2C1E:  MOVLW  00
2C20:  ADDWFC x3E,W
2C22:  MOVWF  FEA
2C24:  MOVFF  FEC,03
2C28:  MOVF   FED,F
2C2A:  MOVFF  FEF,00
2C2E:  MOVFF  03,01
2C32:  CLRF   02
2C34:  CLRF   03
2C36:  MOVF   00,W
2C38:  SUBWF  x44,W
2C3A:  MOVWF  x40
2C3C:  MOVF   01,W
2C3E:  SUBWFB x45,W
2C40:  MOVWF  x41
2C42:  MOVF   02,W
2C44:  SUBWFB x46,W
2C46:  MOVWF  x42
2C48:  MOVF   03,W
2C4A:  SUBWFB x47,W
2C4C:  MOVWF  x43
....................    if(temp < 0)
2C4E:  BTFSS  x43.7
2C50:  BRA    2C66
....................    {
....................       ps->RemoteWindow = 0;
2C52:  MOVLW  14
2C54:  ADDWF  x3D,W
2C56:  MOVWF  FE9
2C58:  MOVLW  00
2C5A:  ADDWFC x3E,W
2C5C:  MOVWF  FEA
2C5E:  CLRF   FEC
2C60:  MOVF   FED,F
2C62:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n",
....................             ps->RemoteWindow,
....................             temp,
....................             h->Window,
....................             seq,
....................             h->AckNumber,
....................             ps->TxCount
....................          );
....................    }
2C64:  BRA    2C7A
....................    else
....................    {
....................       ps->RemoteWindow = ack;
2C66:  MOVLW  14
2C68:  ADDWF  x3D,W
2C6A:  MOVWF  FE9
2C6C:  MOVLW  00
2C6E:  ADDWFC x3E,W
2C70:  MOVWF  FEA
2C72:  MOVFF  32D,FEF
2C76:  MOVFF  32E,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow);
....................    }
.................... 
....................    // Handle TCP_SYN_SENT state
....................    // The TCP_SYN_SENT state occurs when an application
....................    // calls TCPConnect().  After an initial SYN is sent,
....................    // we expect a SYN + ACK before establishing the
....................    // connection.
....................    if(ps->smState == TCP_SYN_SENT)
2C7A:  MOVFF  33D,FE9
2C7E:  MOVFF  33E,FEA
2C82:  DECFSZ FEF,W
2C84:  BRA    2DF0
....................    {
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot
....................       // handle any other packet types.
....................       if(!h->Flags.bits.flagSYN)
2C86:  MOVLW  0D
2C88:  ADDWF  x29,W
2C8A:  MOVWF  FE9
2C8C:  MOVLW  00
2C8E:  ADDWFC x2A,W
2C90:  MOVWF  FEA
2C92:  BTFSC  FEF.1
2C94:  BRA    2CBA
....................       {
....................          MACDiscardRx();
2C96:  MOVLB  0
2C98:  CALL   1100
.................... 
....................          // Send out a RESET if the remote node thinks a connection is already established
....................           if(h->Flags.bits.flagACK)
2C9C:  MOVLW  0D
2C9E:  MOVLB  3
2CA0:  ADDWF  x29,W
2CA2:  MOVWF  FE9
2CA4:  MOVLW  00
2CA6:  ADDWFC x2A,W
2CA8:  MOVWF  FEA
2CAA:  BTFSS  FEF.4
2CAC:  BRA    2CB6
....................           {
....................             flags = RST;
2CAE:  MOVLW  04
2CB0:  MOVWF  x3F
....................             goto SendTCPControlPacket;
2CB2:  GOTO   347E
....................            }
.................... 
....................          return;
2CB6:  GOTO   34E6
....................       }
.................... 
....................       // We now have a sequence number for the remote node
....................       ps->SND_ACK = h->SeqNumber + len + 1;
2CBA:  MOVLW  1A
2CBC:  ADDWF  x3D,W
2CBE:  MOVWF  01
2CC0:  MOVLW  00
2CC2:  ADDWFC x3E,W
2CC4:  MOVFF  01,344
2CC8:  MOVWF  x45
2CCA:  MOVLW  04
2CCC:  ADDWF  x29,W
2CCE:  MOVWF  FE9
2CD0:  MOVLW  00
2CD2:  ADDWFC x2A,W
2CD4:  MOVWF  FEA
2CD6:  MOVFF  FEF,346
2CDA:  MOVFF  FEC,347
2CDE:  MOVFF  FEC,348
2CE2:  MOVFF  FEC,349
2CE6:  MOVF   x2B,W
2CE8:  ADDWF  x46,F
2CEA:  MOVF   x2C,W
2CEC:  ADDWFC x47,F
2CEE:  MOVLW  00
2CF0:  ADDWFC x48,F
2CF2:  ADDWFC x49,F
2CF4:  MOVLW  01
2CF6:  ADDWF  x46,W
2CF8:  MOVWF  00
2CFA:  MOVLW  00
2CFC:  ADDWFC x47,W
2CFE:  MOVWF  01
2D00:  MOVLW  00
2D02:  ADDWFC x48,W
2D04:  MOVWF  02
2D06:  MOVLW  00
2D08:  ADDWFC x49,W
2D0A:  MOVFF  345,FEA
2D0E:  MOVFF  344,FE9
2D12:  MOVFF  00,FEF
2D16:  MOVFF  01,FEC
2D1A:  MOVFF  02,FEC
2D1E:  MOVWF  FEC
....................       ack = ps->SND_ACK;
2D20:  MOVLW  1A
2D22:  ADDWF  x3D,W
2D24:  MOVWF  FE9
2D26:  MOVLW  00
2D28:  ADDWFC x3E,W
2D2A:  MOVWF  FEA
2D2C:  MOVFF  FEF,32D
2D30:  MOVFF  FEC,32E
2D34:  MOVFF  FEC,32F
2D38:  MOVFF  FEC,330
.................... 
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK,
....................       // we can establish the connection now.
....................       if(!h->Flags.bits.flagACK)
2D3C:  MOVLW  0D
2D3E:  ADDWF  x29,W
2D40:  MOVWF  FE9
2D42:  MOVLW  00
2D44:  ADDWFC x2A,W
2D46:  MOVWF  FEA
2D48:  BTFSC  FEF.4
2D4A:  BRA    2D66
....................       {
....................          ps->smState = TCP_SYN_RECEIVED;
2D4C:  MOVFF  33D,FE9
2D50:  MOVFF  33E,FEA
2D54:  MOVLW  02
2D56:  MOVWF  FEF
....................          MACDiscardRx();
2D58:  MOVLB  0
2D5A:  CALL   1100
....................          // Send out a SYN+ACK for simultaneous connection open
....................          flags = SYN | ACK;
2D5E:  MOVLW  12
2D60:  MOVLB  3
2D62:  MOVWF  x3F
....................          goto SendTCPControlPacket;
2D64:  BRA    347E
....................       }
.................... 
....................       // We received SYN+ACK, establish the connection now
....................       ps->smState = TCP_ESTABLISHED;
2D66:  MOVFF  33D,FE9
2D6A:  MOVFF  33E,FEA
2D6E:  MOVLW  03
2D70:  MOVWF  FEF
....................       // Send out an ACK
....................       flags = ACK;
2D72:  MOVLW  10
2D74:  MOVWF  x3F
.................... 
....................       ps->RemoteWindow = h->Window;
2D76:  MOVLW  14
2D78:  ADDWF  x3D,W
2D7A:  MOVWF  01
2D7C:  MOVLW  00
2D7E:  ADDWFC x3E,W
2D80:  MOVWF  03
2D82:  MOVWF  x45
2D84:  MOVLW  0E
2D86:  ADDWF  x29,W
2D88:  MOVWF  FE9
2D8A:  MOVLW  00
2D8C:  ADDWFC x2A,W
2D8E:  MOVWF  FEA
2D90:  MOVFF  FEC,03
2D94:  MOVF   FED,F
2D96:  MOVFF  FEF,346
2D9A:  MOVFF  345,FEA
2D9E:  MOVFF  01,FE9
2DA2:  MOVFF  03,FEC
2DA6:  MOVF   FED,F
2DA8:  MOVFF  346,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow);
.................... 
....................       // Check for application data and make it
....................       // available, if present
....................       if(len)
2DAC:  MOVF   x2B,W
2DAE:  IORWF  x2C,W
2DB0:  BZ    2DE6
....................       {
....................          ps->Flags.bIsGetReady   = TRUE;
2DB2:  MOVLW  23
2DB4:  ADDWF  x3D,W
2DB6:  MOVWF  FE9
2DB8:  MOVLW  00
2DBA:  ADDWFC x3E,W
2DBC:  MOVWF  FEA
2DBE:  BSF    FEF.3
....................          ps->RxCount             = len;
2DC0:  MOVLW  12
2DC2:  ADDWF  x3D,W
2DC4:  MOVWF  FE9
2DC6:  MOVLW  00
2DC8:  ADDWFC x3E,W
2DCA:  MOVWF  FEA
2DCC:  MOVFF  32C,FEC
2DD0:  MOVF   FED,F
2DD2:  MOVFF  32B,FEF
....................          ps->Flags.bFirstRead    = TRUE;
2DD6:  MOVLW  23
2DD8:  ADDWF  x3D,W
2DDA:  MOVWF  FE9
2DDC:  MOVLW  00
2DDE:  ADDWFC x3E,W
2DE0:  MOVWF  FEA
2DE2:  BSF    FEF.2
....................       }
2DE4:  BRA    2DEE
....................       else   // No application data in this packet
....................       {
....................          MACDiscardRx();
2DE6:  MOVLB  0
2DE8:  CALL   1100
2DEC:  MOVLB  3
....................       }
....................       goto SendTCPControlPacket;
2DEE:  BRA    347E
....................    }
.................... 
....................    // Handle TCP_LISTEN state
....................    if(ps->smState == TCP_LISTEN )
2DF0:  MOVFF  33D,FE9
2DF4:  MOVFF  33E,FEA
2DF8:  MOVF   FEF,F
2DFA:  BTFSS  FD8.2
2DFC:  BRA    2F6C
....................    {
....................       MACDiscardRx();
2DFE:  MOVLB  0
2E00:  CALL   1100
.................... 
....................       // Send a RST if this isn't a SYN packet
....................       if(!h->Flags.bits.flagSYN)
2E04:  MOVLW  0D
2E06:  MOVLB  3
2E08:  ADDWF  x29,W
2E0A:  MOVWF  FE9
2E0C:  MOVLW  00
2E0E:  ADDWFC x2A,W
2E10:  MOVWF  FEA
2E12:  BTFSC  FEF.1
2E14:  BRA    2E1C
....................       {
....................          flags = RST;
2E16:  MOVLW  04
2E18:  MOVWF  x3F
....................          goto SendTCPControlPacket;
2E1A:  BRA    347E
....................       }
.................... 
....................       ps->SND_ACK = h->SeqNumber + len + 1;
2E1C:  MOVLW  1A
2E1E:  ADDWF  x3D,W
2E20:  MOVWF  01
2E22:  MOVLW  00
2E24:  ADDWFC x3E,W
2E26:  MOVFF  01,344
2E2A:  MOVWF  x45
2E2C:  MOVLW  04
2E2E:  ADDWF  x29,W
2E30:  MOVWF  FE9
2E32:  MOVLW  00
2E34:  ADDWFC x2A,W
2E36:  MOVWF  FEA
2E38:  MOVFF  FEF,346
2E3C:  MOVFF  FEC,347
2E40:  MOVFF  FEC,348
2E44:  MOVFF  FEC,349
2E48:  MOVF   x2B,W
2E4A:  ADDWF  x46,F
2E4C:  MOVF   x2C,W
2E4E:  ADDWFC x47,F
2E50:  MOVLW  00
2E52:  ADDWFC x48,F
2E54:  ADDWFC x49,F
2E56:  MOVLW  01
2E58:  ADDWF  x46,W
2E5A:  MOVWF  00
2E5C:  MOVLW  00
2E5E:  ADDWFC x47,W
2E60:  MOVWF  01
2E62:  MOVLW  00
2E64:  ADDWFC x48,W
2E66:  MOVWF  02
2E68:  MOVLW  00
2E6A:  ADDWFC x49,W
2E6C:  MOVFF  345,FEA
2E70:  MOVFF  344,FE9
2E74:  MOVFF  00,FEF
2E78:  MOVFF  01,FEC
2E7C:  MOVFF  02,FEC
2E80:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window;
2E82:  MOVLW  14
2E84:  ADDWF  x3D,W
2E86:  MOVWF  01
2E88:  MOVLW  00
2E8A:  ADDWFC x3E,W
2E8C:  MOVWF  03
2E8E:  MOVWF  x45
2E90:  MOVLW  0E
2E92:  ADDWF  x29,W
2E94:  MOVWF  FE9
2E96:  MOVLW  00
2E98:  ADDWFC x2A,W
2E9A:  MOVWF  FEA
2E9C:  MOVFF  FEC,03
2EA0:  MOVF   FED,F
2EA2:  MOVFF  FEF,346
2EA6:  MOVFF  345,FEA
2EAA:  MOVFF  01,FE9
2EAE:  MOVFF  03,FEC
2EB2:  MOVF   FED,F
2EB4:  MOVFF  346,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow);
.................... 
....................       // This socket has received connection request (SYN).
....................       // Remember calling node, assign next segment seq. number
....................       // for this potential connection.
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote));
2EB8:  MOVLW  01
2EBA:  ADDWF  x3D,W
2EBC:  MOVWF  01
2EBE:  MOVLW  00
2EC0:  ADDWFC x3E,W
2EC2:  MOVWF  03
2EC4:  MOVFF  01,344
2EC8:  MOVWF  x45
2ECA:  MOVWF  FEA
2ECC:  MOVFF  01,FE9
2ED0:  MOVFF  328,FE2
2ED4:  MOVFF  327,FE1
2ED8:  MOVLW  0A
2EDA:  MOVWF  01
2EDC:  MOVFF  FE6,FEE
2EE0:  DECFSZ 01,F
2EE2:  BRA    2EDC
....................       ps->remotePort = h->SourcePort;
2EE4:  MOVLW  0D
2EE6:  ADDWF  x3D,W
2EE8:  MOVWF  01
2EEA:  MOVLW  00
2EEC:  ADDWFC x3E,W
2EEE:  MOVFF  329,FE9
2EF2:  MOVFF  32A,FEA
2EF6:  MOVFF  FEC,03
2EFA:  MOVF   FED,F
2EFC:  MOVFF  FEF,346
2F00:  MOVWF  FEA
2F02:  MOVFF  01,FE9
2F06:  MOVFF  03,FEC
2F0A:  MOVF   FED,F
2F0C:  MOVFF  346,FEF
.................... 
....................       // Grant connection request.
....................       ps->smState = TCP_SYN_RECEIVED;
2F10:  MOVFF  33D,FE9
2F14:  MOVFF  33E,FEA
2F18:  MOVLW  02
2F1A:  MOVWF  FEF
....................       seq = ps->SND_SEQ++;
2F1C:  MOVLW  16
2F1E:  ADDWF  x3D,W
2F20:  MOVWF  FE9
2F22:  MOVLW  00
2F24:  ADDWFC x3E,W
2F26:  MOVWF  FEA
2F28:  MOVF   FEE,F
2F2A:  MOVF   FEE,F
2F2C:  MOVF   FEE,F
2F2E:  MOVFF  FED,334
2F32:  MOVFF  FED,333
2F36:  MOVFF  FED,332
2F3A:  MOVFF  FEF,331
2F3E:  MOVLW  01
2F40:  ADDWF  FEE,F
2F42:  MOVLW  00
2F44:  ADDWFC FEE,F
2F46:  ADDWFC FEE,F
2F48:  ADDWFC FED,F
....................       ack =  ps->SND_ACK;
2F4A:  MOVLW  1A
2F4C:  ADDWF  x3D,W
2F4E:  MOVWF  FE9
2F50:  MOVLW  00
2F52:  ADDWFC x3E,W
2F54:  MOVWF  FEA
2F56:  MOVFF  FEF,32D
2F5A:  MOVFF  FEC,32E
2F5E:  MOVFF  FEC,32F
2F62:  MOVFF  FEC,330
....................       flags = SYN | ACK;
2F66:  MOVLW  12
2F68:  MOVWF  x3F
....................       goto SendTCPControlPacket;
2F6A:  BRA    347E
....................    }
.................... 
.................... 
....................    // Remember current seq and ack for our connection so that if
....................    // we have to silently discard this packet, we can go back to
....................    // previous ack and seq numbers.
....................    prevAck = ps->SND_ACK;
2F6C:  MOVLW  1A
2F6E:  ADDWF  x3D,W
2F70:  MOVWF  FE9
2F72:  MOVLW  00
2F74:  ADDWFC x3E,W
2F76:  MOVWF  FEA
2F78:  MOVFF  FEF,335
2F7C:  MOVFF  FEC,336
2F80:  MOVFF  FEC,337
2F84:  MOVFF  FEC,338
....................    prevSeq = ps->SND_SEQ;
2F88:  MOVLW  16
2F8A:  ADDWF  x3D,W
2F8C:  MOVWF  FE9
2F8E:  MOVLW  00
2F90:  ADDWFC x3E,W
2F92:  MOVWF  FEA
2F94:  MOVFF  FEF,339
2F98:  MOVFF  FEC,33A
2F9C:  MOVFF  FEC,33B
2FA0:  MOVFF  FEC,33C
.................... 
....................    ack = h->SeqNumber;
2FA4:  MOVLW  04
2FA6:  ADDWF  x29,W
2FA8:  MOVWF  FE9
2FAA:  MOVLW  00
2FAC:  ADDWFC x2A,W
2FAE:  MOVWF  FEA
2FB0:  MOVFF  FEF,32D
2FB4:  MOVFF  FEC,32E
2FB8:  MOVFF  FEC,32F
2FBC:  MOVFF  FEC,330
....................    ack += (DWORD)len;
2FC0:  MOVFF  32B,00
2FC4:  MOVFF  32C,01
2FC8:  CLRF   02
2FCA:  CLRF   03
2FCC:  MOVF   00,W
2FCE:  ADDWF  x2D,F
2FD0:  MOVF   01,W
2FD2:  ADDWFC x2E,F
2FD4:  MOVF   02,W
2FD6:  ADDWFC x2F,F
2FD8:  MOVF   03,W
2FDA:  ADDWFC x30,F
....................    seq = ps->SND_SEQ;
2FDC:  MOVLW  16
2FDE:  ADDWF  x3D,W
2FE0:  MOVWF  FE9
2FE2:  MOVLW  00
2FE4:  ADDWFC x3E,W
2FE6:  MOVWF  FEA
2FE8:  MOVFF  FEF,331
2FEC:  MOVFF  FEC,332
2FF0:  MOVFF  FEC,333
2FF4:  MOVFF  FEC,334
.................... 
....................    // State is something other than TCP_LISTEN, handle it.
....................    {
....................       // Check to see if the incomming sequence number is what
....................       // we expect (last transmitted ACK value).  Throw this packet
....................       // away if it is wrong.
....................       if(h->SeqNumber == prevAck)
2FF8:  MOVLW  04
2FFA:  ADDWF  x29,W
2FFC:  MOVWF  FE9
2FFE:  MOVLW  00
3000:  ADDWFC x2A,W
3002:  MOVWF  FEA
3004:  MOVFF  FEF,344
3008:  MOVFF  FEC,345
300C:  MOVFF  FEC,346
3010:  MOVFF  FEC,347
3014:  MOVF   x35,W
3016:  SUBWF  x44,W
3018:  BTFSS  FD8.2
301A:  BRA    3462
301C:  MOVF   x36,W
301E:  SUBWF  x45,W
3020:  BTFSS  FD8.2
3022:  BRA    3462
3024:  MOVF   x37,W
3026:  SUBWF  x46,W
3028:  BTFSS  FD8.2
302A:  BRA    3462
302C:  MOVF   x38,W
302E:  SUBWF  x47,W
3030:  BTFSS  FD8.2
3032:  BRA    3462
....................       {
....................          // After receiving a SYNchronization request, we expect an
....................          // ACK to our transmitted SYN
....................          if(ps->smState == TCP_SYN_RECEIVED)
3034:  MOVFF  33D,FE9
3038:  MOVFF  33E,FEA
303C:  MOVF   FEF,W
303E:  SUBLW  02
3040:  BNZ   30C8
....................          {
....................             if(h->Flags.bits.flagACK)
3042:  MOVLW  0D
3044:  ADDWF  x29,W
3046:  MOVWF  FE9
3048:  MOVLW  00
304A:  ADDWFC x2A,W
304C:  MOVWF  FEA
304E:  BTFSS  FEF.4
3050:  BRA    30BE
....................             {
....................                // ACK received as expected, this connection is
....................                // now established
....................                ps->SND_ACK = ack;
3052:  MOVLW  1A
3054:  ADDWF  x3D,W
3056:  MOVWF  FE9
3058:  MOVLW  00
305A:  ADDWFC x3E,W
305C:  MOVWF  FEA
305E:  MOVFF  32D,FEF
3062:  MOVFF  32E,FEC
3066:  MOVFF  32F,FEC
306A:  MOVFF  330,FEC
....................                ps->smState = TCP_ESTABLISHED;
306E:  MOVFF  33D,FE9
3072:  MOVFF  33E,FEA
3076:  MOVLW  03
3078:  MOVWF  FEF
.................... 
....................                // Check if this first packet has application data
....................                // in it.  Make it available if so.
....................                if(len)
307A:  MOVF   x2B,W
307C:  IORWF  x2C,W
307E:  BZ    30B4
....................                {
....................                   ps->Flags.bIsGetReady   = TRUE;
3080:  MOVLW  23
3082:  ADDWF  x3D,W
3084:  MOVWF  FE9
3086:  MOVLW  00
3088:  ADDWFC x3E,W
308A:  MOVWF  FEA
308C:  BSF    FEF.3
....................                   ps->RxCount             = len;
308E:  MOVLW  12
3090:  ADDWF  x3D,W
3092:  MOVWF  FE9
3094:  MOVLW  00
3096:  ADDWFC x3E,W
3098:  MOVWF  FEA
309A:  MOVFF  32C,FEC
309E:  MOVF   FED,F
30A0:  MOVFF  32B,FEF
....................                   ps->Flags.bFirstRead    = TRUE;
30A4:  MOVLW  23
30A6:  ADDWF  x3D,W
30A8:  MOVWF  FE9
30AA:  MOVLW  00
30AC:  ADDWFC x3E,W
30AE:  MOVWF  FEA
30B0:  BSF    FEF.2
....................                }
30B2:  BRA    30BC
....................                else
....................                   MACDiscardRx();
30B4:  MOVLB  0
30B6:  CALL   1100
30BA:  MOVLB  3
....................             }
30BC:  BRA    30C6
....................             else   // No ACK to our SYN
....................             {
....................                MACDiscardRx();
30BE:  MOVLB  0
30C0:  CALL   1100
30C4:  MOVLB  3
....................             }
....................          }
30C6:  BRA    3460
....................          // Connection is established, closing, or otherwise
....................          else
....................          {
.................... 
....................             // Save the seq+len value of the packet for our future
....................             // ACK transmission, and so out of sequence packets
....................             // can be detected in the future.
....................             ps->SND_ACK = ack;
30C8:  MOVLW  1A
30CA:  ADDWF  x3D,W
30CC:  MOVWF  FE9
30CE:  MOVLW  00
30D0:  ADDWFC x3E,W
30D2:  MOVWF  FEA
30D4:  MOVFF  32D,FEF
30D8:  MOVFF  32E,FEC
30DC:  MOVFF  32F,FEC
30E0:  MOVFF  330,FEC
.................... 
....................             // Handle packets received while connection established.
....................             if(ps->smState == TCP_ESTABLISHED)
30E4:  MOVFF  33D,FE9
30E8:  MOVFF  33E,FEA
30EC:  MOVF   FEF,W
30EE:  SUBLW  03
30F0:  BTFSS  FD8.2
30F2:  BRA    3292
....................             {
....................                // If this packet has the ACK set, mark all
....................                // previous TX packets as no longer needed for
....................                // possible retransmission.
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability.
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady)
30F4:  MOVLW  0D
30F6:  ADDWF  x29,W
30F8:  MOVWF  FE9
30FA:  MOVLW  00
30FC:  ADDWFC x2A,W
30FE:  MOVWF  FEA
3100:  BTFSS  FEF.4
3102:  BRA    315A
3104:  MOVLW  23
3106:  ADDWF  x3D,W
3108:  MOVWF  FE9
310A:  MOVLW  00
310C:  ADDWFC x3E,W
310E:  MOVWF  FEA
3110:  BTFSC  FEF.1
3112:  BRA    315A
....................                {
....................                   if(ps->TxBuffer != INVALID_BUFFER)
3114:  MOVLW  0F
3116:  ADDWF  x3D,W
3118:  MOVWF  FE9
311A:  MOVLW  00
311C:  ADDWFC x3E,W
311E:  MOVWF  FEA
3120:  INCFSZ FEF,W
3122:  BRA    3126
3124:  BRA    315A
....................                   {
....................                      MACDiscardTx(ps->TxBuffer);
3126:  MOVLW  0F
3128:  ADDWF  x3D,W
312A:  MOVWF  FE9
312C:  MOVLW  00
312E:  ADDWFC x3E,W
3130:  MOVWF  FEA
3132:  MOVFF  FEF,347
3136:  MOVLB  0
3138:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER;
313C:  MOVLW  0F
313E:  MOVLB  3
3140:  ADDWF  x3D,W
3142:  MOVWF  FE9
3144:  MOVLW  00
3146:  ADDWFC x3E,W
3148:  MOVWF  FEA
314A:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE;
314C:  MOVLW  23
314E:  ADDWF  x3D,W
3150:  MOVWF  FE9
3152:  MOVLW  00
3154:  ADDWFC x3E,W
3156:  MOVWF  FEA
3158:  BSF    FEF.1
....................                   }
....................                }
.................... 
....................                // Check if the remote node is closing the connection
....................                if(h->Flags.bits.flagFIN)
315A:  MOVLW  0D
315C:  ADDWF  x29,W
315E:  MOVWF  FE9
3160:  MOVLW  00
3162:  ADDWFC x2A,W
3164:  MOVWF  FEA
3166:  BTFSS  FEF.0
3168:  BRA    31FA
....................                {
....................                   //DebugPrint("|");
....................                   flags = FIN | ACK;
316A:  MOVLW  11
316C:  MOVWF  x3F
....................                   seq = ps->SND_SEQ++;
316E:  MOVLW  16
3170:  ADDWF  x3D,W
3172:  MOVWF  FE9
3174:  MOVLW  00
3176:  ADDWFC x3E,W
3178:  MOVWF  FEA
317A:  MOVF   FEE,F
317C:  MOVF   FEE,F
317E:  MOVF   FEE,F
3180:  MOVFF  FED,334
3184:  MOVFF  FED,333
3188:  MOVFF  FED,332
318C:  MOVFF  FEF,331
3190:  MOVLW  01
3192:  ADDWF  FEE,F
3194:  MOVLW  00
3196:  ADDWFC FEE,F
3198:  ADDWFC FEE,F
319A:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
319C:  MOVLW  1A
319E:  ADDWF  x3D,W
31A0:  MOVWF  FE9
31A2:  MOVLW  00
31A4:  ADDWFC x3E,W
31A6:  MOVWF  FEA
31A8:  MOVLW  01
31AA:  ADDWF  FEF,W
31AC:  MOVWF  00
31AE:  MOVLW  00
31B0:  ADDWFC FEC,W
31B2:  MOVWF  01
31B4:  MOVLW  00
31B6:  ADDWFC FEC,W
31B8:  MOVWF  02
31BA:  MOVLW  00
31BC:  ADDWFC FEC,W
31BE:  MOVF   FED,F
31C0:  MOVF   FED,F
31C2:  MOVF   FED,F
31C4:  MOVFF  00,FEF
31C8:  MOVFF  01,FEC
31CC:  MOVFF  02,FEC
31D0:  MOVWF  FEC
....................               ack = ps->SND_ACK;
31D2:  MOVLW  1A
31D4:  ADDWF  x3D,W
31D6:  MOVWF  FE9
31D8:  MOVLW  00
31DA:  ADDWFC x3E,W
31DC:  MOVWF  FEA
31DE:  MOVFF  FEF,32D
31E2:  MOVFF  FEC,32E
31E6:  MOVFF  FEC,32F
31EA:  MOVFF  FEC,330
....................                   ps->smState = TCP_LAST_ACK;
31EE:  MOVFF  33D,FE9
31F2:  MOVFF  33E,FEA
31F6:  MOVLW  09
31F8:  MOVWF  FEF
....................                }
.................... 
....................                // Check if there is any application data in
....................                // this packet.
....................                if(len)
31FA:  MOVF   x2B,W
31FC:  IORWF  x2C,W
31FE:  BZ    3288
....................                {
....................                   // There is data.  Make it available if we
....................                   // don't already have data available.
....................                   if(!ps->Flags.bIsGetReady)
3200:  MOVLW  23
3202:  ADDWF  x3D,W
3204:  MOVWF  FE9
3206:  MOVLW  00
3208:  ADDWFC x3E,W
320A:  MOVWF  FEA
320C:  BTFSC  FEF.3
320E:  BRA    3246
....................                   {
....................                      ps->Flags.bIsGetReady   = TRUE;
3210:  MOVLW  23
3212:  ADDWF  x3D,W
3214:  MOVWF  FE9
3216:  MOVLW  00
3218:  ADDWFC x3E,W
321A:  MOVWF  FEA
321C:  BSF    FEF.3
....................                      ps->RxCount             = len;
321E:  MOVLW  12
3220:  ADDWF  x3D,W
3222:  MOVWF  FE9
3224:  MOVLW  00
3226:  ADDWFC x3E,W
3228:  MOVWF  FEA
322A:  MOVFF  32C,FEC
322E:  MOVF   FED,F
3230:  MOVFF  32B,FEF
....................                      ps->Flags.bFirstRead    = TRUE;
3234:  MOVLW  23
3236:  ADDWF  x3D,W
3238:  MOVWF  FE9
323A:  MOVLW  00
323C:  ADDWFC x3E,W
323E:  MOVWF  FEA
3240:  BSF    FEF.2
.................... 
....................                      // 4/1/02
....................                      flags |= ACK;
3242:  BSF    x3F.4
....................                   }
3244:  BRA    3286
....................                   // There is data, but we cannot handle it at this time.
....................                   else
....................                   {
....................                      //DebugPrint("D");
....................                      // Since we cannot accept this packet,
....................                      // restore to previous seq and ack.
....................                      // and do not send anything back.
....................                      // Host has to resend this packet when
....................                      // we are ready.
....................                      ps->SND_SEQ = prevSeq;
3246:  MOVLW  16
3248:  ADDWF  x3D,W
324A:  MOVWF  FE9
324C:  MOVLW  00
324E:  ADDWFC x3E,W
3250:  MOVWF  FEA
3252:  MOVFF  339,FEF
3256:  MOVFF  33A,FEC
325A:  MOVFF  33B,FEC
325E:  MOVFF  33C,FEC
....................                      ps->SND_ACK = prevAck;
3262:  MOVLW  1A
3264:  ADDWF  x3D,W
3266:  MOVWF  FE9
3268:  MOVLW  00
326A:  ADDWFC x3E,W
326C:  MOVWF  FEA
326E:  MOVFF  335,FEF
3272:  MOVFF  336,FEC
3276:  MOVFF  337,FEC
327A:  MOVFF  338,FEC
.................... 
....................                      MACDiscardRx();
327E:  MOVLB  0
3280:  CALL   1100
3284:  MOVLB  3
....................                   }
....................                }
3286:  BRA    3290
....................                // There is no data in this packet, and thus it
....................                // can be thrown away.
....................                else
....................                {
....................                   MACDiscardRx();
3288:  MOVLB  0
328A:  CALL   1100
328E:  MOVLB  3
....................                }
....................             }
3290:  BRA    3460
....................             // Connection is not established; check if we've sent
....................             // a FIN and expect our last ACK
....................             else if(ps->smState == TCP_LAST_ACK)
3292:  MOVFF  33D,FE9
3296:  MOVFF  33E,FEA
329A:  MOVF   FEF,W
329C:  SUBLW  09
329E:  BNZ   32CA
....................             {
....................                MACDiscardRx();
32A0:  MOVLB  0
32A2:  CALL   1100
.................... 
....................                if(h->Flags.bits.flagACK)
32A6:  MOVLW  0D
32A8:  MOVLB  3
32AA:  ADDWF  x29,W
32AC:  MOVWF  FE9
32AE:  MOVLW  00
32B0:  ADDWFC x2A,W
32B2:  MOVWF  FEA
32B4:  BTFSS  FEF.4
32B6:  BRA    32C8
....................                {
....................                   CloseSocket(ps);
32B8:  MOVFF  33E,345
32BC:  MOVFF  33D,344
32C0:  MOVLB  0
32C2:  CALL   24A4
32C6:  MOVLB  3
....................                }
....................             }
32C8:  BRA    3460
....................             else if(ps->smState == TCP_FIN_WAIT_1)
32CA:  MOVFF  33D,FE9
32CE:  MOVFF  33E,FEA
32D2:  MOVF   FEF,W
32D4:  SUBLW  04
32D6:  BNZ   339C
....................             {
....................                MACDiscardRx();
32D8:  MOVLB  0
32DA:  CALL   1100
.................... 
....................                if(h->Flags.bits.flagFIN)
32DE:  MOVLW  0D
32E0:  MOVLB  3
32E2:  ADDWF  x29,W
32E4:  MOVWF  FE9
32E6:  MOVLW  00
32E8:  ADDWFC x2A,W
32EA:  MOVWF  FEA
32EC:  BTFSS  FEF.0
32EE:  BRA    337A
....................                {
....................                   flags = ACK;
32F0:  MOVLW  10
32F2:  MOVWF  x3F
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
32F4:  MOVLW  1A
32F6:  ADDWF  x3D,W
32F8:  MOVWF  FE9
32FA:  MOVLW  00
32FC:  ADDWFC x3E,W
32FE:  MOVWF  FEA
3300:  MOVLW  01
3302:  ADDWF  FEF,W
3304:  MOVWF  00
3306:  MOVLW  00
3308:  ADDWFC FEC,W
330A:  MOVWF  01
330C:  MOVLW  00
330E:  ADDWFC FEC,W
3310:  MOVWF  02
3312:  MOVLW  00
3314:  ADDWFC FEC,W
3316:  MOVF   FED,F
3318:  MOVF   FED,F
331A:  MOVF   FED,F
331C:  MOVFF  00,FEF
3320:  MOVFF  01,FEC
3324:  MOVFF  02,FEC
3328:  MOVWF  FEC
....................               ack = ps->SND_ACK;
332A:  MOVLW  1A
332C:  ADDWF  x3D,W
332E:  MOVWF  FE9
3330:  MOVLW  00
3332:  ADDWFC x3E,W
3334:  MOVWF  FEA
3336:  MOVFF  FEF,32D
333A:  MOVFF  FEC,32E
333E:  MOVFF  FEC,32F
3342:  MOVFF  FEC,330
....................                   if(h->Flags.bits.flagACK)
3346:  MOVLW  0D
3348:  ADDWF  x29,W
334A:  MOVWF  FE9
334C:  MOVLW  00
334E:  ADDWFC x2A,W
3350:  MOVWF  FEA
3352:  BTFSS  FEF.4
3354:  BRA    3368
....................                   {
....................                      CloseSocket(ps);
3356:  MOVFF  33E,345
335A:  MOVFF  33D,344
335E:  MOVLB  0
3360:  CALL   24A4
....................                   }
3364:  BRA    3376
3366:  MOVLB  3
....................                   else
....................                   {
....................                      ps->smState = TCP_CLOSING;
3368:  MOVFF  33D,FE9
336C:  MOVFF  33E,FEA
3370:  MOVLW  06
3372:  MOVWF  FEF
3374:  MOVLB  0
....................                   }
....................                }
3376:  BRA    3398
3378:  MOVLB  3
....................                else if(h->Flags.bits.flagACK)
337A:  MOVLW  0D
337C:  ADDWF  x29,W
337E:  MOVWF  FE9
3380:  MOVLW  00
3382:  ADDWFC x2A,W
3384:  MOVWF  FEA
3386:  BTFSS  FEF.4
3388:  BRA    3396
....................                {
....................                   ps->smState = TCP_FIN_WAIT_2;
338A:  MOVFF  33D,FE9
338E:  MOVFF  33E,FEA
3392:  MOVLW  05
3394:  MOVWF  FEF
3396:  MOVLB  0
....................                }
....................             }
3398:  BRA    345E
339A:  MOVLB  3
....................             else if(ps->smState == TCP_FIN_WAIT_2)
339C:  MOVFF  33D,FE9
33A0:  MOVFF  33E,FEA
33A4:  MOVF   FEF,W
33A6:  SUBLW  05
33A8:  BNZ   342A
....................             {
....................                MACDiscardRx();
33AA:  MOVLB  0
33AC:  CALL   1100
.................... 
....................                if(h->Flags.bits.flagFIN)
33B0:  MOVLW  0D
33B2:  MOVLB  3
33B4:  ADDWF  x29,W
33B6:  MOVWF  FE9
33B8:  MOVLW  00
33BA:  ADDWFC x2A,W
33BC:  MOVWF  FEA
33BE:  BTFSS  FEF.0
33C0:  BRA    3428
....................                {
....................                   flags = ACK;
33C2:  MOVLW  10
33C4:  MOVWF  x3F
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
33C6:  MOVLW  1A
33C8:  ADDWF  x3D,W
33CA:  MOVWF  FE9
33CC:  MOVLW  00
33CE:  ADDWFC x3E,W
33D0:  MOVWF  FEA
33D2:  MOVLW  01
33D4:  ADDWF  FEF,W
33D6:  MOVWF  00
33D8:  MOVLW  00
33DA:  ADDWFC FEC,W
33DC:  MOVWF  01
33DE:  MOVLW  00
33E0:  ADDWFC FEC,W
33E2:  MOVWF  02
33E4:  MOVLW  00
33E6:  ADDWFC FEC,W
33E8:  MOVF   FED,F
33EA:  MOVF   FED,F
33EC:  MOVF   FED,F
33EE:  MOVFF  00,FEF
33F2:  MOVFF  01,FEC
33F6:  MOVFF  02,FEC
33FA:  MOVWF  FEC
....................               ack = ps->SND_ACK;
33FC:  MOVLW  1A
33FE:  ADDWF  x3D,W
3400:  MOVWF  FE9
3402:  MOVLW  00
3404:  ADDWFC x3E,W
3406:  MOVWF  FEA
3408:  MOVFF  FEF,32D
340C:  MOVFF  FEC,32E
3410:  MOVFF  FEC,32F
3414:  MOVFF  FEC,330
....................                   CloseSocket(ps);
3418:  MOVFF  33E,345
341C:  MOVFF  33D,344
3420:  MOVLB  0
3422:  CALL   24A4
3426:  MOVLB  3
....................                }
....................             }
3428:  BRA    3460
....................             else if ( ps->smState == TCP_CLOSING )
342A:  MOVFF  33D,FE9
342E:  MOVFF  33E,FEA
3432:  MOVF   FEF,W
3434:  SUBLW  06
3436:  BNZ   3460
....................             {
....................                MACDiscardRx();
3438:  MOVLB  0
343A:  CALL   1100
.................... 
....................                if ( h->Flags.bits.flagACK )
343E:  MOVLW  0D
3440:  MOVLB  3
3442:  ADDWF  x29,W
3444:  MOVWF  FE9
3446:  MOVLW  00
3448:  ADDWFC x2A,W
344A:  MOVWF  FEA
344C:  BTFSS  FEF.4
344E:  BRA    3460
....................                {
....................                   CloseSocket(ps);
3450:  MOVFF  33E,345
3454:  MOVFF  33D,344
3458:  MOVLB  0
345A:  CALL   24A4
345E:  MOVLB  3
....................                }
....................             }
....................          }
....................       }
3460:  BRA    347E
....................       // This packet's sequence number does not match what we were
....................       // expecting (the last value we ACKed).  Throw this packet
....................       // away.  This may happen if packets are delivered out of order.
....................       // Not enough memory is available on our PIC or Ethernet
....................       // controller to implement a robust stream reconstruction
....................       // buffer.  As a result, the remote node will just have to
....................       // retransmit its packets starting with the proper sequence number.
....................       else
....................       {
....................          MACDiscardRx();
3462:  MOVLB  0
3464:  CALL   1100
.................... 
....................          // Send a new ACK out in case if the previous one was lost
....................          // (ACKs aren't ACKed).  This is required to prevent an
....................          // unlikely but possible situation which would cause the
....................          // connection to time out if the ACK was lost and the
....................          // remote node keeps sending us older data than we are
....................          // expecting.
....................          flags = ACK;
3468:  MOVLW  10
346A:  MOVLB  3
346C:  MOVWF  x3F
....................          ack = prevAck;
346E:  MOVFF  338,330
3472:  MOVFF  337,32F
3476:  MOVFF  336,32E
347A:  MOVFF  335,32D
....................       }
....................    }
.................... 
.................... SendTCPControlPacket:
....................    if(flags)
347E:  MOVLB  3
3480:  MOVF   x3F,F
3482:  BZ    34E6
....................    {
....................       SendTCP(remote,
....................          h->DestPort,
....................          h->SourcePort,
....................          seq,
....................          ack,
....................          flags);
3484:  MOVLW  02
3486:  ADDWF  x29,W
3488:  MOVWF  FE9
348A:  MOVLW  00
348C:  ADDWFC x2A,W
348E:  MOVWF  FEA
3490:  MOVFF  FEC,354
3494:  MOVF   FED,F
3496:  MOVFF  FEF,353
349A:  MOVFF  329,FE9
349E:  MOVFF  32A,FEA
34A2:  MOVFF  FEC,356
34A6:  MOVF   FED,F
34A8:  MOVFF  FEF,355
34AC:  MOVFF  328,352
34B0:  MOVFF  327,351
34B4:  MOVFF  334,35A
34B8:  MOVFF  333,359
34BC:  MOVFF  332,358
34C0:  MOVFF  331,357
34C4:  MOVFF  330,35E
34C8:  MOVFF  32F,35D
34CC:  MOVFF  32E,35C
34D0:  MOVFF  32D,35B
34D4:  MOVFF  33F,35F
34D8:  SETF   x60
34DA:  CLRF   x62
34DC:  CLRF   x61
34DE:  MOVLB  0
34E0:  CALL   28D0
34E4:  MOVLB  3
....................    }
34E6:  MOVLB  0
34E8:  GOTO   3676 (RETURN)
.................... 
....................    /*if (debugLastState != ps->smState)
....................    {
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s);
....................       DebugTCPDisplayState(debugLastState);
....................       debug_tcp(" -> ");
....................       DebugTCPDisplayState(ps->smState);
....................    }*/
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_ICMP
....................    #include "tcpip/icmp.c"
.................... /*********************************************************************
....................  *
....................  *                  ICMP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ICMP.C
....................  * Dependencies:    ICMP.h
....................  *                  string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                  IP.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/icmp.h"
.................... /*********************************************************************
....................  *
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ICMP.h
....................  * Dependencies:    StackTsk.h
....................  *                  IP.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef ICMP_H
.................... #define ICMP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes.
.................... //#define MAX_ICMP_DATA       (32)
.................... #define MAX_ICMP_DATA       (64)
.................... 
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA)
.................... 
.................... 
.................... typedef enum _ICMP_CODE
.................... {
....................     ICMP_ECHO_REPLY = 0,
....................     ICMP_ECHO_REQUEST = 8
.................... } ICMP_CODE, ICMP_REQUESTS;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPIsTxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is ready
....................  *                  FALSE if transmit buffer is not ready
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ICMPPut(NODE_INFO *remote,
....................  *                               ICMP_CODE code,
....................  *                               BYTE *data,
....................  *                               BYTE len,
....................  *                               WORD id,
....................  *                               WORD seq)
....................  *
....................  * PreCondition:    ICMPIsTxReady() == TRUE
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST
....................  *                  data        - Data bytes
....................  *                  len         - Number of bytes to send
....................  *                  id          - ICMP identifier
....................  *                  seq         - ICMP sequence number
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            A ICMP packet is created and put on MAC.
....................  *
....................  ********************************************************************/
.................... void ICMPPut(NODE_INFO *remote,
....................              ICMP_CODE code,
....................              BYTE *data,
....................              BYTE len,
....................              WORD id,
....................              WORD seq);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code,
....................  *                              BYTE *data,
....................  *                              BYTE *len,
....................  *                              WORD *id,
....................  *                              WORD *seq)
....................  *
....................  * PreCondition:    MAC buffer contains ICMP type packet.
....................  *
....................  * Input:           code    - Buffer to hold ICMP code value
....................  *                  data    - Buffer to hold ICMP data
....................  *                  len     - Buffer to hold ICMP data length
....................  *                  id      - Buffer to hold ICMP id
....................  *                  seq     - Buffer to hold ICMP seq
....................  *
....................  * Output:          TRUE if valid ICMP packet was received
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ICMPGet(ICMP_CODE *code,
....................              BYTE *data,
....................              BYTE *len,
....................              WORD *id,
....................              WORD *seq);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define debug_icmp
.................... //#define debug_icmp   debug_printf
.................... 
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h
.................... 
.................... /*
....................  * ICMP packet definition
....................  */
.................... typedef struct _ICMP_PACKET
.................... {
....................     BYTE    Type;
....................     BYTE    Code;
....................     WORD    Checksum;
....................     WORD    Identifier;
....................     WORD    SequenceNumber;
....................     BYTE    Data[MAX_ICMP_DATA];
.................... } ICMP_PACKET;
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA)
.................... 
.................... static void SwapICMPPacket(ICMP_PACKET* p);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code,
....................  *                              BYTE *data,
....................  *                              BYTE *len,
....................  *                              WORD *id,
....................  *                              WORD *seq)
....................  *
....................  * PreCondition:    MAC buffer contains ICMP type packet.
....................  *
....................  * Input:           code    - Buffer to hold ICMP code value
....................  *                  data    - Buffer to hold ICMP data
....................  *                  len     - Buffer to hold ICMP data length
....................  *                  id      - Buffer to hold ICMP id
....................  *                  seq     - Buffer to hold ICMP seq
....................  *
....................  * Output:          TRUE if valid ICMP packet was received
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ICMPGet(ICMP_CODE *code,
....................              BYTE *data,
....................              BYTE *len,
....................              WORD *id,
....................              WORD *seq)
.................... {
....................     ICMP_PACKET packet;
....................     WORD CalcChecksum;
....................     WORD ReceivedChecksum;
.................... #if !defined(MCHP_MAC)
....................     WORD checksums[2];
.................... #endif
.................... 
.................... //    debug_icmp("\r\nICMP GET ");
.................... 
....................     // Obtain the ICMP Header
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE);
*
3750:  MOVLW  03
3752:  MOVLB  3
3754:  MOVWF  x53
3756:  MOVLW  06
3758:  MOVWF  x52
375A:  MOVFF  353,398
375E:  MOVWF  x97
3760:  CLRF   x9A
3762:  MOVLW  08
3764:  MOVWF  x99
3766:  MOVLB  0
3768:  CALL   116C
.................... 
.................... 
.................... #if defined(MCHP_MAC)
....................    // Calculate the checksum using the Microchip MAC's DMA module
....................    // The checksum data includes the precomputed checksum in the
....................    // header, so a valid packet will always have a checksum of
....................    // 0x0000 if the packet is not disturbed.
....................    ReceivedChecksum = 0x0000;
376C:  MOVLB  3
376E:  CLRF   x51
3770:  CLRF   x50
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len);
3772:  MOVFF  301,FEA
3776:  MOVFF  300,FE9
377A:  MOVFF  FEF,355
377E:  CLRF   x54
3780:  MOVLW  14
3782:  MOVWF  x53
3784:  CLRF   x56
3786:  MOVLB  0
3788:  CALL   1AFA
378C:  MOVFF  02,34F
3790:  MOVFF  01,34E
.................... #endif
.................... 
....................    // Obtain the ICMP data payload
....................     *len -= ICMP_HEADER_SIZE;
3794:  MOVFF  301,FEA
3798:  MOVLB  3
379A:  MOVFF  300,FE9
379E:  MOVLW  08
37A0:  SUBWF  FEF,W
37A2:  MOVWF  FEF
....................     MACGetArray(data, *len);
37A4:  MOVFF  301,FEA
37A8:  MOVFF  300,FE9
37AC:  MOVFF  FEF,399
37B0:  MOVFF  2FF,398
37B4:  MOVFF  2FE,397
37B8:  CLRF   x9A
37BA:  MOVLB  0
37BC:  CALL   116C
.................... 
.................... 
.................... #if !defined(MCHP_MAC)
....................    // Calculte the checksum in local memory without hardware help
....................     ReceivedChecksum = packet.Checksum;
....................     packet.Checksum = 0;
.................... 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE);
....................     checksums[1] = ~CalcIPChecksum(data, *len);
.................... 
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD));
.................... #endif
.................... 
....................     SwapICMPPacket(&packet);
37C0:  MOVLW  03
37C2:  MOVLB  3
37C4:  MOVWF  x53
37C6:  MOVLW  06
37C8:  MOVWF  x52
37CA:  MOVLB  0
37CC:  RCALL  3688
.................... 
....................     *code = packet.Type;
37CE:  MOVFF  2FD,FEA
37D2:  MOVLB  2
37D4:  MOVFF  2FC,FE9
37D8:  MOVFF  306,FEF
....................     *id = packet.Identifier;
37DC:  MOVFF  303,FEA
37E0:  MOVLB  3
37E2:  MOVFF  302,FE9
37E6:  MOVFF  30B,FEC
37EA:  MOVF   FED,F
37EC:  MOVFF  30A,FEF
....................     *seq = packet.SequenceNumber;
37F0:  MOVFF  305,FEA
37F4:  MOVFF  304,FE9
37F8:  MOVFF  30D,FEC
37FC:  MOVF   FED,F
37FE:  MOVFF  30C,FEF
.................... 
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum);
.................... 
....................     return ( CalcChecksum == ReceivedChecksum );
3802:  MOVF   x50,W
3804:  SUBWF  x4E,W
3806:  BNZ   380E
3808:  MOVF   x51,W
380A:  SUBWF  x4F,W
380C:  BZ    3812
380E:  MOVLW  00
3810:  BRA    3814
3812:  MOVLW  01
3814:  MOVWF  01
3816:  MOVLB  0
3818:  GOTO   6D6C (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void ICMPPut(NODE_INFO *remote,
....................  *                               ICMP_CODE code,
....................  *                               BYTE *data,
....................  *                               BYTE len,
....................  *                               WORD id,
....................  *                               WORD seq)
....................  *
....................  * PreCondition:    ICMPIsTxReady() == TRUE
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST
....................  *                  data        - Data bytes
....................  *                  len         - Number of bytes to send
....................  *                  id          - ICMP identifier
....................  *                  seq         - ICMP sequence number
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            A ICMP packet is created and put on MAC.
....................  *
....................  ********************************************************************/
.................... void ICMPPut(NODE_INFO *remote,
....................              ICMP_CODE code,
....................              BYTE *data,
....................              BYTE len,
....................              WORD id,
....................              WORD seq)
.................... {
....................     ICMP_PACKET   packet;
....................     WORD ICMPLen;
....................    BUFFER MyTxBuffer;
....................    MyTxBuffer = MACGetTxBuffer(TRUE);
381C:  MOVLW  01
381E:  MOVLB  3
3820:  MOVWF  x89
3822:  MOVLB  0
3824:  CALL   14DE
3828:  MOVFF  01,34E
.................... 
....................    // Abort if there is no where in the Ethernet controller to
....................    // store this packet.
....................    if(MyTxBuffer == INVALID_BUFFER)
382C:  MOVLB  3
382E:  INCFSZ x4E,W
3830:  BRA    3834
....................       return;
3832:  BRA    3930
.................... 
....................    IPSetTxBuffer(MyTxBuffer, 0);
3834:  MOVFF  34E,3A2
3838:  CLRF   xA4
383A:  MOVLW  14
383C:  MOVWF  xA3
383E:  MOVLB  0
3840:  CALL   1506
.................... 
.................... 
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len;
3844:  CLRF   03
3846:  MOVLB  2
3848:  MOVF   xFF,W
384A:  ADDLW  08
384C:  MOVLB  3
384E:  MOVWF  x4C
3850:  MOVLW  00
3852:  ADDWFC 03,W
3854:  MOVWF  x4D
.................... 
....................     packet.Code             = 0;
3856:  CLRF   x05
....................     packet.Type             = code;
3858:  MOVFF  2FC,304
....................     packet.Checksum         = 0;
385C:  CLRF   x07
385E:  CLRF   x06
....................     packet.Identifier       = id;
3860:  MOVFF  301,309
3864:  MOVFF  300,308
....................     packet.SequenceNumber   = seq;
3868:  MOVFF  303,30B
386C:  MOVFF  302,30A
.................... 
....................     memcpy((void*)packet.Data, (void*)data, len);
3870:  MOVLW  03
3872:  MOVWF  FEA
3874:  MOVLW  0C
3876:  MOVWF  FE9
3878:  MOVFF  2FE,FE2
387C:  MOVFF  2FD,FE1
3880:  MOVLB  2
3882:  MOVF   xFF,W
3884:  MOVWF  01
3886:  BZ    3890
3888:  MOVFF  FE6,FEE
388C:  DECFSZ 01,F
388E:  BRA    3888
.................... 
....................     SwapICMPPacket(&packet);
3890:  MOVLW  03
3892:  MOVLB  3
3894:  MOVWF  x53
3896:  MOVLW  04
3898:  MOVWF  x52
389A:  MOVLB  0
389C:  RCALL  3688
.................... 
.................... #if !defined(MCHP_MAC)
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet,
....................                                     ICMPLen);
.................... #endif
.................... 
....................     IPPutHeader(remote,
....................                 IP_PROT_ICMP,
....................                 (WORD)(ICMP_HEADER_SIZE + len));
389E:  MOVLW  08
38A0:  MOVLB  2
38A2:  ADDWF  xFF,W
38A4:  MOVLB  3
38A6:  MOVWF  x4F
38A8:  MOVFF  2FB,38A
38AC:  MOVFF  2FA,389
38B0:  MOVLW  01
38B2:  MOVWF  x8B
38B4:  CLRF   x8D
38B6:  MOVFF  34F,38C
38BA:  MOVLB  0
38BC:  CALL   27B0
.................... 
....................     IPPutArray((BYTE*)&packet, ICMPLen);
38C0:  MOVLW  03
38C2:  MOVLB  3
38C4:  MOVWF  x50
38C6:  MOVLW  04
38C8:  MOVWF  x4F
38CA:  MOVFF  350,3AE
38CE:  MOVWF  xAD
38D0:  MOVFF  34D,3B0
38D4:  MOVFF  34C,3AF
38D8:  MOVLB  0
38DA:  CALL   15C2
.................... 
.................... #if defined(MCHP_MAC)
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen);
38DE:  MOVLB  3
38E0:  CLRF   xA3
38E2:  MOVLW  14
38E4:  MOVWF  xA2
38E6:  MOVFF  34D,3A5
38EA:  MOVFF  34C,3A4
38EE:  MOVLB  0
38F0:  CALL   26D8
38F4:  MOVFF  02,307
38F8:  MOVFF  01,306
....................    IPSetTxBuffer(MyTxBuffer, 2);
38FC:  MOVFF  34E,3A2
3900:  MOVLB  3
3902:  CLRF   xA4
3904:  MOVLW  16
3906:  MOVWF  xA3
3908:  MOVLB  0
390A:  CALL   1506
....................    MACPutArray((BYTE*)&packet.Checksum, 2);
390E:  MOVLW  03
3910:  MOVLB  3
3912:  MOVWF  x50
3914:  MOVLW  06
3916:  MOVWF  x4F
3918:  MOVFF  350,3AE
391C:  MOVWF  xAD
391E:  CLRF   xB0
3920:  MOVLW  02
3922:  MOVWF  xAF
3924:  MOVLB  0
3926:  CALL   15C2
.................... #endif
.................... 
.................... 
....................     MACFlush();
392A:  CALL   16D0
392E:  MOVLB  3
3930:  MOVLB  0
3932:  GOTO   6DC6 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           p - ICMP packet header
....................  *
....................  * Output:          ICMP packet is swapped
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void SwapICMPPacket(ICMP_PACKET* p)
.................... {
....................     p->Identifier           = swaps(p->Identifier);
*
3688:  MOVLW  04
368A:  MOVLB  3
368C:  ADDWF  x52,W
368E:  MOVWF  01
3690:  MOVLW  00
3692:  ADDWFC x53,W
3694:  MOVWF  03
3696:  MOVFF  01,354
369A:  MOVWF  x55
369C:  MOVLW  04
369E:  ADDWF  x52,W
36A0:  MOVWF  FE9
36A2:  MOVLW  00
36A4:  ADDWFC x53,W
36A6:  MOVWF  FEA
36A8:  MOVFF  FEC,3A9
36AC:  MOVF   FED,F
36AE:  MOVFF  FEF,3A8
36B2:  MOVLB  0
36B4:  CALL   11CC
36B8:  MOVFF  355,FEA
36BC:  MOVFF  354,FE9
36C0:  MOVFF  02,FEC
36C4:  MOVF   FED,F
36C6:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber);
36CA:  MOVLW  06
36CC:  MOVLB  3
36CE:  ADDWF  x52,W
36D0:  MOVWF  01
36D2:  MOVLW  00
36D4:  ADDWFC x53,W
36D6:  MOVWF  03
36D8:  MOVFF  01,354
36DC:  MOVWF  x55
36DE:  MOVLW  06
36E0:  ADDWF  x52,W
36E2:  MOVWF  FE9
36E4:  MOVLW  00
36E6:  ADDWFC x53,W
36E8:  MOVWF  FEA
36EA:  MOVFF  FEC,3A9
36EE:  MOVF   FED,F
36F0:  MOVFF  FEF,3A8
36F4:  MOVLB  0
36F6:  CALL   11CC
36FA:  MOVFF  355,FEA
36FE:  MOVFF  354,FE9
3702:  MOVFF  02,FEC
3706:  MOVF   FED,F
3708:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum);
370C:  MOVLW  02
370E:  MOVLB  3
3710:  ADDWF  x52,W
3712:  MOVWF  01
3714:  MOVLW  00
3716:  ADDWFC x53,W
3718:  MOVWF  03
371A:  MOVFF  01,354
371E:  MOVWF  x55
3720:  MOVLW  02
3722:  ADDWF  x52,W
3724:  MOVWF  FE9
3726:  MOVLW  00
3728:  ADDWFC x53,W
372A:  MOVWF  FEA
372C:  MOVFF  FEC,3A9
3730:  MOVF   FED,F
3732:  MOVFF  FEF,3A8
3736:  MOVLB  0
3738:  CALL   11CC
373C:  MOVFF  355,FEA
3740:  MOVFF  354,FE9
3744:  MOVFF  02,FEC
3748:  MOVF   FED,F
374A:  MOVFF  01,FEF
374E:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_UDP
....................    #include "tcpip/udp.c"
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    #include "tcpip/dhcp.c"
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    #include "tcpip/telnet2.c"
.................... #endif
.................... 
.................... #if STACK_USE_ARP
....................    #include "tcpip/arptsk.c"
.................... /*********************************************************************
....................  *
....................  *                  ARP Server Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARPTsk.c
....................  * Dependencies:    compiler.h
....................  *                  string.h
....................  *                  ARP.h
....................  *                  ARPTsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case)
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes].
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP.
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/arp.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.h
....................  * Dependencies:    Stacktsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... #ifndef ARP_H
.................... #define ARP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................  * Following codes are must be used with ARPGet/Put functions.
....................  */
.................... #define ARP_REPLY       (0x00)
.................... #define ARP_REQUEST     (0x01)
.................... #define ARP_UNKNOWN     (0x02)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           ARPIsRxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if ARP receive buffer is full.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE)
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    MACIsTxReady() == TRUE
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode);
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/arptsk.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Server Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARPTsk.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes].
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef ARP_TSK_H
.................... #define ARP_TSK_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP Cache is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void ARPInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPProcess(void)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPProcess(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr  - IP Address to be resolved.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        An ARP request is sent.
....................  *
....................  * Note:
....................  ********************************************************************/
.................... void ARPResolve(IP_ADDR *IPAddr);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr,
....................  *                                      MAC_ADDR *MACAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr      - IPAddress to be resolved.
....................  *                  MACAddr     - Buffer to hold corresponding
....................  *                                MAC Address.
....................  *
....................  * Output:          TRUE if given IP Address has been resolved.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_arptask
.................... //#define debug_arptask   debug_printf
.................... 
.................... /*
....................  * ARP Task FSM States
....................  */
.................... typedef enum _ARP_STATE
.................... {
....................     SM_ARP_IDLE,
....................     SM_ARP_REPLY
.................... } ARP_STATE;
.................... 
.................... 
.................... /*
....................  * This ARP task caches one ARP response.
....................  */
.................... static ARP_STATE smARP;
.................... 
.................... static NODE_INFO Cache;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP Cache is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void ARPInit(void)
.................... {
....................     smARP = SM_ARP_IDLE;
*
0D18:  BCF    5A.1
.................... 
....................     Cache.MACAddr.v[0] = 0xff;
0D1A:  SETF   x63
....................     Cache.MACAddr.v[1] = 0xff;
0D1C:  SETF   x64
....................     Cache.MACAddr.v[2] = 0xff;
0D1E:  SETF   x65
....................     Cache.MACAddr.v[3] = 0xff;
0D20:  SETF   x66
....................     Cache.MACAddr.v[4] = 0xff;
0D22:  SETF   x67
....................     Cache.MACAddr.v[5] = 0xff;
0D24:  SETF   x68
.................... 
....................     Cache.IPAddr.Val = 0x0;
0D26:  CLRF   x6C
0D28:  CLRF   x6B
0D2A:  CLRF   x6A
0D2C:  CLRF   x69
0D2E:  GOTO   10F8 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPProcess(void)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPProcess(void)
.................... {
....................     NODE_INFO remoteNode;
....................     BYTE opCode;
.................... 
....................     switch(smARP)
*
1A6C:  MOVLW  00
1A6E:  BTFSC  5A.1
1A70:  MOVLW  01
1A72:  XORLW  00
1A74:  BZ    1A78
1A76:  BRA    1AD4
....................     {
....................     case SM_ARP_IDLE:
....................         if ( !ARPGet(&remoteNode, &opCode) )
1A78:  MOVLW  02
1A7A:  MOVLB  3
1A7C:  MOVWF  x06
1A7E:  MOVLW  FA
1A80:  MOVWF  x05
1A82:  MOVLW  03
1A84:  MOVWF  x08
1A86:  MOVLW  04
1A88:  MOVWF  x07
1A8A:  MOVLB  0
1A8C:  BRA    13FE
1A8E:  MOVF   01,F
1A90:  BNZ   1A94
....................             break;
1A92:  BRA    1AF2
.................... 
....................          //dsr add 071204
....................          //dsr fix 071206
....................          MACDiscardRx();
1A94:  CALL   1100
.................... 
....................         if ( opCode == ARP_REPLY )
1A98:  MOVLB  3
1A9A:  MOVF   x04,F
1A9C:  BNZ   1AD0
....................         {
.................... 			Cache.MACAddr = remoteNode.MACAddr;
1A9E:  CLRF   FEA
1AA0:  MOVLW  63
1AA2:  MOVWF  FE9
1AA4:  MOVLW  02
1AA6:  MOVWF  FE2
1AA8:  MOVLW  FA
1AAA:  MOVWF  FE1
1AAC:  MOVLW  06
1AAE:  MOVWF  01
1AB0:  MOVFF  FE6,FEE
1AB4:  DECFSZ 01,F
1AB6:  BRA    1AB0
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val;
1AB8:  MOVFF  303,6C
1ABC:  MOVFF  302,6B
1AC0:  MOVFF  301,6A
1AC4:  MOVFF  300,69
....................             break;
1AC8:  MOVLB  0
1ACA:  BRA    1AF2
....................         }
1ACC:  BRA    1AD4
1ACE:  MOVLB  3
....................         else
....................             smARP = SM_ARP_REPLY;
1AD0:  BSF    5A.1
1AD2:  MOVLB  0
.................... 
....................     default:
.................... 		if(ARPPut(&remoteNode, ARP_REPLY))
1AD4:  MOVLW  02
1AD6:  MOVLB  3
1AD8:  MOVWF  x06
1ADA:  MOVLW  FA
1ADC:  MOVWF  x05
1ADE:  CLRF   x07
1AE0:  MOVLB  0
1AE2:  BRA    18FC
1AE4:  MOVF   01,F
1AE6:  BZ    1AEC
.................... 		{
.................... 			smARP = SM_ARP_IDLE;
1AE8:  BCF    5A.1
.................... 		}
1AEA:  BRA    1AF2
....................         else
....................             return FALSE;
1AEC:  MOVLW  00
1AEE:  MOVWF  01
1AF0:  BRA    1AF6
....................         break;
.................... 
....................     }
....................     return TRUE;
1AF2:  MOVLW  01
1AF4:  MOVWF  01
1AF6:  GOTO   6C9E (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr)
....................  *
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE
....................  *
....................  * Input:           IPAddr  - IP Address to be resolved.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        An ARP request is sent.
....................  ********************************************************************/
.................... void ARPResolve(IP_ADDR *IPAddr)
.................... {
....................     NODE_INFO remoteNode;
.................... 
....................     remoteNode.IPAddr = *IPAddr;
.................... 
....................     ARPPut(&remoteNode, ARP_REQUEST);
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr,
....................  *                                      MAC_ADDR *MACAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr      - IPAddress to be resolved.
....................  *                  MACAddr     - Buffer to hold corresponding
....................  *                                MAC Address.
....................  *
....................  * Output:          TRUE if given IP Address has been resolved.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr)
.................... {
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val)
....................     {
....................         *MACAddr = Cache.MACAddr;
....................         return TRUE;
....................     }
....................     return FALSE;
.................... }
.................... 
.................... 
.................... 
....................    #include "tcpip/arp.c"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.c
....................  * Dependencies:    string.h
....................  *                  stacktsk.h
....................  *                  helpers.h
....................  *                  arp.h
....................  *                  mac.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/arp.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.h
....................  * Dependencies:    Stacktsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the Company) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Companys customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... #ifndef ARP_H
.................... #define ARP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... #include "tcpip/mac.h"
.................... 
.................... /*
....................  * Following codes are must be used with ARPGet/Put functions.
....................  */
.................... #define ARP_REPLY       (0x00)
.................... #define ARP_REQUEST     (0x01)
.................... #define ARP_UNKNOWN     (0x02)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           ARPIsRxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if ARP receive buffer is full.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE)
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    MACIsTxReady() == TRUE
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode);
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_arp
.................... //#define debug_arp debug_printf
.................... 
.................... // ARP Operation codes.
.................... #define ARP_OPERATION_REQ       0x01u
.................... #define ARP_OPERATION_RESP      0x02u
.................... 
.................... // ETHERNET packet type as defined by IEEE 802.3
.................... #define HW_ETHERNET             (0x0001u)
.................... #define ARP_IP                  (0x0800u)
.................... 
.................... 
.................... 
.................... // ARP packet
.................... typedef struct _ARP_PACKET
.................... {
....................     WORD        HardwareType;
....................     WORD        Protocol;
....................     BYTE        MACAddrLen;
....................     BYTE        ProtocolLen;
....................     WORD        Operation;
....................     MAC_ADDR    SenderMACAddr;
....................     IP_ADDR     SenderIPAddr;
....................     MAC_ADDR    TargetMACAddr;
....................     IP_ADDR     TargetIPAddr;
.................... } ARP_PACKET;
.................... 
.................... // Helper function
.................... static void SwapARPPacket(ARP_PACKET *p);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode)
.................... {
....................     ARP_PACKET packet;
.................... 
....................     //MACGetArray((int8*)&packet, sizeof(packet));
....................     MACGetArray(&packet, sizeof(ARP_PACKET));
*
13FE:  MOVLW  03
1400:  MOVLB  3
1402:  MOVWF  x98
1404:  MOVLW  09
1406:  MOVWF  x97
1408:  CLRF   x9A
140A:  MOVLW  1C
140C:  MOVWF  x99
140E:  MOVLB  0
1410:  RCALL  116C
.................... 
....................     MACDiscardRx();
1412:  RCALL  1100
.................... 
....................     SwapARPPacket(&packet);
1414:  MOVLW  03
1416:  MOVLB  3
1418:  MOVWF  x26
141A:  MOVLW  09
141C:  MOVWF  x25
141E:  MOVLB  0
1420:  RCALL  1348
.................... 
....................    //debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U",
....................      // packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen,
....................      // packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1],
....................      // packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3],
....................      // packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]);
.................... 
....................     if ( packet.HardwareType != HW_ETHERNET     ||
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  ||
....................          packet.ProtocolLen != sizeof(IP_ADDR) )
1422:  MOVLB  3
1424:  DECFSZ x09,W
1426:  BRA    1438
1428:  MOVF   x0A,F
142A:  BNZ   1438
142C:  MOVF   x0D,W
142E:  SUBLW  06
1430:  BNZ   1438
1432:  MOVF   x0E,W
1434:  SUBLW  04
1436:  BZ    143E
....................          return FALSE;
1438:  MOVLW  00
143A:  MOVWF  01
143C:  BRA    14D8
.................... 
....................     if ( packet.Operation == ARP_OPERATION_RESP )
143E:  MOVF   x0F,W
1440:  SUBLW  02
1442:  BNZ   1454
1444:  MOVF   x10,F
1446:  BNZ   1454
....................         *opCode = ARP_REPLY;
1448:  MOVFF  308,FEA
144C:  MOVFF  307,FE9
1450:  CLRF   FEF
1452:  BRA    147C
....................     else if ( packet.Operation == ARP_OPERATION_REQ )
1454:  DECFSZ x0F,W
1456:  BRA    146A
1458:  MOVF   x10,F
145A:  BNZ   146A
....................         *opCode = ARP_REQUEST;
145C:  MOVFF  308,FEA
1460:  MOVFF  307,FE9
1464:  MOVLW  01
1466:  MOVWF  FEF
1468:  BRA    147C
....................     else
....................     {
....................         *opCode = ARP_UNKNOWN;
146A:  MOVFF  308,FEA
146E:  MOVFF  307,FE9
1472:  MOVLW  02
1474:  MOVWF  FEF
....................         return FALSE;
1476:  MOVLW  00
1478:  MOVWF  01
147A:  BRA    14D8
....................     }
.................... 
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val)
147C:  MOVF   1D,W
147E:  SUBWF  x21,W
1480:  BNZ   14D4
1482:  MOVF   1E,W
1484:  SUBWF  x22,W
1486:  BNZ   14D4
1488:  MOVF   1F,W
148A:  SUBWF  x23,W
148C:  BNZ   14D4
148E:  MOVF   20,W
1490:  SUBWF  x24,W
1492:  BNZ   14D4
....................     {
....................         remote->MACAddr     = packet.SenderMACAddr;
1494:  MOVFF  305,FE9
1498:  MOVFF  306,FEA
149C:  MOVLW  03
149E:  MOVWF  FE2
14A0:  MOVLW  11
14A2:  MOVWF  FE1
14A4:  MOVLW  06
14A6:  MOVWF  01
14A8:  MOVFF  FE6,FEE
14AC:  DECFSZ 01,F
14AE:  BRA    14A8
....................         remote->IPAddr      = packet.SenderIPAddr;
14B0:  MOVLW  06
14B2:  ADDWF  x05,W
14B4:  MOVWF  FE9
14B6:  MOVLW  00
14B8:  ADDWFC x06,W
14BA:  MOVWF  FEA
14BC:  MOVFF  317,FEF
14C0:  MOVFF  318,FEC
14C4:  MOVFF  319,FEC
14C8:  MOVFF  31A,FEC
....................         return TRUE;
14CC:  MOVLW  01
14CE:  MOVWF  01
14D0:  BRA    14D8
....................     }
14D2:  BRA    14D8
....................     else
....................         return FALSE;
14D4:  MOVLW  00
14D6:  MOVWF  01
14D8:  MOVLB  0
14DA:  GOTO   1A8E (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          TRUE - The ARP packet was generated properly
....................  *               FALSE - Unable to allocate a TX buffer
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode)
.................... {
....................     ARP_PACKET packet;
.................... 
....................    BUFFER MyTxBuffer;
....................    MyTxBuffer = MACGetTxBuffer(TRUE);
*
18FC:  MOVLW  01
18FE:  MOVLB  3
1900:  MOVWF  x89
1902:  MOVLB  0
1904:  RCALL  14DE
1906:  MOVFF  01,324
....................    
....................    // Do not respond if there is no room to generate the ARP reply
....................    if(MyTxBuffer == INVALID_BUFFER)
190A:  MOVLB  3
190C:  INCFSZ x24,W
190E:  BRA    1916
....................       return FALSE;
1910:  MOVLW  00
1912:  MOVWF  01
1914:  BRA    1A66
.................... 
....................    MACSetTxBuffer(MyTxBuffer, 0);
1916:  MOVFF  324,3A2
191A:  CLRF   xA4
191C:  CLRF   xA3
191E:  MOVLB  0
1920:  RCALL  1506
....................    
....................    
....................     packet.HardwareType             = HW_ETHERNET;
1922:  MOVLB  3
1924:  CLRF   x09
1926:  MOVLW  01
1928:  MOVWF  x08
....................     packet.Protocol                 = ARP_IP;
192A:  MOVLW  08
192C:  MOVWF  x0B
192E:  CLRF   x0A
....................     packet.MACAddrLen               = sizeof(MAC_ADDR);
1930:  MOVLW  06
1932:  MOVWF  x0C
....................     packet.ProtocolLen              = sizeof(IP_ADDR);
1934:  MOVLW  04
1936:  MOVWF  x0D
.................... 
....................     if ( opCode == ARP_REQUEST )
1938:  DECFSZ x07,W
193A:  BRA    1950
....................     {
....................         packet.Operation            = ARP_OPERATION_REQ;
193C:  CLRF   x0F
193E:  MOVLW  01
1940:  MOVWF  x0E
....................         packet.TargetMACAddr.v[0]   = 0xff;
1942:  SETF   x1A
....................         packet.TargetMACAddr.v[1]   = 0xff;
1944:  SETF   x1B
....................         packet.TargetMACAddr.v[2]   = 0xff;
1946:  SETF   x1C
....................         packet.TargetMACAddr.v[3]   = 0xff;
1948:  SETF   x1D
....................         packet.TargetMACAddr.v[4]   = 0xff;
194A:  SETF   x1E
....................         packet.TargetMACAddr.v[5]   = 0xff;
194C:  SETF   x1F
....................     }
194E:  BRA    1972
....................     else
....................     {
....................         packet.Operation            = ARP_OPERATION_RESP;
1950:  CLRF   x0F
1952:  MOVLW  02
1954:  MOVWF  x0E
....................         packet.TargetMACAddr        = remote->MACAddr;
1956:  MOVFF  305,FE1
195A:  MOVFF  306,FE2
195E:  MOVLW  03
1960:  MOVWF  FEA
1962:  MOVLW  1A
1964:  MOVWF  FE9
1966:  MOVLW  06
1968:  MOVWF  01
196A:  MOVFF  FE6,FEE
196E:  DECFSZ 01,F
1970:  BRA    196A
....................     }
.................... 
....................     packet.SenderMACAddr = AppConfig.MyMACAddr;
1972:  MOVLW  03
1974:  MOVWF  FEA
1976:  MOVLW  10
1978:  MOVWF  FE9
197A:  CLRF   FE2
197C:  MOVLW  21
197E:  MOVWF  FE1
1980:  MOVLW  06
1982:  MOVWF  01
1984:  MOVFF  FE6,FEE
1988:  DECFSZ 01,F
198A:  BRA    1984
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr;
198C:  MOVFF  20,319
1990:  MOVFF  1F,318
1994:  MOVFF  1E,317
1998:  MOVFF  1D,316
.................... 
.................... 
....................     // Check to see if target is on same subnet, if not, find Gateway MAC.
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway.
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val)
199C:  MOVLW  06
199E:  ADDWF  x05,W
19A0:  MOVWF  FE9
19A2:  MOVLW  00
19A4:  ADDWFC x06,W
19A6:  MOVWF  FEA
19A8:  MOVFF  FEF,00
19AC:  MOVFF  FEC,01
19B0:  MOVFF  FEC,02
19B4:  MOVFF  FEC,03
19B8:  MOVF   00,W
19BA:  XORWF  x16,W
19BC:  MOVWF  x25
19BE:  MOVF   01,W
19C0:  XORWF  x17,W
19C2:  MOVWF  x26
19C4:  MOVF   02,W
19C6:  XORWF  x18,W
19C8:  MOVWF  x27
19CA:  MOVF   03,W
19CC:  XORWF  x19,W
19CE:  MOVWF  x28
19D0:  MOVF   x25,W
19D2:  ANDWF  27,W
19D4:  MOVWF  00
19D6:  MOVF   x26,W
19D8:  ANDWF  28,W
19DA:  MOVWF  01
19DC:  MOVF   x27,W
19DE:  ANDWF  29,W
19E0:  MOVWF  02
19E2:  MOVF   x28,W
19E4:  ANDWF  2A,W
19E6:  MOVWF  03
19E8:  MOVF   00,F
19EA:  BNZ   19F8
19EC:  MOVF   01,F
19EE:  BNZ   19F8
19F0:  MOVF   02,F
19F2:  BNZ   19F8
19F4:  MOVF   03,F
19F6:  BZ    1A0A
....................     {
....................       packet.TargetIPAddr = AppConfig.MyGateway;
19F8:  MOVFF  2E,323
19FC:  MOVFF  2D,322
1A00:  MOVFF  2C,321
1A04:  MOVFF  2B,320
....................     }
1A08:  BRA    1A26
....................     else
....................         packet.TargetIPAddr             = remote->IPAddr;
1A0A:  MOVLW  06
1A0C:  ADDWF  x05,W
1A0E:  MOVWF  FE9
1A10:  MOVLW  00
1A12:  ADDWFC x06,W
1A14:  MOVWF  FEA
1A16:  MOVFF  FEF,320
1A1A:  MOVFF  FEC,321
1A1E:  MOVFF  FEC,322
1A22:  MOVFF  FEC,323
.................... 
....................     SwapARPPacket(&packet);
1A26:  MOVLW  03
1A28:  MOVWF  x26
1A2A:  MOVLW  08
1A2C:  MOVWF  x25
1A2E:  MOVLB  0
1A30:  RCALL  1348
.................... 
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet));
1A32:  MOVLW  03
1A34:  MOVLB  3
1A36:  MOVWF  xA7
1A38:  MOVLW  1A
1A3A:  MOVWF  xA6
1A3C:  MOVLW  06
1A3E:  MOVWF  xA8
1A40:  CLRF   xAA
1A42:  MOVLW  1C
1A44:  MOVWF  xA9
1A46:  MOVLB  0
1A48:  RCALL  1608
.................... 
....................     //MACPutArray((int8*)&packet, sizeof(packet));
....................     MACPutArray(&packet, sizeof(ARP_PACKET));
1A4A:  MOVLW  03
1A4C:  MOVLB  3
1A4E:  MOVWF  xAE
1A50:  MOVLW  08
1A52:  MOVWF  xAD
1A54:  CLRF   xB0
1A56:  MOVLW  1C
1A58:  MOVWF  xAF
1A5A:  MOVLB  0
1A5C:  RCALL  15C2
.................... 
....................     MACFlush();
1A5E:  RCALL  16D0
....................    
....................    return TRUE;
1A60:  MOVLW  01
1A62:  MOVWF  01
1A64:  MOVLB  3
1A66:  MOVLB  0
1A68:  GOTO   1AE4 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           p   - ARP packet to be swapped.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void SwapARPPacket(ARP_PACKET *p)
.................... {
....................     p->HardwareType     = swaps(p->HardwareType);
*
1348:  MOVFF  325,01
134C:  MOVFF  326,328
1350:  MOVFF  01,327
1354:  MOVFF  325,FE9
1358:  MOVFF  326,FEA
135C:  MOVFF  FEC,3A9
1360:  MOVF   FED,F
1362:  MOVFF  FEF,3A8
1366:  MOVLB  0
1368:  RCALL  11CC
136A:  MOVFF  328,FEA
136E:  MOVFF  327,FE9
1372:  MOVFF  02,FEC
1376:  MOVF   FED,F
1378:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol);
137C:  MOVLW  02
137E:  MOVLB  3
1380:  ADDWF  x25,W
1382:  MOVWF  01
1384:  MOVLW  00
1386:  ADDWFC x26,W
1388:  MOVWF  03
138A:  MOVFF  01,327
138E:  MOVWF  x28
1390:  MOVLW  02
1392:  ADDWF  x25,W
1394:  MOVWF  FE9
1396:  MOVLW  00
1398:  ADDWFC x26,W
139A:  MOVWF  FEA
139C:  MOVFF  FEC,3A9
13A0:  MOVF   FED,F
13A2:  MOVFF  FEF,3A8
13A6:  MOVLB  0
13A8:  RCALL  11CC
13AA:  MOVFF  328,FEA
13AE:  MOVFF  327,FE9
13B2:  MOVFF  02,FEC
13B6:  MOVF   FED,F
13B8:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation);
13BC:  MOVLW  06
13BE:  MOVLB  3
13C0:  ADDWF  x25,W
13C2:  MOVWF  01
13C4:  MOVLW  00
13C6:  ADDWFC x26,W
13C8:  MOVWF  03
13CA:  MOVFF  01,327
13CE:  MOVWF  x28
13D0:  MOVLW  06
13D2:  ADDWF  x25,W
13D4:  MOVWF  FE9
13D6:  MOVLW  00
13D8:  ADDWFC x26,W
13DA:  MOVWF  FEA
13DC:  MOVFF  FEC,3A9
13E0:  MOVF   FED,F
13E2:  MOVFF  FEF,3A8
13E6:  MOVLB  0
13E8:  RCALL  11CC
13EA:  MOVFF  328,FEA
13EE:  MOVFF  327,FE9
13F2:  MOVFF  02,FEC
13F6:  MOVF   FED,F
13F8:  MOVFF  01,FEF
13FC:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    #include "tcpip/http.c"
.................... //////////////////////////////////////////////////////////////////////////////
.................... ///
.................... ///                              HTTP.C
.................... ///
.................... /// Simple webserver for the Microchip TCP/IP stack.
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES
.................... ///
.................... /// **** CONFIGURATION ****
.................... ///
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c
.................... ///        in your application.  Defining this to be true will cause
.................... ///        the stack to include the HTTP portion and execute the init
.................... ///        and process any HTTP tasks.
.................... ///
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP
.................... ///        connections.
.................... ///
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the
.................... ///        HTTP server.  You probably will be fine with just 1.  The
.................... ///        more sockets you use the more RAM is used to hold buffers
.................... ///        and state configuration.
.................... ///
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several
.................... ///        buffers.  This limits the size of your GET or POST requests
.................... ///        and all CGI POST data:
.................... ///            If using GET, then max amount of cgi data is this value
.................... ///            minus everything else on the initial GET command (which
.................... ///            also includes the filename).  I believe the max specified
.................... ///            by W3C is 255.
.................... ///            If using POST, then this is the maximum size for one
.................... ///            key=value pair (including the '=' sign).
.................... ///        These values do not inlude any escape characters.
.................... ///
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE.
.................... ///
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have
.................... ///      two escape characters after the %.  An example of each:
.................... ///         If FALSE: %A
.................... ///         If TRUE: %0A
.................... ///
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third
.................... ///      parameter which is the content-type of the requested page.
.................... ///
.................... /// **** HOW IT WORKS ****
.................... ///
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will
.................... /// then listen for GET or POST requests.  When it gets a GET or POST
.................... /// request it passes the page request to the callback function
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or
.................... /// a pointer to the constant memory area that holds the page in program
.................... /// memory.  If it was a POST request it waits until the HTTP header is
.................... /// done and then saves the POST data into a buffer, and passes the
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will
.................... /// parse the CGI post data and act upon it.  When done, the HTTP
.................... /// server then responds by sending the page.  If the page is to have
.................... /// variable data, it can be represented by an escape code - %0 or %1
.................... /// for example.  When the HTTP stack sees such an escape code it calls
.................... /// the callback function http_format_char() to format the escape code
.................... /// into the needed variable data (such as ADC readings).  After the
.................... /// HTTP stack is done sending the request it will close the port.
.................... /// If the page didn't exist in program memory it will send a 404 File
.................... /// not found error.  If there was a problem/timeout parsing the request
.................... /// the HTTP stack will send a 500 Internal Server Error response.
.................... ///
.................... /// **** CALL BACK FUNCTIONS ****
.................... ///
.................... /// Your main application must provide the following callback functions to
.................... /// fill application dependent needs:
.................... ///
.................... /// http_get_page(char *file);
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else,
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph.
.................... ///    A call-back function provided by your application that finds the
.................... ///    required file.  If the file exists, returns address to page in
.................... ///    program memory.  If it doesn't exist, returns 0.
.................... ///
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else,
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph.
.................... ///    A call-back function provided by your application that finds the
.................... ///    required file.  If the file exists, saves value to retAddress.  If
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the
.................... ///    content-type (text/html, text/xml, etc).
.................... ///
.................... /// http_exec_cgi(int32 file, char *key, char *val);
.................... ///    A call-back function provided by your application that processes incoming
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is
.................... ///    the file address as returned by http_get_page().
.................... ///
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... ///    Given an escaped character in the program memory HTTP file, convert to
.................... ///    variable data.  id is the escaped character, *str is where to save the
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str.
.................... ///    Returns the number of bytes written to *str.  file is
.................... ///    the file address as returned by http_get_page().
.................... ///
.................... /// **** LIMITATIONS ****
.................... ///
.................... /// When creating web pages with forms, keep your form names (keys) simple
.................... /// because the HTTP stack does not format the escape characters.  For example,
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord".
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving
.................... /// the value, but not the key.  Therefore keep your keys simple.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// * Author         Date           Comment
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.................... ///
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST
.................... ///
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix
.................... ///                                 many bugs.  The biggest bug is that
.................... ///                                 it can send pages and receive CGI that
.................... ///                                 is larger than 1 TCP packet.  Also
.................... ///                                 added the HTTP_USE_CHUNKS,
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #include "tcpip/http.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///                                                                     ///
.................... ///                              HTTP.H                                 ///
.................... ///                                                                     ///
.................... /// Simple webserver for the Microchip TCP/IP stack.                    ///
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       ///
.................... ///                                                                     ///
.................... /// See HTTP.C for documenation                                         ///
.................... ///                                                                     ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef HTTP_USE_CHUNKS
.................... #define HTTP_USE_CHUNKS   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_CONTENT_TYPE
.................... #define HTTP_USE_CONTENT_TYPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_PORT
.................... #define HTTP_PORT             80
.................... #endif
.................... 
.................... #ifndef HTTP_NUM_SOCKETS
.................... #define HTTP_NUM_SOCKETS      1
.................... #endif
.................... 
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE
.................... #define HTTP_GET_PARAM_MAX_SIZE  254
.................... #endif
.................... 
.................... void HTTP_Init(void);
.................... void HTTP_Task(void);
.................... 
.................... //**** CALLBACKS START ******///
.................... 
.................... /// the following three functions are callbacks and
.................... /// must be written in your main application!!!  see the documentation above
.................... /// for more help.
.................... 
.................... #if HTTP_USE_CONTENT_TYPE
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... #else
....................  int32 http_get_page(char *file_str);
.................... #endif
.................... 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... void http_exec_cgi(int32 file, char *key, char *val);
.................... 
.................... //**** CALLBACKS END ******///
.................... 
.................... 
.................... //#define debug_http   debug_printf
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u)
.................... 
.................... const char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>";
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>";
.................... 
.................... //key=val pair string, & delimited
.................... void http_parse_cgi_str(int32 file, char *cgistr);
.................... 
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET};
.................... 
.................... enum {
....................    HTTP_DISABLED = 0xFF,
....................    HTTP_IGNORE,
....................    HTTP_LISTEN_WAIT,
....................    HTTP_CONNECTED,
....................    HTTP_GET_HEADERS,
....................    HTTP_GET_POST,
....................    HTTP_GET_POST_CONTINUE,
....................    HTTP_SEND_RESPONSE,
....................    HTTP_SEND_RESPONSE_CONTINUE,
....................    HTTP_CLOSE,
....................    HTTP_CLOSE_WAITING,
....................    HTTP_CLOSED
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE};
.................... 
.................... //strips out any escape characters that the HTTP client may have inserted.
.................... // (+ is replaced with space)
.................... // (%xx is replaced with character representation of xx)
.................... char * http_escape_chars(char *str)
.................... {
....................    char *ostr;
....................    char new[3];
....................    char c;
....................    char val;
.................... 
....................    new[2]=0;
*
46B0:  MOVLB  3
46B2:  CLRF   x21
.................... 
....................    ostr = str;
46B4:  MOVFF  31C,31E
46B8:  MOVFF  31B,31D
.................... 
....................    while((c=*str) != 0)
46BC:  MOVFF  31C,FEA
46C0:  MOVFF  31B,FE9
46C4:  MOVFF  FEF,322
46C8:  MOVF   x22,F
46CA:  BZ    4784
....................    {
....................       if (c=='+')
46CC:  MOVF   x22,W
46CE:  SUBLW  2B
46D0:  BNZ   46E6
....................          *str++=' ';
46D2:  MOVFF  31C,FEA
46D6:  MOVF   x1B,W
46D8:  INCF   x1B,F
46DA:  BTFSC  FD8.2
46DC:  INCF   x1C,F
46DE:  MOVWF  FE9
46E0:  MOVLW  20
46E2:  MOVWF  FEF
46E4:  BRA    4780
....................       else if (c=='%')
46E6:  MOVF   x22,W
46E8:  SUBLW  25
46EA:  BNZ   477A
....................       {
....................          memcpy(new, str + 1, 2);
46EC:  MOVLW  01
46EE:  ADDWF  x1B,W
46F0:  MOVWF  x24
46F2:  MOVLW  00
46F4:  ADDWFC x1C,W
46F6:  MOVWF  FE2
46F8:  MOVFF  324,FE1
46FC:  MOVFF  FE6,31F
4700:  MOVFF  FE6,320
....................          val = strtoul(new, 0, 16);
4704:  MOVLW  03
4706:  MOVWF  x25
4708:  MOVLW  1F
470A:  MOVWF  x24
470C:  CLRF   x27
470E:  CLRF   x26
4710:  MOVLW  10
4712:  MOVWF  x28
4714:  MOVLB  0
4716:  BRA    41F0
4718:  MOVFF  01,323
....................          *str++ = val;
471C:  MOVLB  3
471E:  MOVFF  31C,FEA
4722:  MOVF   x1B,W
4724:  INCF   x1B,F
4726:  BTFSC  FD8.2
4728:  INCF   x1C,F
472A:  MOVWF  FE9
472C:  MOVFF  323,FEF
....................          memmove(str, str + 2, strlen(str) - 1);
4730:  MOVLW  02
4732:  ADDWF  x1B,W
4734:  MOVWF  x24
4736:  MOVLW  00
4738:  ADDWFC x1C,W
473A:  MOVWF  x25
473C:  MOVFF  31C,338
4740:  MOVFF  31B,337
4744:  MOVLB  0
4746:  RCALL  4042
4748:  MOVFF  02,327
474C:  MOVFF  01,326
4750:  MOVLW  01
4752:  MOVLB  3
4754:  SUBWF  x26,F
4756:  MOVLW  00
4758:  SUBWFB x27,F
475A:  MOVFF  31C,329
475E:  MOVFF  31B,328
4762:  MOVFF  325,32B
4766:  MOVFF  324,32A
476A:  MOVFF  327,32D
476E:  MOVFF  326,32C
4772:  MOVLB  0
4774:  BRA    45D2
....................       }
4776:  BRA    4780
4778:  MOVLB  3
....................       else
....................          str++;
477A:  INCF   x1B,F
477C:  BTFSC  FD8.2
477E:  INCF   x1C,F
4780:  MOVLB  3
4782:  BRA    46BC
....................    }
.................... 
....................    return(ostr);
4784:  MOVFF  31D,01
4788:  MOVFF  31E,02
478C:  MOVLB  0
478E:  RETURN 0
.................... }
.................... 
.................... void http_parse_cgi_string(int32 file, char *ptr)
.................... {
....................    char *pKey, *pValue, c;
.................... 
....................    pKey=ptr;
*
4C98:  MOVFF  315,317
4C9C:  MOVFF  314,316
....................    pValue=0;
4CA0:  MOVLB  3
4CA2:  CLRF   x19
4CA4:  CLRF   x18
.................... 
....................    while(TRUE)
....................    {
....................       c = *ptr;
4CA6:  MOVFF  315,FEA
4CAA:  MOVFF  314,FE9
4CAE:  MOVFF  FEF,31A
....................       if ((c=='&') || (c==0))
4CB2:  MOVF   x1A,W
4CB4:  SUBLW  26
4CB6:  BZ    4CBC
4CB8:  MOVF   x1A,F
4CBA:  BNZ   4D18
....................       {
....................          *ptr=0;
4CBC:  MOVFF  315,FEA
4CC0:  MOVFF  314,FE9
4CC4:  CLRF   FEF
....................          http_escape_chars(pKey);
4CC6:  MOVFF  317,31C
4CCA:  MOVFF  316,31B
4CCE:  MOVLB  0
4CD0:  RCALL  46B0
....................          http_escape_chars(pValue);
4CD2:  MOVFF  319,31C
4CD6:  MOVFF  318,31B
4CDA:  RCALL  46B0
....................          http_exec_cgi(file, pKey, pValue);
4CDC:  MOVFF  313,31E
4CE0:  MOVFF  312,31D
4CE4:  MOVFF  311,31C
4CE8:  MOVFF  310,31B
4CEC:  MOVFF  317,320
4CF0:  MOVFF  316,31F
4CF4:  MOVFF  319,322
4CF8:  MOVFF  318,321
4CFC:  BRA    4B7A
....................          pKey=ptr+1;
4CFE:  MOVLW  01
4D00:  MOVLB  3
4D02:  ADDWF  x14,W
4D04:  MOVWF  x16
4D06:  MOVLW  00
4D08:  ADDWFC x15,W
4D0A:  MOVWF  x17
....................          pValue=0;
4D0C:  CLRF   x19
4D0E:  CLRF   x18
....................          if (c==0)
4D10:  MOVF   x1A,F
4D12:  BNZ   4D16
....................             break;
4D14:  BRA    4D3C
....................       }
4D16:  BRA    4D34
....................       else if (c=='=')
4D18:  MOVF   x1A,W
4D1A:  SUBLW  3D
4D1C:  BNZ   4D34
....................       {
....................          *ptr=0;
4D1E:  MOVFF  315,FEA
4D22:  MOVFF  314,FE9
4D26:  CLRF   FEF
....................          pValue=ptr+1;
4D28:  MOVLW  01
4D2A:  ADDWF  x14,W
4D2C:  MOVWF  x18
4D2E:  MOVLW  00
4D30:  ADDWFC x15,W
4D32:  MOVWF  x19
....................       }
....................       ptr++;
4D34:  INCF   x14,F
4D36:  BTFSC  FD8.2
4D38:  INCF   x15,F
4D3A:  BRA    4CA6
....................    }
4D3C:  MOVLB  0
4D3E:  RETURN 0
.................... }
.................... 
.................... int8 _httpPutcSocket;
.................... 
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket)
.................... 
.................... void set_tcp_http_putc(int8 newSocket)
.................... {
....................    _httpPutcSocket=newSocket;
*
5054:  MOVFF  318,70
5058:  GOTO   5B64 (RETURN)
.................... }
.................... 
.................... int tcp_http_putc(char c)
.................... {
....................    return(TCPPut(_httpPutcSocket,c));
*
5328:  MOVFF  70,337
532C:  MOVFF  336,338
5330:  BRA    51E8
5332:  MOVF   01,W
5334:  RETURN 0
.................... }
.................... 
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS];
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS];
.................... 
.................... #if HTTP_USE_CHUNKS
.................... void TCPPutFileChunkStart(int16 count)
.................... {
....................    printf(tcp_http_putc, "%04LX\r\n", count);
.................... }
.................... 
.................... void TCPPutFileChunkStop(void)
.................... {
....................    tcp_http_putc('\r');
....................    tcp_http_putc('\n');
.................... }
.................... #else
....................  #define TCPPutFileChunkStart(x)
....................  #define TCPPutFileChunkStop()
.................... #endif
.................... 
.................... typedef enum
.................... {
....................    TCP_PUT_CONST_EC_FINISH = 0,
....................    TCP_PUT_CONST_EC_CONTINUE,
....................    TCP_PUT_CONST_EC_ESCAPE
.................... } TCP_PUT_CONST_EC;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileVarChunk(ptr)
.................... //
.................... // send a chunked response from ram
.................... //
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated
.................... //          with the continue position before exit.
.................... //
.................... // Returns a status code:
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr)
.................... //because of a compiler error i had to make this double pointer an int16, when
.................... //it should be a char.
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr)
.................... {
....................    int16 txLeft, n;
....................    char *ptr, ec;
.................... 
....................    ptr=*retPtr;
*
555E:  MOVFF  31B,FEA
5562:  MOVLB  3
5564:  MOVFF  31A,FE9
5568:  MOVFF  FEC,321
556C:  MOVF   FED,F
556E:  MOVFF  FEF,320
.................... 
....................    n=strlen(ptr);
5572:  MOVFF  321,338
5576:  MOVFF  320,337
557A:  MOVLB  0
557C:  CALL   4042
5580:  MOVFF  02,31F
5584:  MOVFF  01,31E
.................... 
....................    if (!n)
5588:  MOVLB  3
558A:  MOVF   x1E,W
558C:  IORWF  x1F,W
558E:  BNZ   5596
....................       return(TCP_PUT_CONST_EC_FINISH);
5590:  MOVLW  00
5592:  MOVWF  01
5594:  BRA    5612
.................... 
....................    txLeft = tcp_http_tx_left();
5596:  MOVFF  70,326
559A:  MOVLB  0
559C:  RCALL  546E
559E:  MOVFF  02,31D
55A2:  MOVFF  01,31C
.................... 
....................   #if HTTP_USE_CHUNKS
....................    if (txLeft > 8)
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars
....................    else
....................       return(TCP_PUT_CONST_EC_CONTINUE);
....................   #else
....................    if (!txLeft)
55A6:  MOVLB  3
55A8:  MOVF   x1C,W
55AA:  IORWF  x1D,W
55AC:  BNZ   55B4
....................       return(TCP_PUT_CONST_EC_CONTINUE);
55AE:  MOVLW  01
55B0:  MOVWF  01
55B2:  BRA    5612
....................   #endif
.................... 
....................    if (n > txLeft)
55B4:  MOVF   x1D,W
55B6:  SUBWF  x1F,W
55B8:  BNC   55C8
55BA:  BNZ   55C2
55BC:  MOVF   x1E,W
55BE:  SUBWF  x1C,W
55C0:  BC    55C8
....................    {
....................       ec = TCP_PUT_CONST_EC_CONTINUE;
55C2:  MOVLW  01
55C4:  MOVWF  x22
....................    }
55C6:  BRA    55D2
....................    else
....................    {
....................       txLeft = n;
55C8:  MOVFF  31F,31D
55CC:  MOVFF  31E,31C
....................       ec = TCP_PUT_CONST_EC_FINISH;
55D0:  CLRF   x22
....................    }
.................... 
....................    TCPPutFileChunkStart(txLeft);
.................... 
....................    while (txLeft--)
55D2:  MOVFF  31D,03
55D6:  MOVF   x1C,W
55D8:  BTFSC  FD8.2
55DA:  DECF   x1D,F
55DC:  DECF   x1C,F
55DE:  IORWF  03,W
55E0:  BZ    55FC
....................    {
....................       tcp_http_putc(*ptr++);
55E2:  MOVFF  321,FEA
55E6:  MOVF   x20,W
55E8:  INCF   x20,F
55EA:  BTFSC  FD8.2
55EC:  INCF   x21,F
55EE:  MOVWF  FE9
55F0:  MOVFF  FEF,336
55F4:  MOVLB  0
55F6:  RCALL  5328
55F8:  MOVLB  3
55FA:  BRA    55D2
....................    }
.................... 
....................    TCPPutFileChunkStop();
.................... 
....................    *retPtr=ptr;
55FC:  MOVFF  31B,FEA
5600:  MOVFF  31A,FE9
5604:  MOVFF  321,FEC
5608:  MOVF   FED,F
560A:  MOVFF  320,FEF
.................... 
....................    return(ec);
560E:  MOVFF  322,01
5612:  MOVLB  0
5614:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileParseConst(addy, n, doSend)
.................... //
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence,
.................... // n chars or an end of file
.................... //
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address
.................... //        will be updated for the next call.
.................... //
.................... // n - max number of chars to read from file.  will save the total number
.................... //    of chars passed to this pointer.
.................... //
.................... // doSend - if TRUE, then send data to TCP socket
.................... //
.................... // returns the last char read
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend)
*
5634:  MOVLB  3
5636:  CLRF   x2E
5638:  CLRF   x2D
563A:  BSF    x35.0
.................... {
....................    char stopC, checkC;
....................    int16 fileSize = 0, max;
....................    int32 addy;
....................    int1 premature = TRUE;
.................... 
....................    max = *n;
563C:  MOVFF  329,FEA
5640:  MOVFF  328,FE9
5644:  MOVFF  FEC,330
5648:  MOVF   FED,F
564A:  MOVFF  FEF,32F
....................    addy = *retAddy;
564E:  MOVFF  327,FEA
5652:  MOVFF  326,FE9
5656:  MOVFF  FEF,331
565A:  MOVFF  FEC,332
565E:  MOVFF  FEC,333
5662:  MOVFF  FEC,334
.................... 
....................    while (TRUE)
....................    {
....................       read_program_memory(addy++, &stopC, 1);
5666:  MOVFF  334,339
566A:  MOVFF  333,02
566E:  MOVFF  332,01
5672:  MOVFF  331,00
5676:  MOVLW  01
5678:  ADDWF  x31,F
567A:  BTFSC  FD8.0
567C:  INCF   x32,F
567E:  BTFSC  FD8.2
5680:  INCF   x33,F
5682:  BTFSC  FD8.2
5684:  INCF   x34,F
5686:  MOVFF  02,338
568A:  MOVFF  01,337
568E:  MOVFF  00,336
5692:  MOVFF  02,FF8
5696:  MOVFF  01,FF7
569A:  MOVFF  00,FF6
569E:  MOVLW  03
56A0:  MOVWF  FEA
56A2:  MOVLW  2B
56A4:  MOVWF  FE9
56A6:  CLRF   x3B
56A8:  MOVLW  01
56AA:  MOVWF  x3A
56AC:  MOVLB  0
56AE:  RCALL  5616
....................       if (stopC == '%')
56B0:  MOVLB  3
56B2:  MOVF   x2B,W
56B4:  SUBLW  25
56B6:  BNZ   5736
....................       {
....................          read_program_memory(addy++, &checkC, 1);
56B8:  MOVFF  334,339
56BC:  MOVFF  333,02
56C0:  MOVFF  332,01
56C4:  MOVFF  331,00
56C8:  MOVLW  01
56CA:  ADDWF  x31,F
56CC:  BTFSC  FD8.0
56CE:  INCF   x32,F
56D0:  BTFSC  FD8.2
56D2:  INCF   x33,F
56D4:  BTFSC  FD8.2
56D6:  INCF   x34,F
56D8:  MOVFF  02,338
56DC:  MOVFF  01,337
56E0:  MOVFF  00,336
56E4:  MOVFF  02,FF8
56E8:  MOVFF  01,FF7
56EC:  MOVFF  00,FF6
56F0:  MOVLW  03
56F2:  MOVWF  FEA
56F4:  MOVLW  2C
56F6:  MOVWF  FE9
56F8:  CLRF   x3B
56FA:  MOVLW  01
56FC:  MOVWF  x3A
56FE:  MOVLB  0
5700:  RCALL  5616
....................          if (checkC == '%')
5702:  MOVLB  3
5704:  MOVF   x2C,W
5706:  SUBLW  25
5708:  BNZ   5732
....................          {
....................             if (fileSize < max)
570A:  MOVF   x2E,W
570C:  SUBWF  x30,W
570E:  BNC   572E
5710:  BNZ   5718
5712:  MOVF   x2F,W
5714:  SUBWF  x2D,W
5716:  BC    572E
....................             {
....................                if (doSend)
5718:  MOVF   x2A,F
571A:  BZ    5726
....................                   tcp_http_putc('%');
571C:  MOVLW  25
571E:  MOVWF  x36
5720:  MOVLB  0
5722:  RCALL  5328
5724:  MOVLB  3
....................                fileSize++;
5726:  INCF   x2D,F
5728:  BTFSC  FD8.2
572A:  INCF   x2E,F
....................             }
572C:  BRA    5730
....................             else
....................                break;
572E:  BRA    5768
....................          }
5730:  BRA    5734
....................          else
....................             break;   //ESCAPE
5732:  BRA    5768
....................       }
5734:  BRA    5766
....................       else if (stopC)
5736:  MOVF   x2B,F
5738:  BZ    5762
....................       {
....................          if (fileSize < max)
573A:  MOVF   x2E,W
573C:  SUBWF  x30,W
573E:  BNC   575E
5740:  BNZ   5748
5742:  MOVF   x2F,W
5744:  SUBWF  x2D,W
5746:  BC    575E
....................          {
....................             if (doSend)
5748:  MOVF   x2A,F
574A:  BZ    5756
....................                tcp_http_putc(stopC);
574C:  MOVFF  32B,336
5750:  MOVLB  0
5752:  RCALL  5328
5754:  MOVLB  3
....................             fileSize++;
5756:  INCF   x2D,F
5758:  BTFSC  FD8.2
575A:  INCF   x2E,F
....................          }
575C:  BRA    5760
....................          else
....................             break;
575E:  BRA    5768
....................       }
5760:  BRA    5766
....................       else
....................       {
....................          premature = FALSE;
5762:  BCF    x35.0
....................          break;   //EOF (stopC == 0)
5764:  BRA    5768
....................       }
5766:  BRA    5666
....................    }
.................... 
....................    if (premature)
5768:  BTFSS  x35.0
576A:  BRA    577C
....................       addy--;
576C:  MOVLW  FF
576E:  ADDWF  x31,F
5770:  BTFSS  FD8.0
5772:  ADDWF  x32,F
5774:  BTFSS  FD8.0
5776:  ADDWF  x33,F
5778:  BTFSS  FD8.0
577A:  ADDWF  x34,F
.................... 
....................    *n = fileSize;
577C:  MOVFF  329,FEA
5780:  MOVFF  328,FE9
5784:  MOVFF  32E,FEC
5788:  MOVF   FED,F
578A:  MOVFF  32D,FEF
....................    *retAddy = addy;
578E:  MOVFF  327,FEA
5792:  MOVFF  326,FE9
5796:  MOVFF  331,FEF
579A:  MOVFF  332,FEC
579E:  MOVFF  333,FEC
57A2:  MOVFF  334,FEC
.................... 
....................    return(stopC);
57A6:  MOVFF  32B,01
57AA:  MOVLB  0
57AC:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileConstChunk(*addy)
.................... //
.................... // send a chunked response from constant memory
.................... //
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address
.................... //        will be updated for the next call.
.................... //
.................... // returns a response:
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue
.................... //                            from this position on next call.
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file.
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy)
57AE:  MOVLB  3
57B0:  CLRF   x22
57B2:  CLRF   x21
.................... {
....................    char stopC;
....................    int32 addy;
....................    int16 fileSize = 0, txLeft;
....................    TCP_PUT_CONST_EC ec;
.................... 
....................    txLeft = tcp_http_tx_left();
57B4:  MOVFF  70,326
57B8:  MOVLB  0
57BA:  RCALL  546E
57BC:  MOVFF  02,324
57C0:  MOVFF  01,323
.................... 
....................  #if HTTP_USE_CHUNKS
....................    if (txLeft > 8)
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars
....................    else
....................       return(TCP_PUT_CONST_EC_CONTINUE);
....................  #else
....................    if (!txLeft)
57C4:  MOVLB  3
57C6:  MOVF   x23,W
57C8:  IORWF  x24,W
57CA:  BNZ   57D2
....................       return(TCP_PUT_CONST_EC_CONTINUE);
57CC:  MOVLW  01
57CE:  MOVWF  01
57D0:  BRA    586E
....................  #endif
.................... 
....................    addy = *retAddy;
57D2:  MOVFF  31B,FEA
57D6:  MOVFF  31A,FE9
57DA:  MOVFF  FEF,31D
57DE:  MOVFF  FEC,31E
57E2:  MOVFF  FEC,31F
57E6:  MOVFF  FEC,320
.................... 
....................    fileSize = 0xFFFF;
57EA:  SETF   x22
57EC:  SETF   x21
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE);
57EE:  MOVLW  03
57F0:  MOVWF  x27
57F2:  MOVLW  1D
57F4:  MOVWF  x26
57F6:  MOVLW  03
57F8:  MOVWF  x29
57FA:  MOVLW  21
57FC:  MOVWF  x28
57FE:  CLRF   x2A
5800:  MOVLB  0
5802:  RCALL  5634
5804:  MOVFF  01,31C
.................... 
....................    if (!fileSize && (stopC!='%'))
5808:  MOVLB  3
580A:  MOVF   x21,W
580C:  IORWF  x22,W
580E:  BNZ   581C
5810:  MOVF   x1C,W
5812:  SUBLW  25
5814:  BZ    581C
....................       return(TCP_PUT_CONST_EC_FINISH);
5816:  MOVLW  00
5818:  MOVWF  01
581A:  BRA    586E
.................... 
....................    //TODO: optimize
....................    if (fileSize > txLeft)
581C:  MOVF   x24,W
581E:  SUBWF  x22,W
5820:  BNC   5838
5822:  BNZ   582A
5824:  MOVF   x21,W
5826:  SUBWF  x23,W
5828:  BC    5838
....................    {
....................       fileSize = txLeft;
582A:  MOVFF  324,322
582E:  MOVFF  323,321
.................... //      if (stopC == '%')
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE;
.................... //      else
....................          ec = TCP_PUT_CONST_EC_CONTINUE;
5832:  MOVLW  01
5834:  MOVWF  x25
....................    }
5836:  BRA    5850
....................    else
....................    {
....................       if (stopC == '%')
5838:  MOVF   x1C,W
583A:  SUBLW  25
583C:  BNZ   5844
....................          ec = TCP_PUT_CONST_EC_ESCAPE;
583E:  MOVLW  02
5840:  MOVWF  x25
5842:  BRA    5850
....................       else if (stopC)
5844:  MOVF   x1C,F
5846:  BZ    584E
....................          ec = TCP_PUT_CONST_EC_CONTINUE;
5848:  MOVLW  01
584A:  MOVWF  x25
584C:  BRA    5850
....................       else
....................          ec = TCP_PUT_CONST_EC_FINISH;
584E:  CLRF   x25
....................    }
.................... 
....................    TCPPutFileChunkStart(fileSize);
.................... 
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE);
5850:  MOVFF  31B,327
5854:  MOVFF  31A,326
5858:  MOVLW  03
585A:  MOVWF  x29
585C:  MOVLW  21
585E:  MOVWF  x28
5860:  MOVLW  01
5862:  MOVWF  x2A
5864:  MOVLB  0
5866:  RCALL  5634
.................... 
....................    TCPPutFileChunkStop();
.................... 
....................    return(ec);
5868:  MOVLB  3
586A:  MOVFF  325,01
586E:  MOVLB  0
5870:  GOTO   5D60 (RETURN)
.................... }
.................... 
.................... int TCPPutFileConstGetEscape(int32 addy)
.................... {
.................... #if HTTP_USE_DOUBLE_ESCAPE
....................    char str[3];
....................    int ret;
.................... 
....................    read_program_memory(addy, &str[0], 2);
....................    str[2] = 0;
....................    ret = strtol(str, 0, 16);
.................... #else
....................    char ret;
....................    read_program_memory(addy, &ret, 1);
5874:  MOVFF  31E,FF8
5878:  MOVFF  31D,FF7
587C:  MOVFF  31C,FF6
5880:  MOVLW  03
5882:  MOVWF  FEA
5884:  MOVLW  20
5886:  MOVWF  FE9
5888:  MOVLB  3
588A:  CLRF   x3B
588C:  MOVLW  01
588E:  MOVWF  x3A
5890:  MOVLB  0
5892:  RCALL  5616
.................... #endif
.................... 
....................    return(ret);
5894:  MOVLB  3
5896:  MOVFF  320,01
589A:  MOVLB  0
589C:  GOTO   5D94 (RETURN)
.................... }
.................... 
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType)
.................... {
....................    static char str[40];
....................    int8 socket;
....................    char ec;
....................    int escaped;
.................... 
....................    static enum
....................    {
....................       HTTP_PUT_FILE_INIT = 0,
....................       HTTP_PUT_FILE_CONTINUE,
....................       HTTP_PUT_FILE_CHUNK_END,
....................       HTTP_PUT_FILE_DONE
....................    } status;
.................... 
....................    socket=http_socket[which];
*
5B46:  CLRF   03
5B48:  MOVLB  3
5B4A:  MOVF   x0C,W
5B4C:  ADDLW  6D
5B4E:  MOVWF  FE9
5B50:  MOVLW  00
5B52:  ADDWFC 03,W
5B54:  MOVWF  FEA
5B56:  MOVFF  FEF,315
.................... 
....................    set_tcp_http_putc(socket);
5B5A:  MOVFF  315,318
5B5E:  MOVLB  0
5B60:  GOTO   5054
.................... 
....................    if (lastHTTPPutConstPos[which] == 0)
5B64:  MOVLB  3
5B66:  MOVF   x0C,W
5B68:  MULLW  04
5B6A:  MOVF   FF3,W
5B6C:  CLRF   03
5B6E:  ADDLW  71
5B70:  MOVWF  FE9
5B72:  MOVLW  00
5B74:  ADDWFC 03,W
5B76:  MOVWF  FEA
5B78:  MOVFF  FEF,318
5B7C:  MOVFF  FEC,319
5B80:  MOVFF  FEC,31A
5B84:  MOVFF  FEC,31B
5B88:  MOVF   x18,F
5B8A:  BTFSS  FD8.2
5B8C:  BRA    5CCE
5B8E:  MOVF   x19,F
5B90:  BTFSS  FD8.2
5B92:  BRA    5CCE
5B94:  MOVF   x1A,F
5B96:  BTFSS  FD8.2
5B98:  BRA    5CCE
5B9A:  MOVF   x1B,F
5B9C:  BTFSS  FD8.2
5B9E:  BRA    5CCE
....................    {
....................       lastHTTPPutVarPos[which] = 0;
5BA0:  CLRF   03
5BA2:  MOVFF  30C,02
5BA6:  BCF    FD8.0
5BA8:  RLCF   02,F
5BAA:  RLCF   03,F
5BAC:  MOVF   02,W
5BAE:  ADDLW  75
5BB0:  MOVWF  FE9
5BB2:  MOVLW  00
5BB4:  ADDWFC 03,W
5BB6:  MOVWF  FEA
5BB8:  CLRF   FEC
5BBA:  MOVF   FED,F
5BBC:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file;
5BBE:  MOVF   x0C,W
5BC0:  MULLW  04
5BC2:  MOVF   FF3,W
5BC4:  CLRF   03
5BC6:  ADDLW  71
5BC8:  MOVWF  FE9
5BCA:  MOVLW  00
5BCC:  ADDWFC 03,W
5BCE:  MOVWF  FEA
5BD0:  MOVFF  30F,FEF
5BD4:  MOVFF  310,FEC
5BD8:  MOVFF  311,FEC
5BDC:  MOVFF  312,FEC
....................       status = HTTP_PUT_FILE_CONTINUE;
5BE0:  MOVLW  01
5BE2:  MOVLB  0
5BE4:  MOVWF  x77
.................... 
....................     #if HTTP_USE_CHUNKS
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode);
....................     #else
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode);
5BE6:  MOVLW  5C
5BE8:  MOVWF  FF6
5BEA:  MOVLW  01
5BEC:  MOVWF  FF7
5BEE:  MOVLW  09
5BF0:  MOVLB  3
5BF2:  MOVWF  x18
5BF4:  MOVLB  0
5BF6:  GOTO   5336
5BFA:  MOVLW  10
5BFC:  MOVWF  FE9
5BFE:  MOVFF  30E,319
5C02:  MOVFF  30D,318
5C06:  GOTO   5360
5C0A:  MOVLW  20
5C0C:  MOVLB  3
5C0E:  MOVWF  x36
5C10:  MOVLB  0
5C12:  CALL   5328
....................     #endif
.................... 
....................       switch(errorCode)
5C16:  MOVLB  3
5C18:  MOVF   x0D,W
5C1A:  MOVWF  00
5C1C:  MOVF   x0E,W
5C1E:  MOVWF  03
5C20:  MOVF   03,W
5C22:  BNZ   5C2E
5C24:  MOVLW  C8
5C26:  SUBWF  00,W
5C28:  MOVLB  0
5C2A:  BZ    5C50
5C2C:  MOVLB  3
5C2E:  MOVLW  01
5C30:  SUBWF  03,W
5C32:  BNZ   5C3E
5C34:  MOVLW  94
5C36:  SUBWF  00,W
5C38:  MOVLB  0
5C3A:  BZ    5C6A
5C3C:  MOVLB  3
5C3E:  MOVLW  01
5C40:  SUBWF  03,W
5C42:  BNZ   5C4E
5C44:  MOVLW  F4
5C46:  SUBWF  00,W
5C48:  MOVLB  0
5C4A:  BZ    5C78
5C4C:  MOVLB  3
5C4E:  BRA    5C88
....................       {
....................          case 200:
....................             printf(tcp_http_putc,"OK");
5C50:  MOVLW  4F
5C52:  MOVLB  3
5C54:  MOVWF  x36
5C56:  MOVLB  0
5C58:  CALL   5328
5C5C:  MOVLW  4B
5C5E:  MOVLB  3
5C60:  MOVWF  x36
5C62:  MOVLB  0
5C64:  CALL   5328
....................             break;
5C68:  BRA    5C8A
....................          case 404:
....................             printf(tcp_http_putc,"Not found");
5C6A:  MOVLW  6A
5C6C:  MOVWF  FF6
5C6E:  MOVLW  01
5C70:  MOVWF  FF7
5C72:  CALL   5428
....................             break;
5C76:  BRA    5C8A
....................          case 500:
....................             printf(tcp_http_putc,"Server Error");
5C78:  MOVLW  74
5C7A:  MOVWF  FF6
5C7C:  MOVLW  01
5C7E:  MOVWF  FF7
5C80:  CALL   5428
....................             break;
5C84:  BRA    5C8A
5C86:  MOVLB  3
....................          default:
....................             break;
5C88:  MOVLB  0
....................       }
.................... 
....................       printf(tcp_http_putc, "\r\nContent-Type: ");
5C8A:  MOVLW  82
5C8C:  MOVWF  FF6
5C8E:  MOVLW  01
5C90:  MOVWF  FF7
5C92:  CALL   5428
....................       if (contentType)
5C96:  MOVLB  3
5C98:  MOVF   x13,W
5C9A:  IORWF  x14,W
5C9C:  BZ    5CB2
....................          printf(tcp_http_putc, "%s", contentType);
5C9E:  MOVFF  314,FEA
5CA2:  MOVFF  313,FE9
5CA6:  MOVLB  0
5CA8:  GOTO   5448
5CAC:  MOVLB  0
5CAE:  BRA    5CC0
5CB0:  MOVLB  3
....................       else
....................          printf(tcp_http_putc,"text/html");
5CB2:  MOVLW  94
5CB4:  MOVWF  FF6
5CB6:  MOVLW  01
5CB8:  MOVWF  FF7
5CBA:  MOVLB  0
5CBC:  CALL   5428
.................... 
....................     #if HTTP_USE_CHUNKS
....................       printf(tcp_http_putc, "\r\nConnection: close");
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked");
....................     #endif
.................... 
....................       printf(tcp_http_putc, "\r\n\r\n");
5CC0:  MOVLW  9E
5CC2:  MOVWF  FF6
5CC4:  MOVLW  01
5CC6:  MOVWF  FF7
5CC8:  CALL   5428
5CCC:  MOVLB  3
....................    }
.................... 
....................    if (lastHTTPPutVarPos[which])
5CCE:  CLRF   03
5CD0:  MOVFF  30C,02
5CD4:  BCF    FD8.0
5CD6:  RLCF   02,F
5CD8:  RLCF   03,F
5CDA:  MOVF   02,W
5CDC:  ADDLW  75
5CDE:  MOVWF  FE9
5CE0:  MOVLW  00
5CE2:  ADDWFC 03,W
5CE4:  MOVWF  FEA
5CE6:  MOVF   FEF,F
5CE8:  BZ    5D34
....................    {
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]);
5CEA:  CLRF   03
5CEC:  MOVFF  30C,02
5CF0:  BCF    FD8.0
5CF2:  RLCF   02,F
5CF4:  RLCF   03,F
5CF6:  MOVF   02,W
5CF8:  ADDLW  75
5CFA:  MOVWF  01
5CFC:  MOVLW  00
5CFE:  ADDWFC 03,F
5D00:  MOVFF  01,318
5D04:  MOVFF  03,319
5D08:  MOVFF  03,31B
5D0C:  MOVFF  01,31A
5D10:  MOVLB  0
5D12:  RCALL  555E
....................       lastHTTPPutVarPos[which] = 0;
5D14:  CLRF   03
5D16:  MOVLB  3
5D18:  MOVFF  30C,02
5D1C:  BCF    FD8.0
5D1E:  RLCF   02,F
5D20:  RLCF   03,F
5D22:  MOVF   02,W
5D24:  ADDLW  75
5D26:  MOVWF  FE9
5D28:  MOVLW  00
5D2A:  ADDWFC 03,W
5D2C:  MOVWF  FEA
5D2E:  CLRF   FEC
5D30:  MOVF   FED,F
5D32:  CLRF   FEF
....................    }
.................... 
....................    if (status == HTTP_PUT_FILE_CONTINUE)
5D34:  MOVLB  0
5D36:  DECFSZ x77,W
5D38:  BRA    5E86
....................    {
....................       do {
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]);
5D3A:  MOVLB  3
5D3C:  MOVF   x0C,W
5D3E:  MULLW  04
5D40:  MOVF   FF3,W
5D42:  CLRF   03
5D44:  ADDLW  71
5D46:  MOVWF  01
5D48:  MOVLW  00
5D4A:  ADDWFC 03,F
5D4C:  MOVFF  01,318
5D50:  MOVFF  03,319
5D54:  MOVFF  03,31B
5D58:  MOVFF  01,31A
5D5C:  MOVLB  0
5D5E:  BRA    57AE
5D60:  MOVFF  01,316
.................... 
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE)
5D64:  MOVLB  3
5D66:  MOVF   x16,W
5D68:  SUBLW  02
5D6A:  BTFSS  FD8.2
5D6C:  BRA    5E74
....................          {
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]);
5D6E:  MOVF   x0C,W
5D70:  MULLW  04
5D72:  MOVF   FF3,W
5D74:  CLRF   03
5D76:  ADDLW  71
5D78:  MOVWF  FE9
5D7A:  MOVLW  00
5D7C:  ADDWFC 03,W
5D7E:  MOVWF  FEA
5D80:  MOVFF  FEF,31C
5D84:  MOVFF  FEC,31D
5D88:  MOVFF  FEC,31E
5D8C:  MOVFF  FEC,31F
5D90:  MOVLB  0
5D92:  BRA    5874
5D94:  MOVFF  01,317
....................            #if HTTP_USE_DOUBLE_ESCAPE
....................             lastHTTPPutConstPos[which] += 2;
....................            #else
....................             lastHTTPPutConstPos[which] += 1;
5D98:  MOVLB  3
5D9A:  MOVF   x0C,W
5D9C:  MULLW  04
5D9E:  MOVF   FF3,W
5DA0:  CLRF   03
5DA2:  ADDLW  71
5DA4:  MOVWF  FE9
5DA6:  MOVLW  00
5DA8:  ADDWFC 03,W
5DAA:  MOVWF  FEA
5DAC:  MOVLW  01
5DAE:  ADDWF  FEF,W
5DB0:  MOVWF  00
5DB2:  MOVLW  00
5DB4:  ADDWFC FEC,W
5DB6:  MOVWF  01
5DB8:  MOVLW  00
5DBA:  ADDWFC FEC,W
5DBC:  MOVWF  02
5DBE:  MOVLW  00
5DC0:  ADDWFC FEC,W
5DC2:  MOVF   FED,F
5DC4:  MOVF   FED,F
5DC6:  MOVF   FED,F
5DC8:  MOVFF  00,FEF
5DCC:  MOVFF  01,FEC
5DD0:  MOVFF  02,FEC
5DD4:  MOVWF  FEC
....................            #endif
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1);
5DD6:  MOVFF  312,31B
5DDA:  MOVFF  311,31A
5DDE:  MOVFF  310,319
5DE2:  MOVFF  30F,318
5DE6:  MOVFF  317,31C
5DEA:  CLRF   x1E
5DEC:  MOVLW  88
5DEE:  MOVWF  x1D
5DF0:  MOVLW  27
5DF2:  MOVWF  x1F
5DF4:  MOVLB  0
5DF6:  BRA    5A50
....................             lastHTTPPutVarPos[which] = &str[0];
5DF8:  CLRF   03
5DFA:  MOVLB  3
5DFC:  MOVFF  30C,02
5E00:  BCF    FD8.0
5E02:  RLCF   02,F
5E04:  RLCF   03,F
5E06:  MOVF   02,W
5E08:  ADDLW  75
5E0A:  MOVWF  FE9
5E0C:  MOVLW  00
5E0E:  ADDWFC 03,W
5E10:  MOVWF  FEA
5E12:  CLRF   FEC
5E14:  MOVF   FED,F
5E16:  MOVLW  88
5E18:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]);
5E1A:  CLRF   03
5E1C:  MOVFF  30C,02
5E20:  BCF    FD8.0
5E22:  RLCF   02,F
5E24:  RLCF   03,F
5E26:  MOVF   02,W
5E28:  ADDLW  75
5E2A:  MOVWF  01
5E2C:  MOVLW  00
5E2E:  ADDWFC 03,F
5E30:  MOVFF  01,318
5E34:  MOVFF  03,319
5E38:  MOVFF  03,31B
5E3C:  MOVFF  01,31A
5E40:  MOVLB  0
5E42:  CALL   555E
5E46:  MOVFF  01,316
....................             if (ec == TCP_PUT_CONST_EC_FINISH)
5E4A:  MOVLB  3
5E4C:  MOVF   x16,F
5E4E:  BNZ   5E70
....................                lastHTTPPutVarPos[which] = 0;
5E50:  CLRF   03
5E52:  MOVFF  30C,02
5E56:  BCF    FD8.0
5E58:  RLCF   02,F
5E5A:  RLCF   03,F
5E5C:  MOVF   02,W
5E5E:  ADDLW  75
5E60:  MOVWF  FE9
5E62:  MOVLW  00
5E64:  ADDWFC 03,W
5E66:  MOVWF  FEA
5E68:  CLRF   FEC
5E6A:  MOVF   FED,F
5E6C:  CLRF   FEF
5E6E:  BRA    5E72
....................             else
....................                break;
5E70:  BRA    5E84
....................          }
5E72:  BRA    5E82
....................          else
....................          {
....................             if (ec == TCP_PUT_CONST_EC_FINISH)
5E74:  MOVF   x16,F
5E76:  BNZ   5E80
....................                status = HTTP_PUT_FILE_CHUNK_END;
5E78:  MOVLW  02
5E7A:  MOVLB  0
5E7C:  MOVWF  x77
5E7E:  MOVLB  3
....................             break;
5E80:  BRA    5E84
....................          }
....................       } while (TRUE);
5E82:  BRA    5D3C
5E84:  MOVLB  0
....................    }
.................... 
....................    if (status == HTTP_PUT_FILE_CHUNK_END)
5E86:  MOVF   x77,W
5E88:  SUBLW  02
5E8A:  BNZ   5E90
....................    {
....................      #if HTTP_USE_CHUNKS
....................       if (tcp_http_tx_left() > 8)
....................       {
....................          TCPPutFileChunkStart(0);
....................          TCPPutFileChunkStop();
....................          status = HTTP_PUT_FILE_DONE;
....................       }
....................      #else
....................       status = HTTP_PUT_FILE_DONE;
5E8C:  MOVLW  03
5E8E:  MOVWF  x77
....................      #endif
....................    }
.................... 
.................... 
....................    TCPFlush(socket);
5E90:  MOVFF  315,33D
5E94:  CALL   505C
.................... 
....................    return(status == HTTP_PUT_FILE_DONE);
5E98:  MOVF   x77,W
5E9A:  SUBLW  03
5E9C:  BZ    5EA2
5E9E:  MOVLW  00
5EA0:  BRA    5EA4
5EA2:  MOVLW  01
5EA4:  MOVWF  01
5EA6:  RETURN 0
.................... }
.................... 
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack
.................... void HTTP_Init(void) {
....................    int8 i;
....................    debug_http("\r\nHTTP OPENING");
....................    if (HTTP_PORT != 0)
....................    {
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++)
*
1084:  MOVLB  2
1086:  CLRF   xF4
1088:  MOVF   xF4,F
108A:  BNZ   10E8
....................       {
....................          http_socket[i]=TCPListen(HTTP_PORT);
108C:  CLRF   03
108E:  MOVF   xF4,W
1090:  ADDLW  6D
1092:  MOVWF  01
1094:  MOVLW  00
1096:  ADDWFC 03,F
1098:  MOVFF  01,2F5
109C:  MOVFF  03,2F6
10A0:  CLRF   xF8
10A2:  MOVLW  50
10A4:  MOVWF  xF7
10A6:  MOVLB  0
10A8:  BRA    0F9A
10AA:  MOVFF  2F6,FEA
10AE:  MOVFF  2F5,FE9
10B2:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]);
....................          if (http_socket[i]!=INVALID_SOCKET)
10B6:  CLRF   03
10B8:  MOVLB  2
10BA:  MOVF   xF4,W
10BC:  ADDLW  6D
10BE:  MOVWF  FE9
10C0:  MOVLW  00
10C2:  ADDWFC 03,W
10C4:  MOVWF  FEA
10C6:  MOVF   FEF,W
10C8:  SUBLW  FE
10CA:  BZ    10E4
....................          {
....................             http_state[i]=HTTP_LISTEN_WAIT;
10CC:  BCF    FD8.0
10CE:  RLCF   xF4,W
10D0:  CLRF   03
10D2:  ADDLW  6E
10D4:  MOVWF  FE9
10D6:  MOVLW  00
10D8:  ADDWFC 03,W
10DA:  MOVWF  FEA
10DC:  MOVLW  01
10DE:  MOVWF  FEC
10E0:  MOVF   FED,F
10E2:  MOVWF  FEF
....................          }
10E4:  INCF   xF4,F
10E6:  BRA    1088
....................       }
....................    }
....................    else
....................    {
....................       debug_http("\r\nHTTP DISABLED");
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++)
....................       {
....................             http_state[i]=HTTP_DISABLED;
....................       }
....................    }
10E8:  MOVLB  0
10EA:  GOTO   10FC (RETURN)
.................... }
.................... 
.................... void HTTP_Task(void) {
....................    static char tokens_header[]=" ";
....................    static char tokens_get[]="?";
....................    static char http_get_str[]="GET";
....................    static char http_post_str[]="POST";
....................    static char http_len_str[]="Content-Length:";
....................    //static char http_keepalive_str[]="keep-alive";
....................    //static char http_connection_str[]="Connection";
.................... 
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE];
.................... 
....................    static int8 i[HTTP_NUM_SOCKETS];
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0};
....................    static int32 http_page_req[HTTP_NUM_SOCKETS];
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0};
....................    static int16 http_timer[HTTP_NUM_SOCKETS];
....................  #if HTTP_USE_CONTENT_TYPE
....................    static char contentType[HTTP_NUM_SOCKETS][12];
....................  #endif
.................... 
....................    int1 doneSend, postContinue;
.................... 
....................    char c, *pKey, *pValue;
....................    int8 hs, currSocket;
.................... 
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++)
*
5FB4:  MOVLB  3
5FB6:  CLRF   x00
5FB8:  MOVF   x00,F
5FBA:  BTFSS  FD8.2
5FBC:  GOTO   6C38
....................    {
....................       if (http_state[hs]==HTTP_DISABLED)
5FC0:  BCF    FD8.0
5FC2:  RLCF   x00,W
5FC4:  CLRF   03
5FC6:  ADDLW  6E
5FC8:  MOVWF  FE9
5FCA:  MOVLW  00
5FCC:  ADDWFC 03,W
5FCE:  MOVWF  FEA
5FD0:  MOVFF  FEC,303
5FD4:  MOVF   FED,F
5FD6:  MOVFF  FEF,302
5FDA:  INCFSZ x02,W
5FDC:  BRA    5FE6
5FDE:  MOVF   x03,F
5FE0:  BNZ   5FE6
....................          return;
5FE2:  GOTO   6C38
.................... 
....................       currSocket=http_socket[hs];
5FE6:  CLRF   03
5FE8:  MOVF   x00,W
5FEA:  ADDLW  6D
5FEC:  MOVWF  FE9
5FEE:  MOVLW  00
5FF0:  ADDWFC 03,W
5FF2:  MOVWF  FEA
5FF4:  MOVFF  FEF,301
.................... 
....................       if (!TCPIsConnected(currSocket))
5FF8:  MOVFF  301,308
5FFC:  MOVLB  0
5FFE:  CALL   3E2A
6002:  MOVF   01,F
6004:  BNZ   6022
....................          http_state[hs]=HTTP_LISTEN_WAIT;
6006:  BCF    FD8.0
6008:  MOVLB  3
600A:  RLCF   x00,W
600C:  CLRF   03
600E:  ADDLW  6E
6010:  MOVWF  FE9
6012:  MOVLW  00
6014:  ADDWFC 03,W
6016:  MOVWF  FEA
6018:  MOVLW  01
601A:  MOVWF  FEC
601C:  MOVF   FED,F
601E:  MOVWF  FEF
6020:  MOVLB  0
.................... 
....................       switch(http_state[hs])
6022:  BCF    FD8.0
6024:  MOVLB  3
6026:  RLCF   x00,W
6028:  CLRF   03
602A:  ADDLW  6E
602C:  MOVWF  FE9
602E:  MOVLW  00
6030:  ADDWFC 03,W
6032:  MOVWF  FEA
6034:  MOVF   FEF,W
6036:  MOVWF  00
6038:  MOVF   FEE,F
603A:  MOVF   FED,W
603C:  MOVWF  03
603E:  MOVLW  01
6040:  SUBWF  03,W
6042:  BNZ   604E
6044:  MOVLW  01
6046:  SUBWF  00,W
6048:  MOVLB  0
604A:  BZ    60FC
604C:  MOVLB  3
604E:  MOVLW  01
6050:  SUBWF  03,W
6052:  BNZ   605E
6054:  MOVLW  02
6056:  SUBWF  00,W
6058:  MOVLB  0
605A:  BZ    610C
605C:  MOVLB  3
605E:  MOVLW  01
6060:  SUBWF  03,W
6062:  BNZ   6070
6064:  MOVLW  03
6066:  SUBWF  00,W
6068:  MOVLB  0
606A:  BTFSC  FD8.2
606C:  BRA    61B2
606E:  MOVLB  3
6070:  MOVLW  01
6072:  SUBWF  03,W
6074:  BNZ   6082
6076:  MOVLW  04
6078:  SUBWF  00,W
607A:  MOVLB  0
607C:  BTFSC  FD8.2
607E:  BRA    6646
6080:  MOVLB  3
6082:  MOVLW  01
6084:  SUBWF  03,W
6086:  BNZ   6094
6088:  MOVLW  05
608A:  SUBWF  00,W
608C:  MOVLB  0
608E:  BTFSC  FD8.2
6090:  BRA    66A4
6092:  MOVLB  3
6094:  MOVLW  01
6096:  SUBWF  03,W
6098:  BNZ   60A8
609A:  MOVLW  06
609C:  SUBWF  00,W
609E:  MOVLB  0
60A0:  BTFSC  FD8.2
60A2:  GOTO   695E
60A6:  MOVLB  3
60A8:  MOVLW  01
60AA:  SUBWF  03,W
60AC:  BNZ   60BC
60AE:  MOVLW  07
60B0:  SUBWF  00,W
60B2:  MOVLB  0
60B4:  BTFSC  FD8.2
60B6:  GOTO   6996
60BA:  MOVLB  3
60BC:  MOVLW  01
60BE:  SUBWF  03,W
60C0:  BNZ   60D0
60C2:  MOVLW  08
60C4:  SUBWF  00,W
60C6:  MOVLB  0
60C8:  BTFSC  FD8.2
60CA:  GOTO   6ADA
60CE:  MOVLB  3
60D0:  MOVLW  01
60D2:  SUBWF  03,W
60D4:  BNZ   60E4
60D6:  MOVLW  09
60D8:  SUBWF  00,W
60DA:  MOVLB  0
60DC:  BTFSC  FD8.2
60DE:  GOTO   6B24
60E2:  MOVLB  3
60E4:  MOVLW  01
60E6:  SUBWF  03,W
60E8:  BNZ   60F8
60EA:  MOVLW  0A
60EC:  SUBWF  00,W
60EE:  MOVLB  0
60F0:  BTFSC  FD8.2
60F2:  GOTO   6C2C
60F6:  MOVLB  3
60F8:  GOTO   6C2E
....................       {
....................          case HTTP_LISTEN_WAIT:
....................             if (!TCPIsConnected(currSocket))
60FC:  MOVFF  301,308
6100:  CALL   3E2A
6104:  MOVF   01,F
6106:  BNZ   610C
....................                break;
6108:  GOTO   6C30
....................             debug_http("HTTP %U CONNECTED\r\n", hs);
.................... 
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header
....................          case HTTP_CONNECTED:
....................             debug_http("HTTP %U LISTENING\r\n", hs);
....................             buffer[hs][0]=0;
610C:  MOVLB  3
610E:  MOVF   x00,W
6110:  MULLW  FE
6112:  MOVF   FF3,W
6114:  CLRF   x03
6116:  MOVWF  x02
6118:  MOVLW  B4
611A:  ADDWF  x02,W
611C:  MOVWF  FE9
611E:  MOVLW  01
6120:  ADDWFC x03,W
6122:  MOVWF  FEA
6124:  CLRF   FEF
....................             i[hs]=0;
6126:  CLRF   03
6128:  MOVF   x00,W
612A:  ADDLW  C0
612C:  MOVWF  FE9
612E:  MOVLW  00
6130:  ADDWFC 03,W
6132:  MOVWF  FEA
6134:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS;
6136:  BCF    FD8.0
6138:  RLCF   x00,W
613A:  CLRF   03
613C:  ADDLW  6E
613E:  MOVWF  FE9
6140:  MOVLW  00
6142:  ADDWFC 03,W
6144:  MOVWF  FEA
6146:  MOVLW  01
6148:  MOVWF  FEC
614A:  MOVF   FED,F
614C:  MOVLW  03
614E:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
6150:  BCF    FD8.0
6152:  RLCF   x00,W
6154:  CLRF   03
6156:  ADDLW  C8
6158:  MOVWF  01
615A:  MOVLW  00
615C:  ADDWFC 03,F
615E:  MOVFF  01,302
6162:  MOVFF  03,303
6166:  MOVLB  0
6168:  CALL   248A
616C:  MOVFF  303,FEA
6170:  MOVFF  302,FE9
6174:  MOVFF  02,FEC
6178:  MOVF   FED,F
617A:  MOVFF  01,FEF
....................             http_page_req[hs]=0;
617E:  MOVLB  3
6180:  MOVF   x00,W
6182:  MULLW  04
6184:  MOVF   FF3,W
6186:  CLRF   03
6188:  ADDLW  C2
618A:  MOVWF  FE9
618C:  MOVLW  00
618E:  ADDWFC 03,W
6190:  MOVWF  FEA
6192:  CLRF   FEF
6194:  CLRF   FEC
6196:  CLRF   FEC
6198:  CLRF   FEC
....................             http_post_len[hs]=0;
619A:  BCF    FD8.0
619C:  RLCF   x00,W
619E:  CLRF   03
61A0:  ADDLW  C6
61A2:  MOVWF  FE9
61A4:  MOVLW  00
61A6:  ADDWFC 03,W
61A8:  MOVWF  FEA
61AA:  CLRF   FEC
61AC:  MOVF   FED,F
61AE:  CLRF   FEF
61B0:  MOVLB  0
....................             //http_got_headers[hs]=FALSE;
....................             //http_isKeepAlive[hs]=FALSE;
.................... 
....................          case HTTP_GET_HEADERS:
....................             postContinue=FALSE;
61B2:  MOVLB  2
61B4:  BCF    xFA.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c))
61B6:  MOVFF  301,308
61BA:  MOVLB  0
61BC:  CALL   3E50
61C0:  MOVF   01,F
61C2:  BTFSC  FD8.2
61C4:  BRA    6548
61C6:  MOVFF  301,308
61CA:  MOVLW  02
61CC:  MOVLB  3
61CE:  MOVWF  x0A
61D0:  MOVLW  FB
61D2:  MOVWF  x09
61D4:  MOVLB  0
61D6:  CALL   3E7A
61DA:  MOVF   01,F
61DC:  BTFSC  FD8.2
61DE:  BRA    6548
....................             {
....................                //http_got_headers[hs]=TRUE;
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) )
61E0:  MOVLB  2
61E2:  MOVF   xFB,W
61E4:  SUBLW  1F
61E6:  BC    623C
61E8:  CLRF   03
61EA:  MOVLB  3
61EC:  MOVF   x00,W
61EE:  ADDLW  C0
61F0:  MOVWF  FE9
61F2:  MOVLW  00
61F4:  ADDWFC 03,W
61F6:  MOVWF  FEA
61F8:  MOVF   FEF,W
61FA:  SUBLW  FB
61FC:  BTFSC  FD8.0
61FE:  BRA    6204
6200:  MOVLB  2
6202:  BRA    623C
....................                {
....................                   buffer[hs][i[hs]++]=c;
6204:  MOVF   x00,W
6206:  MULLW  FE
6208:  MOVF   FF3,W
620A:  CLRF   x03
620C:  MOVWF  x02
620E:  CLRF   03
6210:  MOVF   x00,W
6212:  ADDLW  C0
6214:  MOVWF  FE9
6216:  MOVLW  00
6218:  ADDWFC 03,W
621A:  MOVWF  FEA
621C:  MOVF   FEF,W
621E:  INCF   FEF,F
6220:  CLRF   03
6222:  ADDWF  x02,W
6224:  MOVWF  01
6226:  MOVF   x03,W
6228:  ADDWFC 03,F
622A:  MOVF   01,W
622C:  ADDLW  B4
622E:  MOVWF  FE9
6230:  MOVLW  01
6232:  ADDWFC 03,W
6234:  MOVWF  FEA
6236:  MOVFF  2FB,FEF
623A:  MOVLB  2
....................                }
....................                if (c=='\n')
623C:  MOVF   xFB,W
623E:  SUBLW  0A
6240:  BTFSS  FD8.2
6242:  BRA    6544
....................                {
....................                   buffer[hs][i[hs]]=0;
6244:  MOVLB  3
6246:  MOVF   x00,W
6248:  MULLW  FE
624A:  MOVF   FF3,W
624C:  CLRF   x03
624E:  MOVWF  x02
6250:  CLRF   03
6252:  MOVF   x00,W
6254:  ADDLW  C0
6256:  MOVWF  FE9
6258:  MOVLW  00
625A:  ADDWFC 03,W
625C:  MOVWF  FEA
625E:  CLRF   03
6260:  MOVF   FEF,W
6262:  ADDWF  x02,W
6264:  MOVWF  01
6266:  MOVF   x03,W
6268:  ADDWFC 03,F
626A:  MOVF   01,W
626C:  ADDLW  B4
626E:  MOVWF  FE9
6270:  MOVLW  01
6272:  ADDWFC 03,W
6274:  MOVWF  FEA
6276:  CLRF   FEF
....................                   if (
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) &&
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 )
6278:  MOVF   x00,W
627A:  MULLW  FE
627C:  MOVF   FF3,W
627E:  CLRF   x03
6280:  MOVWF  x02
6282:  MOVLW  B4
6284:  ADDWF  x02,W
6286:  MOVWF  01
6288:  MOVLW  01
628A:  ADDWFC x03,W
628C:  MOVWF  03
628E:  MOVFF  01,304
6292:  MOVWF  x05
6294:  MOVWF  x0D
6296:  MOVFF  01,30C
629A:  CLRF   x0F
629C:  MOVLW  7A
629E:  MOVWF  x0E
62A0:  MOVLB  0
62A2:  CALL   407A
62A6:  MOVFF  02,2FD
62AA:  MOVFF  01,2FC
62AE:  MOVLB  2
62B0:  MOVF   xFC,F
62B2:  BNZ   62BA
62B4:  MOVF   xFD,F
62B6:  BTFSC  FD8.2
62B8:  BRA    64BC
62BA:  MOVLB  3
62BC:  CLRF   x0D
62BE:  CLRF   x0C
62C0:  CLRF   x0F
62C2:  MOVLW  7A
62C4:  MOVWF  x0E
62C6:  MOVLB  0
62C8:  CALL   407A
62CC:  MOVFF  02,2FF
62D0:  MOVFF  01,2FE
62D4:  MOVLB  2
62D6:  MOVF   xFE,F
62D8:  BNZ   62E0
62DA:  MOVF   xFF,F
62DC:  BTFSC  FD8.2
62DE:  BRA    64BC
....................                      )
....................                   {
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue);
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) )
62E0:  MOVFF  2FD,309
62E4:  MOVFF  2FC,308
62E8:  MOVLB  3
62EA:  CLRF   x0B
62EC:  MOVLW  7E
62EE:  MOVWF  x0A
62F0:  MOVLB  0
62F2:  CALL   412E
62F6:  MOVLB  3
62F8:  CLRF   x03
62FA:  MOVFF  01,302
62FE:  BTFSC  01.7
6300:  DECF   x03,F
6302:  MOVF   x02,F
6304:  BNZ   630A
6306:  MOVF   x03,F
6308:  BZ    6336
630A:  MOVFF  2FD,309
630E:  MOVFF  2FC,308
6312:  CLRF   x0B
6314:  MOVLW  82
6316:  MOVWF  x0A
6318:  MOVLB  0
631A:  CALL   412E
631E:  MOVLB  3
6320:  CLRF   x03
6322:  MOVFF  01,302
6326:  BTFSC  01.7
6328:  DECF   x03,F
632A:  MOVF   x02,F
632C:  BTFSS  FD8.2
632E:  BRA    6446
6330:  MOVF   x03,F
6332:  BTFSS  FD8.2
6334:  BRA    6446
....................                      {
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ?
6336:  MOVFF  2FF,30D
633A:  MOVFF  2FE,30C
633E:  CLRF   x0F
6340:  MOVLW  7C
6342:  MOVWF  x0E
6344:  MOVLB  0
6346:  CALL   407A
634A:  MOVFF  02,2FF
634E:  MOVFF  01,2FE
....................                         http_escape_chars(pValue);
6352:  MOVFF  2FF,31C
6356:  MOVFF  2FE,31B
635A:  CALL   46B0
....................                        #if HTTP_USE_CONTENT_TYPE
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]);
....................                        #else
....................                         http_page_req[hs] = http_get_page(pValue);
635E:  MOVLB  3
6360:  MOVF   x00,W
6362:  MULLW  04
6364:  MOVF   FF3,W
6366:  CLRF   03
6368:  ADDLW  C2
636A:  MOVWF  01
636C:  MOVLW  00
636E:  ADDWFC 03,F
6370:  MOVFF  01,302
6374:  MOVFF  03,303
6378:  MOVFF  2FF,30B
637C:  MOVFF  2FE,30A
6380:  MOVLB  0
6382:  GOTO   4884
6386:  MOVFF  303,FEA
638A:  MOVFF  302,FE9
638E:  MOVFF  00,FEF
6392:  MOVFF  01,FEC
6396:  MOVFF  02,FEC
639A:  MOVFF  03,FEC
....................                        #endif
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]);
....................                         pValue=strtok(0, tokens_get);
639E:  MOVLB  3
63A0:  CLRF   x0D
63A2:  CLRF   x0C
63A4:  CLRF   x0F
63A6:  MOVLW  7C
63A8:  MOVWF  x0E
63AA:  MOVLB  0
63AC:  CALL   407A
63B0:  MOVFF  02,2FF
63B4:  MOVFF  01,2FE
....................                         if (pValue)
63B8:  MOVLB  2
63BA:  MOVF   xFE,W
63BC:  IORWF  xFF,W
63BE:  BZ    63F4
....................                            http_parse_cgi_string(http_page_req[hs], pValue);
63C0:  MOVLB  3
63C2:  MOVF   x00,W
63C4:  MULLW  04
63C6:  MOVF   FF3,W
63C8:  CLRF   03
63CA:  ADDLW  C2
63CC:  MOVWF  FE9
63CE:  MOVLW  00
63D0:  ADDWFC 03,W
63D2:  MOVWF  FEA
63D4:  MOVFF  FEF,310
63D8:  MOVFF  FEC,311
63DC:  MOVFF  FEC,312
63E0:  MOVFF  FEC,313
63E4:  MOVFF  2FF,315
63E8:  MOVFF  2FE,314
63EC:  MOVLB  0
63EE:  CALL   4C98
63F2:  MOVLB  2
.................... 
....................                         if (strcmp(pKey, http_get_str)==0)
63F4:  MOVFF  2FD,309
63F8:  MOVFF  2FC,308
63FC:  MOVLB  3
63FE:  CLRF   x0B
6400:  MOVLW  7E
6402:  MOVWF  x0A
6404:  MOVLB  0
6406:  CALL   412E
640A:  MOVLB  3
640C:  CLRF   x03
640E:  MOVFF  01,302
6412:  BTFSC  01.7
6414:  DECF   x03,F
6416:  MOVF   x02,F
6418:  BNZ   6432
641A:  MOVF   x03,F
641C:  BNZ   6432
....................                            http_cmd[hs]=HTTP_REQ_GET;
641E:  CLRF   03
6420:  MOVF   x00,W
6422:  ADDLW  C1
6424:  MOVWF  FE9
6426:  MOVLW  00
6428:  ADDWFC 03,W
642A:  MOVWF  FEA
642C:  MOVLW  01
642E:  MOVWF  FEF
6430:  BRA    6444
....................                         else
....................                            http_cmd[hs]=HTTP_REQ_POST;
6432:  CLRF   03
6434:  MOVF   x00,W
6436:  ADDLW  C1
6438:  MOVWF  FE9
643A:  MOVLW  00
643C:  ADDWFC 03,W
643E:  MOVWF  FEA
6440:  MOVLW  02
6442:  MOVWF  FEF
....................                      }
6444:  BRA    64B8
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST
6446:  CLRF   03
6448:  MOVF   x00,W
644A:  ADDLW  C1
644C:  MOVWF  FE9
644E:  MOVLW  00
6450:  ADDWFC 03,W
6452:  MOVWF  FEA
6454:  MOVF   FEF,F
6456:  BZ    64B8
....................                      {
....................                         //if you want to parse HTTP headers, do it here.
....................                         //pKey and pVal hold the individual headers.
.................... 
....................                         //this driver only parses the Content-Length header.
....................                         if (strcmp(pKey, http_len_str)==0)
6458:  MOVFF  2FD,309
645C:  MOVFF  2FC,308
6460:  CLRF   x0B
6462:  MOVLW  B0
6464:  MOVWF  x0A
6466:  MOVLB  0
6468:  CALL   412E
646C:  MOVLB  3
646E:  CLRF   x03
6470:  MOVFF  01,302
6474:  BTFSC  01.7
6476:  DECF   x03,F
6478:  MOVF   x02,F
647A:  BNZ   64B8
647C:  MOVF   x03,F
647E:  BNZ   64B8
....................                         {
....................                            http_post_len[hs]=atol(pValue);
6480:  BCF    FD8.0
6482:  RLCF   x00,W
6484:  CLRF   03
6486:  ADDLW  C6
6488:  MOVWF  01
648A:  MOVLW  00
648C:  ADDWFC 03,F
648E:  MOVFF  01,302
6492:  MOVFF  03,303
6496:  MOVFF  2FF,30B
649A:  MOVFF  2FE,30A
649E:  MOVLB  0
64A0:  GOTO   4D96
64A4:  MOVFF  303,FEA
64A8:  MOVFF  302,FE9
64AC:  MOVFF  02,FEC
64B0:  MOVF   FED,F
64B2:  MOVFF  01,FEF
64B6:  MOVLB  3
....................                         }
....................                      }
....................                   }
64B8:  BRA    6532
64BA:  MOVLB  2
....................                   else if (i[hs] == 0)
64BC:  CLRF   03
64BE:  MOVLB  3
64C0:  MOVF   x00,W
64C2:  ADDLW  C0
64C4:  MOVWF  FE9
64C6:  MOVLW  00
64C8:  ADDWFC 03,W
64CA:  MOVWF  FEA
64CC:  MOVF   FEF,F
64CE:  BNZ   6532
....................                   {
....................                      //got a double \r\n
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs);
....................                      if (http_cmd[hs] == HTTP_REQ_POST)
64D0:  CLRF   03
64D2:  MOVF   x00,W
64D4:  ADDLW  C1
64D6:  MOVWF  FE9
64D8:  MOVLW  00
64DA:  ADDWFC 03,W
64DC:  MOVWF  FEA
64DE:  MOVF   FEF,W
64E0:  SUBLW  02
64E2:  BNZ   6506
....................                      {
....................                         http_state[hs]=HTTP_GET_POST;
64E4:  BCF    FD8.0
64E6:  RLCF   x00,W
64E8:  CLRF   03
64EA:  ADDLW  6E
64EC:  MOVWF  FE9
64EE:  MOVLW  00
64F0:  ADDWFC 03,W
64F2:  MOVWF  FEA
64F4:  MOVLW  01
64F6:  MOVWF  FEC
64F8:  MOVF   FED,F
64FA:  MOVLW  04
64FC:  MOVWF  FEF
....................                         postContinue=TRUE;
64FE:  MOVLB  2
6500:  BSF    xFA.1
....................                      }
6502:  BRA    652C
6504:  MOVLB  3
....................                      else
....................                      {
....................                         http_state[hs]=HTTP_SEND_RESPONSE;
6506:  BCF    FD8.0
6508:  RLCF   x00,W
650A:  CLRF   03
650C:  ADDLW  6E
650E:  MOVWF  FE9
6510:  MOVLW  00
6512:  ADDWFC 03,W
6514:  MOVWF  FEA
6516:  MOVLW  01
6518:  MOVWF  FEC
651A:  MOVF   FED,F
651C:  MOVLW  06
651E:  MOVWF  FEF
....................                         TCPDiscard(currSocket);
6520:  MOVFF  301,30B
6524:  MOVLB  0
6526:  CALL   4F72
652A:  MOVLB  2
....................                      }
....................                      break;   //break out of read from ethernet loop
652C:  MOVLB  0
652E:  BRA    6548
6530:  MOVLB  3
....................                   }
....................                   i[hs]=0;
6532:  CLRF   03
6534:  MOVF   x00,W
6536:  ADDLW  C0
6538:  MOVWF  FE9
653A:  MOVLW  00
653C:  ADDWFC 03,W
653E:  MOVWF  FEA
6540:  CLRF   FEF
6542:  MOVLB  2
....................                }
6544:  BRA    61B6
6546:  MOVLB  0
....................             }
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20)
6548:  CALL   248A
654C:  MOVFF  02,303
6550:  MOVFF  01,302
6554:  BCF    FD8.0
6556:  MOVLB  3
6558:  RLCF   x00,W
655A:  CLRF   03
655C:  ADDLW  C8
655E:  MOVWF  FE9
6560:  MOVLW  00
6562:  ADDWFC 03,W
6564:  MOVWF  FEA
6566:  MOVFF  FEC,03
656A:  MOVF   FED,F
656C:  MOVFF  FEF,01
6570:  MOVF   02,W
6572:  SUBWF  03,W
6574:  BNC   657E
6576:  BNZ   6582
6578:  MOVF   01,W
657A:  SUBWF  x02,W
657C:  BNC   6582
657E:  MOVLW  00
6580:  BRA    6584
6582:  MOVLW  01
6584:  CLRF   03
6586:  IORWF  03,W
6588:  BZ    65CC
658A:  BCF    FD8.0
658C:  RLCF   x00,W
658E:  CLRF   03
6590:  ADDLW  C8
6592:  MOVWF  FE9
6594:  MOVLW  00
6596:  ADDWFC 03,W
6598:  MOVWF  FEA
659A:  MOVFF  FEC,03
659E:  MOVF   FED,F
65A0:  MOVF   FEF,W
65A2:  SUBLW  FF
65A4:  MOVWF  x02
65A6:  MOVLW  FF
65A8:  SUBFWB 03,W
65AA:  MOVWF  x03
65AC:  MOVLB  0
65AE:  CALL   248A
65B2:  MOVF   01,W
65B4:  MOVLB  3
65B6:  ADDWF  x02,F
65B8:  MOVF   02,W
65BA:  ADDWFC x03,F
65BC:  MOVLW  01
65BE:  ADDWF  x02,W
65C0:  MOVWF  01
65C2:  MOVLW  00
65C4:  ADDWFC x03,W
65C6:  MOVWF  03
65C8:  MOVF   01,W
65CA:  BRA    6600
65CC:  MOVLB  0
65CE:  CALL   248A
65D2:  MOVFF  02,303
65D6:  MOVFF  01,302
65DA:  BCF    FD8.0
65DC:  MOVLB  3
65DE:  RLCF   x00,W
65E0:  CLRF   03
65E2:  ADDLW  C8
65E4:  MOVWF  FE9
65E6:  MOVLW  00
65E8:  ADDWFC 03,W
65EA:  MOVWF  FEA
65EC:  MOVFF  FEC,03
65F0:  MOVF   FED,F
65F2:  MOVF   FEF,W
65F4:  SUBWF  01,W
65F6:  MOVWF  00
65F8:  MOVF   03,W
65FA:  SUBWFB 02,W
65FC:  MOVWF  03
65FE:  MOVF   00,W
6600:  SUBLW  C8
6602:  BC    6638
....................             {
....................                //if (http_got_headers[hs])
....................                //{
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs);
....................                   http_page_req[hs]=0xFFFFFFFF;
6604:  MOVF   x00,W
6606:  MULLW  04
6608:  MOVF   FF3,W
660A:  CLRF   03
660C:  ADDLW  C2
660E:  MOVWF  FE9
6610:  MOVLW  00
6612:  ADDWFC 03,W
6614:  MOVWF  FEA
6616:  SETF   FEF
6618:  SETF   FEC
661A:  SETF   FEC
661C:  SETF   FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE;
661E:  BCF    FD8.0
6620:  RLCF   x00,W
6622:  CLRF   03
6624:  ADDLW  6E
6626:  MOVWF  FE9
6628:  MOVLW  00
662A:  ADDWFC 03,W
662C:  MOVWF  FEA
662E:  MOVLW  01
6630:  MOVWF  FEC
6632:  MOVF   FED,F
6634:  MOVLW  06
6636:  MOVWF  FEF
....................                //}
....................                //else
....................                //{
....................                //   http_state[hs]=HTTP_CLOSE;
....................                //}
....................             }
....................             if (!postContinue)
6638:  MOVLB  2
663A:  BTFSC  xFA.1
663C:  BRA    6644
....................                break;
663E:  MOVLB  0
6640:  BRA    6C30
6642:  MOVLB  2
6644:  MOVLB  0
.................... 
....................          case HTTP_GET_POST:
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]);
....................             http_state[hs]=HTTP_GET_POST_CONTINUE;
6646:  BCF    FD8.0
6648:  MOVLB  3
664A:  RLCF   x00,W
664C:  CLRF   03
664E:  ADDLW  6E
6650:  MOVWF  FE9
6652:  MOVLW  00
6654:  ADDWFC 03,W
6656:  MOVWF  FEA
6658:  MOVLW  01
665A:  MOVWF  FEC
665C:  MOVF   FED,F
665E:  MOVLW  05
6660:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
6662:  BCF    FD8.0
6664:  RLCF   x00,W
6666:  CLRF   03
6668:  ADDLW  C8
666A:  MOVWF  01
666C:  MOVLW  00
666E:  ADDWFC 03,F
6670:  MOVFF  01,302
6674:  MOVFF  03,303
6678:  MOVLB  0
667A:  CALL   248A
667E:  MOVFF  303,FEA
6682:  MOVFF  302,FE9
6686:  MOVFF  02,FEC
668A:  MOVF   FED,F
668C:  MOVFF  01,FEF
....................             i[hs]=0;
6690:  CLRF   03
6692:  MOVLB  3
6694:  MOVF   x00,W
6696:  ADDLW  C0
6698:  MOVWF  FE9
669A:  MOVLW  00
669C:  ADDWFC 03,W
669E:  MOVWF  FEA
66A0:  CLRF   FEF
66A2:  MOVLB  0
.................... 
....................          case HTTP_GET_POST_CONTINUE:
....................             while (
....................                      TCPIsGetReady(currSocket) &&
....................                      TCPGet(currSocket, &c) &&
....................                      (http_post_len[hs] != 0)
....................                   )
66A4:  MOVFF  301,308
66A8:  CALL   3E50
66AC:  MOVF   01,F
66AE:  BTFSC  FD8.2
66B0:  BRA    686A
66B2:  MOVFF  301,308
66B6:  MOVLW  02
66B8:  MOVLB  3
66BA:  MOVWF  x0A
66BC:  MOVLW  FB
66BE:  MOVWF  x09
66C0:  MOVLB  0
66C2:  CALL   3E7A
66C6:  MOVF   01,F
66C8:  BTFSC  FD8.2
66CA:  BRA    686A
66CC:  BCF    FD8.0
66CE:  MOVLB  3
66D0:  RLCF   x00,W
66D2:  CLRF   03
66D4:  ADDLW  C6
66D6:  MOVWF  FE9
66D8:  MOVLW  00
66DA:  ADDWFC 03,W
66DC:  MOVWF  FEA
66DE:  MOVFF  FEC,303
66E2:  MOVF   FED,F
66E4:  MOVFF  FEF,302
66E8:  MOVF   x02,F
66EA:  BNZ   66F6
66EC:  MOVF   x03,F
66EE:  BTFSS  FD8.2
66F0:  BRA    66F6
66F2:  MOVLB  0
66F4:  BRA    686A
....................             {
....................                http_post_len[hs] -= 1;
66F6:  BCF    FD8.0
66F8:  RLCF   x00,W
66FA:  CLRF   03
66FC:  ADDLW  C6
66FE:  MOVWF  FE9
6700:  MOVLW  00
6702:  ADDWFC 03,W
6704:  MOVWF  FEA
6706:  MOVLW  01
6708:  SUBWF  FEF,W
670A:  MOVWF  00
670C:  MOVLW  00
670E:  SUBWFB FEC,W
6710:  MOVWF  03
6712:  MOVF   00,W
6714:  MOVF   FED,F
6716:  MOVWF  FEF
6718:  MOVFF  03,FEC
.................... 
....................                if (c!='&')
671C:  MOVLB  2
671E:  MOVF   xFB,W
6720:  SUBLW  26
6722:  BZ    675E
....................                {
....................                   buffer[hs][i[hs]++]=c;
6724:  MOVLB  3
6726:  MOVF   x00,W
6728:  MULLW  FE
672A:  MOVF   FF3,W
672C:  CLRF   x03
672E:  MOVWF  x02
6730:  CLRF   03
6732:  MOVF   x00,W
6734:  ADDLW  C0
6736:  MOVWF  FE9
6738:  MOVLW  00
673A:  ADDWFC 03,W
673C:  MOVWF  FEA
673E:  MOVF   FEF,W
6740:  INCF   FEF,F
6742:  CLRF   03
6744:  ADDWF  x02,W
6746:  MOVWF  01
6748:  MOVF   x03,W
674A:  ADDWFC 03,F
674C:  MOVF   01,W
674E:  ADDLW  B4
6750:  MOVWF  FE9
6752:  MOVLW  01
6754:  ADDWFC 03,W
6756:  MOVWF  FEA
6758:  MOVFF  2FB,FEF
675C:  MOVLB  2
....................                }
.................... 
....................                if ( (c=='&') || (http_post_len[hs] == 0) )
675E:  MOVF   xFB,W
6760:  SUBLW  26
6762:  BZ    678A
6764:  BCF    FD8.0
6766:  MOVLB  3
6768:  RLCF   x00,W
676A:  CLRF   03
676C:  ADDLW  C6
676E:  MOVWF  FE9
6770:  MOVLW  00
6772:  ADDWFC 03,W
6774:  MOVWF  FEA
6776:  MOVFF  FEC,303
677A:  MOVF   FED,F
677C:  MOVFF  FEF,302
6780:  MOVF   x02,F
6782:  BNZ   6866
6784:  MOVF   x03,F
6786:  BNZ   6866
6788:  MOVLB  2
....................                {
....................                   buffer[hs][i[hs]]=0;
678A:  MOVLB  3
678C:  MOVF   x00,W
678E:  MULLW  FE
6790:  MOVF   FF3,W
6792:  CLRF   x03
6794:  MOVWF  x02
6796:  CLRF   03
6798:  MOVF   x00,W
679A:  ADDLW  C0
679C:  MOVWF  FE9
679E:  MOVLW  00
67A0:  ADDWFC 03,W
67A2:  MOVWF  FEA
67A4:  CLRF   03
67A6:  MOVF   FEF,W
67A8:  ADDWF  x02,W
67AA:  MOVWF  01
67AC:  MOVF   x03,W
67AE:  ADDWFC 03,F
67B0:  MOVF   01,W
67B2:  ADDLW  B4
67B4:  MOVWF  FE9
67B6:  MOVLW  01
67B8:  ADDWFC 03,W
67BA:  MOVWF  FEA
67BC:  CLRF   FEF
.................... 
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]);
.................... 
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]);
67BE:  MOVF   x00,W
67C0:  MULLW  04
67C2:  MOVF   FF3,W
67C4:  CLRF   03
67C6:  ADDLW  C2
67C8:  MOVWF  FE9
67CA:  MOVLW  00
67CC:  ADDWFC 03,W
67CE:  MOVWF  FEA
67D0:  MOVFF  FEF,310
67D4:  MOVFF  FEC,311
67D8:  MOVFF  FEC,312
67DC:  MOVFF  FEC,313
67E0:  MOVF   x00,W
67E2:  MULLW  FE
67E4:  MOVF   FF3,W
67E6:  CLRF   x07
67E8:  MOVWF  x06
67EA:  MOVLW  B4
67EC:  ADDWF  x06,W
67EE:  MOVWF  01
67F0:  MOVLW  01
67F2:  ADDWFC x07,W
67F4:  MOVWF  03
67F6:  MOVFF  01,308
67FA:  MOVWF  x09
67FC:  MOVWF  x15
67FE:  MOVFF  01,314
6802:  MOVLB  0
6804:  CALL   4C98
....................                   if (http_post_len[hs] == 0)
6808:  BCF    FD8.0
680A:  MOVLB  3
680C:  RLCF   x00,W
680E:  CLRF   03
6810:  ADDLW  C6
6812:  MOVWF  FE9
6814:  MOVLW  00
6816:  ADDWFC 03,W
6818:  MOVWF  FEA
681A:  MOVFF  FEC,303
681E:  MOVF   FED,F
6820:  MOVFF  FEF,302
6824:  MOVF   x02,F
6826:  BNZ   6856
6828:  MOVF   x03,F
682A:  BNZ   6856
....................                   {
....................                      http_state[hs]=HTTP_SEND_RESPONSE;
682C:  BCF    FD8.0
682E:  RLCF   x00,W
6830:  CLRF   03
6832:  ADDLW  6E
6834:  MOVWF  FE9
6836:  MOVLW  00
6838:  ADDWFC 03,W
683A:  MOVWF  FEA
683C:  MOVLW  01
683E:  MOVWF  FEC
6840:  MOVF   FED,F
6842:  MOVLW  06
6844:  MOVWF  FEF
....................                      TCPDiscard(currSocket);
6846:  MOVFF  301,30B
684A:  MOVLB  0
684C:  CALL   4F72
....................                      break;
6850:  BRA    686A
....................                   }
6852:  BRA    6868
6854:  MOVLB  3
....................                   else
....................                      i[hs]=0;
6856:  CLRF   03
6858:  MOVF   x00,W
685A:  ADDLW  C0
685C:  MOVWF  FE9
685E:  MOVLW  00
6860:  ADDWFC 03,W
6862:  MOVWF  FEA
6864:  CLRF   FEF
6866:  MOVLB  0
....................                }
6868:  BRA    66A4
....................             }
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20)
686A:  CALL   248A
686E:  MOVFF  02,303
6872:  MOVFF  01,302
6876:  BCF    FD8.0
6878:  MOVLB  3
687A:  RLCF   x00,W
687C:  CLRF   03
687E:  ADDLW  C8
6880:  MOVWF  FE9
6882:  MOVLW  00
6884:  ADDWFC 03,W
6886:  MOVWF  FEA
6888:  MOVFF  FEC,03
688C:  MOVF   FED,F
688E:  MOVFF  FEF,01
6892:  MOVF   02,W
6894:  SUBWF  03,W
6896:  BNC   68A0
6898:  BNZ   68A4
689A:  MOVF   01,W
689C:  SUBWF  x02,W
689E:  BNC   68A4
68A0:  MOVLW  00
68A2:  BRA    68A6
68A4:  MOVLW  01
68A6:  CLRF   03
68A8:  IORWF  03,W
68AA:  BZ    68EE
68AC:  BCF    FD8.0
68AE:  RLCF   x00,W
68B0:  CLRF   03
68B2:  ADDLW  C8
68B4:  MOVWF  FE9
68B6:  MOVLW  00
68B8:  ADDWFC 03,W
68BA:  MOVWF  FEA
68BC:  MOVFF  FEC,03
68C0:  MOVF   FED,F
68C2:  MOVF   FEF,W
68C4:  SUBLW  FF
68C6:  MOVWF  x02
68C8:  MOVLW  FF
68CA:  SUBFWB 03,W
68CC:  MOVWF  x03
68CE:  MOVLB  0
68D0:  CALL   248A
68D4:  MOVF   01,W
68D6:  MOVLB  3
68D8:  ADDWF  x02,F
68DA:  MOVF   02,W
68DC:  ADDWFC x03,F
68DE:  MOVLW  01
68E0:  ADDWF  x02,W
68E2:  MOVWF  01
68E4:  MOVLW  00
68E6:  ADDWFC x03,W
68E8:  MOVWF  03
68EA:  MOVF   01,W
68EC:  BRA    6922
68EE:  MOVLB  0
68F0:  CALL   248A
68F4:  MOVFF  02,303
68F8:  MOVFF  01,302
68FC:  BCF    FD8.0
68FE:  MOVLB  3
6900:  RLCF   x00,W
6902:  CLRF   03
6904:  ADDLW  C8
6906:  MOVWF  FE9
6908:  MOVLW  00
690A:  ADDWFC 03,W
690C:  MOVWF  FEA
690E:  MOVFF  FEC,03
6912:  MOVF   FED,F
6914:  MOVF   FEF,W
6916:  SUBWF  01,W
6918:  MOVWF  00
691A:  MOVF   03,W
691C:  SUBWFB 02,W
691E:  MOVWF  03
6920:  MOVF   00,W
6922:  SUBLW  C8
6924:  BC    695A
....................             {
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs);
....................                http_page_req[hs]=0xFFFFFFFF;
6926:  MOVF   x00,W
6928:  MULLW  04
692A:  MOVF   FF3,W
692C:  CLRF   03
692E:  ADDLW  C2
6930:  MOVWF  FE9
6932:  MOVLW  00
6934:  ADDWFC 03,W
6936:  MOVWF  FEA
6938:  SETF   FEF
693A:  SETF   FEC
693C:  SETF   FEC
693E:  SETF   FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE;
6940:  BCF    FD8.0
6942:  RLCF   x00,W
6944:  CLRF   03
6946:  ADDLW  6E
6948:  MOVWF  FE9
694A:  MOVLW  00
694C:  ADDWFC 03,W
694E:  MOVWF  FEA
6950:  MOVLW  01
6952:  MOVWF  FEC
6954:  MOVF   FED,F
6956:  MOVLW  06
6958:  MOVWF  FEF
....................             }
....................             break;
695A:  MOVLB  0
695C:  BRA    6C30
.................... 
....................          case HTTP_SEND_RESPONSE:
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs);
....................             lastHTTPPutConstPos[hs]=0;
695E:  MOVLB  3
6960:  MOVF   x00,W
6962:  MULLW  04
6964:  MOVF   FF3,W
6966:  CLRF   03
6968:  ADDLW  71
696A:  MOVWF  FE9
696C:  MOVLW  00
696E:  ADDWFC 03,W
6970:  MOVWF  FEA
6972:  CLRF   FEF
6974:  CLRF   FEC
6976:  CLRF   FEC
6978:  CLRF   FEC
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE;
697A:  BCF    FD8.0
697C:  RLCF   x00,W
697E:  CLRF   03
6980:  ADDLW  6E
6982:  MOVWF  FE9
6984:  MOVLW  00
6986:  ADDWFC 03,W
6988:  MOVWF  FEA
698A:  MOVLW  01
698C:  MOVWF  FEC
698E:  MOVF   FED,F
6990:  MOVLW  07
6992:  MOVWF  FEF
6994:  MOVLB  0
.................... 
....................          case HTTP_SEND_RESPONSE_CONTINUE:
....................             TCPDiscard(currSocket);
6996:  MOVFF  301,30B
699A:  CALL   4F72
....................             if (TCPIsPutReady(currSocket))
699E:  MOVFF  301,32B
69A2:  CALL   4FBE
69A6:  MOVF   01,F
69A8:  BTFSC  FD8.2
69AA:  BRA    6AD8
....................             {
....................                debug_http("\r\nPUTTING HTTP SEG\r\n");
....................                if (http_page_req[hs]==0xFFFFFFFF)
69AC:  MOVLB  3
69AE:  MOVF   x00,W
69B0:  MULLW  04
69B2:  MOVF   FF3,W
69B4:  CLRF   03
69B6:  ADDLW  C2
69B8:  MOVWF  FE9
69BA:  MOVLW  00
69BC:  ADDWFC 03,W
69BE:  MOVWF  FEA
69C0:  MOVFF  FEF,302
69C4:  MOVFF  FEC,303
69C8:  MOVFF  FEC,304
69CC:  MOVFF  FEC,305
69D0:  INCFSZ x02,W
69D2:  BRA    6A1A
69D4:  INCFSZ x03,W
69D6:  BRA    6A1A
69D8:  INCFSZ x04,W
69DA:  BRA    6A1A
69DC:  INCFSZ x05,W
69DE:  BRA    6A1A
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0);
69E0:  MOVLW  01
69E2:  MOVWF  03
69E4:  MOVLW  12
69E6:  MOVWF  x02
69E8:  MOVFF  03,303
69EC:  MOVFF  300,30C
69F0:  MOVLW  01
69F2:  MOVWF  x0E
69F4:  MOVLW  F4
69F6:  MOVWF  x0D
69F8:  CLRF   x12
69FA:  CLRF   x11
69FC:  MOVFF  03,310
6A00:  MOVFF  302,30F
6A04:  CLRF   x14
6A06:  CLRF   x13
6A08:  MOVLB  0
6A0A:  CALL   5B46
6A0E:  MOVLB  2
6A10:  BCF    xFA.0
6A12:  BTFSC  01.0
6A14:  BSF    xFA.0
6A16:  BRA    6AB4
6A18:  MOVLB  3
....................                else if (http_page_req[hs])
....................                 #if HTTP_USE_CONTENT_TYPE
6A1A:  MOVF   x00,W
6A1C:  MULLW  04
6A1E:  MOVF   FF3,W
6A20:  CLRF   03
6A22:  ADDLW  C2
6A24:  MOVWF  FE9
6A26:  MOVLW  00
6A28:  ADDWFC 03,W
6A2A:  MOVWF  FEA
6A2C:  MOVF   FEF,F
6A2E:  BNZ   6A3C
6A30:  MOVF   FEC,F
6A32:  BNZ   6A3C
6A34:  MOVF   FEC,F
6A36:  BNZ   6A3C
6A38:  MOVF   FEC,F
6A3A:  BZ    6A7E
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]);
....................                 #else
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0);
6A3C:  MOVF   x00,W
6A3E:  MULLW  04
6A40:  MOVF   FF3,W
6A42:  CLRF   03
6A44:  ADDLW  C2
6A46:  MOVWF  FE9
6A48:  MOVLW  00
6A4A:  ADDWFC 03,W
6A4C:  MOVWF  FEA
6A4E:  MOVFF  FEF,30F
6A52:  MOVFF  FEC,310
6A56:  MOVFF  FEC,311
6A5A:  MOVFF  FEC,312
6A5E:  MOVFF  300,30C
6A62:  CLRF   x0E
6A64:  MOVLW  C8
6A66:  MOVWF  x0D
6A68:  CLRF   x14
6A6A:  CLRF   x13
6A6C:  MOVLB  0
6A6E:  CALL   5B46
6A72:  MOVLB  2
6A74:  BCF    xFA.0
6A76:  BTFSC  01.0
6A78:  BSF    xFA.0
....................                 #endif
6A7A:  BRA    6AB4
6A7C:  MOVLB  3
....................                else
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0);
6A7E:  MOVLW  00
6A80:  MOVWF  03
6A82:  MOVLW  CE
6A84:  MOVWF  x02
6A86:  MOVFF  03,303
6A8A:  MOVFF  300,30C
6A8E:  MOVLW  01
6A90:  MOVWF  x0E
6A92:  MOVLW  94
6A94:  MOVWF  x0D
6A96:  CLRF   x12
6A98:  CLRF   x11
6A9A:  MOVFF  03,310
6A9E:  MOVFF  302,30F
6AA2:  CLRF   x14
6AA4:  CLRF   x13
6AA6:  MOVLB  0
6AA8:  CALL   5B46
6AAC:  MOVLB  2
6AAE:  BCF    xFA.0
6AB0:  BTFSC  01.0
6AB2:  BSF    xFA.0
.................... 
....................                if (doneSend)
6AB4:  BTFSS  xFA.0
6AB6:  BRA    6AD6
....................                {
....................                   //if (http_isKeepAlive[hs])
....................                   //   http_state[hs]=HTTP_CONNECTED;
....................                   //else
....................                   //   http_state[hs]=HTTP_CLOSE;
....................                   http_state[hs] = HTTP_CLOSE;
6AB8:  BCF    FD8.0
6ABA:  MOVLB  3
6ABC:  RLCF   x00,W
6ABE:  CLRF   03
6AC0:  ADDLW  6E
6AC2:  MOVWF  FE9
6AC4:  MOVLW  00
6AC6:  ADDWFC 03,W
6AC8:  MOVWF  FEA
6ACA:  MOVLW  01
6ACC:  MOVWF  FEC
6ACE:  MOVF   FED,F
6AD0:  MOVLW  08
6AD2:  MOVWF  FEF
6AD4:  MOVLB  2
6AD6:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs);
....................                }
....................             }
....................             /*else
....................             {
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n",
....................                      TCB[currSocket].RemoteWindow,
....................                      TCB[currSocket].TxBuffer,
....................                      TCB[currSocket].Flags.bIsPutReady
....................                   );
....................                delay_ms(100);
....................             }*/
....................             break;
6AD8:  BRA    6C30
.................... 
....................          case HTTP_CLOSE:
....................             //since we set connection: close in the header, the client
....................             //should automatically close.  but after so many seconds we
....................             //shall kill the connection
....................             http_state[hs]=HTTP_CLOSE_WAITING;
6ADA:  BCF    FD8.0
6ADC:  MOVLB  3
6ADE:  RLCF   x00,W
6AE0:  CLRF   03
6AE2:  ADDLW  6E
6AE4:  MOVWF  FE9
6AE6:  MOVLW  00
6AE8:  ADDWFC 03,W
6AEA:  MOVWF  FEA
6AEC:  MOVLW  01
6AEE:  MOVWF  FEC
6AF0:  MOVF   FED,F
6AF2:  MOVLW  09
6AF4:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
6AF6:  BCF    FD8.0
6AF8:  RLCF   x00,W
6AFA:  CLRF   03
6AFC:  ADDLW  C8
6AFE:  MOVWF  01
6B00:  MOVLW  00
6B02:  ADDWFC 03,F
6B04:  MOVFF  01,302
6B08:  MOVFF  03,303
6B0C:  MOVLB  0
6B0E:  CALL   248A
6B12:  MOVFF  303,FEA
6B16:  MOVFF  302,FE9
6B1A:  MOVFF  02,FEC
6B1E:  MOVF   FED,F
6B20:  MOVFF  01,FEF
.................... 
....................          case HTTP_CLOSE_WAITING:
....................             TCPDiscard(currSocket);
6B24:  MOVFF  301,30B
6B28:  CALL   4F72
....................             if (  TCPIsPutReady(currSocket) ||
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5))
6B2C:  MOVFF  301,32B
6B30:  CALL   4FBE
6B34:  MOVF   01,F
6B36:  BNZ   6C04
6B38:  CALL   248A
6B3C:  MOVFF  02,303
6B40:  MOVFF  01,302
6B44:  BCF    FD8.0
6B46:  MOVLB  3
6B48:  RLCF   x00,W
6B4A:  CLRF   03
6B4C:  ADDLW  C8
6B4E:  MOVWF  FE9
6B50:  MOVLW  00
6B52:  ADDWFC 03,W
6B54:  MOVWF  FEA
6B56:  MOVFF  FEC,03
6B5A:  MOVF   FED,F
6B5C:  MOVFF  FEF,01
6B60:  MOVF   02,W
6B62:  SUBWF  03,W
6B64:  BNC   6B6E
6B66:  BNZ   6B72
6B68:  MOVF   01,W
6B6A:  SUBWF  x02,W
6B6C:  BNC   6B72
6B6E:  MOVLW  00
6B70:  BRA    6B74
6B72:  MOVLW  01
6B74:  CLRF   03
6B76:  IORWF  03,W
6B78:  BZ    6BBC
6B7A:  BCF    FD8.0
6B7C:  RLCF   x00,W
6B7E:  CLRF   03
6B80:  ADDLW  C8
6B82:  MOVWF  FE9
6B84:  MOVLW  00
6B86:  ADDWFC 03,W
6B88:  MOVWF  FEA
6B8A:  MOVFF  FEC,03
6B8E:  MOVF   FED,F
6B90:  MOVF   FEF,W
6B92:  SUBLW  FF
6B94:  MOVWF  x02
6B96:  MOVLW  FF
6B98:  SUBFWB 03,W
6B9A:  MOVWF  x03
6B9C:  MOVLB  0
6B9E:  CALL   248A
6BA2:  MOVF   01,W
6BA4:  MOVLB  3
6BA6:  ADDWF  x02,F
6BA8:  MOVF   02,W
6BAA:  ADDWFC x03,F
6BAC:  MOVLW  01
6BAE:  ADDWF  x02,W
6BB0:  MOVWF  01
6BB2:  MOVLW  00
6BB4:  ADDWFC x03,W
6BB6:  MOVWF  03
6BB8:  MOVF   01,W
6BBA:  BRA    6BEC
6BBC:  MOVLB  0
6BBE:  CALL   248A
6BC2:  MOVFF  02,303
6BC6:  BCF    FD8.0
6BC8:  MOVLB  3
6BCA:  RLCF   x00,W
6BCC:  CLRF   03
6BCE:  ADDLW  C8
6BD0:  MOVWF  FE9
6BD2:  MOVLW  00
6BD4:  ADDWFC 03,W
6BD6:  MOVWF  FEA
6BD8:  MOVFF  FEC,03
6BDC:  MOVF   FED,F
6BDE:  MOVF   FEF,W
6BE0:  SUBWF  01,W
6BE2:  MOVWF  00
6BE4:  MOVF   03,W
6BE6:  SUBWFB 02,W
6BE8:  MOVWF  03
6BEA:  MOVF   00,W
6BEC:  MOVWF  x02
6BEE:  MOVFF  03,303
6BF2:  MOVF   x03,F
6BF4:  BTFSC  FD8.2
6BF6:  BRA    6BFC
6BF8:  MOVLB  0
6BFA:  BRA    6C04
6BFC:  MOVF   x02,W
6BFE:  SUBLW  32
6C00:  BC    6C28
6C02:  MOVLB  0
....................                )
....................             {
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs);
....................                TCPDisconnect(currSocket);
6C04:  MOVFF  301,308
6C08:  GOTO   5EA8
....................                http_state[hs]=HTTP_CLOSED;
6C0C:  BCF    FD8.0
6C0E:  MOVLB  3
6C10:  RLCF   x00,W
6C12:  CLRF   03
6C14:  ADDLW  6E
6C16:  MOVWF  FE9
6C18:  MOVLW  00
6C1A:  ADDWFC 03,W
6C1C:  MOVWF  FEA
6C1E:  MOVLW  01
6C20:  MOVWF  FEC
6C22:  MOVF   FED,F
6C24:  MOVLW  0A
6C26:  MOVWF  FEF
....................             }
....................             break;
6C28:  MOVLB  0
6C2A:  BRA    6C30
6C2C:  MOVLB  3
.................... 
....................          case HTTP_CLOSED: //do nothing until socket actually closes
....................          default:
....................             break;
6C2E:  MOVLB  0
....................       }
6C30:  MOVLB  3
6C32:  INCF   x00,F
6C34:  GOTO   5FB8
....................    }
6C38:  MOVLB  0
6C3A:  GOTO   6DD8 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP2
....................    #include "tcpip/http2.c"
.................... #endif
.................... 
.................... #if STACK_USE_MPFS
....................    #include "tcpip/mpfs.c"
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    #include "tcpip/smtp.c"
.................... #endif
.................... 
.................... #if STACK_USE_DNS
....................    #include "tcpip/dns.c"
.................... #endif
.................... 
.................... #if STACK_USE_ANNOUNCE
....................    #include "tcpip/announce.h"
....................    #include "tcpip/announce.c"
.................... #endif
.................... 
.................... #if STACK_USE_SNMP
....................    #include "tcpip/snmp.c"
.................... #endif
.................... 
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h
.................... 
.................... /*
....................  * Stack FSM states.
....................  */
.................... typedef enum _SM_STACK
.................... {
....................     SM_STACK_IDLE=0,
....................     SM_STACK_MAC,
....................     SM_STACK_IP,
....................     SM_STACK_ICMP,
....................     SM_STACK_ICMP_REPLY,
....................     SM_STACK_ARP,
....................     SM_STACK_TCP,
....................     SM_STACK_UDP
.................... } SM_STACK;
.................... 
.................... static SM_STACK smStack;
.................... 
.................... NODE_INFO remoteNode;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componets are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines are used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void)
.................... {
....................     smStack                     = SM_STACK_IDLE;
*
10EE:  CLRF   xCA
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     /*
....................      * If DHCP or IP Gleaning is enabled,
....................      * startup in Config Mode.
....................      */
....................     AppConfig.Flags.bInConfigMode = TRUE;
.................... #endif
.................... 
....................    TickInit();
10F0:  GOTO   083C
.................... 
.................... #if STACK_USE_MAC
....................     MACInit();
10F4:  BRA    0B4A
.................... #endif
.................... 
.................... #if STACK_USE_ARP
....................     ARPInit();
10F6:  BRA    0D18
.................... #endif
.................... 
.................... #if STACK_USE_UDP
....................     UDPInit();
.................... #endif
.................... 
.................... #if STACK_USE_TCP
....................     TCPInit();
10F8:  BRA    0E5C
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    DHCPReset();
.................... #endif
.................... 
.................... #if STACK_USE_PPP
....................    ppp_init();
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    TelnetInit();
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    SMTPInit();
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    HTTP_Init();
10FA:  BRA    1084
.................... #endif
10FC:  GOTO   6F70 (RETURN)
.................... }
.................... 
.................... /*
.................... #if STACK_USE_MCPENC
.................... #if MAC_TX_BUFFER_COUNT > 1
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val)
.................... #else
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val)
.................... #endif
.................... #else
....................  #define DebugDisplayVals()
.................... #endif
.................... */
.................... 
.................... #define DebugDisplayVals()
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically to
....................  *                  ensure timely responses.
....................  *
....................  ********************************************************************/
.................... void StackTask(void)
*
6C3E:  MOVLB  2
6C40:  BCF    xF9.0
.................... {
....................     static WORD dataCount;
.................... 
.................... #if STACK_USE_ICMP
....................     static BYTE data[MAX_ICMP_DATA_LEN];
....................     static WORD ICMPId;
....................     static WORD ICMPSeq;
.................... #endif
....................     IP_ADDR tempLocalIP;
.................... 
.................... 
....................     union
....................     {
....................         BYTE MACFrameType;
....................         BYTE IPFrameType;
.................... #if STACK_USE_ICMP
....................         ICMP_CODE ICMPCode;
.................... #endif
....................     } type;
.................... 
.................... 
....................     BOOL lbContinue=FALSE;
.................... 
....................     do
....................     {
....................         lbContinue = FALSE;
6C42:  BCF    xF9.0
....................         switch(smStack)
6C44:  MOVLB  0
6C46:  MOVF   xCA,W
6C48:  ADDLW  F9
6C4A:  BTFSC  FD8.0
6C4C:  BRA    6DC8
6C4E:  ADDLW  07
6C50:  GOTO   6DDC
....................         {
....................         case SM_STACK_IDLE:
....................         case SM_STACK_MAC:
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) )
6C54:  MOVLB  2
6C56:  CLRF   xFB
6C58:  MOVLW  CB
6C5A:  MOVWF  xFA
6C5C:  MOVLW  02
6C5E:  MOVWF  xFD
6C60:  MOVLW  F8
6C62:  MOVWF  xFC
6C64:  MOVLB  0
6C66:  GOTO   11E2
6C6A:  MOVF   01,F
6C6C:  BNZ   6C70
....................             {
....................                 #if STACK_USE_DHCP
....................                     // Normally, an application would not include  DHCP module
....................                     // if it is not enabled. But in case some one wants to disable
....................                     // DHCP module at run-time, remember to not clear our IP
....................                     // address if link is removed.
....................                     if ( !DHCPIsDisabled() )
....................                     {
....................                         if ( !MACIsLinked() )
....................                         {
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul;
....................                             AppConfig.Flags.bInConfigMode = TRUE;
....................                             DHCPReset();
....................                         }
....................                     }
....................                 #endif
....................                 break;
6C6E:  BRA    6DC8
....................             }
.................... 
.................... //            debug_stack("\r\nMAC GET ");
.................... 
....................             lbContinue = TRUE;
6C70:  MOVLB  2
6C72:  BSF    xF9.0
....................             if ( type.MACFrameType == MAC_IP ) {
6C74:  MOVF   xF8,F
6C76:  BNZ   6C82
....................                 smStack = SM_STACK_IP;
6C78:  MOVLW  02
6C7A:  MOVLB  0
6C7C:  MOVWF  xCA
.................... //                debug_stack("IP ");
....................             }
6C7E:  BRA    6C98
6C80:  MOVLB  2
....................             else if ( type.MACFrameType == MAC_ARP ) {
6C82:  MOVF   xF8,W
6C84:  SUBLW  06
6C86:  BNZ   6C92
....................                 smStack = SM_STACK_ARP;
6C88:  MOVLW  05
6C8A:  MOVLB  0
6C8C:  MOVWF  xCA
.................... //                debug_stack("ARP ");
....................             }
6C8E:  BRA    6C98
6C90:  MOVLB  2
....................             else {
....................                 MACDiscardRx();
6C92:  MOVLB  0
6C94:  CALL   1100
.................... //                debug_stack("DISCARD");
....................             }
....................             break;
6C98:  BRA    6DC8
.................... 
....................         case SM_STACK_ARP:
.................... #if STACK_USE_ARP
....................             if ( ARPProcess() ) {
6C9A:  GOTO   1A6C
6C9E:  MOVF   01,F
6CA0:  BZ    6CA4
....................                 smStack = SM_STACK_IDLE;
6CA2:  CLRF   xCA
....................             }
.................... #else
....................             smStack = SM_STACK_IDLE;
.................... #endif
....................             break;
6CA4:  BRA    6DC8
.................... 
....................         case SM_STACK_IP:
....................             if ( IPGetHeader(&tempLocalIP,
....................                              &remoteNode,
....................                              &type.IPFrameType,
....................                              &dataCount) )
6CA6:  MOVLW  02
6CA8:  MOVLB  2
6CAA:  MOVWF  xFB
6CAC:  MOVLW  F4
6CAE:  MOVWF  xFA
6CB0:  CLRF   xFD
6CB2:  MOVLW  CB
6CB4:  MOVWF  xFC
6CB6:  MOVLW  02
6CB8:  MOVWF  xFF
6CBA:  MOVLW  F8
6CBC:  MOVWF  xFE
6CBE:  MOVLB  3
6CC0:  CLRF   x01
6CC2:  MOVLW  D5
6CC4:  MOVWF  x00
6CC6:  MOVLB  0
6CC8:  GOTO   1D46
6CCC:  MOVF   01,F
6CCE:  BZ    6CFE
....................             {
....................                 lbContinue = TRUE;
6CD0:  MOVLB  2
6CD2:  BSF    xF9.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP )
6CD4:  DECFSZ xF8,W
6CD6:  BRA    6CE2
....................                 {
....................                     smStack = SM_STACK_ICMP;
6CD8:  MOVLW  03
6CDA:  MOVLB  0
6CDC:  MOVWF  xCA
.................... //                    debug_stack("ICMP ");
.................... #if STACK_USE_IP_GLEANING
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled())
....................                     {
....................                         /*
....................                          * Accoriding to "IP Gleaning" procedure,
....................                          * when we receive an ICMP packet with a valid
....................                          * IP address while we are still in configuration
....................                          * mode, accept that address as ours and conclude
....................                          * configuration mode.
....................                          */
....................                         if( tempLocalIP.Val != 0xffffffff )
....................                         {
....................                             AppConfig.Flags.bInConfigMode = FALSE;
....................                             AppConfig.MyIPAddr = tempLocalIP;
....................                             myDHCPBindCount--;
....................                         }
....................                     }
.................... #endif
....................                 }
.................... 
.................... #if STACK_USE_TCP
6CDE:  BRA    6CFC
6CE0:  MOVLB  2
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) {
6CE2:  MOVF   xF8,W
6CE4:  SUBLW  06
6CE6:  BNZ   6CF2
....................                     smStack = SM_STACK_TCP;
6CE8:  MOVLW  06
6CEA:  MOVLB  0
6CEC:  MOVWF  xCA
....................                     debug_stack("TCP ");
....................                 }
.................... #endif
.................... 
.................... #if STACK_USE_UDP
6CEE:  BRA    6CFC
6CF0:  MOVLB  2
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) {
....................                     smStack = SM_STACK_UDP;
.................... //                    debug_stack("UDP ");
....................                 }
.................... #endif
.................... 
....................                 else
....................                 {
....................                     lbContinue = FALSE;
6CF2:  BCF    xF9.0
....................                     MACDiscardRx();
6CF4:  MOVLB  0
6CF6:  CALL   1100
.................... 
....................                     smStack = SM_STACK_IDLE;
6CFA:  CLRF   xCA
.................... //                    debug_stack("UNKOWN-IP1 ");
....................                 }
....................             }
6CFC:  BRA    6D04
....................             else
....................             {
....................                 MACDiscardRx();
6CFE:  CALL   1100
....................                 smStack = SM_STACK_IDLE;
6D02:  CLRF   xCA
.................... //                debug_stack("UNKOWN-IP2 ");
....................             }
....................             break;
6D04:  BRA    6DC8
.................... 
.................... #if STACK_USE_UDP
....................         case SM_STACK_UDP:
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) )
....................             {
.................... //                debug_stack("\r\nUDP PROCESSED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
....................             }
....................             break;
.................... #endif
.................... 
.................... #if STACK_USE_TCP
....................         case SM_STACK_TCP:
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) )
6D06:  MOVLB  2
6D08:  CLRF   xFB
6D0A:  MOVLW  CB
6D0C:  MOVWF  xFA
6D0E:  MOVLW  02
6D10:  MOVWF  xFD
6D12:  MOVLW  F4
6D14:  MOVWF  xFC
6D16:  MOVFF  D6,2FF
6D1A:  MOVFF  D5,2FE
6D1E:  MOVLB  0
6D20:  GOTO   34EC
6D24:  MOVF   01,F
6D26:  BZ    6D2A
....................             {
....................                 debug_stack("\r\nTCP PROCESSED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
6D28:  CLRF   xCA
....................             }
....................             break;
6D2A:  BRA    6DC8
.................... #endif
.................... 
....................         case SM_STACK_ICMP:
....................             smStack = SM_STACK_IDLE;
6D2C:  CLRF   xCA
.................... 
.................... #if STACK_USE_ICMP
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) )
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) )
6D2E:  MOVF   xD6,F
6D30:  BNZ   6D80
6D32:  MOVF   xD5,W
6D34:  SUBLW  48
6D36:  BNC   6D80
....................             {
....................                 if ( ICMPGet(&type.ICMPCode,
....................                              data,
....................                              (BYTE*)&dataCount,
....................                              &ICMPId,
....................                              &ICMPSeq) )
6D38:  MOVLB  2
6D3A:  CLRF   xFB
6D3C:  MOVLW  D5
6D3E:  MOVWF  xFA
6D40:  MOVLW  02
6D42:  MOVWF  xFD
6D44:  MOVLW  F8
6D46:  MOVWF  xFC
6D48:  MOVLW  02
6D4A:  MOVWF  xFF
6D4C:  MOVLW  B2
6D4E:  MOVWF  xFE
6D50:  MOVFF  2FB,301
6D54:  MOVFF  2FA,300
6D58:  MOVLB  3
6D5A:  CLRF   x03
6D5C:  MOVLW  D7
6D5E:  MOVWF  x02
6D60:  CLRF   x05
6D62:  MOVLW  D9
6D64:  MOVWF  x04
6D66:  MOVLB  0
6D68:  GOTO   3750
6D6C:  MOVF   01,F
6D6E:  BZ    6D80
....................                 {
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST )
6D70:  MOVLB  2
6D72:  MOVF   xF8,W
6D74:  SUBLW  08
6D76:  BNZ   6D82
....................                     {
.................... //                        debug_stack("\r\nICMP PROCESSED");
....................                         lbContinue = TRUE;
6D78:  BSF    xF9.0
....................                         smStack = SM_STACK_ICMP_REPLY;
6D7A:  MOVLW  04
6D7C:  MOVLB  0
6D7E:  MOVWF  xCA
6D80:  MOVLB  2
....................                     }
....................                 }
....................             }
....................             DebugDisplayVals();
.................... #endif
....................             MACDiscardRx();
6D82:  MOVLB  0
6D84:  CALL   1100
....................             break;
6D88:  BRA    6DC8
.................... 
.................... #if STACK_USE_ICMP
....................         case SM_STACK_ICMP_REPLY:
....................             if ( ICMPIsTxReady() )
6D8A:  MOVLW  01
6D8C:  MOVLB  3
6D8E:  MOVWF  x89
6D90:  MOVLB  0
6D92:  CALL   2598
6D96:  MOVF   01,F
6D98:  BZ    6DC8
....................             {
....................                 ICMPPut(&remoteNode,
....................                         ICMP_ECHO_REPLY,
....................                         data,
....................                         (BYTE)dataCount,
....................                         ICMPId,
....................                         ICMPSeq);
6D9A:  MOVLB  2
6D9C:  CLRF   xFB
6D9E:  MOVLW  CB
6DA0:  MOVWF  xFA
6DA2:  CLRF   xFC
6DA4:  MOVLW  02
6DA6:  MOVWF  xFE
6DA8:  MOVLW  B2
6DAA:  MOVWF  xFD
6DAC:  MOVFF  D5,2FF
6DB0:  MOVFF  D8,301
6DB4:  MOVFF  D7,300
6DB8:  MOVFF  DA,303
6DBC:  MOVFF  D9,302
6DC0:  MOVLB  0
6DC2:  GOTO   381C
.................... 
.................... //                debug_stack("\r\nICMP REPLIED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
6DC6:  CLRF   xCA
....................             }
....................             break;
.................... #endif
.................... 
....................         }
.................... 
....................     } while( lbContinue );
6DC8:  MOVLB  2
6DCA:  BTFSC  xF9.0
6DCC:  BRA    6C42
.................... 
.................... #if STACK_USE_SMTP
....................    SMTPTask();
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_TCP
....................     // Perform timed TCP FSM.
....................     TCPTick();
6DCE:  MOVLB  0
6DD0:  GOTO   3936
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    TelnetTask();
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    HTTP_Task();
6DD4:  GOTO   5FB4
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
6DD8:  GOTO   6F72 (RETURN)
....................     /*
....................      * DHCP must be called all the time even after IP configuration is
....................      * discovered.
....................      * DHCP has to account lease expiration time and renew the configuration
....................      * time.
....................      */
....................     DHCPTask();
.................... 
....................     if ( DHCPIsBound() )
....................         AppConfig.Flags.bInConfigMode = FALSE;
.................... 
.................... #endif
.................... 
.................... 
.................... }
.................... 
.................... /******************************************************************************/
.................... 
.................... /*********************  PAGINA WEB A MOSTRAR **********************************/
.................... /* Página principal INDEX (/) */
.................... const char  HTML_INDEX_PAGE[]="
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000>
.................... 
.................... <center><H1>BeepControl </H1></center>
.................... <BR><center><H2>Dashboard</H2></CENTER>
.................... 
.................... 
.................... <FORM METHOD=GET>
.................... <P>LCD: <INPUT TYPE=\"text\" NAME=\"lcd\" size=20 maxlength=16>
.................... <input type=\"submit\" value=\"Enviar texto\">
.................... </FORM>
.................... 
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM1\" value=\"A\">
.................... <input type=\"submit\" name=\"CM1\" value=\"C\">
.................... <input type=\"submit\" name=\"CM1\" value=\"Z\">
.................... </FORM>
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM2\" value=\"A\">
.................... <input type=\"submit\" name=\"CM2\" value=\"C\">
.................... <input type=\"submit\" name=\"CM2\" value=\"Z\">
.................... </FORM>
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM3\" value=\"A\">
.................... <input type=\"submit\" name=\"CM3\" value=\"C\">
.................... <input type=\"submit\" name=\"CM3\" value=\"Z\">
.................... </FORM>
.................... </BODY></HTML>
.................... ";
.................... 
.................... /* Elección de MAC. No puede haber 2 dispositivos con misma MAC en una misma red
....................    Microchip Vendor ID  MAC: 00.04.A3.xx.xx.xx.  */
.................... void MACAddrInit(void) {
....................    MY_MAC_BYTE1=0;
*
07F8:  CLRF   21
....................    MY_MAC_BYTE2=0x04;
07FA:  MOVLW  04
07FC:  MOVWF  22
....................    MY_MAC_BYTE3=0xA3;
07FE:  MOVLW  A3
0800:  MOVWF  23
....................    MY_MAC_BYTE4=0x06;
0802:  MOVLW  06
0804:  MOVWF  24
....................    MY_MAC_BYTE5=0x07;
0806:  MOVLW  07
0808:  MOVWF  25
....................    MY_MAC_BYTE6=0x08;
080A:  MOVLW  08
080C:  MOVWF  26
080E:  GOTO   6F68 (RETURN)
.................... }
.................... 
.................... void IPAddrInit(void) {
....................    //Elección de la dirección IP. 
....................    MY_IP_BYTE1=192;
0812:  MOVLW  C0
0814:  MOVWF  1D
....................    MY_IP_BYTE2=168;
0816:  MOVLW  A8
0818:  MOVWF  1E
....................    MY_IP_BYTE3=1;
081A:  MOVLW  01
081C:  MOVWF  1F
....................    MY_IP_BYTE4=15;
081E:  MOVLW  0F
0820:  MOVWF  20
.................... 
....................    //Elección de la dirección de puerta de enlace. 
....................    MY_GATE_BYTE1=192;
0822:  MOVLW  C0
0824:  MOVWF  2B
....................    MY_GATE_BYTE2=168;
0826:  MOVLW  A8
0828:  MOVWF  2C
....................    MY_GATE_BYTE3=1;
082A:  MOVLW  01
082C:  MOVWF  2D
....................    MY_GATE_BYTE4=1;
082E:  MOVWF  2E
.................... 
....................    //Elección de la máscara de red.Si no se indica nada se tomará 255.255.255.0
....................    MY_MASK_BYTE1=255;
0830:  SETF   27
....................    MY_MASK_BYTE2=255;
0832:  SETF   28
....................    MY_MASK_BYTE3=255;
0834:  SETF   29
....................    MY_MASK_BYTE4=0;
0836:  CLRF   2A
0838:  GOTO   6F6C (RETURN)
.................... }
.................... 
.................... void moveServo(int16 puerto,int16 tiempo){
.................... unsigned int i;
....................    for(i=0;i<60;i++){ 
*
49B0:  MOVLB  3
49B2:  CLRF   x30
49B4:  MOVF   x30,W
49B6:  SUBLW  3B
49B8:  BNC   4A46
....................       output_toggle(puerto);
49BA:  MOVFF  32C,331
49BE:  MOVLW  0F
49C0:  MOVWF  x33
49C2:  MOVLW  80
49C4:  MOVWF  x32
49C6:  MOVLB  0
49C8:  BRA    4958
49CA:  MOVLW  00
49CC:  BTFSS  01.0
49CE:  MOVLW  01
49D0:  MOVFF  32C,331
49D4:  MOVLB  3
49D6:  MOVWF  x32
49D8:  MOVLW  0F
49DA:  MOVWF  x34
49DC:  MOVLW  89
49DE:  MOVWF  x33
49E0:  MOVLB  0
49E2:  RCALL  4916
49E4:  MOVFF  32C,331
49E8:  MOVLB  3
49EA:  CLRF   x32
49EC:  MOVLW  0F
49EE:  MOVWF  x34
49F0:  MOVLW  92
49F2:  MOVWF  x33
49F4:  MOVLB  0
49F6:  RCALL  4916
....................       delay_us(tiempo);
49F8:  MOVFF  32F,331
49FC:  MOVLB  3
49FE:  INCF   x31,F
4A00:  DECF   x31,F
4A02:  BTFSC  FD8.2
4A04:  BRA    4A10
4A06:  SETF   x32
4A08:  MOVLB  0
4A0A:  RCALL  4990
4A0C:  MOVLB  3
4A0E:  BRA    4A00
4A10:  MOVFF  32E,332
4A14:  MOVLB  0
4A16:  RCALL  4990
....................       output_low(puerto);
4A18:  MOVFF  32C,331
4A1C:  MOVLB  3
4A1E:  CLRF   x32
4A20:  MOVLW  0F
4A22:  MOVWF  x34
4A24:  MOVLW  89
4A26:  MOVWF  x33
4A28:  MOVLB  0
4A2A:  RCALL  4916
4A2C:  MOVFF  32C,331
4A30:  MOVLB  3
4A32:  CLRF   x32
4A34:  MOVLW  0F
4A36:  MOVWF  x34
4A38:  MOVLW  92
4A3A:  MOVWF  x33
4A3C:  MOVLB  0
4A3E:  RCALL  4916
4A40:  MOVLB  3
4A42:  INCF   x30,F
4A44:  BRA    49B4
....................     }}
4A46:  MOVLB  0
4A48:  RETURN 0
.................... 
.................... 
.................... void servoAccion(int servo, int accion)   //180 Degree
4A4A:  MOVLW  7C
4A4C:  MOVLB  3
4A4E:  MOVWF  x27
4A50:  MOVLW  10
4A52:  MOVWF  x26
4A54:  MOVLW  01
4A56:  MOVWF  x29
4A58:  MOVLW  64
4A5A:  MOVWF  x28
4A5C:  MOVLW  08
4A5E:  MOVWF  x2B
4A60:  MOVLW  66
4A62:  MOVWF  x2A
.................... {
.................... int16 puerto = PIN_C0;
.................... int16 tiempoCerrar = 356;
.................... int16 tiempoAbrir = 2150;
.................... 
.................... switch(servo){
4A64:  MOVF   x24,W
4A66:  XORLW  01
4A68:  MOVLB  0
4A6A:  BZ    4A76
4A6C:  XORLW  03
4A6E:  BZ    4A84
4A70:  XORLW  01
4A72:  BZ    4A92
4A74:  BRA    4A9E
....................    case 1:
....................       puerto = PIN_C0; break;
4A76:  MOVLW  7C
4A78:  MOVLB  3
4A7A:  MOVWF  x27
4A7C:  MOVLW  10
4A7E:  MOVWF  x26
4A80:  MOVLB  0
4A82:  BRA    4A9E
....................    case 2:
....................       puerto = PIN_C1; break;
4A84:  MOVLW  7C
4A86:  MOVLB  3
4A88:  MOVWF  x27
4A8A:  MOVLW  11
4A8C:  MOVWF  x26
4A8E:  MOVLB  0
4A90:  BRA    4A9E
....................    case 3:
....................       puerto = PIN_C2; break;
4A92:  MOVLW  7C
4A94:  MOVLB  3
4A96:  MOVWF  x27
4A98:  MOVLW  12
4A9A:  MOVWF  x26
4A9C:  MOVLB  0
.................... }
.................... 
.................... output_low(puerto); //Me aseguro que este apagado
4A9E:  MOVFF  326,331
4AA2:  MOVLB  3
4AA4:  CLRF   x32
4AA6:  MOVLW  0F
4AA8:  MOVWF  x34
4AAA:  MOVLW  89
4AAC:  MOVWF  x33
4AAE:  MOVLB  0
4AB0:  RCALL  4916
4AB2:  MOVFF  326,331
4AB6:  MOVLB  3
4AB8:  CLRF   x32
4ABA:  MOVLW  0F
4ABC:  MOVWF  x34
4ABE:  MOVLW  92
4AC0:  MOVWF  x33
4AC2:  MOVLB  0
4AC4:  RCALL  4916
.................... 
.................... switch(accion){
4AC6:  MOVLB  3
4AC8:  MOVF   x25,W
4ACA:  XORLW  00
4ACC:  MOVLB  0
4ACE:  BZ    4ADA
4AD0:  XORLW  01
4AD2:  BZ    4AEE
4AD4:  XORLW  03
4AD6:  BZ    4B02
4AD8:  BRA    4B50
....................    case 0: //Cerrar
....................       moveServo(puerto,tiempoCerrar);
4ADA:  MOVFF  327,32D
4ADE:  MOVFF  326,32C
4AE2:  MOVFF  329,32F
4AE6:  MOVFF  328,32E
4AEA:  RCALL  49B0
....................       break;
4AEC:  BRA    4B50
....................    case 1: //Abrir 180 grados
....................       moveServo(puerto,tiempoAbrir);
4AEE:  MOVFF  327,32D
4AF2:  MOVFF  326,32C
4AF6:  MOVFF  32B,32F
4AFA:  MOVFF  32A,32E
4AFE:  RCALL  49B0
....................       break;
4B00:  BRA    4B50
....................    case 2: //Abre y cierra
....................       moveServo(puerto,tiempoCerrar); //Me aseguro que se cierre
4B02:  MOVFF  327,32D
4B06:  MOVFF  326,32C
4B0A:  MOVFF  329,32F
4B0E:  MOVFF  328,32E
4B12:  RCALL  49B0
....................       moveServo(puerto,tiempoAbrir); //Lo abro
4B14:  MOVFF  327,32D
4B18:  MOVFF  326,32C
4B1C:  MOVFF  32B,32F
4B20:  MOVFF  32A,32E
4B24:  RCALL  49B0
....................       delay_ms(1000); //Espero un segundo en maquina virtual, en no virtual es 3000 ms
4B26:  MOVLW  04
4B28:  MOVLB  3
4B2A:  MOVWF  x2C
4B2C:  MOVLW  FA
4B2E:  MOVWF  x2D
4B30:  MOVLB  0
4B32:  CALL   04FA
4B36:  MOVLB  3
4B38:  DECFSZ x2C,F
4B3A:  BRA    4B2C
....................       moveServo(puerto,tiempoCerrar); //Lo cierro
4B3C:  MOVFF  327,32D
4B40:  MOVFF  326,32C
4B44:  MOVFF  329,32F
4B48:  MOVFF  328,32E
4B4C:  MOVLB  0
4B4E:  RCALL  49B0
....................       break;
....................       }
4B50:  RETURN 0
.................... }
.................... 
.................... 
.................... /***************************  FUNCIÓN GET PAGE   ******************************/
.................... /* Esta función devuelve la posición de memoria donde se encuentra la página web 
.................... a mostrar. En este caso se trata de una web con 2 páginas. Una principal index(/) 
.................... y una secundaria(/lecturas)                                                   */
.................... 
.................... int32 http_get_page(char *file_str) {
*
4884:  MOVLB  3
4886:  CLRF   x0F
4888:  CLRF   x0E
488A:  CLRF   x0D
488C:  CLRF   x0C
....................    int32 file_loc=0;
....................    static char index[]="/";
....................  
....................    
....................    //printf(lcd_putc,"\fRequest %s ",file_str);      //Muestra en lcd solicitud
.................... 
....................    /* Busca la posición de memoria donde se encuentra la página solicitada */
....................    if (stricmp(file_str,index)==0)                 //Si es la principal...
488E:  MOVFF  30B,325
4892:  MOVFF  30A,324
4896:  CLRF   x27
4898:  MOVLW  DB
489A:  MOVWF  x26
489C:  MOVLB  0
489E:  RCALL  4790
48A0:  MOVLB  3
48A2:  CLRF   x11
48A4:  MOVFF  01,310
48A8:  BTFSC  01.7
48AA:  DECF   x11,F
48AC:  MOVF   x10,F
48AE:  BNZ   48C4
48B0:  MOVF   x11,F
48B2:  BNZ   48C4
....................       file_loc=label_address(HTML_INDEX_PAGE);     //...toma su posición en la memoria
48B4:  MOVLW  01
48B6:  MOVWF  03
48B8:  MOVLW  A4
48BA:  MOVWF  x0C
48BC:  MOVFF  03,30D
48C0:  CLRF   x0E
48C2:  CLRF   x0F
.................... 
....................    return(file_loc);
48C4:  MOVFF  30C,00
48C8:  MOVFF  30D,01
48CC:  MOVFF  30E,02
48D0:  MOVFF  30F,03
48D4:  MOVLB  0
48D6:  GOTO   6386 (RETURN)
.................... }
.................... 
.................... /**************************  FUNCIÓN FORMAT CHAR  *****************************/
.................... /* Con  la función http_format_char  interconectamos las variables virtuales de 
.................... la página web con las variables del programa del PIC. Se encarga de enviar los 
.................... cambios producidos en la aplicación del PIC y reflejarlos en la aplicación web. 
.................... Muestra,por tanto, las lectura obtenidas por el PIC y las representa en la 
.................... aplicación de la página web      
.................... 
.................... %0 es la variable virtual para representar el valor de la lectura del canal 
.................... analógico
.................... %1 es la variable virtual para representar el valor de la lectura del bit 0 del 
.................... puerto E.
.................... */
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret) {
*
5A50:  MOVLB  3
5A52:  CLRF   x34
....................    char new_str[20];
....................    int8 len=0;
....................    int8 AD0;
....................    int8 RE0;
.................... 
....................    *str=0;
5A54:  MOVFF  31E,FEA
5A58:  MOVFF  31D,FE9
5A5C:  CLRF   FEF
.................... 
....................    switch(id) {
5A5E:  MOVF   x1C,W
5A60:  XORLW  30
5A62:  MOVLB  0
5A64:  BZ    5A6C
5A66:  XORLW  01
5A68:  BZ    5ACC
5A6A:  BRA    5B02
....................       case '0':
....................          set_adc_channel(0);
5A6C:  MOVLW  00
5A6E:  MOVWF  01
5A70:  MOVF   FC2,W
5A72:  ANDLW  C3
5A74:  IORWF  01,W
5A76:  MOVWF  FC2
....................          delay_us(100);
5A78:  MOVLW  A6
5A7A:  MOVWF  00
5A7C:  DECFSZ 00,F
5A7E:  BRA    5A7C
5A80:  NOP   
....................          AD0=read_adc();
5A82:  BSF    FC2.1
5A84:  BTFSC  FC2.1
5A86:  BRA    5A84
5A88:  MOVFF  FC4,335
....................          sprintf(new_str,"0x%X",AD0);
5A8C:  MOVLW  03
5A8E:  MOVWF  x79
5A90:  MOVLW  20
5A92:  MOVWF  x78
5A94:  MOVLW  30
5A96:  MOVLB  3
5A98:  MOVWF  x3D
5A9A:  MOVLB  0
5A9C:  RCALL  58A0
5A9E:  MOVLW  78
5AA0:  MOVLB  3
5AA2:  MOVWF  x3D
5AA4:  MOVLB  0
5AA6:  RCALL  58A0
5AA8:  MOVFF  335,337
5AAC:  MOVLW  37
5AAE:  MOVLB  3
5AB0:  MOVWF  x38
5AB2:  MOVLB  0
5AB4:  BRA    58BE
....................          len=strlen(new_str);
5AB6:  MOVLW  03
5AB8:  MOVLB  3
5ABA:  MOVWF  x38
5ABC:  MOVLW  20
5ABE:  MOVWF  x37
5AC0:  MOVLB  0
5AC2:  CALL   4042
5AC6:  MOVFF  01,334
....................       break;
5ACA:  BRA    5B08
....................       case '1':
....................          RE0=bit_test(porte,0);
5ACC:  MOVLB  3
5ACE:  CLRF   x36
5AD0:  BTFSC  F84.0
5AD2:  INCF   x36,F
....................          sprintf(new_str,"%d",RE0);
5AD4:  MOVLW  03
5AD6:  MOVLB  0
5AD8:  MOVWF  x79
5ADA:  MOVLW  20
5ADC:  MOVWF  x78
5ADE:  MOVFF  336,337
5AE2:  MOVLW  18
5AE4:  MOVLB  3
5AE6:  MOVWF  x38
5AE8:  MOVLB  0
5AEA:  BRA    5906
....................          len=strlen(new_str);
5AEC:  MOVLW  03
5AEE:  MOVLB  3
5AF0:  MOVWF  x38
5AF2:  MOVLW  20
5AF4:  MOVWF  x37
5AF6:  MOVLB  0
5AF8:  CALL   4042
5AFC:  MOVFF  01,334
....................       break;  
5B00:  BRA    5B08
....................       default:
....................       len=0;
5B02:  MOVLB  3
5B04:  CLRF   x34
5B06:  MOVLB  0
....................    }
.................... 
....................    if (len)strncpy(str, new_str, max_ret);
5B08:  MOVLB  3
5B0A:  MOVF   x34,F
5B0C:  BZ    5B2E
5B0E:  MOVFF  31E,338
5B12:  MOVFF  31D,337
5B16:  MOVLW  03
5B18:  MOVWF  x3A
5B1A:  MOVLW  20
5B1C:  MOVWF  x39
5B1E:  CLRF   x3C
5B20:  MOVFF  31F,33B
5B24:  MOVLB  0
5B26:  BRA    59C8
5B28:  MOVLB  0
5B2A:  BRA    5B3A
5B2C:  MOVLB  3
....................    else  *str=0;
5B2E:  MOVFF  31E,FEA
5B32:  MOVFF  31D,FE9
5B36:  CLRF   FEF
5B38:  MOVLB  0
....................    
....................    return(len);
5B3A:  MOVLB  3
5B3C:  MOVF   x34,W
5B3E:  MOVWF  01
5B40:  MOVLB  0
5B42:  GOTO   5DF8 (RETURN)
.................... }
.................... 
.................... /***************************  FUNCIÓN EXEC CGI   ******************************/
.................... /* Con la función http_exec_cgi interconectamos las variables virtuales de la 
.................... página web con las variables del programa del PIC. Se encarga de recibir 
.................... los cambios producidos en la aplicación web y reflejarlos en el hardware del PIC. 
.................... Ejecuta, por tanto, la acción elegida según el valor de la variable virtual recibida 
.................... de la página web
.................... 
.................... key es la variable virtual que viene de la pagina web
.................... val es el valor de una variable virtual de la página web
.................... file es la dirección de la página web devuelta por http__page ()
.................... 
.................... */
.................... 
.................... void http_exec_cgi(int32 file, char *key, char *val) {
*
4B7A:  MOVLB  3
4B7C:  CLRF   x23
....................    static char boton1_key[]="CM1";
....................    static char boton2_key[]="CM2";
....................    static char boton3_key[]="CM3";
....................    static char lcd_key[]="lcd";
....................    int accionServo = 0;
....................    
....................    //Para ver en la pantalla los valores recibidos
....................   /*
....................    printf(lcd_putc,"\nKEY=%S", key);
....................    printf(lcd_putc,"\nVAL=%S", val);
....................   */
....................    
....................    switch (val){
4B7E:  MOVLW  A0
4B80:  MOVWF  FF6
4B82:  MOVLW  04
4B84:  MOVWF  FF7
4B86:  MOVFF  322,FEA
4B8A:  MOVFF  321,FE9
4B8E:  BRA    48DA
4B90:  MOVF   01,W
4B92:  BZ    4B9E
4B94:  XORLW  01
4B96:  BZ    4BA6
4B98:  XORLW  03
4B9A:  BZ    4BB0
4B9C:  BRA    4BB8
....................    case "C": accionServo = 0; break;
4B9E:  MOVLB  3
4BA0:  CLRF   x23
4BA2:  MOVLB  0
4BA4:  BRA    4BB8
....................    case "A": accionServo = 1; break;
4BA6:  MOVLW  01
4BA8:  MOVLB  3
4BAA:  MOVWF  x23
4BAC:  MOVLB  0
4BAE:  BRA    4BB8
....................    case "Z": accionServo = 2; break;
4BB0:  MOVLW  02
4BB2:  MOVLB  3
4BB4:  MOVWF  x23
4BB6:  MOVLB  0
....................    }
.................... 
.................... 
....................    /* Se ejecutará al recibir un request a CM1 */
....................    if (stricmp(key,boton1_key)==0) {
4BB8:  MOVFF  320,325
4BBC:  MOVFF  31F,324
4BC0:  MOVLB  3
4BC2:  CLRF   x27
4BC4:  MOVLW  DD
4BC6:  MOVWF  x26
4BC8:  MOVLB  0
4BCA:  RCALL  4790
4BCC:  MOVLB  3
4BCE:  CLRF   x25
4BD0:  MOVFF  01,324
4BD4:  BTFSC  01.7
4BD6:  DECF   x25,F
4BD8:  MOVF   x24,F
4BDA:  BNZ   4BEE
4BDC:  MOVF   x25,F
4BDE:  BNZ   4BEE
....................       servoAccion(1,accionServo);
4BE0:  MOVLW  01
4BE2:  MOVWF  x24
4BE4:  MOVFF  323,325
4BE8:  MOVLB  0
4BEA:  RCALL  4A4A
4BEC:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a CM2 */
....................    if (stricmp(key,boton2_key)==0) {
4BEE:  MOVFF  320,325
4BF2:  MOVFF  31F,324
4BF6:  CLRF   x27
4BF8:  MOVLW  E1
4BFA:  MOVWF  x26
4BFC:  MOVLB  0
4BFE:  RCALL  4790
4C00:  MOVLB  3
4C02:  CLRF   x25
4C04:  MOVFF  01,324
4C08:  BTFSC  01.7
4C0A:  DECF   x25,F
4C0C:  MOVF   x24,F
4C0E:  BNZ   4C22
4C10:  MOVF   x25,F
4C12:  BNZ   4C22
....................       servoAccion(2,accionServo);
4C14:  MOVLW  02
4C16:  MOVWF  x24
4C18:  MOVFF  323,325
4C1C:  MOVLB  0
4C1E:  RCALL  4A4A
4C20:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a CM3 */
....................    if (stricmp(key,boton3_key)==0) {
4C22:  MOVFF  320,325
4C26:  MOVFF  31F,324
4C2A:  CLRF   x27
4C2C:  MOVLW  E5
4C2E:  MOVWF  x26
4C30:  MOVLB  0
4C32:  RCALL  4790
4C34:  MOVLB  3
4C36:  CLRF   x25
4C38:  MOVFF  01,324
4C3C:  BTFSC  01.7
4C3E:  DECF   x25,F
4C40:  MOVF   x24,F
4C42:  BNZ   4C56
4C44:  MOVF   x25,F
4C46:  BNZ   4C56
....................       servoAccion(3,accionServo);
4C48:  MOVLW  03
4C4A:  MOVWF  x24
4C4C:  MOVFF  323,325
4C50:  MOVLB  0
4C52:  RCALL  4A4A
4C54:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a lcd */
....................    if (stricmp(key,lcd_key)==0) {
4C56:  MOVFF  320,325
4C5A:  MOVFF  31F,324
4C5E:  CLRF   x27
4C60:  MOVLW  E9
4C62:  MOVWF  x26
4C64:  MOVLB  0
4C66:  RCALL  4790
4C68:  MOVLB  3
4C6A:  CLRF   x25
4C6C:  MOVFF  01,324
4C70:  BTFSC  01.7
4C72:  DECF   x25,F
4C74:  MOVF   x24,F
4C76:  BNZ   4C92
4C78:  MOVF   x25,F
4C7A:  BNZ   4C92
....................       printf(lcd_putc,"\f%s",val);  //Muestra en el lcd el texto recibido
4C7C:  MOVLW  0C
4C7E:  MOVWF  x26
4C80:  MOVLB  0
4C82:  CALL   069A
4C86:  MOVFF  322,FEA
4C8A:  MOVFF  321,FE9
4C8E:  BRA    4B52
4C90:  MOVLB  3
....................    }
4C92:  MOVLB  0
4C94:  GOTO   4CFE (RETURN)
.................... }
.................... 
.................... 
.................... /************************** FUNCIÓN PRINCIPAL *********************************/
.................... void main(void) {
*
6E04:  CLRF   FF8
6E06:  BCF    FD0.7
6E08:  BSF    0B.7
6E0A:  CLRF   53
6E0C:  CLRF   52
6E0E:  CLRF   54
6E10:  CLRF   55
6E12:  CLRF   x79
6E14:  CLRF   x78
6E16:  MOVF   FC1,W
6E18:  ANDLW  C0
6E1A:  IORLW  0F
6E1C:  MOVWF  FC1
6E1E:  MOVLW  07
6E20:  MOVWF  FB4
6E22:  BCF    5A.1
6E24:  BRA    6E88
6E26:  DATA 02,00
6E28:  DATA 04,00
6E2A:  DATA 00,04
6E2C:  DATA 40,5C
6E2E:  DATA 00,01
6E30:  DATA 80,04
6E32:  DATA 0A,40
6E34:  DATA 63,00
6E36:  DATA 03,80
6E38:  DATA FE,00
6E3A:  DATA 01,01
6E3C:  DATA 00,77
6E3E:  DATA 00,0D
6E40:  DATA 00,7A
6E42:  DATA 20,00
6E44:  DATA 3F,00
6E46:  DATA 47,45
6E48:  DATA 54,00
6E4A:  DATA 50,4F
6E4C:  DATA 53,54
6E4E:  DATA 00,28
6E50:  DATA 40,88
6E52:  DATA 00,0F
6E54:  DATA 80,43
6E56:  DATA 6F,6E
6E58:  DATA 74,65
6E5A:  DATA 6E,74
6E5C:  DATA 2D,4C
6E5E:  DATA 65,6E
6E60:  DATA 67,74
6E62:  DATA 68,3A
6E64:  DATA 0C,C0
6E66:  DATA 00,06
6E68:  DATA 40,D5
6E6A:  DATA 00,12
6E6C:  DATA 80,2F
6E6E:  DATA 00,43
6E70:  DATA 4D,31
6E72:  DATA 00,43
6E74:  DATA 4D,32
6E76:  DATA 00,43
6E78:  DATA 4D,33
6E7A:  DATA 00,6C
6E7C:  DATA 63,64
6E7E:  DATA 00,FF
6E80:  DATA 41,B4
6E82:  DATA 00,3F
6E84:  DATA C0,00
6E86:  DATA 00,00
6E88:  MOVLW  00
6E8A:  MOVWF  FF8
6E8C:  MOVLW  6E
6E8E:  MOVWF  FF7
6E90:  MOVLW  26
6E92:  MOVWF  FF6
6E94:  TBLRD*+
6E96:  MOVF   FF5,W
6E98:  MOVWF  00
6E9A:  XORLW  00
6E9C:  BZ    6EC4
6E9E:  TBLRD*+
6EA0:  MOVF   FF5,W
6EA2:  MOVWF  01
6EA4:  BTFSC  FE8.7
6EA6:  BRA    6EB2
6EA8:  ANDLW  3F
6EAA:  MOVWF  FEA
6EAC:  TBLRD*+
6EAE:  MOVFF  FF5,FE9
6EB2:  BTFSC  01.6
6EB4:  TBLRD*+
6EB6:  BTFSS  01.6
6EB8:  TBLRD*+
6EBA:  MOVFF  FF5,FEE
6EBE:  DCFSNZ 00,F
6EC0:  BRA    6E94
6EC2:  BRA    6EB6
6EC4:  CLRF   FF8
....................    /* Habilitación y configuración del canal analógico 0 */
....................    setup_adc(ADC_CLOCK_INTERNAL);
6EC6:  MOVF   FC0,W
6EC8:  ANDLW  C0
6ECA:  IORLW  07
6ECC:  MOVWF  FC0
6ECE:  BCF    FC0.7
6ED0:  BSF    FC2.0
....................    setup_adc_ports(AN0);
6ED2:  MOVF   FC1,W
6ED4:  ANDLW  C0
6ED6:  IORLW  0E
6ED8:  MOVWF  FC1
....................    set_adc_channel(0);
6EDA:  MOVLW  00
6EDC:  MOVWF  01
6EDE:  MOVF   FC2,W
6EE0:  ANDLW  C3
6EE2:  IORWF  01,W
6EE4:  MOVWF  FC2
....................    delay_ms(1);
6EE6:  MOVLW  01
6EE8:  MOVLB  3
6EEA:  MOVWF  x2D
6EEC:  MOVLB  0
6EEE:  CALL   04FA
....................    TRISA = 0xFF;
6EF2:  SETF   F92
....................    int lab_no = 0;
6EF4:  MOVLB  2
6EF6:  CLRF   xF2
.................... 
....................    /*Reset de las salidas */
....................    output_low(PIN_C0);
6EF8:  BCF    F94.0
6EFA:  BCF    F8B.0
....................    output_low(PIN_C1);
6EFC:  BCF    F94.1
6EFE:  BCF    F8B.1
....................    output_low(PIN_C2);
6F00:  BCF    F94.2
6F02:  BCF    F8B.2
....................     
....................    /* Inicialización del lcd */
....................    lcd_init();
6F04:  MOVLB  0
6F06:  GOTO   05DC
....................    printf(lcd_putc,"\fUniversidad APEC");   //Mensaje de inicio en lcd
6F0A:  MOVLW  A8
6F0C:  MOVWF  FF6
6F0E:  MOVLW  04
6F10:  MOVWF  FF7
6F12:  GOTO   0706
....................    lcd_gotoxy(1,4);
6F16:  MOVLW  01
6F18:  MOVLB  3
6F1A:  MOVWF  x27
6F1C:  MOVLW  04
6F1E:  MOVWF  x28
6F20:  MOVLB  0
6F22:  CALL   0674
....................    printf(lcd_putc,"Laboratorio: %u",lab_no);
6F26:  MOVLW  BA
6F28:  MOVWF  FF6
6F2A:  MOVLW  04
6F2C:  MOVWF  FF7
6F2E:  MOVLW  0D
6F30:  MOVLB  2
6F32:  MOVWF  xF4
6F34:  MOVLB  0
6F36:  CALL   0728
6F3A:  MOVFF  2F2,2F4
6F3E:  MOVLW  1B
6F40:  MOVLB  2
6F42:  MOVWF  xF5
6F44:  MOVLB  0
6F46:  CALL   077C
....................    delay_ms(1000);
6F4A:  MOVLW  04
6F4C:  MOVLB  2
6F4E:  MOVWF  xF4
6F50:  MOVLW  FA
6F52:  MOVLB  3
6F54:  MOVWF  x2D
6F56:  MOVLB  0
6F58:  CALL   04FA
6F5C:  MOVLB  2
6F5E:  DECFSZ xF4,F
6F60:  BRA    6F50
....................   
....................    /* Inicialización del Stack */
....................    MACAddrInit(); //Se asigna la dirección MAC elegida 
6F62:  MOVLB  0
6F64:  GOTO   07F8
....................    IPAddrInit();  //Se asigna IP, mascara de red y puerta de enlace elegidos
6F68:  GOTO   0812
....................    StackInit();   //Inicializa el stack
6F6C:  GOTO   10EE
....................    
....................    /* Muestra la IP elegida en lcd */
....................   /* printf(lcd_putc,"\nIP: %u.%u.%u.%u:%u", MY_IP_BYTE1, MY_IP_BYTE2, MY_IP_BYTE3, MY_IP_BYTE4,HTTP_SOCKET);
....................    delay_ms(10);*/
....................    while(TRUE) {
....................    StackTask();
6F70:  BRA    6C3E
....................    int pulsado = PORTA;
6F72:  MOVFF  F80,2F3
.................... 
....................    if (pulsado == 4){
6F76:  MOVLB  2
6F78:  MOVF   xF3,W
6F7A:  SUBLW  04
6F7C:  BNZ   6FC8
....................    pulsado = 0;
6F7E:  CLRF   xF3
....................    lab_no = 1;
6F80:  MOVLW  01
6F82:  MOVWF  xF2
....................    lcd_gotoxy(1,3);
6F84:  MOVLB  3
6F86:  MOVWF  x27
6F88:  MOVLW  03
6F8A:  MOVWF  x28
6F8C:  MOVLB  0
6F8E:  CALL   0674
....................    printf(lcd_putc,"Laboratorio: %u",lab_no);
6F92:  MOVLW  CA
6F94:  MOVWF  FF6
6F96:  MOVLW  04
6F98:  MOVWF  FF7
6F9A:  MOVLW  0D
6F9C:  MOVLB  2
6F9E:  MOVWF  xF4
6FA0:  MOVLB  0
6FA2:  CALL   0728
6FA6:  MOVFF  2F2,2F4
6FAA:  MOVLW  1B
6FAC:  MOVLB  2
6FAE:  MOVWF  xF5
6FB0:  MOVLB  0
6FB2:  CALL   077C
....................    servoAccion(1,2);
6FB6:  MOVLW  01
6FB8:  MOVLB  3
6FBA:  MOVWF  x24
6FBC:  MOVLW  02
6FBE:  MOVWF  x25
6FC0:  MOVLB  0
6FC2:  CALL   4A4A
6FC6:  MOVLB  2
....................    }
....................    if (pulsado == 8){
6FC8:  MOVF   xF3,W
6FCA:  SUBLW  08
6FCC:  BNZ   7018
....................    pulsado = 0;
6FCE:  CLRF   xF3
....................    lab_no = 2;
6FD0:  MOVLW  02
6FD2:  MOVWF  xF2
....................    lcd_gotoxy(1,3);
6FD4:  MOVLW  01
6FD6:  MOVLB  3
6FD8:  MOVWF  x27
6FDA:  MOVLW  03
6FDC:  MOVWF  x28
6FDE:  MOVLB  0
6FE0:  CALL   0674
....................    printf(lcd_putc,"Laboratorio: %u",lab_no);
6FE4:  MOVLW  DA
6FE6:  MOVWF  FF6
6FE8:  MOVLW  04
6FEA:  MOVWF  FF7
6FEC:  MOVLW  0D
6FEE:  MOVLB  2
6FF0:  MOVWF  xF4
6FF2:  MOVLB  0
6FF4:  CALL   0728
6FF8:  MOVFF  2F2,2F4
6FFC:  MOVLW  1B
6FFE:  MOVLB  2
7000:  MOVWF  xF5
7002:  MOVLB  0
7004:  CALL   077C
....................    servoAccion(2,2);
7008:  MOVLW  02
700A:  MOVLB  3
700C:  MOVWF  x24
700E:  MOVWF  x25
7010:  MOVLB  0
7012:  CALL   4A4A
7016:  MOVLB  2
....................    }
....................    if (pulsado == 16){
7018:  MOVF   xF3,W
701A:  SUBLW  10
701C:  BNZ   7068
....................    pulsado = 0;
701E:  CLRF   xF3
....................    lab_no = 3;
7020:  MOVLW  03
7022:  MOVWF  xF2
....................    lcd_gotoxy(1,3);
7024:  MOVLW  01
7026:  MOVLB  3
7028:  MOVWF  x27
702A:  MOVLW  03
702C:  MOVWF  x28
702E:  MOVLB  0
7030:  CALL   0674
....................    printf(lcd_putc,"Laboratorio: %u",lab_no);
7034:  MOVLW  EA
7036:  MOVWF  FF6
7038:  MOVLW  04
703A:  MOVWF  FF7
703C:  MOVLW  0D
703E:  MOVLB  2
7040:  MOVWF  xF4
7042:  MOVLB  0
7044:  CALL   0728
7048:  MOVFF  2F2,2F4
704C:  MOVLW  1B
704E:  MOVLB  2
7050:  MOVWF  xF5
7052:  MOVLB  0
7054:  CALL   077C
....................    servoAccion(3,2);
7058:  MOVLW  03
705A:  MOVLB  3
705C:  MOVWF  x24
705E:  MOVLW  02
7060:  MOVWF  x25
7062:  MOVLB  0
7064:  CALL   4A4A
....................    }
7068:  MOVLB  0
706A:  BRA    6F70
.................... }
....................    }
706C:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E26   PUT BROWNOUT VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: A00F   NOWRT NOWRTC WRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
