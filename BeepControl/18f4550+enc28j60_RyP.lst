CCS PCH C Compiler, Version 5.094d, 1               13-Apr-20 15:24
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\pdelacruz\Downloads\AutomatizacionRobotica\BeepControl\18f4550+enc28j60_RyP.lst

               ROM used:   28694 bytes (88%)
                           Largest free fragment is 4072
               RAM used:   737 (36%) at main() level
                           922 (45%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

0000:  GOTO   6E44
*
0008:  MOVWF  08
000A:  MOVFF  FD8,09
000E:  MOVFF  FE0,0A
0012:  MOVLB  0
0014:  MOVFF  FE9,10
0018:  MOVFF  FEA,0B
001C:  MOVFF  FE1,0C
0020:  MOVFF  FE2,0D
0024:  MOVFF  FD9,0E
0028:  MOVFF  FDA,0F
002C:  MOVFF  FF3,16
0030:  MOVFF  FF4,17
0034:  MOVFF  FFA,18
0038:  MOVFF  FF5,19
003C:  MOVFF  FF6,1A
0040:  MOVFF  FF7,1B
0044:  MOVFF  00,12
0048:  MOVFF  01,13
004C:  MOVFF  02,14
0050:  MOVFF  03,15
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00C2
0060:  MOVFF  12,00
0064:  MOVFF  13,01
0068:  MOVFF  14,02
006C:  MOVFF  15,03
0070:  MOVFF  10,FE9
0074:  MOVFF  0B,FEA
0078:  BSF    0B.7
007A:  MOVFF  0C,FE1
007E:  MOVFF  0D,FE2
0082:  MOVFF  0E,FD9
0086:  MOVFF  0F,FDA
008A:  MOVFF  16,FF3
008E:  MOVFF  17,FF4
0092:  MOVFF  18,FFA
0096:  MOVFF  19,FF5
009A:  MOVFF  1A,FF6
009E:  MOVFF  1B,FF7
00A2:  MOVF   08,W
00A4:  MOVFF  0A,FE0
00A8:  MOVFF  09,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 28,0C
00C0:  DATA 01,06
*
00E2:  DATA 3C,48
00E4:  DATA 54,4D
00E6:  DATA 4C,3E
00E8:  DATA 3C,42
00EA:  DATA 4F,44
00EC:  DATA 59,3E
00EE:  DATA 3C,48
00F0:  DATA 31,3E
00F2:  DATA 34,30
00F4:  DATA 34,20
00F6:  DATA 45,72
00F8:  DATA 72,6F
00FA:  DATA 72,3C
00FC:  DATA 2F,48
00FE:  DATA 31,3E
0100:  DATA 3C,48
0102:  DATA 52,3E
0104:  DATA 3C,50
0106:  DATA 3E,46
0108:  DATA 69,6C
010A:  DATA 65,20
010C:  DATA 4E,6F
010E:  DATA 74,20
0110:  DATA 66,6F
0112:  DATA 75,6E
0114:  DATA 64,2E
0116:  DATA 3C,2F
0118:  DATA 42,4F
011A:  DATA 44,59
011C:  DATA 3E,3C
011E:  DATA 2F,48
0120:  DATA 54,4D
0122:  DATA 4C,3E
0124:  DATA 00,00
0126:  DATA 3C,48
0128:  DATA 54,4D
012A:  DATA 4C,3E
012C:  DATA 3C,42
012E:  DATA 4F,44
0130:  DATA 59,3E
0132:  DATA 3C,48
0134:  DATA 31,3E
0136:  DATA 35,30
0138:  DATA 30,20
013A:  DATA 45,72
013C:  DATA 72,6F
013E:  DATA 72,3C
0140:  DATA 2F,48
0142:  DATA 31,3E
0144:  DATA 3C,48
0146:  DATA 52,3E
0148:  DATA 3C,50
014A:  DATA 3E,49
014C:  DATA 6E,74
014E:  DATA 65,72
0150:  DATA 6E,61
0152:  DATA 6C,20
0154:  DATA 53,65
0156:  DATA 72,76
0158:  DATA 65,72
015A:  DATA 20,45
015C:  DATA 72,72
015E:  DATA 6F,72
0160:  DATA 3C,2F
0162:  DATA 42,4F
0164:  DATA 44,59
0166:  DATA 3E,3C
0168:  DATA 2F,48
016A:  DATA 54,4D
016C:  DATA 4C,3E
016E:  DATA 00,00
0170:  DATA 48,54
0172:  DATA 54,50
0174:  DATA 2F,31
0176:  DATA 2E,30
0178:  DATA 20,25
017A:  DATA 4C,55
017C:  DATA 20,00
017E:  DATA 4E,6F
0180:  DATA 74,20
0182:  DATA 66,6F
0184:  DATA 75,6E
0186:  DATA 64,00
0188:  DATA 53,65
018A:  DATA 72,76
018C:  DATA 65,72
018E:  DATA 20,45
0190:  DATA 72,72
0192:  DATA 6F,72
0194:  DATA 00,00
0196:  DATA 0D,0A
0198:  DATA 43,6F
019A:  DATA 6E,74
019C:  DATA 65,6E
019E:  DATA 74,2D
01A0:  DATA 54,79
01A2:  DATA 70,65
01A4:  DATA 3A,20
01A6:  DATA 00,00
01A8:  DATA 74,65
01AA:  DATA 78,74
01AC:  DATA 2F,68
01AE:  DATA 74,6D
01B0:  DATA 6C,00
01B2:  DATA 0D,0A
01B4:  DATA 0D,0A
01B6:  DATA 00,00
01B8:  DATA 20,0A
01BA:  DATA 3C,48
01BC:  DATA 54,4D
01BE:  DATA 4C,3E
01C0:  DATA 3C,42
01C2:  DATA 4F,44
01C4:  DATA 59,20
01C6:  DATA 42,47
01C8:  DATA 43,4F
01CA:  DATA 4C,4F
01CC:  DATA 52,3D
01CE:  DATA 23,46
01D0:  DATA 46,46
01D2:  DATA 46,46
01D4:  DATA 46,20
01D6:  DATA 54,45
01D8:  DATA 58,54
01DA:  DATA 3D,23
01DC:  DATA 30,30
01DE:  DATA 30,30
01E0:  DATA 30,30
01E2:  DATA 3E,20
01E4:  DATA 0A,20
01E6:  DATA 0A,3C
01E8:  DATA 63,65
01EA:  DATA 6E,74
01EC:  DATA 65,72
01EE:  DATA 3E,3C
01F0:  DATA 48,31
01F2:  DATA 3E,42
01F4:  DATA 65,65
01F6:  DATA 70,43
01F8:  DATA 6F,6E
01FA:  DATA 74,72
01FC:  DATA 6F,6C
01FE:  DATA 20,3C
0200:  DATA 2F,48
0202:  DATA 31,3E
0204:  DATA 3C,2F
0206:  DATA 63,65
0208:  DATA 6E,74
020A:  DATA 65,72
020C:  DATA 3E,20
020E:  DATA 0A,3C
0210:  DATA 42,52
0212:  DATA 3E,3C
0214:  DATA 63,65
0216:  DATA 6E,74
0218:  DATA 65,72
021A:  DATA 3E,3C
021C:  DATA 48,32
021E:  DATA 3E,44
0220:  DATA 61,73
0222:  DATA 68,62
0224:  DATA 6F,61
0226:  DATA 72,64
0228:  DATA 3C,2F
022A:  DATA 48,32
022C:  DATA 3E,3C
022E:  DATA 2F,43
0230:  DATA 45,4E
0232:  DATA 54,45
0234:  DATA 52,3E
0236:  DATA 20,0A
0238:  DATA 20,0A
023A:  DATA 20,0A
023C:  DATA 3C,46
023E:  DATA 4F,52
0240:  DATA 4D,20
0242:  DATA 4D,45
0244:  DATA 54,48
0246:  DATA 4F,44
0248:  DATA 3D,47
024A:  DATA 45,54
024C:  DATA 3E,20
024E:  DATA 0A,3C
0250:  DATA 50,3E
0252:  DATA 4C,43
0254:  DATA 44,3A
0256:  DATA 20,3C
0258:  DATA 49,4E
025A:  DATA 50,55
025C:  DATA 54,20
025E:  DATA 54,59
0260:  DATA 50,45
0262:  DATA 3D,22
0264:  DATA 74,65
0266:  DATA 78,74
0268:  DATA 22,20
026A:  DATA 4E,41
026C:  DATA 4D,45
026E:  DATA 3D,22
0270:  DATA 6C,63
0272:  DATA 64,22
0274:  DATA 20,73
0276:  DATA 69,7A
0278:  DATA 65,3D
027A:  DATA 32,30
027C:  DATA 20,6D
027E:  DATA 61,78
0280:  DATA 6C,65
0282:  DATA 6E,67
0284:  DATA 74,68
0286:  DATA 3D,31
0288:  DATA 36,3E
028A:  DATA 20,0A
028C:  DATA 3C,69
028E:  DATA 6E,70
0290:  DATA 75,74
0292:  DATA 20,74
0294:  DATA 79,70
0296:  DATA 65,3D
0298:  DATA 22,73
029A:  DATA 75,62
029C:  DATA 6D,69
029E:  DATA 74,22
02A0:  DATA 20,76
02A2:  DATA 61,6C
02A4:  DATA 75,65
02A6:  DATA 3D,22
02A8:  DATA 45,6E
02AA:  DATA 76,69
02AC:  DATA 61,72
02AE:  DATA 20,74
02B0:  DATA 65,78
02B2:  DATA 74,6F
02B4:  DATA 22,3E
02B6:  DATA 20,0A
02B8:  DATA 3C,2F
02BA:  DATA 46,4F
02BC:  DATA 52,4D
02BE:  DATA 3E,20
02C0:  DATA 0A,20
02C2:  DATA 0A,3C
02C4:  DATA 46,4F
02C6:  DATA 52,4D
02C8:  DATA 20,4D
02CA:  DATA 45,54
02CC:  DATA 48,4F
02CE:  DATA 44,3D
02D0:  DATA 47,45
02D2:  DATA 54,3E
02D4:  DATA 20,0A
02D6:  DATA 3C,69
02D8:  DATA 6E,70
02DA:  DATA 75,74
02DC:  DATA 20,74
02DE:  DATA 79,70
02E0:  DATA 65,3D
02E2:  DATA 22,73
02E4:  DATA 75,62
02E6:  DATA 6D,69
02E8:  DATA 74,22
02EA:  DATA 20,6E
02EC:  DATA 61,6D
02EE:  DATA 65,3D
02F0:  DATA 22,43
02F2:  DATA 4D,31
02F4:  DATA 22,20
02F6:  DATA 76,61
02F8:  DATA 6C,75
02FA:  DATA 65,3D
02FC:  DATA 22,41
02FE:  DATA 22,3E
0300:  DATA 20,0A
0302:  DATA 3C,69
0304:  DATA 6E,70
0306:  DATA 75,74
0308:  DATA 20,74
030A:  DATA 79,70
030C:  DATA 65,3D
030E:  DATA 22,73
0310:  DATA 75,62
0312:  DATA 6D,69
0314:  DATA 74,22
0316:  DATA 20,6E
0318:  DATA 61,6D
031A:  DATA 65,3D
031C:  DATA 22,43
031E:  DATA 4D,31
0320:  DATA 22,20
0322:  DATA 76,61
0324:  DATA 6C,75
0326:  DATA 65,3D
0328:  DATA 22,43
032A:  DATA 22,3E
032C:  DATA 20,0A
032E:  DATA 3C,69
0330:  DATA 6E,70
0332:  DATA 75,74
0334:  DATA 20,74
0336:  DATA 79,70
0338:  DATA 65,3D
033A:  DATA 22,73
033C:  DATA 75,62
033E:  DATA 6D,69
0340:  DATA 74,22
0342:  DATA 20,6E
0344:  DATA 61,6D
0346:  DATA 65,3D
0348:  DATA 22,43
034A:  DATA 4D,31
034C:  DATA 22,20
034E:  DATA 76,61
0350:  DATA 6C,75
0352:  DATA 65,3D
0354:  DATA 22,5A
0356:  DATA 22,3E
0358:  DATA 20,0A
035A:  DATA 3C,2F
035C:  DATA 46,4F
035E:  DATA 52,4D
0360:  DATA 3E,20
0362:  DATA 0A,3C
0364:  DATA 46,4F
0366:  DATA 52,4D
0368:  DATA 20,4D
036A:  DATA 45,54
036C:  DATA 48,4F
036E:  DATA 44,3D
0370:  DATA 47,45
0372:  DATA 54,3E
0374:  DATA 20,0A
0376:  DATA 3C,69
0378:  DATA 6E,70
037A:  DATA 75,74
037C:  DATA 20,74
037E:  DATA 79,70
0380:  DATA 65,3D
0382:  DATA 22,73
0384:  DATA 75,62
0386:  DATA 6D,69
0388:  DATA 74,22
038A:  DATA 20,6E
038C:  DATA 61,6D
038E:  DATA 65,3D
0390:  DATA 22,43
0392:  DATA 4D,32
0394:  DATA 22,20
0396:  DATA 76,61
0398:  DATA 6C,75
039A:  DATA 65,3D
039C:  DATA 22,41
039E:  DATA 22,3E
03A0:  DATA 20,0A
03A2:  DATA 3C,69
03A4:  DATA 6E,70
03A6:  DATA 75,74
03A8:  DATA 20,74
03AA:  DATA 79,70
03AC:  DATA 65,3D
03AE:  DATA 22,73
03B0:  DATA 75,62
03B2:  DATA 6D,69
03B4:  DATA 74,22
03B6:  DATA 20,6E
03B8:  DATA 61,6D
03BA:  DATA 65,3D
03BC:  DATA 22,43
03BE:  DATA 4D,32
03C0:  DATA 22,20
03C2:  DATA 76,61
03C4:  DATA 6C,75
03C6:  DATA 65,3D
03C8:  DATA 22,43
03CA:  DATA 22,3E
03CC:  DATA 20,0A
03CE:  DATA 3C,69
03D0:  DATA 6E,70
03D2:  DATA 75,74
03D4:  DATA 20,74
03D6:  DATA 79,70
03D8:  DATA 65,3D
03DA:  DATA 22,73
03DC:  DATA 75,62
03DE:  DATA 6D,69
03E0:  DATA 74,22
03E2:  DATA 20,6E
03E4:  DATA 61,6D
03E6:  DATA 65,3D
03E8:  DATA 22,43
03EA:  DATA 4D,32
03EC:  DATA 22,20
03EE:  DATA 76,61
03F0:  DATA 6C,75
03F2:  DATA 65,3D
03F4:  DATA 22,5A
03F6:  DATA 22,3E
03F8:  DATA 20,0A
03FA:  DATA 3C,2F
03FC:  DATA 46,4F
03FE:  DATA 52,4D
0400:  DATA 3E,20
0402:  DATA 0A,3C
0404:  DATA 46,4F
0406:  DATA 52,4D
0408:  DATA 20,4D
040A:  DATA 45,54
040C:  DATA 48,4F
040E:  DATA 44,3D
0410:  DATA 47,45
0412:  DATA 54,3E
0414:  DATA 20,0A
0416:  DATA 3C,69
0418:  DATA 6E,70
041A:  DATA 75,74
041C:  DATA 20,74
041E:  DATA 79,70
0420:  DATA 65,3D
0422:  DATA 22,73
0424:  DATA 75,62
0426:  DATA 6D,69
0428:  DATA 74,22
042A:  DATA 20,6E
042C:  DATA 61,6D
042E:  DATA 65,3D
0430:  DATA 22,43
0432:  DATA 4D,33
0434:  DATA 22,20
0436:  DATA 76,61
0438:  DATA 6C,75
043A:  DATA 65,3D
043C:  DATA 22,41
043E:  DATA 22,3E
0440:  DATA 20,0A
0442:  DATA 3C,69
0444:  DATA 6E,70
0446:  DATA 75,74
0448:  DATA 20,74
044A:  DATA 79,70
044C:  DATA 65,3D
044E:  DATA 22,73
0450:  DATA 75,62
0452:  DATA 6D,69
0454:  DATA 74,22
0456:  DATA 20,6E
0458:  DATA 61,6D
045A:  DATA 65,3D
045C:  DATA 22,43
045E:  DATA 4D,33
0460:  DATA 22,20
0462:  DATA 76,61
0464:  DATA 6C,75
0466:  DATA 65,3D
0468:  DATA 22,43
046A:  DATA 22,3E
046C:  DATA 20,0A
046E:  DATA 3C,69
0470:  DATA 6E,70
0472:  DATA 75,74
0474:  DATA 20,74
0476:  DATA 79,70
0478:  DATA 65,3D
047A:  DATA 22,73
047C:  DATA 75,62
047E:  DATA 6D,69
0480:  DATA 74,22
0482:  DATA 20,6E
0484:  DATA 61,6D
0486:  DATA 65,3D
0488:  DATA 22,43
048A:  DATA 4D,33
048C:  DATA 22,20
048E:  DATA 76,61
0490:  DATA 6C,75
0492:  DATA 65,3D
0494:  DATA 22,5A
0496:  DATA 22,3E
0498:  DATA 20,0A
049A:  DATA 3C,2F
049C:  DATA 46,4F
049E:  DATA 52,4D
04A0:  DATA 3E,20
04A2:  DATA 0A,3C
04A4:  DATA 2F,42
04A6:  DATA 4F,44
04A8:  DATA 59,3E
04AA:  DATA 3C,2F
04AC:  DATA 48,54
04AE:  DATA 4D,4C
04B0:  DATA 3E,20
04B2:  DATA 0A,00
04B4:  DATA 43,00
04B6:  DATA 41,00
04B8:  DATA 5A,00
04BA:  DATA 00,00
04BC:  DATA 0C,42
04BE:  DATA 65,65
04C0:  DATA 70,43
04C2:  DATA 6F,6E
04C4:  DATA 74,72
04C6:  DATA 6F,6C
04C8:  DATA 00,00
04CA:  DATA 0A,49
04CC:  DATA 50,3A
04CE:  DATA 20,25
04D0:  DATA 75,2E
04D2:  DATA 25,75
04D4:  DATA 2E,25
04D6:  DATA 75,2E
04D8:  DATA 25,75
04DA:  DATA 3A,25
04DC:  DATA 75,00
*
06C0:  ADDWF  FE8,W
06C2:  CLRF   FF7
06C4:  RLCF   FF7,F
06C6:  ADDLW  DB
06C8:  MOVWF  FF6
06CA:  MOVLW  06
06CC:  ADDWFC FF7,F
06CE:  TBLRD*-
06D0:  MOVF   FF5,W
06D2:  MOVWF  FFA
06D4:  TBLRD*
06D6:  MOVF   FF5,W
06D8:  MOVWF  FF9
06DA:  DATA 7C,06
06DC:  DATA 88,06
06DE:  DATA 94,06
06E0:  DATA A0,06
*
0754:  TBLRD*+
0756:  MOVF   FF5,F
0758:  BZ    0772
075A:  MOVFF  FF6,2E0
075E:  MOVFF  FF7,2E1
0762:  MOVFF  FF5,30C
0766:  RCALL  06E2
0768:  MOVFF  2E0,FF6
076C:  MOVFF  2E1,FF7
0770:  BRA    0754
0772:  GOTO   6F4C (RETURN)
*
0CC4:  MOVLB  3
0CC6:  CLRF   x48
0CC8:  CLRF   x49
0CCA:  MOVLW  01
0CCC:  MOVWF  x4A
0CCE:  CLRF   FDA
0CD0:  CLRF   FD9
0CD2:  MOVLW  03
0CD4:  MOVWF  x4D
0CD6:  MOVLW  40
0CD8:  MOVWF  x4C
0CDA:  MOVLW  03
0CDC:  MOVWF  FEA
0CDE:  MOVLW  44
0CE0:  MOVWF  FE9
0CE2:  MOVFF  34D,FE2
0CE6:  MOVFF  34C,FE1
0CEA:  MOVFF  34A,34B
0CEE:  BCF    FD8.0
0CF0:  MOVF   FE5,W
0CF2:  MULWF  FEE
0CF4:  MOVF   FF3,W
0CF6:  ADDWFC x48,F
0CF8:  MOVF   FF4,W
0CFA:  ADDWFC x49,F
0CFC:  DECFSZ x4B,F
0CFE:  BRA    0CEE
0D00:  MOVFF  348,FDE
0D04:  MOVFF  349,348
0D08:  CLRF   x49
0D0A:  BTFSC  FD8.0
0D0C:  INCF   x49,F
0D0E:  INCF   x4C,F
0D10:  BTFSC  FD8.2
0D12:  INCF   x4D,F
0D14:  INCF   x4A,F
0D16:  MOVF   x4A,W
0D18:  SUBLW  05
0D1A:  BNZ   0CDA
0D1C:  MOVLB  0
0D1E:  RETURN 0
0D20:  CLRF   01
0D22:  CLRF   02
0D24:  CLRF   00
0D26:  CLRF   03
0D28:  MOVLB  2
0D2A:  MOVF   xE9,W
0D2C:  BNZ   0D32
0D2E:  MOVF   xE8,W
0D30:  BZ    0D62
0D32:  MOVLW  10
0D34:  MOVWF  xEA
0D36:  BCF    FD8.0
0D38:  RLCF   xE6,F
0D3A:  RLCF   xE7,F
0D3C:  RLCF   00,F
0D3E:  RLCF   03,F
0D40:  MOVF   xE9,W
0D42:  SUBWF  03,W
0D44:  BNZ   0D4A
0D46:  MOVF   xE8,W
0D48:  SUBWF  00,W
0D4A:  BNC   0D5A
0D4C:  MOVF   xE8,W
0D4E:  SUBWF  00,F
0D50:  BTFSS  FD8.0
0D52:  DECF   03,F
0D54:  MOVF   xE9,W
0D56:  SUBWF  03,F
0D58:  BSF    FD8.0
0D5A:  RLCF   01,F
0D5C:  RLCF   02,F
0D5E:  DECFSZ xEA,F
0D60:  BRA    0D36
0D62:  MOVLB  0
0D64:  GOTO   0DCE (RETURN)
*
1086:  TBLRD*+
1088:  MOVFF  FF6,2E1
108C:  MOVFF  FF7,2E2
1090:  MOVFF  FF5,30C
1094:  CALL   06E2
1098:  MOVFF  2E1,FF6
109C:  MOVFF  2E2,FF7
10A0:  MOVLB  2
10A2:  DECFSZ xE0,F
10A4:  BRA    10A8
10A6:  BRA    10AC
10A8:  MOVLB  0
10AA:  BRA    1086
10AC:  MOVLB  0
10AE:  GOTO   6F86 (RETURN)
10B2:  MOVLB  3
10B4:  MOVF   x24,W
10B6:  CLRF   01
10B8:  SUBWF  x23,W
10BA:  BC    10C2
10BC:  MOVFF  323,00
10C0:  BRA    10DA
10C2:  CLRF   00
10C4:  MOVLW  08
10C6:  MOVWF  x25
10C8:  RLCF   x23,F
10CA:  RLCF   00,F
10CC:  MOVF   x24,W
10CE:  SUBWF  00,W
10D0:  BTFSC  FD8.0
10D2:  MOVWF  00
10D4:  RLCF   01,F
10D6:  DECFSZ x25,F
10D8:  BRA    10C8
10DA:  MOVLB  0
10DC:  RETURN 0
10DE:  MOVF   01,W
10E0:  MOVFF  2E0,323
10E4:  MOVLW  64
10E6:  MOVLB  3
10E8:  MOVWF  x24
10EA:  MOVLB  0
10EC:  RCALL  10B2
10EE:  MOVFF  00,2E0
10F2:  MOVF   01,W
10F4:  MOVLW  30
10F6:  BNZ   1108
10F8:  MOVLB  2
10FA:  BTFSS  xE1.1
10FC:  BRA    111C
10FE:  BTFSC  xE1.3
1100:  BRA    111C
1102:  BTFSC  xE1.4
1104:  MOVLW  20
1106:  BRA    1110
1108:  MOVLB  2
110A:  BCF    xE1.3
110C:  BCF    xE1.4
110E:  BSF    xE1.0
1110:  ADDWF  01,F
1112:  MOVFF  01,30C
1116:  MOVLB  0
1118:  CALL   06E2
111C:  MOVFF  2E0,323
1120:  MOVLW  0A
1122:  MOVLB  3
1124:  MOVWF  x24
1126:  MOVLB  0
1128:  RCALL  10B2
112A:  MOVFF  00,2E0
112E:  MOVF   01,W
1130:  MOVLW  30
1132:  BNZ   1144
1134:  MOVLB  2
1136:  BTFSC  xE1.3
1138:  BRA    1150
113A:  BTFSS  xE1.0
113C:  BRA    1150
113E:  BTFSC  xE1.4
1140:  MOVLW  20
1142:  MOVLB  0
1144:  ADDWF  01,F
1146:  MOVFF  01,30C
114A:  CALL   06E2
114E:  MOVLB  2
1150:  MOVLW  30
1152:  ADDWF  xE0,F
1154:  MOVFF  2E0,30C
1158:  MOVLB  0
115A:  CALL   06E2
115E:  RETURN 0
*
3DE6:  ADDWF  FE8,W
3DE8:  CLRF   FF7
3DEA:  RLCF   FF7,F
3DEC:  ADDLW  01
3DEE:  MOVWF  FF6
3DF0:  MOVLW  3E
3DF2:  ADDWFC FF7,F
3DF4:  TBLRD*-
3DF6:  MOVF   FF5,W
3DF8:  MOVWF  FFA
3DFA:  TBLRD*
3DFC:  MOVF   FF5,W
3DFE:  MOVWF  FF9
3E00:  DATA 82,3B
3E02:  DATA 8A,3B
3E04:  DATA D2,3B
3E06:  DATA 74,3C
3E08:  DATA A0,3C
3E0A:  DATA A0,3C
3E0C:  DATA B0,3C
3E0E:  DATA C0,3C
3E10:  DATA D4,3C
*
48E8:  MOVFF  FEA,FE2
48EC:  MOVFF  FE9,FE1
48F0:  CLRF   01
48F2:  BSF    00.0
48F4:  TBLRD*+
48F6:  MOVF   FF5,W
48F8:  BTFSS  00.0
48FA:  BRA    4906
48FC:  SUBWF  FEE,W
48FE:  BNZ   4906
4900:  MOVF   FF5,F
4902:  BNZ   48F4
4904:  BRA    4920
4906:  BCF    00.0
4908:  MOVF   FF5,F
490A:  BNZ   48F4
490C:  INCF   01,F
490E:  BSF    00.0
4910:  MOVFF  FE2,FEA
4914:  MOVFF  FE1,FE9
4918:  TBLRD*
491A:  MOVF   FF5,F
491C:  BNZ   48F4
491E:  SETF   01
4920:  GOTO   4B9E (RETURN)
4924:  MOVLB  3
4926:  MOVF   x17,W
4928:  ANDLW  07
492A:  MOVWF  00
492C:  RRCF   x17,W
492E:  MOVWF  01
4930:  RRCF   01,F
4932:  RRCF   01,F
4934:  MOVLW  1F
4936:  ANDWF  01,F
4938:  MOVF   01,W
493A:  ADDWF  x19,W
493C:  MOVWF  FE9
493E:  MOVLW  00
4940:  ADDWFC x1A,W
4942:  MOVWF  FEA
4944:  CLRF   01
4946:  INCF   01,F
4948:  INCF   00,F
494A:  BRA    494E
494C:  RLCF   01,F
494E:  DECFSZ 00,F
4950:  BRA    494C
4952:  MOVF   x18,F
4954:  BZ    495C
4956:  MOVF   01,W
4958:  IORWF  FEF,F
495A:  BRA    4962
495C:  COMF   01,F
495E:  MOVF   01,W
4960:  ANDWF  FEF,F
4962:  MOVLB  0
4964:  RETURN 0
4966:  MOVLB  3
4968:  MOVF   x17,W
496A:  ANDLW  07
496C:  MOVWF  00
496E:  RRCF   x17,W
4970:  MOVWF  01
4972:  RRCF   01,F
4974:  RRCF   01,F
4976:  MOVLW  1F
4978:  ANDWF  01,F
497A:  MOVF   01,W
497C:  ADDWF  x18,W
497E:  MOVWF  FE9
4980:  MOVLW  00
4982:  ADDWFC x19,W
4984:  MOVWF  FEA
4986:  MOVFF  FEF,01
498A:  INCF   00,F
498C:  BRA    4990
498E:  RRCF   01,F
4990:  DECFSZ 00,F
4992:  BRA    498E
4994:  MOVLW  01
4996:  ANDWF  01,F
4998:  MOVLB  0
499A:  GOTO   49D8 (RETURN)
*
4B60:  MOVF   FEF,F
4B62:  BZ    4B84
4B64:  MOVFF  FEA,30B
4B68:  MOVFF  FE9,30A
4B6C:  MOVFF  FEF,30C
4B70:  CALL   06E2
4B74:  MOVFF  30B,FEA
4B78:  MOVFF  30A,FE9
4B7C:  INCF   FE9,F
4B7E:  BTFSC  FD8.2
4B80:  INCF   FEA,F
4B82:  BRA    4B60
4B84:  GOTO   4CA6 (RETURN)
*
4D64:  MOVLB  2
4D66:  MOVF   xF9,W
4D68:  XORWF  xFB,W
4D6A:  ANDLW  80
4D6C:  MOVWF  xFD
4D6E:  BTFSS  xF9.7
4D70:  BRA    4D7C
4D72:  COMF   xF8,F
4D74:  COMF   xF9,F
4D76:  INCF   xF8,F
4D78:  BTFSC  FD8.2
4D7A:  INCF   xF9,F
4D7C:  BTFSS  xFB.7
4D7E:  BRA    4D8A
4D80:  COMF   xFA,F
4D82:  COMF   xFB,F
4D84:  INCF   xFA,F
4D86:  BTFSC  FD8.2
4D88:  INCF   xFB,F
4D8A:  MOVF   xF8,W
4D8C:  MULWF  xFA
4D8E:  MOVFF  FF3,01
4D92:  MOVFF  FF4,00
4D96:  MULWF  xFB
4D98:  MOVF   FF3,W
4D9A:  ADDWF  00,F
4D9C:  MOVF   xF9,W
4D9E:  MULWF  xFA
4DA0:  MOVF   FF3,W
4DA2:  ADDWFC 00,W
4DA4:  MOVWF  02
4DA6:  BTFSS  xFD.7
4DA8:  BRA    4DB4
4DAA:  COMF   01,F
4DAC:  COMF   02,F
4DAE:  INCF   01,F
4DB0:  BTFSC  FD8.2
4DB2:  INCF   02,F
4DB4:  MOVLB  0
4DB6:  GOTO   4E94 (RETURN)
*
5366:  TBLRD*+
5368:  MOVFF  FF6,2FF
536C:  MOVFF  FF7,300
5370:  MOVFF  FF5,31C
5374:  RCALL  5358
5376:  MOVFF  2FF,FF6
537A:  MOVFF  300,FF7
537E:  MOVLB  2
5380:  DECFSZ xFE,F
5382:  BRA    5386
5384:  BRA    538A
5386:  MOVLB  0
5388:  BRA    5366
538A:  MOVLB  0
538C:  GOTO   5C46 (RETURN)
5390:  MOVFF  FEA,306
5394:  MOVFF  FE9,305
5398:  MOVLB  2
539A:  SWAPF  xFF,W
539C:  IORLW  F0
539E:  MOVLB  3
53A0:  MOVWF  x01
53A2:  ADDWF  x01,F
53A4:  ADDLW  E2
53A6:  MOVWF  x02
53A8:  ADDLW  32
53AA:  MOVWF  x04
53AC:  MOVLB  2
53AE:  MOVF   xFF,W
53B0:  ANDLW  0F
53B2:  MOVLB  3
53B4:  ADDWF  x02,F
53B6:  ADDWF  x02,F
53B8:  ADDWF  x04,F
53BA:  ADDLW  E9
53BC:  MOVWF  x03
53BE:  ADDWF  x03,F
53C0:  ADDWF  x03,F
53C2:  MOVLB  2
53C4:  SWAPF  xFE,W
53C6:  ANDLW  0F
53C8:  MOVLB  3
53CA:  ADDWF  x03,F
53CC:  ADDWF  x04,F
53CE:  RLCF   x03,F
53D0:  RLCF   x04,F
53D2:  COMF   x04,F
53D4:  RLCF   x04,F
53D6:  MOVLB  2
53D8:  MOVF   xFE,W
53DA:  ANDLW  0F
53DC:  MOVLB  3
53DE:  ADDWF  x04,F
53E0:  RLCF   x01,F
53E2:  MOVLW  07
53E4:  MOVWF  x00
53E6:  MOVLW  0A
53E8:  DECF   x03,F
53EA:  ADDWF  x04,F
53EC:  BNC   53E8
53EE:  DECF   x02,F
53F0:  ADDWF  x03,F
53F2:  BNC   53EE
53F4:  DECF   x01,F
53F6:  ADDWF  x02,F
53F8:  BNC   53F4
53FA:  DECF   x00,F
53FC:  ADDWF  x01,F
53FE:  BNC   53FA
5400:  MOVLW  03
5402:  MOVWF  FEA
5404:  CLRF   FE9
5406:  MOVLW  07
5408:  ANDWF  x05,W
540A:  BCF    x05.6
540C:  ADDWF  FE9,F
540E:  MOVLW  00
5410:  ADDWFC FEA,F
5412:  MOVF   FE9,W
5414:  SUBLW  04
5416:  BNZ   5420
5418:  MOVF   FEA,W
541A:  SUBLW  03
541C:  BNZ   5420
541E:  BSF    x05.6
5420:  MOVF   FEF,W
5422:  MOVWF  00
5424:  BNZ   5436
5426:  BTFSC  x05.6
5428:  BRA    5436
542A:  BTFSC  x05.4
542C:  BRA    5458
542E:  BTFSC  x05.3
5430:  BRA    5436
5432:  MOVLW  20
5434:  BRA    543C
5436:  BSF    x05.3
5438:  BCF    x05.4
543A:  MOVLW  30
543C:  ADDWF  00,F
543E:  MOVFF  FEA,2FF
5442:  MOVFF  FE9,2FE
5446:  MOVFF  00,31C
544A:  MOVLB  0
544C:  RCALL  5358
544E:  MOVFF  2FF,FEA
5452:  MOVFF  2FE,FE9
5456:  MOVLB  3
5458:  MOVF   FEE,W
545A:  BTFSS  x05.6
545C:  BRA    5412
545E:  MOVLB  0
5460:  GOTO   5C56 (RETURN)
5464:  TBLRD*+
5466:  MOVF   FF5,F
5468:  BZ    5482
546A:  MOVFF  FF6,2FE
546E:  MOVFF  FF7,2FF
5472:  MOVFF  FF5,31C
5476:  RCALL  5358
5478:  MOVFF  2FE,FF6
547C:  MOVFF  2FF,FF7
5480:  BRA    5464
5482:  RETURN 0
5484:  MOVF   FEF,F
5486:  BZ    54A6
5488:  MOVFF  FEA,2FF
548C:  MOVFF  FE9,2FE
5490:  MOVFF  FEF,31C
5494:  RCALL  5358
5496:  MOVFF  2FF,FEA
549A:  MOVFF  2FE,FE9
549E:  INCF   FE9,F
54A0:  BTFSC  FD8.2
54A2:  INCF   FEA,F
54A4:  BRA    5484
54A6:  GOTO   5D0C (RETURN)
*
565A:  MOVFF  321,01
565E:  MOVFF  320,00
5662:  TSTFSZ 00
5664:  INCF   01,F
5666:  TBLRD*+
5668:  MOVFF  FF5,FEE
566C:  DECFSZ 00,F
566E:  BRA    5666
5670:  DECFSZ 01,F
5672:  BRA    5666
5674:  CLRF   FF8
5676:  RETURN 0
*
58E0:  MOVFF  7A,FEA
58E4:  MOVFF  79,FE9
58E8:  MOVFF  323,FEF
58EC:  INCF   FE9,F
58EE:  BTFSC  FD8.2
58F0:  INCF   FEA,F
58F2:  CLRF   FEF
58F4:  MOVLB  0
58F6:  INCF   x79,F
58F8:  BTFSC  FD8.2
58FA:  INCF   x7A,F
58FC:  RETURN 0
58FE:  MOVLB  3
5900:  BTFSC  x1E.7
5902:  BRA    5926
5904:  MOVLW  0F
5906:  MOVWF  00
5908:  SWAPF  x1D,W
590A:  ANDWF  00,F
590C:  MOVLW  0A
590E:  SUBWF  00,W
5910:  BC    5918
5912:  MOVLW  30
5914:  ADDWF  00,F
5916:  BRA    591C
5918:  MOVF   x1E,W
591A:  ADDWF  00,F
591C:  MOVFF  00,323
5920:  MOVLB  0
5922:  RCALL  58E0
5924:  MOVLB  3
5926:  MOVLW  0F
5928:  ANDWF  x1D,F
592A:  MOVLW  0A
592C:  SUBWF  x1D,W
592E:  BC    5934
5930:  MOVLW  30
5932:  BRA    5938
5934:  BCF    x1E.7
5936:  MOVF   x1E,W
5938:  ADDWF  x1D,F
593A:  MOVFF  31D,323
593E:  MOVLB  0
5940:  RCALL  58E0
5942:  GOTO   5AF6 (RETURN)
5946:  MOVLW  20
5948:  MOVLB  3
594A:  BTFSS  x1E.4
594C:  MOVLW  30
594E:  MOVWF  x1F
5950:  MOVFF  31D,00
5954:  BTFSS  00.7
5956:  BRA    5968
5958:  COMF   00,F
595A:  INCF   00,F
595C:  MOVFF  00,31D
5960:  MOVLW  2D
5962:  MOVWF  x1F
5964:  BSF    x1E.7
5966:  BSF    x1E.0
5968:  MOVF   01,W
596A:  MOVFF  31D,323
596E:  MOVLW  64
5970:  MOVWF  x24
5972:  MOVLB  0
5974:  CALL   10B2
5978:  MOVFF  00,31D
597C:  MOVLW  30
597E:  ADDWF  01,W
5980:  MOVLB  3
5982:  MOVWF  x20
5984:  MOVFF  31D,323
5988:  MOVLW  0A
598A:  MOVWF  x24
598C:  MOVLB  0
598E:  CALL   10B2
5992:  MOVLW  30
5994:  ADDWF  00,W
5996:  MOVLB  3
5998:  MOVWF  x22
599A:  MOVLW  30
599C:  ADDWF  01,W
599E:  MOVWF  x21
59A0:  MOVFF  31F,00
59A4:  MOVLW  30
59A6:  SUBWF  x20,W
59A8:  BZ    59B2
59AA:  BSF    x1E.1
59AC:  BTFSC  x1E.7
59AE:  BSF    x1E.2
59B0:  BRA    59D6
59B2:  MOVFF  31F,320
59B6:  MOVLW  20
59B8:  MOVWF  x1F
59BA:  MOVLW  30
59BC:  SUBWF  x21,W
59BE:  BZ    59C8
59C0:  BSF    x1E.0
59C2:  BTFSC  x1E.7
59C4:  BSF    x1E.1
59C6:  BRA    59D6
59C8:  BTFSS  FD8.2
59CA:  BSF    x1E.0
59CC:  BNZ   59D6
59CE:  MOVFF  320,321
59D2:  MOVLW  20
59D4:  MOVWF  x20
59D6:  BTFSC  x1E.2
59D8:  BRA    59E4
59DA:  BTFSC  x1E.1
59DC:  BRA    59EC
59DE:  BTFSC  x1E.0
59E0:  BRA    59F4
59E2:  BRA    59FC
59E4:  MOVFF  31F,323
59E8:  MOVLB  0
59EA:  RCALL  58E0
59EC:  MOVFF  320,323
59F0:  MOVLB  0
59F2:  RCALL  58E0
59F4:  MOVFF  321,323
59F8:  MOVLB  0
59FA:  RCALL  58E0
59FC:  MOVFF  322,323
5A00:  MOVLB  0
5A02:  RCALL  58E0
5A04:  GOTO   5B2C (RETURN)
*
6E1C:  ADDWF  FE8,W
6E1E:  CLRF   FF7
6E20:  RLCF   FF7,F
6E22:  ADDLW  37
6E24:  MOVWF  FF6
6E26:  MOVLW  6E
6E28:  ADDWFC FF7,F
6E2A:  TBLRD*-
6E2C:  MOVF   FF5,W
6E2E:  MOVWF  FFA
6E30:  TBLRD*
6E32:  MOVF   FF5,W
6E34:  MOVWF  FF9
6E36:  DATA 7A,6C
6E38:  DATA 7A,6C
6E3A:  DATA D2,6C
6E3C:  DATA 60,6D
6E3E:  DATA C0,6D
6E40:  DATA C0,6C
6E42:  DATA 32,6D
.................... 
.................... #list
.................... 
.................... #device ADC=8
.................... #use delay(clock=20000000)
*
04DE:  MOVLW  03
04E0:  MOVWF  FEA
04E2:  MOVLW  13
04E4:  MOVWF  FE9
04E6:  MOVF   FEF,W
04E8:  BZ    0504
04EA:  MOVLW  06
04EC:  MOVWF  01
04EE:  CLRF   00
04F0:  DECFSZ 00,F
04F2:  BRA    04F0
04F4:  DECFSZ 01,F
04F6:  BRA    04EE
04F8:  MOVLW  7B
04FA:  MOVWF  00
04FC:  DECFSZ 00,F
04FE:  BRA    04FC
0500:  DECFSZ FEF,F
0502:  BRA    04EA
0504:  RETURN 0
*
499E:  MOVLW  03
49A0:  MOVLB  3
49A2:  SUBWF  x18,F
49A4:  BNC   49BA
49A6:  MOVLW  03
49A8:  MOVWF  FEA
49AA:  MOVLW  18
49AC:  MOVWF  FE9
49AE:  MOVF   FEF,W
49B0:  BZ    49BA
49B2:  BRA    49B6
49B4:  BRA    49B6
49B6:  DECFSZ FEF,F
49B8:  BRA    49B4
49BA:  MOVLB  0
49BC:  RETURN 0
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,VREGEN,NOPBADEN,WRTB
.................... 
.................... #byte porte = 0xF84
.................... #byte trisc=0x87
.................... #byte portc = 0x07
.................... 
.................... /** Configuración para el uso del stack tcip **/
.................... #define STACK_USE_ICMP        1  //Módulo de respuesta ICMP (ping)
.................... #define STACK_USE_ARP         1  //Para solucionar direccionamiento MAC de las IP
.................... #define STACK_USE_TCP         1  //Para enviar paquetes TCP 
.................... #define STACK_USE_HTTP        1  //Uso de las funciones http del stack.
.................... #define STACK_USE_CCS_PICENS  1  //CCS PICENS (Embedded Ethernet) 18F4620 + ENC28J60
.................... #define STACK_USE_MCPENC      1  //Uso del enc28j60 por el stack (stacktsk.c)
.................... #define STACK_USE_MAC         1  //Uso de la tarjeta de red
.................... #define HTTP_SOCKET 80         //Nº de puerto asociado al socket.
.................... #define ENC_MAC_USE_SPI 1           //Uso del SPI por hardware
.................... #define PIN_ENC_MAC_SO  PIN_B0      //Entrada serie de datos
.................... #define PIN_ENC_MAC_CS  PIN_B2      //Chip select
.................... #define PIN_ENC_MAC_RST PIN_B3      //Reset
.................... #define PIN_ENC_MAC_INT PIN_B4      //Interrupción
.................... /******************************************************************************/
.................... 
.................... #define use_portd_lcd TRUE       //Uso del puerto d para control del lcd
.................... #include <LCD420PIC18F_RyP.c>    //Carga librería del lcd de 4x20 para familia 18F
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //                                                                            //
.................... //           LIBRERIA PARA CONTROL DE LCD 4X20 con PIC 18F4550                //
.................... //                                                                            //
.................... //                                                                            //
.................... //      Se debe llamar a este archivo mediante #include <LCD420PIC18_RyP.c>   //
.................... //                                                                            //
.................... //      Es necesariodefinir el puerto a utilizar para el teclado mediante:    //
.................... //      #define use_portb_lcd TRUE   //para el puerto B                       //
.................... //      #define use_portd_lcd TRUE   //para el puerto D                       //
.................... //                                                                            //
.................... //      FUNCIONES:                                                            //
.................... //      void lcd_init(void);         //Inicializa el lcd.                     //
.................... //                                                                            //
.................... //                                                                            //
.................... //                            RobotyPic 2013                                  //
.................... //                    http://robotypic.blogspot.com/                          //
.................... //                                                                            //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //Elección del puerto y pines
.................... 
.................... #ifdef use_portd_lcd
.................... 
.................... #define LCD_DB4  PIN_D4
.................... #define LCD_DB5  PIN_D5
.................... #define LCD_DB6  PIN_D6
.................... #define LCD_DB7  PIN_D7
.................... #define LCD_E    PIN_D0
.................... #define LCD_RS   PIN_D1
.................... #define LCD_RW   PIN_D2
.................... 
.................... #else
.................... 
.................... #define LCD_DB4  PIN_B4
.................... #define LCD_DB5  PIN_B5
.................... #define LCD_DB6  PIN_B6
.................... #define LCD_DB7  PIN_B7
.................... #define LCD_E    PIN_B0
.................... #define LCD_RS   PIN_B1
.................... #define LCD_RW   PIN_B2
.................... 
.................... #endif
.................... 
.................... // If you only want a 6-pin interface to your LCD, then
.................... // connect the R/W pin on the LCD to ground, and comment
.................... // out the following line.
.................... 
.................... #define USE_LCD_RW  1    
.................... 
.................... 
.................... #define lcd_type 2
.................... #define lcd_line_two 0x40
.................... 
.................... BYTE lcdline;
.................... 
.................... int8 const LCD_INIT_STRING[4] =
.................... {
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots
....................  0xc,                    // Display on
....................  1,                      // Clear display
....................  6                      // Increment cursor
....................  };
.................... 
.................... 
.................... //-------------------------------------
.................... void lcd_send_nibble(int8 nibble)
.................... {
....................  output_bit(LCD_DB4, !!(nibble & 1));
*
0506:  MOVLB  3
0508:  BTFSC  x13.0
050A:  BRA    0510
050C:  BCF    F8C.4
050E:  BRA    0512
0510:  BSF    F8C.4
0512:  BCF    F95.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
0514:  BTFSC  x13.1
0516:  BRA    051C
0518:  BCF    F8C.5
051A:  BRA    051E
051C:  BSF    F8C.5
051E:  BCF    F95.5
....................  output_bit(LCD_DB6, !!(nibble & 4));  
0520:  BTFSC  x13.2
0522:  BRA    0528
0524:  BCF    F8C.6
0526:  BRA    052A
0528:  BSF    F8C.6
052A:  BCF    F95.6
....................  output_bit(LCD_DB7, !!(nibble & 8));  
052C:  BTFSC  x13.3
052E:  BRA    0534
0530:  BCF    F8C.7
0532:  BRA    0536
0534:  BSF    F8C.7
0536:  BCF    F95.7
.................... 
....................  delay_cycles(1);
0538:  NOP   
....................  output_high(LCD_E);
053A:  BCF    F95.0
053C:  BSF    F8C.0
....................  delay_us(2);
053E:  MOVLW  03
0540:  MOVWF  00
0542:  DECFSZ 00,F
0544:  BRA    0542
....................  output_low(LCD_E);
0546:  BCF    F95.0
0548:  BCF    F8C.0
054A:  MOVLB  0
054C:  RETURN 0
.................... }
.................... 
.................... #ifdef USE_LCD_RW
.................... int8 lcd_read_nibble(void)
.................... {
.................... int8 retval;
.................... #bit retval_0 = retval.0
.................... #bit retval_1 = retval.1
.................... #bit retval_2 = retval.2
.................... #bit retval_3 = retval.3
.................... 
.................... retval = 0;
054E:  MOVLB  3
0550:  CLRF   x14
....................   
.................... output_high(LCD_E);
0552:  BCF    F95.0
0554:  BSF    F8C.0
.................... delay_cycles(1);
0556:  NOP   
.................... 
.................... retval_0 = input(LCD_DB4);
0558:  BSF    F95.4
055A:  BCF    x14.0
055C:  BTFSC  F83.4
055E:  BSF    x14.0
.................... retval_1 = input(LCD_DB5);
0560:  BSF    F95.5
0562:  BCF    x14.1
0564:  BTFSC  F83.5
0566:  BSF    x14.1
.................... retval_2 = input(LCD_DB6);
0568:  BSF    F95.6
056A:  BCF    x14.2
056C:  BTFSC  F83.6
056E:  BSF    x14.2
.................... retval_3 = input(LCD_DB7);
0570:  BSF    F95.7
0572:  BCF    x14.3
0574:  BTFSC  F83.7
0576:  BSF    x14.3
....................  
.................... output_low(LCD_E);
0578:  BCF    F95.0
057A:  BCF    F8C.0
....................   
.................... return(retval);  
057C:  MOVFF  314,01
0580:  MOVLB  0
0582:  RETURN 0
.................... }  
.................... #endif
.................... 
.................... #ifdef USE_LCD_RW
.................... int8 lcd_read_byte(void)
.................... {
.................... int8 low;
.................... int8 high;
.................... 
.................... output_high(LCD_RW);
0584:  BCF    F95.2
0586:  BSF    F8C.2
.................... delay_cycles(1);
0588:  NOP   
.................... 
.................... high = lcd_read_nibble();
058A:  RCALL  054E
058C:  MOVFF  01,313
.................... 
.................... low = lcd_read_nibble();
0590:  RCALL  054E
0592:  MOVFF  01,312
.................... 
.................... return( (high<<4) | low);
0596:  MOVLB  3
0598:  SWAPF  x13,W
059A:  MOVWF  00
059C:  MOVLW  F0
059E:  ANDWF  00,F
05A0:  MOVF   00,W
05A2:  IORWF  x12,W
05A4:  MOVWF  01
05A6:  MOVLB  0
05A8:  GOTO   05B2 (RETURN)
.................... }
.................... #endif
.................... 
.................... void lcd_send_byte(int8 address, int8 n)
.................... {
.................... output_low(LCD_RS);
05AC:  BCF    F95.1
05AE:  BCF    F8C.1
.................... 
.................... #ifdef USE_LCD_RW
.................... while(bit_test(lcd_read_byte(),7)) ;
05B0:  BRA    0584
05B2:  MOVFF  01,312
05B6:  MOVLB  3
05B8:  BTFSS  01.7
05BA:  BRA    05C0
05BC:  MOVLB  0
05BE:  BRA    05B0
.................... #else
.................... delay_us(60); 
.................... #endif
.................... 
.................... if(address)
05C0:  MOVF   x10,F
05C2:  BZ    05CA
....................   output_high(LCD_RS);
05C4:  BCF    F95.1
05C6:  BSF    F8C.1
05C8:  BRA    05CE
.................... else
....................   output_low(LCD_RS);
05CA:  BCF    F95.1
05CC:  BCF    F8C.1
....................     
....................  delay_cycles(1);
05CE:  NOP   
.................... 
.................... #ifdef USE_LCD_RW
.................... output_low(LCD_RW);
05D0:  BCF    F95.2
05D2:  BCF    F8C.2
.................... delay_cycles(1);
05D4:  NOP   
.................... #endif
.................... 
.................... output_low(LCD_E);
05D6:  BCF    F95.0
05D8:  BCF    F8C.0
.................... 
.................... lcd_send_nibble(n >> 4);
05DA:  SWAPF  x11,W
05DC:  MOVWF  x12
05DE:  MOVLW  0F
05E0:  ANDWF  x12,F
05E2:  MOVFF  312,313
05E6:  MOVLB  0
05E8:  RCALL  0506
.................... lcd_send_nibble(n & 0xf);
05EA:  MOVLB  3
05EC:  MOVF   x11,W
05EE:  ANDLW  0F
05F0:  MOVWF  x12
05F2:  MOVWF  x13
05F4:  MOVLB  0
05F6:  RCALL  0506
05F8:  RETURN 0
.................... }
.................... 
.................... void lcd_init(void)
.................... {
.................... int8 i;
.................... 
.................... output_low(LCD_RS);
05FA:  BCF    F95.1
05FC:  BCF    F8C.1
.................... 
.................... #ifdef USE_LCD_RW
.................... output_low(LCD_RW);
05FE:  BCF    F95.2
0600:  BCF    F8C.2
.................... #endif
.................... 
.................... output_low(LCD_E);
0602:  BCF    F95.0
0604:  BCF    F8C.0
.................... 
.................... delay_ms(15);
0606:  MOVLW  0F
0608:  MOVLB  3
060A:  MOVWF  x13
060C:  MOVLB  0
060E:  RCALL  04DE
.................... 
.................... for(i=0 ;i < 3; i++)
0610:  MOVLB  2
0612:  CLRF   xE0
0614:  MOVF   xE0,W
0616:  SUBLW  02
0618:  BNC   0634
....................   {
....................     lcd_send_nibble(0x03);
061A:  MOVLW  03
061C:  MOVLB  3
061E:  MOVWF  x13
0620:  MOVLB  0
0622:  RCALL  0506
....................     delay_ms(5);
0624:  MOVLW  05
0626:  MOVLB  3
0628:  MOVWF  x13
062A:  MOVLB  0
062C:  RCALL  04DE
062E:  MOVLB  2
0630:  INCF   xE0,F
0632:  BRA    0614
....................   }
.................... 
.................... lcd_send_nibble(0x02);
0634:  MOVLW  02
0636:  MOVLB  3
0638:  MOVWF  x13
063A:  MOVLB  0
063C:  RCALL  0506
.................... 
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)
063E:  MOVLB  2
0640:  CLRF   xE0
0642:  MOVF   xE0,W
0644:  SUBLW  03
0646:  BNC   0664
....................   {
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);
0648:  CLRF   03
064A:  MOVF   xE0,W
064C:  MOVLB  0
064E:  RCALL  00AE
0650:  MOVLB  2
0652:  MOVWF  xE1
0654:  MOVLB  3
0656:  CLRF   x10
0658:  MOVWF  x11
065A:  MOVLB  0
065C:  RCALL  05AC
....................   
....................     #ifndef USE_LCD_RW
065E:  MOVLB  2
0660:  INCF   xE0,F
0662:  BRA    0642
....................     delay_ms(5);
....................     #endif
....................   }
0664:  MOVLB  0
0666:  GOTO   6F40 (RETURN)
.................... 
.................... }
.................... 
.................... void lcd_gotoxy( BYTE x, BYTE y)
.................... {
....................   BYTE address;
....................  
.................... 
....................   switch(y)
066A:  MOVLW  01
066C:  MOVLB  3
066E:  SUBWF  x0E,W
0670:  ADDLW  FC
0672:  BC    06AE
0674:  ADDLW  04
0676:  MOVLB  0
0678:  GOTO   06C0
....................   {
....................     case 1 : address=0x80;
067C:  MOVLW  80
067E:  MOVLB  3
0680:  MOVWF  x0F
....................     lcdline=1;
0682:  MOVLW  01
0684:  MOVWF  04
....................     break;
0686:  BRA    06AE
....................     case 2 : address=0xc0;
0688:  MOVLW  C0
068A:  MOVLB  3
068C:  MOVWF  x0F
....................     lcdline=2;
068E:  MOVLW  02
0690:  MOVWF  04
....................     break;
0692:  BRA    06AE
....................     case 3 : address=0x94;
0694:  MOVLW  94
0696:  MOVLB  3
0698:  MOVWF  x0F
....................     lcdline=3;
069A:  MOVLW  03
069C:  MOVWF  04
....................     break;
069E:  BRA    06AE
....................     case 4 : address=0xd4;
06A0:  MOVLW  D4
06A2:  MOVLB  3
06A4:  MOVWF  x0F
....................     lcdline=4;
06A6:  MOVLW  04
06A8:  MOVWF  04
....................     break;
06AA:  BRA    06AE
06AC:  MOVLB  3
....................   }
.................... 
....................   address+=x-1;
06AE:  MOVLW  01
06B0:  SUBWF  x0D,W
06B2:  ADDWF  x0F,F
....................   lcd_send_byte(0,address);
06B4:  CLRF   x10
06B6:  MOVFF  30F,311
06BA:  MOVLB  0
06BC:  RCALL  05AC
06BE:  RETURN 0
.................... }
.................... 
.................... 
.................... void lcd_putc(char c)
.................... {
....................  switch(c)
*
06E2:  MOVLB  3
06E4:  MOVF   x0C,W
06E6:  XORLW  0C
06E8:  MOVLB  0
06EA:  BZ    06F6
06EC:  XORLW  06
06EE:  BZ    0712
06F0:  XORLW  02
06F2:  BZ    0736
06F4:  BRA    0744
....................   {
....................     case '\f':
....................       lcd_send_byte(0,1);
06F6:  MOVLB  3
06F8:  CLRF   x10
06FA:  MOVLW  01
06FC:  MOVWF  x11
06FE:  MOVLB  0
0700:  RCALL  05AC
....................       lcdline=1;
0702:  MOVLW  01
0704:  MOVWF  04
....................       delay_ms(2);
0706:  MOVLW  02
0708:  MOVLB  3
070A:  MOVWF  x13
070C:  MOVLB  0
070E:  RCALL  04DE
....................       break;
0710:  BRA    0752
....................   
....................     case '\n':
....................       lcd_gotoxy(1,++lcdline);
0712:  INCF   04,F
0714:  MOVLW  01
0716:  MOVLB  3
0718:  MOVWF  x0D
071A:  MOVFF  04,30E
071E:  MOVLB  0
0720:  RCALL  066A
....................       if (lcdline>4) lcd_gotoxy(1,1);
0722:  MOVF   04,W
0724:  SUBLW  04
0726:  BC    0734
0728:  MOVLW  01
072A:  MOVLB  3
072C:  MOVWF  x0D
072E:  MOVWF  x0E
0730:  MOVLB  0
0732:  RCALL  066A
....................       break;
0734:  BRA    0752
....................   
....................     case '\b':
....................       lcd_send_byte(0,0x10);
0736:  MOVLB  3
0738:  CLRF   x10
073A:  MOVLW  10
073C:  MOVWF  x11
073E:  MOVLB  0
0740:  RCALL  05AC
....................       break;
0742:  BRA    0752
....................   
....................     default:
....................       lcd_send_byte(1,c);
0744:  MOVLW  01
0746:  MOVLB  3
0748:  MOVWF  x10
074A:  MOVFF  30C,311
074E:  MOVLB  0
0750:  RCALL  05AC
....................       break;
....................   }
0752:  RETURN 0
.................... }
.................... 
.................... #ifdef USE_LCD_RW
.................... char lcd_getc(int8 x, int8 y)
.................... {
.................... char value;
.................... 
.................... lcd_gotoxy(x,y);
.................... 
.................... // Wait until busy flag is low.
.................... while(bit_test(lcd_read_byte(),7)); 
.................... 
.................... output_high(LCD_RS);
.................... value = lcd_read_byte();
.................... output_low(lcd_RS);
.................... 
.................... return(value);
.................... }
.................... #endif
.................... 
.................... #include "tcpip/stacktsk.c"      //Carga el stack TCP/IP de Microchip 
.................... /*********************************************************************
....................  *
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.c
....................  * Dependencies:    StackTsk.H
....................  *                  ARPTsk.h
....................  *                  MAC.h
....................  *                  IP.h
....................  *                  ICMP.h
....................  *                  Tcp.h
....................  *                  http.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess()
....................  *                                  to include localIP as third param.
....................  *                                  This was done to allow these functions
....................  *                                  to calculate checksum correctly.
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not
....................  *                                  clear statically IP address if link is
....................  *                                  removed and DHCP module is disabled
....................  *                                  at runtime.
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler.
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #case
.................... 
.................... #define STACK_INCLUDE
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... /*********************************************************************
....................  *
....................  *                  PIC18 SFR Definitions
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        pic18.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or later
....................  *
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  ********************************************************************/
.................... #ifndef COMPILER_H
.................... #define COMPILER_H
.................... 
.................... #if !defined(__PCH__)
.................... #error "This version only works with CCS PCH or PCWH"
.................... #endif
.................... 
.................... // ** I/O PORT REGISTERS
.................... 
.................... #byte PORTA    =  0xF80
.................... #byte PORTB    =  0xF81
.................... #byte PORTC    =  0xF82
.................... #byte PORTD    =  0xF83
.................... #byte PORTE    =  0xF84
.................... #byte PORTF    =  0xF85
.................... 
.................... #bit PORTA_RA5 =  0xF80.5
.................... #bit PORTA_RA4 =  0xF80.4
.................... #bit PORTA_RA3 =  0xF80.3
.................... #bit PORTA_RA2 =  0xF80.2
.................... #bit PORTA_RA1 =  0xF80.1
.................... #bit PORTA_RA0 =  0xF80.0
.................... 
.................... #bit PORTB_RB7 =  0xF81.7
.................... #bit PORTB_RB6 =  0xF81.6
.................... #bit PORTB_RB5 =  0xF81.5
.................... #bit PORTB_RB4 =  0xF81.4
.................... #bit PORTB_RB3 =  0xF81.3
.................... #bit PORTB_RB2 =  0xF81.2
.................... #bit PORTB_RB1 =  0xF81.1
.................... #bit PORTB_RB0 =  0xF81.0
.................... 
.................... #bit PORTC_RC7 =  0xF82.7
.................... #bit PORTC_RC6 =  0xF82.6
.................... #bit PORTC_RC5 =  0xF82.5
.................... #bit PORTC_RC4 =  0xF82.4
.................... #bit PORTC_RC3 =  0xF82.3
.................... #bit PORTC_RC2 =  0xF82.2
.................... #bit PORTC_RC1 =  0xF82.1
.................... #bit PORTC_RC0 =  0xF82.0
.................... 
.................... #bit PORTD_RD7 =  0xF83.7
.................... #bit PORTD_RD6 =  0xF83.6
.................... #bit PORTD_RD5 =  0xF83.5
.................... #bit PORTD_RD4 =  0xF83.4
.................... #bit PORTD_RD3 =  0xF83.3
.................... #bit PORTD_RD2 =  0xF83.2
.................... #bit PORTD_RD1 =  0xF83.1
.................... #bit PORTD_RD0 =  0xF83.0
.................... 
.................... #bit PORTE_RE7 =  0xF84.7
.................... #bit PORTE_RE6 =  0xF84.6
.................... #bit PORTE_RE5 =  0xF84.5
.................... #bit PORTE_RE4 =  0xF84.4
.................... #bit PORTE_RE3 =  0xF84.3
.................... #bit PORTE_RE2 =  0xF84.2
.................... #bit PORTE_RE1 =  0xF84.1
.................... #bit PORTE_RE0 =  0xF84.0
.................... 
.................... #bit PORTF_RF7 =  0xF85.7
.................... #bit PORTF_RF6 =  0xF85.6
.................... #bit PORTF_RF5 =  0xF85.5
.................... #bit PORTF_RF4 =  0xF85.4
.................... #bit PORTF_RF3 =  0xF85.3
.................... #bit PORTF_RF2 =  0xF85.2
.................... #bit PORTF_RF1 =  0xF85.1
.................... #bit PORTF_RF0 =  0xF85.0
.................... 
.................... 
.................... // *** TRIS REGISTERS
.................... 
.................... #byte TRISA    =  0xF92
.................... #byte TRISB    =  0xF93
.................... #byte TRISC    =  0xF94
.................... #byte TRISD    =  0xF95
.................... #byte TRISE    =  0xF96
.................... #byte TRISF    =  0xF97
.................... 
.................... #bit TRISA_RA7 =  0xF92.7
.................... #bit TRISA_RA6 =  0xF92.6
.................... #bit TRISA_RA5 =  0xF92.5
.................... #bit TRISA_RA4 =  0xF92.4
.................... #bit TRISA_RA3 =  0xF92.3
.................... #bit TRISA_RA2 =  0xF92.2
.................... #bit TRISA_RA1 =  0xF92.1
.................... #bit TRISA_RA0 =  0xF92.0
.................... 
.................... #bit TRISB_RB7 =  0xF93.7
.................... #bit TRISB_RB6 =  0xF93.6
.................... #bit TRISB_RB5 =  0xF93.5
.................... #bit TRISB_RB4 =  0xF93.4
.................... #bit TRISB_RB3 =  0xF93.3
.................... #bit TRISB_RB2 =  0xF93.2
.................... #bit TRISB_RB1 =  0xF93.1
.................... #bit TRISB_RB0 =  0xF93.0
.................... 
.................... #bit TRISC_RC7 =  0xF94.7
.................... #bit TRISC_RC6 =  0xF94.6
.................... #bit TRISC_RC5 =  0xF94.5
.................... #bit TRISC_RC4 =  0xF94.4
.................... #bit TRISC_RC3 =  0xF94.3
.................... #bit TRISC_RC2 =  0xF94.2
.................... #bit TRISC_RC1 =  0xF94.1
.................... #bit TRISC_RC0 =  0xF94.0
.................... 
.................... #bit TRISD_RD7 =  0xF95.7
.................... #bit TRISD_RD6 =  0xF95.6
.................... #bit TRISD_RD5 =  0xF95.5
.................... #bit TRISD_RD4 =  0xF95.4
.................... #bit TRISD_RD3 =  0xF95.3
.................... #bit TRISD_RD2 =  0xF95.2
.................... #bit TRISD_RD1 =  0xF95.1
.................... #bit TRISD_RD0 =  0xF95.0
.................... 
.................... #bit TRISE_RE7 =  0xF96.7
.................... #bit TRISE_RE6 =  0xF96.6
.................... #bit TRISE_RE5 =  0xF96.5
.................... #bit TRISE_RE4 =  0xF96.4
.................... #bit TRISE_RE3 =  0xF96.3
.................... #bit TRISE_RE2 =  0xF96.2
.................... #bit TRISE_RE1 =  0xF96.1
.................... #bit TRISE_RE0 =  0xF96.0
.................... 
.................... #bit TRISF_RF7 =  0xF97.7
.................... #bit TRISF_RF6 =  0xF97.6
.................... #bit TRISF_RF5 =  0xF97.5
.................... #bit TRISF_RF4 =  0xF97.4
.................... #bit TRISF_RF3 =  0xF97.3
.................... #bit TRISF_RF2 =  0xF97.2
.................... #bit TRISF_RF1 =  0xF97.1
.................... #bit TRISF_RF0 =  0xF97.0
.................... 
.................... 
.................... // *** LAT REGISTERS
.................... #byte LATA    =  0xF89
.................... #byte LATB    =  0xF8A
.................... #byte LATC    =  0xF8B
.................... #byte LATD    =  0xF8C
.................... #byte LATE    =  0xF8D
.................... #byte LATF    =  0xF8E
.................... 
.................... #bit LATA_RA7 =  0xF89.7
.................... #bit LATA_RA6 =  0xF89.6
.................... #bit LATA_RA5 =  0xF89.5
.................... #bit LATA_RA4 =  0xF89.4
.................... #bit LATA_RA3 =  0xF89.3
.................... #bit LATA_RA2 =  0xF89.2
.................... #bit LATA_RA1 =  0xF89.1
.................... #bit LATA_RA0 =  0xF89.0
.................... 
.................... #bit LATB_RB7 =  0xF8A.7
.................... #bit LATB_RB6 =  0xF8A.6
.................... #bit LATB_RB5 =  0xF8A.5
.................... #bit LATB_RB4 =  0xF8A.4
.................... #bit LATB_RB3 =  0xF8A.3
.................... #bit LATB_RB2 =  0xF8A.2
.................... #bit LATB_RB1 =  0xF8A.1
.................... #bit LATB_RB0 =  0xF8A.0
.................... 
.................... #bit LATC_RC7 =  0xF8B.7
.................... #bit LATC_RC6 =  0xF8B.6
.................... #bit LATC_RC5 =  0xF8B.5
.................... #bit LATC_RC4 =  0xF8B.4
.................... #bit LATC_RC3 =  0xF8B.3
.................... #bit LATC_RC2 =  0xF8B.2
.................... #bit LATC_RC1 =  0xF8B.1
.................... #bit LATC_RC0 =  0xF8B.0
.................... 
.................... #bit LATD_RD7 =  0xF8C.7
.................... #bit LATD_RD6 =  0xF8C.6
.................... #bit LATD_RD5 =  0xF8C.5
.................... #bit LATD_RD4 =  0xF8C.4
.................... #bit LATD_RD3 =  0xF8C.3
.................... #bit LATD_RD2 =  0xF8C.2
.................... #bit LATD_RD1 =  0xF8C.1
.................... #bit LATD_RD0 =  0xF8C.0
.................... 
.................... #bit LATE_RE7 =  0xF8D.7
.................... #bit LATE_RE6 =  0xF8D.6
.................... #bit LATE_RE5 =  0xF8D.5
.................... #bit LATE_RE4 =  0xF8D.4
.................... #bit LATE_RE3 =  0xF8D.3
.................... #bit LATE_RE2 =  0xF8D.2
.................... #bit LATE_RE1 =  0xF8D.1
.................... #bit LATE_RE0 =  0xF8D.0
.................... 
.................... #bit LATF_RF7 =  0xF8E.7
.................... #bit LATF_RF6 =  0xF8E.6
.................... #bit LATF_RF5 =  0xF8E.5
.................... #bit LATF_RF4 =  0xF8E.4
.................... #bit LATF_RF3 =  0xF8E.3
.................... #bit LATF_RF2 =  0xF8E.2
.................... #bit LATF_RF1 =  0xF8E.1
.................... #bit LATF_RF0 =  0xF8E.0
.................... 
.................... 
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP
.................... 
.................... #bit  PIE1_TXIE       =  0xF9D.4
.................... #bit  PIE1_RCIE       =  0xF9D.5
.................... #bit  PIR1_TXIF       =  0xF9E.4
.................... #bit  PIR1_RCIF       =  0xF9E.5
.................... #byte TXSTA           =  0xFAC
.................... #byte RCSTA           =  0xFAB
.................... #bit  RCSTA_CREN      =  0xFAB.4
.................... #byte RCREG           =  0xFAE
.................... #byte SPBRG           =  0xFAF
.................... #byte TXREG           =  0xFAD
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                         HARDWARE.H                                ////
.................... ////                                                                   ////
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. ////
.................... ////                                                                   ////
.................... //// These values will probably change with each application.          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// RELEASE HISTORY:                                                  ////
.................... ////                                                                   ////
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT ////
.................... ////                  moved to here.                                   ////
.................... ////                                                                   ////
.................... ////    Jan 09, 2004: Initial Public Release                           ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION
.................... #define ___TCPIP_STACK_CONFIGURATION
.................... 
.................... 
.................... #ifndef STACK_USE_CCS_PICNET
.................... #define STACK_USE_CCS_PICNET  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_CCS_PICENS
.................... #define STACK_USE_CCS_PICENS  FALSE
.................... #endif
.................... 
.................... 
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT.
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED.
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE
.................... 
.................... 
.................... ///DEFAULT HARDCODED IP ADDRESSES.
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM.
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP).
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address.
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        1
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        10
.................... 
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network.
....................    #define MY_DEFAULT_MASK_BYTE4           0x00
.................... 
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks.
....................    #define MY_DEFAULT_GATE_BYTE3           1
....................    #define MY_DEFAULT_GATE_BYTE4           1
.................... 
.................... ///DEFAULT HARDCODED MAC ADDRESS.
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER.
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS.
.................... #define MY_DEFAULT_MAC_BYTE1            0x00
.................... #define MY_DEFAULT_MAC_BYTE2            0x02
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3
.................... #define MY_DEFAULT_MAC_BYTE4            0x04
.................... #define MY_DEFAULT_MAC_BYTE5            0x05
.................... #define MY_DEFAULT_MAC_BYTE6            0x06
.................... 
.................... ///Maximum sockets to be defined.
.................... /// Note that each socket consumes 36 bytes of RAM.
.................... /// If you remove this, a default value will be loaded in stacktsk.h
....................    #ifndef MAX_SOCKETS
....................    #define MAX_SOCKETS                     5
....................    #endif
.................... 
.................... ///Avaialble UDP Socket
.................... /// DCHP takes 1 socket.
.................... /// If you remove this, a default value will be loaded in stacktsk.h
....................    #ifndef MAX_UDP_SOCKETS
....................    #define MAX_UDP_SOCKETS                 2
....................    #endif
.................... 
.................... ///BUFFER SIZE DEFINITIONS
.................... ///
.................... /// For SLIP, there can only be one transmit and one receive buffer.
.................... /// Both buffer must fit in one bank.  If bigger buffer is required,
.................... /// you must manually locate tx and rx buffer in different bank
.................... /// or modify your linker script file to support arrays bigger than
.................... /// 256 bytes.
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE
.................... ///
.................... /// For PPP, there can only be one transmit and one receive buffer.
.................... /// You can receive messages larger than the receive buffer if your
.................... /// routines are fast enough.  You cannot transmit messages larger
.................... /// than the TX buffer.  The larger the buffer you can make, the better.
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE
.................... ///
.................... /// For Ethernet, the Ethernet controler has many buffers that are
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX.
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers.
....................    #if STACK_USE_MAC
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line
....................    #elif STACK_USE_PPP
....................        #define MAC_TX_BUFFER_SIZE          1024
....................        #define MAC_TX_BUFFER_COUNT         1
....................    #elif STACK_USE_SLIP
....................        #define MAC_TX_BUFFER_SIZE          250
....................        #define MAC_TX_BUFFER_COUNT         1
....................    #endif
.................... 
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing
.................... 
.................... #endif
.................... 
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
45DC:  MOVFF  30F,315
45E0:  MOVFF  30E,314
....................    sc2=s2;
45E4:  MOVFF  311,317
45E8:  MOVFF  310,316
....................    if(sc2<sc1 && sc1 <sc2 +n)
45EC:  MOVLB  3
45EE:  MOVF   x17,W
45F0:  SUBWF  x15,W
45F2:  BNC   466C
45F4:  BNZ   45FC
45F6:  MOVF   x14,W
45F8:  SUBWF  x16,W
45FA:  BC    466C
45FC:  MOVF   x12,W
45FE:  ADDWF  x16,W
4600:  MOVWF  01
4602:  MOVF   x13,W
4604:  ADDWFC x17,W
4606:  MOVWF  03
4608:  MOVF   x15,W
460A:  SUBWF  03,W
460C:  BNC   466C
460E:  BNZ   4616
4610:  MOVF   01,W
4612:  SUBWF  x14,W
4614:  BC    466C
....................       for(sc1+=n,sc2+=n;0<n;--n)
4616:  MOVF   x12,W
4618:  ADDWF  x14,F
461A:  MOVF   x13,W
461C:  ADDWFC x15,F
461E:  MOVF   x12,W
4620:  ADDWF  x16,F
4622:  MOVF   x13,W
4624:  ADDWFC x17,F
4626:  MOVF   x13,F
4628:  BNZ   4630
462A:  MOVF   x12,W
462C:  SUBLW  00
462E:  BC    466A
....................          *--sc1=*--sc2;
4630:  MOVF   x14,W
4632:  BTFSC  FD8.2
4634:  DECF   x15,F
4636:  DECF   x14,F
4638:  MOVFF  315,319
463C:  MOVFF  314,318
4640:  MOVF   x16,W
4642:  BTFSC  FD8.2
4644:  DECF   x17,F
4646:  DECF   x16,F
4648:  MOVFF  317,FEA
464C:  MOVFF  316,FE9
4650:  MOVFF  FEF,31A
4654:  MOVFF  315,FEA
4658:  MOVFF  314,FE9
465C:  MOVFF  31A,FEF
4660:  MOVF   x12,W
4662:  BTFSC  FD8.2
4664:  DECF   x13,F
4666:  DECF   x12,F
4668:  BRA    4626
466A:  BRA    46AC
....................    else
....................       for(;0<n;--n)
466C:  MOVF   x13,F
466E:  BNZ   4676
4670:  MOVF   x12,W
4672:  SUBLW  00
4674:  BC    46AC
....................          *sc1++=*sc2++;
4676:  MOVFF  315,319
467A:  MOVF   x14,W
467C:  INCF   x14,F
467E:  BTFSC  FD8.2
4680:  INCF   x15,F
4682:  MOVWF  x18
4684:  MOVFF  317,FEA
4688:  MOVF   x16,W
468A:  INCF   x16,F
468C:  BTFSC  FD8.2
468E:  INCF   x17,F
4690:  MOVWF  FE9
4692:  MOVFF  FEF,31A
4696:  MOVFF  319,FEA
469A:  MOVFF  318,FE9
469E:  MOVFF  31A,FEF
46A2:  MOVF   x12,W
46A4:  BTFSC  FD8.2
46A6:  DECF   x13,F
46A8:  DECF   x12,F
46AA:  BRA    466C
....................   return s1;
46AC:  MOVFF  30E,01
46B0:  MOVFF  30F,02
46B4:  MOVLB  0
46B6:  GOTO   4780 (RETURN)
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
*
5A08:  MOVFF  31E,324
5A0C:  MOVFF  31D,323
5A10:  MOVLB  3
5A12:  MOVF   x21,F
5A14:  BNZ   5A1A
5A16:  MOVF   x22,F
5A18:  BZ    5A60
5A1A:  MOVFF  320,FEA
5A1E:  MOVFF  31F,FE9
5A22:  MOVF   FEF,F
5A24:  BZ    5A60
....................      *s++ = *s2++;
5A26:  MOVFF  324,03
5A2A:  MOVF   x23,W
5A2C:  INCF   x23,F
5A2E:  BTFSC  FD8.2
5A30:  INCF   x24,F
5A32:  MOVWF  x25
5A34:  MOVFF  03,326
5A38:  MOVFF  320,FEA
5A3C:  MOVF   x1F,W
5A3E:  INCF   x1F,F
5A40:  BTFSC  FD8.2
5A42:  INCF   x20,F
5A44:  MOVWF  FE9
5A46:  MOVFF  FEF,327
5A4A:  MOVFF  03,FEA
5A4E:  MOVFF  325,FE9
5A52:  MOVFF  327,FEF
5A56:  MOVF   x21,W
5A58:  BTFSC  FD8.2
5A5A:  DECF   x22,F
5A5C:  DECF   x21,F
5A5E:  BRA    5A12
....................   for (; n > 0; n--)
5A60:  MOVF   x21,F
5A62:  BNZ   5A68
5A64:  MOVF   x22,F
5A66:  BZ    5A82
....................      *s++ = '\0';
5A68:  MOVFF  324,FEA
5A6C:  MOVF   x23,W
5A6E:  INCF   x23,F
5A70:  BTFSC  FD8.2
5A72:  INCF   x24,F
5A74:  MOVWF  FE9
5A76:  CLRF   FEF
5A78:  MOVF   x21,W
5A7A:  BTFSC  FD8.2
5A7C:  DECF   x22,F
5A7E:  DECF   x21,F
5A80:  BRA    5A60
.................... 
....................   return(s1);
5A82:  MOVFF  31D,01
5A86:  MOVFF  31E,02
5A8A:  MOVLB  0
5A8C:  GOTO   5B7A (RETURN)
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
4138:  MOVFF  2EF,FEA
413C:  MOVLB  2
413E:  MOVFF  2EE,FE9
4142:  MOVFF  FEF,2F2
4146:  MOVFF  2F1,FEA
414A:  MOVFF  2F0,FE9
414E:  MOVF   FEF,W
4150:  SUBWF  xF2,W
4152:  BNZ   4182
....................       if (*s1 == '\0')
4154:  MOVFF  2EF,03
4158:  MOVFF  2EE,FE9
415C:  MOVFF  03,FEA
4160:  MOVF   FEF,F
4162:  BNZ   416A
....................          return(0);
4164:  MOVLW  00
4166:  MOVWF  01
4168:  BRA    41AC
416A:  MOVFF  2EF,03
416E:  MOVF   xEE,W
4170:  INCF   xEE,F
4172:  BTFSC  FD8.2
4174:  INCF   xEF,F
4176:  INCF   xF0,F
4178:  BTFSC  FD8.2
417A:  INCF   xF1,F
417C:  MOVLB  0
417E:  BRA    4138
4180:  MOVLB  2
....................    return((*s1 < *s2) ? -1: 1);
4182:  MOVFF  2EF,03
4186:  MOVFF  2EE,FE9
418A:  MOVFF  03,FEA
418E:  MOVFF  FEF,2F2
4192:  MOVFF  2F1,03
4196:  MOVFF  2F0,FE9
419A:  MOVFF  03,FEA
419E:  MOVF   FEF,W
41A0:  SUBWF  xF2,W
41A2:  BC    41A8
41A4:  MOVLW  FF
41A6:  BRA    41AA
41A8:  MOVLW  01
41AA:  MOVWF  01
41AC:  MOVLB  0
41AE:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
41B0:  MOVFF  33F,342
....................    for(su=s;0<n;++su,--n)
41B4:  MOVFF  33E,344
41B8:  MOVFF  33D,343
41BC:  MOVLB  3
41BE:  MOVF   x41,F
41C0:  BNZ   41C8
41C2:  MOVF   x40,W
41C4:  SUBLW  00
41C6:  BC    41F0
....................       if(*su==uc)
41C8:  MOVFF  344,FEA
41CC:  MOVFF  343,FE9
41D0:  MOVF   x42,W
41D2:  SUBWF  FEF,W
41D4:  BNZ   41E0
....................       return su;
41D6:  MOVFF  343,01
41DA:  MOVFF  344,02
41DE:  BRA    41F6
41E0:  INCF   x43,F
41E2:  BTFSC  FD8.2
41E4:  INCF   x44,F
41E6:  MOVF   x40,W
41E8:  BTFSC  FD8.2
41EA:  DECF   x41,F
41EC:  DECF   x40,F
41EE:  BRA    41BE
....................    return NULL;
41F0:  MOVLW  00
41F2:  MOVWF  01
41F4:  MOVWF  02
41F6:  MOVLB  0
41F8:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
3FCE:  MOVFF  2FB,2FF
3FD2:  MOVFF  2FA,2FE
3FD6:  MOVFF  2FF,FEA
3FDA:  MOVLB  2
3FDC:  MOVFF  2FE,FE9
3FE0:  MOVF   FEF,F
3FE2:  BZ    4040
....................       for (sc2 = s2; *sc2 != 0; sc2++)
3FE4:  MOVFF  2FD,301
3FE8:  MOVFF  2FC,300
3FEC:  MOVFF  301,FEA
3FF0:  MOVLB  3
3FF2:  MOVFF  300,FE9
3FF6:  MOVF   FEF,F
3FF8:  BZ    4032
....................          if (*sc1 == *sc2)
3FFA:  MOVFF  2FF,03
3FFE:  MOVFF  2FE,FE9
4002:  MOVFF  03,FEA
4006:  MOVFF  FEF,302
400A:  MOVFF  301,FEA
400E:  MOVLB  3
4010:  MOVFF  300,FE9
4014:  MOVF   FEF,W
4016:  SUBWF  x02,W
4018:  BNZ   4028
....................             return(sc1);
401A:  MOVLB  2
401C:  MOVFF  2FE,01
4020:  MOVFF  2FF,02
4024:  BRA    4046
4026:  MOVLB  3
4028:  INCF   x00,F
402A:  BTFSC  FD8.2
402C:  INCF   x01,F
402E:  MOVLB  2
4030:  BRA    3FEC
4032:  MOVLB  2
4034:  INCF   xFE,F
4036:  BTFSC  FD8.2
4038:  INCF   xFF,F
403A:  MOVLB  0
403C:  BRA    3FD6
403E:  MOVLB  2
....................    return(0);
4040:  MOVLW  00
4042:  MOVWF  01
4044:  MOVWF  02
4046:  MOVLB  0
4048:  GOTO   40E6 (RETURN)
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
3F3A:  MOVFF  2FB,2FF
3F3E:  MOVFF  2FA,2FE
3F42:  MOVFF  2FF,FEA
3F46:  MOVLB  2
3F48:  MOVFF  2FE,FE9
3F4C:  MOVF   FEF,F
3F4E:  BZ    3FB6
....................       for (sc2 = s2; ; sc2++)
3F50:  MOVFF  2FD,301
3F54:  MOVFF  2FC,300
....................     if (*sc2 == '\0')
3F58:  MOVFF  301,FEA
3F5C:  MOVLB  3
3F5E:  MOVFF  300,FE9
3F62:  MOVF   FEF,F
3F64:  BNZ   3F7E
....................        return(sc1 - s1);
3F66:  MOVLB  2
3F68:  MOVF   xFA,W
3F6A:  SUBWF  xFE,W
3F6C:  MOVWF  00
3F6E:  MOVF   xFB,W
3F70:  SUBWFB xFF,W
3F72:  MOVWF  03
3F74:  MOVFF  00,01
3F78:  MOVWF  02
3F7A:  BRA    3FC8
3F7C:  BRA    3F9C
....................          else if (*sc1 == *sc2)
3F7E:  MOVFF  2FF,FEA
3F82:  MOVFF  2FE,FE9
3F86:  MOVFF  FEF,302
3F8A:  MOVFF  301,FEA
3F8E:  MOVLB  3
3F90:  MOVFF  300,FE9
3F94:  MOVF   FEF,W
3F96:  SUBWF  x02,W
3F98:  BNZ   3F9C
....................             break;
3F9A:  BRA    3FA8
3F9C:  MOVLB  3
3F9E:  INCF   x00,F
3FA0:  BTFSC  FD8.2
3FA2:  INCF   x01,F
3FA4:  MOVLB  2
3FA6:  BRA    3F58
3FA8:  MOVLB  2
3FAA:  INCF   xFE,F
3FAC:  BTFSC  FD8.2
3FAE:  INCF   xFF,F
3FB0:  MOVLB  0
3FB2:  BRA    3F42
3FB4:  MOVLB  2
....................    return(sc1 - s1);
3FB6:  MOVF   xFA,W
3FB8:  SUBWF  xFE,W
3FBA:  MOVWF  00
3FBC:  MOVF   xFB,W
3FBE:  SUBWFB xFF,W
3FC0:  MOVWF  03
3FC2:  MOVFF  00,01
3FC6:  MOVWF  02
3FC8:  MOVLB  0
3FCA:  GOTO   40B4 (RETURN)
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
404C:  MOVFF  31E,320
4050:  MOVFF  31D,31F
4054:  MOVFF  320,FEA
4058:  MOVLB  3
405A:  MOVFF  31F,FE9
405E:  MOVF   FEF,F
4060:  BZ    406E
4062:  INCF   x1F,F
4064:  BTFSC  FD8.2
4066:  INCF   x20,F
4068:  MOVLB  0
406A:  BRA    4054
406C:  MOVLB  3
....................    return(sc - s);
406E:  MOVF   x1D,W
4070:  SUBWF  x1F,W
4072:  MOVWF  00
4074:  MOVF   x1E,W
4076:  SUBWFB x20,W
4078:  MOVWF  03
407A:  MOVFF  00,01
407E:  MOVWF  02
4080:  MOVLB  0
4082:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
4084:  MOVLB  2
4086:  MOVF   xF2,W
4088:  IORWF  xF3,W
408A:  BZ    4094
408C:  MOVFF  2F3,03
4090:  MOVF   xF2,W
4092:  BRA    409A
4094:  MOVFF  06,03
4098:  MOVF   05,W
409A:  MOVWF  xF6
409C:  MOVFF  03,2F7
....................    beg += strspn(beg, s2);
40A0:  MOVFF  2F7,2FB
40A4:  MOVFF  2F6,2FA
40A8:  MOVFF  2F5,2FD
40AC:  MOVFF  2F4,2FC
40B0:  MOVLB  0
40B2:  BRA    3F3A
40B4:  MOVF   01,W
40B6:  MOVLB  2
40B8:  ADDWF  xF6,F
40BA:  MOVF   02,W
40BC:  ADDWFC xF7,F
....................    if (*beg == '\0')
40BE:  MOVFF  2F7,FEA
40C2:  MOVFF  2F6,FE9
40C6:  MOVF   FEF,F
40C8:  BNZ   40D2
....................       return(0);
40CA:  MOVLW  00
40CC:  MOVWF  01
40CE:  MOVWF  02
40D0:  BRA    4134
....................       
....................    end = strpbrk(beg, s2);
40D2:  MOVFF  2F7,2FB
40D6:  MOVFF  2F6,2FA
40DA:  MOVFF  2F5,2FD
40DE:  MOVFF  2F4,2FC
40E2:  MOVLB  0
40E4:  BRA    3FCE
40E6:  MOVFF  02,2F9
40EA:  MOVFF  01,2F8
....................    if (end != '\0')
40EE:  MOVLB  2
40F0:  MOVF   xF8,F
40F2:  BNZ   40F8
40F4:  MOVF   xF9,F
40F6:  BZ    4112
....................    {
....................       *end = '\0';
40F8:  MOVFF  2F9,FEA
40FC:  MOVFF  2F8,FE9
4100:  CLRF   FEF
....................       end++;
4102:  INCF   xF8,F
4104:  BTFSC  FD8.2
4106:  INCF   xF9,F
....................       save = end;
4108:  MOVFF  2F9,06
410C:  MOVFF  2F8,05
....................    }
4110:  BRA    412C
....................    else
....................       save = beg + strlen(beg);
4112:  MOVFF  2F7,31E
4116:  MOVFF  2F6,31D
411A:  MOVLB  0
411C:  RCALL  404C
411E:  MOVF   01,W
4120:  MOVLB  2
4122:  ADDWF  xF6,W
4124:  MOVWF  05
4126:  MOVF   02,W
4128:  ADDWFC xF7,W
412A:  MOVWF  06
....................    
....................    return(beg);
412C:  MOVFF  2F6,01
4130:  MOVFF  2F7,02
4134:  MOVLB  0
4136:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
*
479A:  MOVFF  30B,FEA
479E:  MOVLB  3
47A0:  MOVFF  30A,FE9
47A4:  MOVFF  FEF,30E
47A8:  MOVFF  30D,FEA
47AC:  MOVFF  30C,FE9
47B0:  MOVF   FEF,W
47B2:  SUBWF  x0E,W
47B4:  BZ    4836
47B6:  MOVFF  30B,FEA
47BA:  MOVFF  30A,FE9
47BE:  MOVFF  FEF,30E
47C2:  MOVF   x0E,W
47C4:  SUBLW  40
47C6:  BC    47CE
47C8:  MOVF   x0E,W
47CA:  SUBLW  5A
47CC:  BC    47DA
47CE:  MOVF   x0E,W
47D0:  SUBLW  60
47D2:  BC    4860
47D4:  MOVF   x0E,W
47D6:  SUBLW  7A
47D8:  BNC   4860
47DA:  MOVFF  30D,FEA
47DE:  MOVFF  30C,FE9
47E2:  MOVFF  FEF,30E
47E6:  MOVF   x0E,W
47E8:  SUBLW  40
47EA:  BC    47F2
47EC:  MOVF   x0E,W
47EE:  SUBLW  5A
47F0:  BC    47FE
47F2:  MOVF   x0E,W
47F4:  SUBLW  60
47F6:  BC    4860
47F8:  MOVF   x0E,W
47FA:  SUBLW  7A
47FC:  BNC   4860
47FE:  MOVFF  30B,FEA
4802:  MOVFF  30A,FE9
4806:  MOVFF  FEF,30E
480A:  MOVFF  30D,FEA
480E:  MOVFF  30C,FE9
4812:  MOVLW  20
4814:  ADDWF  FEF,W
4816:  SUBWF  x0E,W
4818:  BZ    4836
481A:  MOVFF  30D,FEA
481E:  MOVFF  30C,FE9
4822:  MOVFF  FEF,30E
4826:  MOVFF  30B,FEA
482A:  MOVFF  30A,FE9
482E:  MOVLW  20
4830:  ADDWF  FEF,W
4832:  SUBWF  x0E,W
4834:  BNZ   4860
....................     s1++, s2++)
....................     if (*s1 == '\0')
4836:  MOVFF  30B,FEA
483A:  MOVFF  30A,FE9
483E:  MOVF   FEF,F
4840:  BNZ   4848
....................        return(0);
4842:  MOVLW  00
4844:  MOVWF  01
4846:  BRA    488A
4848:  MOVFF  30B,03
484C:  MOVF   x0A,W
484E:  INCF   x0A,F
4850:  BTFSC  FD8.2
4852:  INCF   x0B,F
4854:  INCF   x0C,F
4856:  BTFSC  FD8.2
4858:  INCF   x0D,F
485A:  MOVLB  0
485C:  BRA    479A
485E:  MOVLB  3
....................  return((*s1 < *s2) ? -1: 1);
4860:  MOVFF  30B,03
4864:  MOVFF  30A,FE9
4868:  MOVFF  03,FEA
486C:  MOVFF  FEF,30E
4870:  MOVFF  30D,03
4874:  MOVFF  30C,FE9
4878:  MOVFF  03,FEA
487C:  MOVF   FEF,W
487E:  SUBWF  x0E,W
4880:  BC    4886
4882:  MOVLW  FF
4884:  BRA    4888
4886:  MOVLW  01
4888:  MOVWF  01
488A:  MOVLB  0
488C:  RETURN 0
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
4DBA:  MOVLB  2
4DBC:  CLRF   xF6
....................    sign = 0;
4DBE:  CLRF   xF4
....................    base = 10;
4DC0:  MOVLW  0A
4DC2:  MOVWF  xF5
....................    result = 0;
4DC4:  CLRF   xF3
4DC6:  CLRF   xF2
.................... 
....................    if (!s)
4DC8:  MOVF   xF0,W
4DCA:  IORWF  xF1,W
4DCC:  BNZ   4DD6
....................       return 0;
4DCE:  MOVLW  00
4DD0:  MOVWF  01
4DD2:  MOVWF  02
4DD4:  BRA    4F90
....................    c = s[index++];
4DD6:  MOVF   xF6,W
4DD8:  INCF   xF6,F
4DDA:  ADDWF  xF0,W
4DDC:  MOVWF  FE9
4DDE:  MOVLW  00
4DE0:  ADDWFC xF1,W
4DE2:  MOVWF  FEA
4DE4:  MOVFF  FEF,2F7
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
4DE8:  MOVF   xF7,W
4DEA:  SUBLW  2D
4DEC:  BNZ   4E06
....................    {
....................       sign = 1;         // Set the sign to negative
4DEE:  MOVLW  01
4DF0:  MOVWF  xF4
....................       c = s[index++];
4DF2:  MOVF   xF6,W
4DF4:  INCF   xF6,F
4DF6:  ADDWF  xF0,W
4DF8:  MOVWF  FE9
4DFA:  MOVLW  00
4DFC:  ADDWFC xF1,W
4DFE:  MOVWF  FEA
4E00:  MOVFF  FEF,2F7
....................    }
4E04:  BRA    4E1E
....................    else if (c == '+')
4E06:  MOVF   xF7,W
4E08:  SUBLW  2B
4E0A:  BNZ   4E1E
....................    {
....................       c = s[index++];
4E0C:  MOVF   xF6,W
4E0E:  INCF   xF6,F
4E10:  ADDWF  xF0,W
4E12:  MOVWF  FE9
4E14:  MOVLW  00
4E16:  ADDWFC xF1,W
4E18:  MOVWF  FEA
4E1A:  MOVFF  FEF,2F7
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
4E1E:  MOVF   xF7,W
4E20:  SUBLW  2F
4E22:  BTFSC  FD8.0
4E24:  BRA    4F74
4E26:  MOVF   xF7,W
4E28:  SUBLW  39
4E2A:  BTFSS  FD8.0
4E2C:  BRA    4F74
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
4E2E:  MOVF   xF7,W
4E30:  SUBLW  30
4E32:  BNZ   4E70
4E34:  MOVF   xF6,W
4E36:  ADDWF  xF0,W
4E38:  MOVWF  FE9
4E3A:  MOVLW  00
4E3C:  ADDWFC xF1,W
4E3E:  MOVWF  FEA
4E40:  MOVF   FEF,W
4E42:  SUBLW  78
4E44:  BZ    4E58
4E46:  MOVF   xF6,W
4E48:  ADDWF  xF0,W
4E4A:  MOVWF  FE9
4E4C:  MOVLW  00
4E4E:  ADDWFC xF1,W
4E50:  MOVWF  FEA
4E52:  MOVF   FEF,W
4E54:  SUBLW  58
4E56:  BNZ   4E70
....................       {
....................          base = 16;
4E58:  MOVLW  10
4E5A:  MOVWF  xF5
....................          index++;
4E5C:  INCF   xF6,F
....................          c = s[index++];
4E5E:  MOVF   xF6,W
4E60:  INCF   xF6,F
4E62:  ADDWF  xF0,W
4E64:  MOVWF  FE9
4E66:  MOVLW  00
4E68:  ADDWFC xF1,W
4E6A:  MOVWF  FEA
4E6C:  MOVFF  FEF,2F7
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
4E70:  MOVF   xF5,W
4E72:  SUBLW  0A
4E74:  BNZ   4EBA
....................       {
....................          while (c >= '0' && c <= '9')
4E76:  MOVF   xF7,W
4E78:  SUBLW  2F
4E7A:  BC    4EB8
4E7C:  MOVF   xF7,W
4E7E:  SUBLW  39
4E80:  BNC   4EB8
....................          {
....................             result = 10*result + (c - '0');
4E82:  CLRF   xF9
4E84:  MOVLW  0A
4E86:  MOVWF  xF8
4E88:  MOVFF  2F3,2FB
4E8C:  MOVFF  2F2,2FA
4E90:  MOVLB  0
4E92:  BRA    4D64
4E94:  MOVLW  30
4E96:  MOVLB  2
4E98:  SUBWF  xF7,W
4E9A:  ADDWF  01,W
4E9C:  MOVWF  xF2
4E9E:  MOVLW  00
4EA0:  ADDWFC 02,W
4EA2:  MOVWF  xF3
....................             c = s[index++];
4EA4:  MOVF   xF6,W
4EA6:  INCF   xF6,F
4EA8:  ADDWF  xF0,W
4EAA:  MOVWF  FE9
4EAC:  MOVLW  00
4EAE:  ADDWFC xF1,W
4EB0:  MOVWF  FEA
4EB2:  MOVFF  FEF,2F7
4EB6:  BRA    4E76
....................          }
....................       }
4EB8:  BRA    4F74
....................       else if (base == 16)    // The number is a hexa number
4EBA:  MOVF   xF5,W
4EBC:  SUBLW  10
4EBE:  BNZ   4F74
....................       {
....................          c = toupper(c);
4EC0:  MOVF   xF7,W
4EC2:  SUBLW  60
4EC4:  BC    4ED2
4EC6:  MOVF   xF7,W
4EC8:  SUBLW  7A
4ECA:  BNC   4ED2
4ECC:  MOVF   xF7,W
4ECE:  ANDLW  DF
4ED0:  BRA    4ED4
4ED2:  MOVF   xF7,W
4ED4:  MOVWF  xF7
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
4ED6:  MOVF   xF7,W
4ED8:  SUBLW  2F
4EDA:  BC    4EE2
4EDC:  MOVF   xF7,W
4EDE:  SUBLW  39
4EE0:  BC    4EEE
4EE2:  MOVF   xF7,W
4EE4:  SUBLW  40
4EE6:  BC    4F74
4EE8:  MOVF   xF7,W
4EEA:  SUBLW  46
4EEC:  BNC   4F74
....................          {
....................             if (c >= '0' && c <= '9')
4EEE:  MOVF   xF7,W
4EF0:  SUBLW  2F
4EF2:  BC    4F22
4EF4:  MOVF   xF7,W
4EF6:  SUBLW  39
4EF8:  BNC   4F22
....................                result = (result << 4) + (c - '0');
4EFA:  RLCF   xF2,W
4EFC:  MOVWF  xF8
4EFE:  RLCF   xF3,W
4F00:  MOVWF  xF9
4F02:  RLCF   xF8,F
4F04:  RLCF   xF9,F
4F06:  RLCF   xF8,F
4F08:  RLCF   xF9,F
4F0A:  RLCF   xF8,F
4F0C:  RLCF   xF9,F
4F0E:  MOVLW  F0
4F10:  ANDWF  xF8,F
4F12:  MOVLW  30
4F14:  SUBWF  xF7,W
4F16:  ADDWF  xF8,W
4F18:  MOVWF  xF2
4F1A:  MOVLW  00
4F1C:  ADDWFC xF9,W
4F1E:  MOVWF  xF3
4F20:  BRA    4F4A
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
4F22:  RLCF   xF2,W
4F24:  MOVWF  xF8
4F26:  RLCF   xF3,W
4F28:  MOVWF  xF9
4F2A:  RLCF   xF8,F
4F2C:  RLCF   xF9,F
4F2E:  RLCF   xF8,F
4F30:  RLCF   xF9,F
4F32:  RLCF   xF8,F
4F34:  RLCF   xF9,F
4F36:  MOVLW  F0
4F38:  ANDWF  xF8,F
4F3A:  MOVLW  41
4F3C:  SUBWF  xF7,W
4F3E:  ADDLW  0A
4F40:  ADDWF  xF8,W
4F42:  MOVWF  xF2
4F44:  MOVLW  00
4F46:  ADDWFC xF9,W
4F48:  MOVWF  xF3
.................... 
....................             c = s[index++];c = toupper(c);
4F4A:  MOVF   xF6,W
4F4C:  INCF   xF6,F
4F4E:  ADDWF  xF0,W
4F50:  MOVWF  FE9
4F52:  MOVLW  00
4F54:  ADDWFC xF1,W
4F56:  MOVWF  FEA
4F58:  MOVFF  FEF,2F7
4F5C:  MOVF   xF7,W
4F5E:  SUBLW  60
4F60:  BC    4F6E
4F62:  MOVF   xF7,W
4F64:  SUBLW  7A
4F66:  BNC   4F6E
4F68:  MOVF   xF7,W
4F6A:  ANDLW  DF
4F6C:  BRA    4F70
4F6E:  MOVF   xF7,W
4F70:  MOVWF  xF7
4F72:  BRA    4ED6
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
4F74:  MOVF   xF5,W
4F76:  SUBLW  0A
4F78:  BNZ   4F88
4F7A:  DECFSZ xF4,W
4F7C:  BRA    4F88
....................       result = -result;
4F7E:  COMF   xF2,F
4F80:  COMF   xF3,F
4F82:  INCF   xF2,F
4F84:  BTFSC  FD8.2
4F86:  INCF   xF3,F
.................... 
....................    return(result);
4F88:  MOVFF  2F2,01
4F8C:  MOVFF  2F3,02
4F90:  MOVLB  0
4F92:  GOTO   64EA (RETURN)
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
41FA:  MOVLB  3
41FC:  CLRF   x16
41FE:  CLRF   x15
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
4200:  MOVLW  30
4202:  MOVWF  x18
4204:  MOVLW  31
4206:  MOVWF  x19
4208:  MOVLW  32
420A:  MOVWF  x1A
420C:  MOVLW  33
420E:  MOVWF  x1B
4210:  MOVLW  34
4212:  MOVWF  x1C
4214:  MOVLW  35
4216:  MOVWF  x1D
4218:  MOVLW  36
421A:  MOVWF  x1E
421C:  MOVLW  37
421E:  MOVWF  x1F
4220:  MOVLW  38
4222:  MOVWF  x20
4224:  MOVLW  39
4226:  MOVWF  x21
4228:  MOVLW  61
422A:  MOVWF  x22
422C:  MOVLW  62
422E:  MOVWF  x23
4230:  MOVLW  63
4232:  MOVWF  x24
4234:  MOVLW  64
4236:  MOVWF  x25
4238:  MOVLW  65
423A:  MOVWF  x26
423C:  MOVLW  66
423E:  MOVWF  x27
4240:  MOVLW  67
4242:  MOVWF  x28
4244:  MOVLW  68
4246:  MOVWF  x29
4248:  MOVLW  69
424A:  MOVWF  x2A
424C:  MOVLW  6A
424E:  MOVWF  x2B
4250:  MOVLW  6B
4252:  MOVWF  x2C
4254:  MOVLW  6C
4256:  MOVWF  x2D
4258:  MOVLW  6D
425A:  MOVWF  x2E
425C:  MOVLW  6E
425E:  MOVWF  x2F
4260:  MOVLW  6F
4262:  MOVWF  x30
4264:  MOVLW  70
4266:  MOVWF  x31
4268:  MOVLW  71
426A:  MOVWF  x32
426C:  MOVLW  73
426E:  MOVWF  x33
4270:  MOVLW  74
4272:  MOVWF  x34
4274:  MOVLW  75
4276:  MOVWF  x35
4278:  MOVLW  76
427A:  MOVWF  x36
427C:  MOVLW  77
427E:  MOVWF  x37
4280:  MOVLW  78
4282:  MOVWF  x38
4284:  MOVLW  79
4286:  MOVWF  x39
4288:  MOVLW  7A
428A:  MOVWF  x3A
428C:  CLRF   x3B
....................    for(sc=s;isspace(*sc);++sc);
428E:  MOVFF  30B,310
4292:  MOVFF  30A,30F
4296:  MOVFF  310,FEA
429A:  MOVFF  30F,FE9
429E:  MOVF   FEF,W
42A0:  SUBLW  20
42A2:  BNZ   42AC
42A4:  INCF   x0F,F
42A6:  BTFSC  FD8.2
42A8:  INCF   x10,F
42AA:  BRA    4296
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
42AC:  MOVFF  310,03
42B0:  MOVFF  30F,FE9
42B4:  MOVFF  03,FEA
42B8:  MOVF   FEF,W
42BA:  SUBLW  2D
42BC:  BZ    42CC
42BE:  MOVFF  310,FEA
42C2:  MOVFF  30F,FE9
42C6:  MOVF   FEF,W
42C8:  SUBLW  2B
42CA:  BNZ   42DE
42CC:  MOVFF  310,FEA
42D0:  MOVF   x0F,W
42D2:  INCF   x0F,F
42D4:  BTFSC  FD8.2
42D6:  INCF   x10,F
42D8:  MOVWF  FE9
42DA:  MOVF   FEF,W
42DC:  BRA    42E0
42DE:  MOVLW  2B
42E0:  MOVWF  x17
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
42E2:  MOVF   x17,W
42E4:  SUBLW  2D
42E6:  BZ    4324
42E8:  CLRF   03
42EA:  MOVF   x0E,W
42EC:  MOVWF  00
42EE:  BTFSC  FE8.7
42F0:  DECF   03,F
42F2:  MOVWF  01
42F4:  BTFSC  03.7
42F6:  BRA    4324
42F8:  CLRF   03
42FA:  MOVF   x0E,W
42FC:  MOVWF  00
42FE:  BTFSC  FE8.7
4300:  DECF   03,F
4302:  SUBLW  01
4304:  BNZ   430A
4306:  MOVF   03,F
4308:  BZ    4324
430A:  CLRF   03
430C:  MOVF   x0E,W
430E:  MOVWF  00
4310:  BTFSC  FE8.7
4312:  DECF   03,F
4314:  MOVWF  01
4316:  BTFSC  03.7
4318:  BRA    4328
431A:  MOVF   03,F
431C:  BNZ   4324
431E:  MOVF   01,W
4320:  SUBLW  24
4322:  BC    4328
....................    goto StrtoulGO;
4324:  BRA    4594
4326:  BRA    4444
.................... 
....................    else if (base)
4328:  MOVF   x0E,F
432A:  BZ    43DC
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
432C:  CLRF   03
432E:  MOVF   x0E,W
4330:  MOVWF  00
4332:  BTFSC  FE8.7
4334:  DECF   03,F
4336:  SUBLW  10
4338:  BNZ   4378
433A:  MOVF   03,F
433C:  BNZ   4378
433E:  MOVFF  310,FEA
4342:  MOVFF  30F,FE9
4346:  MOVF   FEF,W
4348:  SUBLW  30
434A:  BNZ   4378
434C:  MOVLW  01
434E:  ADDWF  x0F,W
4350:  MOVWF  FE9
4352:  MOVLW  00
4354:  ADDWFC x10,W
4356:  MOVWF  FEA
4358:  MOVF   FEF,W
435A:  SUBLW  78
435C:  BZ    4370
435E:  MOVLW  01
4360:  ADDWF  x0F,W
4362:  MOVWF  FE9
4364:  MOVLW  00
4366:  ADDWFC x10,W
4368:  MOVWF  FEA
436A:  MOVF   FEF,W
436C:  SUBLW  58
436E:  BNZ   4378
....................          sc+=2;
4370:  MOVLW  02
4372:  ADDWF  x0F,F
4374:  MOVLW  00
4376:  ADDWFC x10,F
....................       if(base==8 && *sc =='0')
4378:  CLRF   03
437A:  MOVF   x0E,W
437C:  MOVWF  00
437E:  BTFSC  FE8.7
4380:  DECF   03,F
4382:  SUBLW  08
4384:  BNZ   43A0
4386:  MOVF   03,F
4388:  BNZ   43A0
438A:  MOVFF  310,FEA
438E:  MOVFF  30F,FE9
4392:  MOVF   FEF,W
4394:  SUBLW  30
4396:  BNZ   43A0
....................          sc+=1;
4398:  MOVLW  01
439A:  ADDWF  x0F,F
439C:  MOVLW  00
439E:  ADDWFC x10,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
43A0:  CLRF   03
43A2:  MOVF   x0E,W
43A4:  MOVWF  00
43A6:  BTFSC  FE8.7
43A8:  DECF   03,F
43AA:  SUBLW  02
43AC:  BNZ   43DA
43AE:  MOVF   03,F
43B0:  BNZ   43DA
43B2:  MOVFF  310,FEA
43B6:  MOVFF  30F,FE9
43BA:  MOVF   FEF,W
43BC:  SUBLW  30
43BE:  BNZ   43DA
43C0:  MOVLW  01
43C2:  ADDWF  x0F,W
43C4:  MOVWF  FE9
43C6:  MOVLW  00
43C8:  ADDWFC x10,W
43CA:  MOVWF  FEA
43CC:  MOVF   FEF,W
43CE:  SUBLW  62
43D0:  BNZ   43DA
....................          sc+=2;
43D2:  MOVLW  02
43D4:  ADDWF  x0F,F
43D6:  MOVLW  00
43D8:  ADDWFC x10,F
.................... 
....................    }
43DA:  BRA    4444
....................    else if(*sc!='0') // base is 0, find base
43DC:  MOVFF  310,FEA
43E0:  MOVFF  30F,FE9
43E4:  MOVF   FEF,W
43E6:  SUBLW  30
43E8:  BZ    43F0
....................       base=10;
43EA:  MOVLW  0A
43EC:  MOVWF  x0E
43EE:  BRA    4444
....................    else if (sc[1]=='x' || sc[1]=='X')
43F0:  MOVLW  01
43F2:  ADDWF  x0F,W
43F4:  MOVWF  FE9
43F6:  MOVLW  00
43F8:  ADDWFC x10,W
43FA:  MOVWF  FEA
43FC:  MOVF   FEF,W
43FE:  SUBLW  78
4400:  BZ    4414
4402:  MOVLW  01
4404:  ADDWF  x0F,W
4406:  MOVWF  FE9
4408:  MOVLW  00
440A:  ADDWFC x10,W
440C:  MOVWF  FEA
440E:  MOVF   FEF,W
4410:  SUBLW  58
4412:  BNZ   4422
....................       base =16,sc+=2;
4414:  MOVLW  10
4416:  MOVWF  x0E
4418:  MOVLW  02
441A:  ADDWF  x0F,F
441C:  MOVLW  00
441E:  ADDWFC x10,F
4420:  BRA    4444
....................    else if(sc[1]=='b')
4422:  MOVLW  01
4424:  ADDWF  x0F,W
4426:  MOVWF  FE9
4428:  MOVLW  00
442A:  ADDWFC x10,W
442C:  MOVWF  FEA
442E:  MOVF   FEF,W
4430:  SUBLW  62
4432:  BNZ   4440
....................       base=2,sc+=2;
4434:  MOVLW  02
4436:  MOVWF  x0E
4438:  ADDWF  x0F,F
443A:  MOVLW  00
443C:  ADDWFC x10,F
443E:  BRA    4444
....................    else
....................       base=8;
4440:  MOVLW  08
4442:  MOVWF  x0E
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
4444:  MOVFF  310,312
4448:  MOVFF  30F,311
444C:  MOVFF  310,FEA
4450:  MOVFF  30F,FE9
4454:  MOVF   FEF,W
4456:  SUBLW  30
4458:  BNZ   4462
445A:  INCF   x0F,F
445C:  BTFSC  FD8.2
445E:  INCF   x10,F
4460:  BRA    444C
....................    sd=memchr(digits,tolower(*sc),base);
4462:  MOVFF  310,03
4466:  MOVFF  30F,FE9
446A:  MOVFF  03,FEA
446E:  MOVFF  FEF,33C
4472:  MOVF   x3C,W
4474:  SUBLW  40
4476:  BC    4484
4478:  MOVF   x3C,W
447A:  SUBLW  5A
447C:  BNC   4484
447E:  MOVF   x3C,W
4480:  IORLW  20
4482:  BRA    4486
4484:  MOVF   x3C,W
4486:  MOVWF  x3C
4488:  MOVLW  03
448A:  MOVWF  x3E
448C:  MOVLW  18
448E:  MOVWF  x3D
4490:  MOVFF  33C,33F
4494:  CLRF   x41
4496:  MOVFF  30E,340
449A:  BTFSC  x40.7
449C:  DECF   x41,F
449E:  MOVLB  0
44A0:  RCALL  41B0
44A2:  MOVFF  02,314
44A6:  MOVFF  01,313
....................    for(; sd!=0; )
44AA:  MOVLB  3
44AC:  MOVF   x13,F
44AE:  BNZ   44B4
44B0:  MOVF   x14,F
44B2:  BZ    4588
....................    {
....................       x=x*base+(int16)(sd-digits);
44B4:  CLRF   03
44B6:  MOVF   x0E,W
44B8:  BTFSC  FE8.7
44BA:  DECF   03,F
44BC:  MOVWF  00
44BE:  MOVFF  03,01
44C2:  CLRF   02
44C4:  CLRF   03
44C6:  BTFSS  01.7
44C8:  BRA    44CE
44CA:  DECF   02,F
44CC:  DECF   03,F
44CE:  MOVFF  03,33F
44D2:  MOVFF  02,33E
44D6:  MOVFF  01,33D
44DA:  MOVFF  00,33C
44DE:  CLRF   x43
44E0:  CLRF   x42
44E2:  MOVFF  316,341
44E6:  MOVFF  315,340
44EA:  MOVFF  03,347
44EE:  MOVFF  02,346
44F2:  MOVFF  01,345
44F6:  MOVFF  00,344
44FA:  MOVLB  0
44FC:  CALL   0CC4
4500:  MOVFF  03,33F
4504:  MOVFF  02,33E
4508:  MOVFF  01,33D
450C:  MOVFF  00,33C
4510:  MOVLW  18
4512:  MOVLB  3
4514:  SUBWF  x13,W
4516:  MOVWF  00
4518:  MOVLW  03
451A:  SUBWFB x14,W
451C:  MOVWF  03
451E:  MOVF   00,W
4520:  ADDWF  x3C,W
4522:  MOVWF  00
4524:  MOVF   03,W
4526:  ADDWFC 01,W
4528:  MOVWF  01
452A:  MOVLW  00
452C:  ADDWFC 02,W
452E:  MOVLW  00
4530:  ADDWFC x3F,W
4532:  MOVFF  01,316
4536:  MOVFF  00,315
....................       ++sc;
453A:  INCF   x0F,F
453C:  BTFSC  FD8.2
453E:  INCF   x10,F
....................       sd=memchr(digits,tolower(*sc),base);
4540:  MOVFF  310,FEA
4544:  MOVFF  30F,FE9
4548:  MOVFF  FEF,33C
454C:  MOVF   x3C,W
454E:  SUBLW  40
4550:  BC    455E
4552:  MOVF   x3C,W
4554:  SUBLW  5A
4556:  BNC   455E
4558:  MOVF   x3C,W
455A:  IORLW  20
455C:  BRA    4560
455E:  MOVF   x3C,W
4560:  MOVWF  x3C
4562:  MOVLW  03
4564:  MOVWF  x3E
4566:  MOVLW  18
4568:  MOVWF  x3D
456A:  MOVFF  33C,33F
456E:  CLRF   x41
4570:  MOVFF  30E,340
4574:  BTFSC  x40.7
4576:  DECF   x41,F
4578:  MOVLB  0
457A:  RCALL  41B0
457C:  MOVFF  02,314
4580:  MOVFF  01,313
4584:  BRA    44AA
4586:  MOVLB  3
....................    }
....................    if(s1==sc)
4588:  MOVF   x0F,W
458A:  SUBWF  x11,W
458C:  BNZ   45B6
458E:  MOVF   x10,W
4590:  SUBWF  x12,W
4592:  BNZ   45B6
....................    {
....................    StrtoulGO:
....................       if (endptr)
4594:  MOVLB  3
4596:  MOVF   x0C,W
4598:  IORWF  x0D,W
459A:  BZ    45AE
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
459C:  MOVFF  30D,FEA
45A0:  MOVFF  30C,FE9
45A4:  MOVFF  30B,FEC
45A8:  MOVF   FED,F
45AA:  MOVFF  30A,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
45AE:  MOVLW  00
45B0:  MOVWF  01
45B2:  MOVWF  02
45B4:  BRA    45D6
....................    }
....................    if (endptr)
45B6:  MOVF   x0C,W
45B8:  IORWF  x0D,W
45BA:  BZ    45CE
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
45BC:  MOVFF  30D,FEA
45C0:  MOVFF  30C,FE9
45C4:  MOVFF  310,FEC
45C8:  MOVF   FED,F
45CA:  MOVFF  30F,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
45CE:  MOVFF  315,01
45D2:  MOVFF  316,02
45D6:  MOVLB  0
45D8:  GOTO   4722 (RETURN)
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
*
0D68:  MOVFF  51,343
0D6C:  MOVFF  50,342
0D70:  MOVFF  4F,341
0D74:  MOVFF  4E,340
0D78:  MOVLW  41
0D7A:  MOVLB  3
0D7C:  MOVWF  x47
0D7E:  MOVLW  C6
0D80:  MOVWF  x46
0D82:  MOVLW  4E
0D84:  MOVWF  x45
0D86:  MOVLW  6D
0D88:  MOVWF  x44
0D8A:  MOVLB  0
0D8C:  RCALL  0CC4
0D8E:  MOVLW  39
0D90:  MOVLB  2
0D92:  ADDWF  00,W
0D94:  MOVWF  4E
0D96:  MOVLW  30
0D98:  ADDWFC 01,W
0D9A:  MOVWF  4F
0D9C:  MOVLW  00
0D9E:  ADDWFC 02,W
0DA0:  MOVWF  50
0DA2:  MOVLW  00
0DA4:  ADDWFC 03,W
0DA6:  MOVWF  51
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
0DA8:  MOVFF  50,00
0DAC:  MOVFF  51,01
0DB0:  CLRF   02
0DB2:  CLRF   03
0DB4:  MOVFF  51,2E5
0DB8:  MOVFF  50,2E4
0DBC:  MOVFF  51,2E7
0DC0:  MOVFF  50,2E6
0DC4:  MOVLW  7F
0DC6:  MOVWF  xE9
0DC8:  SETF   xE8
0DCA:  MOVLB  0
0DCC:  BRA    0D20
0DCE:  MOVFF  00,01
0DD2:  MOVFF  03,02
0DD6:  GOTO   0EE6 (RETURN)
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
*
0CB0:  MOVFF  2E6,51
0CB4:  MOVFF  2E5,50
0CB8:  MOVFF  2E4,4F
0CBC:  MOVFF  2E3,4E
0CC0:  GOTO   0EE4 (RETURN)
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.c"
.................... /*********************************************************************
....................  *
....................  *                  Helper Functions for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.C
....................  * Dependencies:    compiler.h
....................  *                  helpers.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid
....................  *                               multi-byte shift operation.
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and
....................  *                        btohexa_low()
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... /*********************************************************************
....................  *
....................  *            ENC28J60 registers/bits
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.h
....................  * Description: 	Include file for ENC28J60 control registers
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder		06/01/04	Original
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a 
....................  *									couple of PHY register structs.
....................  * Howard Schlunder		09/29/04	Matched with data sheet
....................  * Howard Schlunder		01/04/06	Matched with new data sheet
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN
....................  * Howard Schlunder		07/21/06	Several bits removed to match now 
....................  *									reserved bits in rev. B data sheet 
....................  *									(DS39662B)
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef ENC28J60_H
.................... #define ENC28J60_H
.................... 
.................... typedef union {
.................... 	BYTE v[7];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 CollisionCount:4;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 Done:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 PacketDefer:1;
.................... 		int8 ExcessiveDefer:1;
.................... 		int8 MaximumCollisions:1;
.................... 		int8 LateCollision:1;
.................... 		int8 Giant:1;
.................... 		int8 Underrun:1;
.................... 		int16 	 BytesTransmittedOnWire;
.................... 		int8 ControlFrame:1;
.................... 		int8 PAUSEControlFrame:1;
.................... 		int8 BackpressureApplied:1;
.................... 		int8 VLANTaggedFrame:1;
.................... 		int8 Zeros:4;
.................... 	} bits;
.................... } TXSTATUS;
.................... 
.................... typedef union {
.................... 	char v[4];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 PreviouslyIgnored:1;
.................... 		int8 RXDCPreviouslySeen:1;
.................... 		int8 CarrierPreviouslySeen:1;
.................... 		int8 CodeViolation:1;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 ReceiveOk:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 DribbleNibble:1;
.................... 		int8 ControlFrame:1;
.................... 		int8 PauseControlFrame:1;
.................... 		int8 UnsupportedOpcode:1;
.................... 		int8 VLANType:1;
.................... 		int8 Zero:1;
.................... 	} bits;
.................... } RXSTATUS;
.................... 
.................... /******************************************************************************
.................... * Register locations
.................... ******************************************************************************/
.................... // Bank 0 registers --------
.................... #define ERDPTL		0x00
.................... #define ERDPTH		0x01
.................... #define EWRPTL		0x02
.................... #define EWRPTH		0x03
.................... #define ETXSTL		0x04
.................... #define ETXSTH		0x05
.................... #define ETXNDL		0x06
.................... #define ETXNDH		0x07
.................... #define ERXSTL		0x08
.................... #define ERXSTH		0x09
.................... #define ERXNDL		0x0A
.................... #define ERXNDH		0x0B
.................... #define ERXRDPTL	0x0C
.................... #define ERXRDPTH	0x0D
.................... #define ERXWRPTL	0x0E
.................... #define ERXWRPTH	0x0F
.................... #define EDMASTL		0x10
.................... #define EDMASTH		0x11
.................... #define EDMANDL		0x12
.................... #define EDMANDH		0x13
.................... #define EDMADSTL	0x14
.................... #define EDMADSTH	0x15
.................... #define EDMACSL		0x16
.................... #define EDMACSH		0x17
.................... //#define			0x18
.................... //#define			0x19
.................... //#define r			0x1A
.................... #define EIE			0x1B
.................... #define EIR			0x1C
.................... #define ESTAT		0x1D
.................... #define ECON2		0x1E
.................... #define ECON1		0x1F
.................... 
.................... // Bank 1 registers -----
.................... #define EHT0		0x100
.................... #define EHT1		0x101
.................... #define EHT2		0x102
.................... #define EHT3		0x103
.................... #define EHT4		0x104
.................... #define EHT5		0x105
.................... #define EHT6		0x106
.................... #define EHT7		0x107
.................... #define EPMM0		0x108
.................... #define EPMM1		0x109
.................... #define EPMM2		0x10A
.................... #define EPMM3		0x10B
.................... #define EPMM4		0x10C
.................... #define EPMM5		0x10D
.................... #define EPMM6		0x10E
.................... #define EPMM7		0x10F
.................... #define EPMCSL		0x110
.................... #define EPMCSH		0x111
.................... //#define			0x112
.................... //#define			0x113
.................... #define EPMOL		0x114
.................... #define EPMOH		0x115
.................... //#define r			0x116
.................... //#define r			0x117
.................... #define ERXFCON		0x118
.................... #define EPKTCNT		0x119
.................... //#define r			0x11A
.................... //#define EIE		0x11B
.................... //#define EIR		0x11C
.................... //#define ESTAT		0x11D
.................... //#define ECON2		0x11E
.................... //#define ECON1		0x11F
.................... 
.................... // Bank 2 registers -----
.................... #define MACON1		0x200
.................... #define MACON2    0x201
.................... //#define r			0x201
.................... #define MACON3		0x202
.................... #define MACON4		0x203
.................... #define MABBIPG		0x204
.................... //#define			0x205
.................... #define MAIPGL		0x206
.................... #define MAIPGH		0x207
.................... #define MACLCON1	0x208
.................... #define MACLCON2	0x209
.................... #define MAMXFLL		0x20A
.................... #define MAMXFLH		0x20B
.................... //#define r			0x20C
.................... //#define r			0x20D
.................... //#define r			0x20E
.................... //#define			0x20F
.................... //#define r			0x210
.................... //#define r			0x211
.................... #define MICMD		0x212
.................... //#define r			0x213
.................... #define MIREGADR	0x214
.................... //#define r			0x215
.................... #define MIWRL		0x216
.................... #define MIWRH		0x217
.................... #define MIRDL		0x218
.................... #define MIRDH		0x219
.................... //#define r			0x21A
.................... //#define EIE		0x21B
.................... //#define EIR		0x21C
.................... //#define ESTAT		0x21D
.................... //#define ECON2		0x21E
.................... //#define ECON1		0x21F
.................... 
.................... // Bank 3 registers -----
.................... #define MAADR5		0x300
.................... #define MAADR6		0x301
.................... #define MAADR3		0x302
.................... #define MAADR4		0x303
.................... #define MAADR1		0x304
.................... #define MAADR2		0x305
.................... #define EBSTSD		0x306
.................... #define EBSTCON		0x307
.................... #define EBSTCSL		0x308
.................... #define EBSTCSH		0x309
.................... #define MISTAT		0x30A
.................... //#define			0x30B
.................... //#define			0x30C
.................... //#define			0x30D
.................... //#define			0x30E
.................... //#define			0x30F
.................... //#define			0x310
.................... //#define			0x311
.................... #define EREVID		0x312
.................... //#define			0x313
.................... //#define			0x314
.................... #define ECOCON		0x315
.................... //#define 			0x316
.................... #define EFLOCON		0x317
.................... #define EPAUSL		0x318
.................... #define EPAUSH		0x319
.................... //#define r			0x31A
.................... //#define EIE		0x31B
.................... //#define EIR		0x31C
.................... //#define ESTAT		0x31D
.................... //#define ECON2		0x31E
.................... //#define ECON1		0x31F
.................... 
.................... 
.................... 
.................... // Structures
.................... typedef union _REG
.................... {
.................... 	char Val;
.................... 
.................... 	// EIE bits ----------
.................... 	struct {
.................... 		unsigned char RXERIE:1;
.................... 		unsigned char TXERIE:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIE:1;
.................... 		unsigned char LINKIE:1;
.................... 		unsigned char DMAIE:1;
.................... 		unsigned char PKTIE:1;
.................... 		unsigned char INTIE:1;
.................... 	} EIEbits;
.................... 
.................... 	// EIR bits ----------
.................... 	struct {
.................... 		unsigned char RXERIF:1;
.................... 		unsigned char TXERIF:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIF:1;
.................... 		unsigned char LINKIF:1;
.................... 		unsigned char DMAIF:1;
.................... 		unsigned char PKTIF:1;
.................... 		unsigned char blank1:1;
.................... 	} EIRbits;
.................... 
.................... 	// ESTAT bits ---------
.................... 	struct {
.................... 		unsigned char CLKRDY:1;
.................... 		unsigned char TXABRT:1;
.................... 		unsigned char RXBUSY:1;
.................... 		unsigned char blank1:1;
.................... 		unsigned char LATECOL:1;
.................... 		unsigned char blank2:2;
.................... 		unsigned char INTR:1;
.................... 	} ESTATbits;
.................... 
.................... 	// ECON2 bits --------
.................... 	struct {
.................... 		unsigned char blank3:3;
.................... 		unsigned char VRPS:1;
.................... 		unsigned char VRTP:1;
.................... 		unsigned char PWRSV:1;
.................... 		unsigned char PKTDEC:1;
.................... 		unsigned char AUTOINC:1;
.................... 	} ECON2bits;
.................... 
.................... 	// ECON1 bits --------
.................... 	struct {
.................... 		unsigned char BSEL0:1;
.................... 		unsigned char BSEL1:1;
.................... 		unsigned char RXEN:1;
.................... 		unsigned char TXRTS:1;
.................... 		unsigned char CSUMEN:1;
.................... 		unsigned char DMAST:1;
.................... 		unsigned char RXRST:1;
.................... 		unsigned char TXRST:1;
.................... 	} ECON1bits;
.................... 
.................... 	// ERXFCON bits ------
.................... 	struct {
.................... 		unsigned char BCEN:1;
.................... 		unsigned char MCEN:1;
.................... 		unsigned char HTEN:1;
.................... 		unsigned char MPEN:1;
.................... 		unsigned char PMEN:1;
.................... 		unsigned char CRCEN:1;
.................... 		unsigned char ANDOR:1;
.................... 		unsigned char UCEN:1;
.................... 	} ERXFCONbits;
.................... 
.................... 	// MACON1 bits --------
.................... 	struct {
.................... 		unsigned char MARXEN:1;
.................... 		unsigned char PASSALL:1;
.................... 		unsigned char RXPAUS:1;
.................... 		unsigned char TXPAUS:1;
.................... 		unsigned char :4;
.................... 	} MACON1bits;
.................... 
.................... 
.................... 	// MACON3 bits --------
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG0:1;
.................... 		unsigned char PADCFG1:1;
.................... 		unsigned char PADCFG2:1;
.................... 	} MACON3bits;
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG:3;
.................... 	} MACON3bits2;
.................... 
.................... 	// MACON4 bits --------
.................... 	struct {
.................... 		unsigned char :4;
.................... 		unsigned char NOBKOFF:1;
.................... 		unsigned char BPEN:1;
.................... 		unsigned char DEFER:1;
.................... 		unsigned char blank1:1;
.................... 	} MACON4bits;
.................... 
.................... 	// MICMD bits ---------
.................... 	struct {
.................... 		unsigned char MIIRD:1;
.................... 		unsigned char MIISCAN:1;
.................... 		unsigned char blank6:6;
.................... 	} MICMDbits;
.................... 
.................... 	// EBSTCON bits -----
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL0:1;
.................... 		unsigned char TMSEL1:1;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV0:1;
.................... 		unsigned char PSV1:1;
.................... 		unsigned char PSV2:1;
.................... 	} EBSTCONbits;
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL:2;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV:3;
.................... 	} EBSTCONbits2;
.................... 
.................... 	// MISTAT bits --------
.................... 	struct {
.................... 		unsigned char BUSY:1;
.................... 		unsigned char SCAN:1;
.................... 		unsigned char NVALID:1;
.................... 		unsigned char blank5:5;
.................... 	} MISTATbits;
.................... 
.................... 	// ECOCON bits -------
.................... 	struct {
.................... 		unsigned char COCON0:1;
.................... 		unsigned char COCON1:1;
.................... 		unsigned char COCON2:1;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits;
.................... 	struct {
.................... 		unsigned char COCON:3;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits2;
.................... 
.................... 	// EFLOCON bits -----
.................... 	struct {
.................... 		unsigned char FCEN0:1;
.................... 		unsigned char FCEN1:1;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits;
.................... 	struct {
.................... 		unsigned char FCEN:2;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits2;
.................... } REG;
.................... 
.................... 
.................... /******************************************************************************
.................... * PH Register Locations
.................... ******************************************************************************/
.................... #define PHCON1	0x00
.................... #define PHSTAT1	0x01
.................... #define PHID1	0x02
.................... #define PHID2	0x03
.................... #define PHCON2	0x10
.................... #define PHSTAT2	0x11
.................... #define PHIE	0x12
.................... #define PHIR	0x13
.................... #define PHLCON	0x14
.................... 
.................... 
.................... typedef union {
.................... 	int16 Val;
.................... 	WORD_VAL VAL;
.................... 
.................... 	// PHCON1 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 PDPXMD:1;
.................... 		int8 blank2:2;
.................... 		int8 PPWRSV:1;
.................... 		int8 blank22:2;
.................... 		int8 PLOOPBK:1;
.................... 		int8 PRST:1;
.................... 	} PHCON1bits;
.................... 
.................... 	// PHSTAT1 bits --------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 JBSTAT:1;
.................... 		int8 LLSTAT:1;
.................... 		int8 blank5:5;
.................... 		int8 blank3:3;
.................... 		int8 PHDPX:1;
.................... 		int8 PFDPX:1;
.................... 		int8 blank33:3;
.................... 	} PHSTAT1bits;
.................... 
.................... 	// PHID2 bits ----------
.................... 	struct {
.................... 		int8 PREV0:1;
.................... 		int8 PREV1:1;
.................... 		int8 PREV2:1;
.................... 		int8 PREV3:1;
.................... 		int8 PPN0:1;
.................... 		int8 PPN1:1;
.................... 		int8 PPN2:1;
.................... 		int8 PPN3:1;
.................... 		int8 PPN4:1;
.................... 		int8 PPN5:1;
.................... 		int8 PID19:1;
.................... 		int8 PID20:1;
.................... 		int8 PID21:1;
.................... 		int8 PID22:1;
.................... 		int8 PID23:1;
.................... 		int8 PID24:1;
.................... 	} PHID2bits;
.................... 	struct {
.................... 		int8 PREV:4;
.................... 		int8 PPNL:4;
.................... 		int8 PPNH:2;
.................... 		int8 PID:6;
.................... 	} PHID2bits2;
.................... 
.................... 	// PHCON2 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 HDLDIS:1;
.................... 		int8 blank1:1;
.................... 		int8 JABBER:1;
.................... 		int8 blank2:2;
.................... 		int8 TXDIS:1;
.................... 		int8 FRCLNK:1;
.................... 		int8 blank11:1;
.................... 	} PHCON2bits;
.................... 
.................... 	// PHSTAT2 bits --------
.................... 	struct {
.................... 		int8 blank5:5;
.................... 		int8 PLRITY:1;
.................... 		int8 blank2:2;
.................... 		int8 blank11:1;
.................... 		int8 DPXSTAT:1;
.................... 		int8 LSTAT:1;
.................... 		int8 COLSTAT:1;
.................... 		int8 RXSTAT:1;
.................... 		int8 TXSTAT:1;
.................... 		int8 blank22:2;
.................... 	} PHSTAT2bits;
.................... 
.................... 	// PHIE bits -----------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 PGEIE:1;
.................... 		int8 blank2:2;
.................... 		int8 PLNKIE:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIEbits;
.................... 
.................... 	// PHIR bits -----------
.................... 	struct {
.................... 		int8 blank2:2;
.................... 		int8 PGIF:1;
.................... 		int8 blank1:1;
.................... 		int8 PLNKIF:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIRbits;
.................... 
.................... 	// PHLCON bits -------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ0:1;
.................... 		int8 LFRQ1:1;
.................... 		int8 LBCFG0:1;
.................... 		int8 LBCFG1:1;
.................... 		int8 LBCFG2:1;
.................... 		int8 LBCFG3:1;
.................... 		int8 LACFG0:1;
.................... 		int8 LACFG1:1;
.................... 		int8 LACFG2:1;
.................... 		int8 LACFG3:1;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits;
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ:2;
.................... 		int8 LBCFG:4;
.................... 		int8 LACFG:4;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits2;
.................... } PHYREG;
.................... 
.................... 
.................... /******************************************************************************
.................... * Individual Register Bits
.................... ******************************************************************************/
.................... // ETH/MAC/MII bits
.................... 
.................... // EIE bits ----------
.................... #define	EIE_INTIE		(1<<7)
.................... #define	EIE_PKTIE		(1<<6)
.................... #define	EIE_DMAIE		(1<<5)
.................... #define	EIE_LINKIE		(1<<4)
.................... #define	EIE_TXIE		(1<<3)
.................... #define	EIE_TXERIE		(1<<1)
.................... #define	EIE_RXERIE		(1)
.................... 
.................... // EIR bits ----------
.................... #define	EIR_PKTIF		(1<<6)
.................... #define	EIR_DMAIF		(1<<5)
.................... #define	EIR_LINKIF		(1<<4)
.................... #define	EIR_TXIF		(1<<3)
.................... #define	EIR_TXERIF		(1<<1)
.................... #define	EIR_RXERIF		(1)
.................... 
.................... // ESTAT bits ---------
.................... #define	ESTAT_INT		(1<<7)
.................... #define ESTAT_BUFFER	(1<<6)
.................... #define	ESTAT_LATECOL	(1<<4)
.................... #define	ESTAT_RXBUSY	(1<<2)
.................... #define	ESTAT_TXABRT	(1<<1)
.................... #define	ESTAT_CLKRDY	(1)
.................... 
.................... // ECON2 bits --------
.................... #define	ECON2_AUTOINC	(1<<7)
.................... #define	ECON2_PKTDEC	(1<<6)
.................... #define	ECON2_PWRSV		(1<<5)
.................... #define	ECON2_VRPS		(1<<3)
.................... 
.................... // ECON1 bits --------
.................... #define	ECON1_TXRST		(1<<7)
.................... #define	ECON1_RXRST		(1<<6)
.................... #define	ECON1_DMAST		(1<<5)
.................... #define	ECON1_CSUMEN	(1<<4)
.................... #define	ECON1_TXRTS		(1<<3)
.................... #define	ECON1_RXEN		(1<<2)
.................... #define	ECON1_BSEL1		(1<<1)
.................... #define	ECON1_BSEL0		(1)
.................... 
.................... // ERXFCON bits ------
.................... #define	ERXFCON_UCEN	(1<<7)
.................... #define	ERXFCON_ANDOR	(1<<6)
.................... #define	ERXFCON_CRCEN	(1<<5)
.................... #define	ERXFCON_PMEN	(1<<4)
.................... #define	ERXFCON_MPEN	(1<<3)
.................... #define	ERXFCON_HTEN	(1<<2)
.................... #define	ERXFCON_MCEN	(1<<1)
.................... #define	ERXFCON_BCEN	(1)
.................... 
.................... // MACON1 bits --------
.................... #define	MACON1_TXPAUS	(1<<3)
.................... #define	MACON1_RXPAUS	(1<<2)
.................... #define	MACON1_PASSALL	(1<<1)
.................... #define	MACON1_MARXEN	(1)
.................... 
.................... // MACON3 bits --------
.................... #define	MACON3_PADCFG2	(1<<7)
.................... #define	MACON3_PADCFG1	(1<<6)
.................... #define	MACON3_PADCFG0	(1<<5)
.................... #define	MACON3_TXCRCEN	(1<<4)
.................... #define	MACON3_PHDRLEN	(1<<3)
.................... #define	MACON3_HFRMEN	(1<<2)
.................... #define	MACON3_FRMLNEN	(1<<1)
.................... #define	MACON3_FULDPX	(1)
.................... 
.................... // MACON4 bits --------
.................... #define	MACON4_DEFER	(1<<6)
.................... #define	MACON4_BPEN		(1<<5)
.................... #define	MACON4_NOBKOFF	(1<<4)
.................... 
.................... 
.................... // MICMD bits ---------
.................... #define	MICMD_MIISCAN	(1<<1)
.................... #define	MICMD_MIIRD		(1)
.................... 
.................... // EBSTCON bits -----
.................... #define	EBSTCON_PSV2	(1<<7)
.................... #define	EBSTCON_PSV1	(1<<6)
.................... #define	EBSTCON_PSV0	(1<<5)
.................... #define	EBSTCON_PSEL	(1<<4)
.................... #define	EBSTCON_TMSEL1	(1<<3)
.................... #define	EBSTCON_TMSEL0	(1<<2)
.................... #define	EBSTCON_TME		(1<<1)
.................... #define	EBSTCON_BISTST	(1)
.................... 
.................... // MISTAT bits --------
.................... #define	MISTAT_NVALID	(1<<2)
.................... #define	MISTAT_SCAN		(1<<1)
.................... #define	MISTAT_BUSY		(1)
.................... 
.................... // ECOCON bits -------
.................... #define	ECOCON_COCON2	(1<<2)
.................... #define	ECOCON_COCON1	(1<<1)
.................... #define	ECOCON_COCON0	(1)
.................... 
.................... // EFLOCON bits -----
.................... #define	EFLOCON_FULDPXS	(1<<2)
.................... #define	EFLOCON_FCEN1	(1<<1)
.................... #define	EFLOCON_FCEN0	(1)
.................... 
.................... 
.................... 
.................... // PHY bits
.................... 
.................... // PHCON1 bits ----------
.................... #define	PHCON1_PRST		(1ul<<15)
.................... #define	PHCON1_PLOOPBK	(1ul<<14)
.................... #define	PHCON1_PPWRSV	(1ul<<11)
.................... #define	PHCON1_PDPXMD	(1ul<<8)
.................... 
.................... // PHSTAT1 bits --------
.................... #define	PHSTAT1_PFDPX	(1ul<<12)
.................... #define	PHSTAT1_PHDPX	(1ul<<11)
.................... #define	PHSTAT1_LLSTAT	(1ul<<2)
.................... #define	PHSTAT1_JBSTAT	(1ul<<1)
.................... 
.................... // PHID2 bits --------
.................... #define	PHID2_PID24		(1ul<<15)
.................... #define	PHID2_PID23		(1ul<<14)
.................... #define	PHID2_PID22		(1ul<<13)
.................... #define	PHID2_PID21		(1ul<<12)
.................... #define	PHID2_PID20		(1ul<<11)
.................... #define	PHID2_PID19		(1ul<<10)
.................... #define	PHID2_PPN5		(1ul<<9)
.................... #define	PHID2_PPN4		(1ul<<8)
.................... #define	PHID2_PPN3		(1ul<<7)
.................... #define	PHID2_PPN2		(1ul<<6)
.................... #define	PHID2_PPN1		(1ul<<5)
.................... #define	PHID2_PPN0		(1ul<<4)
.................... #define	PHID2_PREV3		(1ul<<3)
.................... #define	PHID2_PREV2		(1ul<<2)
.................... #define	PHID2_PREV1		(1ul<<1)
.................... #define	PHID2_PREV0		(1ul)
.................... 
.................... // PHCON2 bits ----------
.................... #define	PHCON2_FRCLNK	(1ul<<14)
.................... #define	PHCON2_TXDIS	(1ul<<13)
.................... #define	PHCON2_JABBER	(1ul<<10)
.................... #define	PHCON2_HDLDIS	(1ul<<8)
.................... 
.................... // PHSTAT2 bits --------
.................... #define	PHSTAT2_TXSTAT	(1ul<<13)
.................... #define	PHSTAT2_RXSTAT	(1ul<<12)
.................... #define	PHSTAT2_COLSTAT	(1ul<<11)
.................... #define	PHSTAT2_LSTAT	(1ul<<10)
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9)
.................... #define	PHSTAT2_PLRITY	(1ul<<5)
.................... 
.................... // PHIE bits -----------
.................... #define	PHIE_PLNKIE		(1ul<<4)
.................... #define	PHIE_PGEIE		(1ul<<1)
.................... 
.................... // PHIR bits -----------
.................... #define	PHIR_PLNKIF		(1ul<<4)
.................... #define	PHIR_PGIF		(1ul<<2)
.................... 
.................... // PHLCON bits -------
.................... #define	PHLCON_LACFG3	(1ul<<11)
.................... #define	PHLCON_LACFG2	(1ul<<10)
.................... #define	PHLCON_LACFG1	(1ul<<9)
.................... #define	PHLCON_LACFG0	(1ul<<8)
.................... #define	PHLCON_LBCFG3	(1ul<<7)
.................... #define	PHLCON_LBCFG2	(1ul<<6)
.................... #define	PHLCON_LBCFG1	(1ul<<5)
.................... #define	PHLCON_LBCFG0	(1ul<<4)
.................... #define	PHLCON_LFRQ1	(1ul<<3)
.................... #define	PHLCON_LFRQ0	(1ul<<2)
.................... #define	PHLCON_STRCH	(1ul<<1)
.................... 
.................... #endif
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars)
.................... *
.................... * PreCondition:    None
.................... *
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or
.................... *                  'a'-'f'
.................... *
.................... * Output:          The resulting packed byte: 0x00-0xFF
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:         None
.................... ********************************************************************/
.................... BYTE hexatob(WORD_VAL AsciiChars)
.................... {
....................    // Convert lowercase to uppercase
....................    if(AsciiChars.v[1] > 'F')
....................       AsciiChars.v[1] -= 'a'-'A';
....................    if(AsciiChars.v[0] > 'F')
....................       AsciiChars.v[0] -= 'a'-'A';
.................... 
....................    // Convert 0-9, A-F to 0x0-0xF
....................    if(AsciiChars.v[1] > '9')
....................       AsciiChars.v[1] -= 'A' - 10;
....................    else
....................       AsciiChars.v[1] -= '0';
.................... 
....................    if(AsciiChars.v[0] > '9')
....................       AsciiChars.v[0] -= 'A' - 10;
....................    else
....................       AsciiChars.v[0] -= '0';
.................... 
....................    // Concatenate
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        BYTE btohexa_high(BYTE b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           One byte ranged 0x00-0xFF
....................  *
....................  * Output:          An ascii byte (always uppercase) between '0'-'9'
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of
....................  *               the input byte.
....................  *               ex: b = 0xAE, btohexa_high() returns 'A'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:         None
....................  ********************************************************************/
.................... BYTE btohexa_high(BYTE b)
.................... {
....................    b >>= 4;
....................    return (b>0x9) ? b+'A'-10:b+'0';
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        BYTE btohexa_low(BYTE b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           One byte ranged 0x00-0xFF
....................  *
....................  * Output:          An ascii byte (always uppercase) between '0'-'9'
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of
....................  *               the input byte.
....................  *               ex: b = 0xAE, btohexa_low() returns 'E'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:         None
....................  ********************************************************************/
.................... BYTE btohexa_low(BYTE b)
.................... {
....................    b &= 0x0F;
....................    return (b>9) ? b+'A'-10:b+'0';
.................... }
.................... 
.................... WORD swaps(WORD_VAL v)
.................... {
....................     WORD_VAL new;
.................... 
....................     new.v[0]=v.v[1];
*
122C:  MOVFF  38F,390
....................     new.v[1]=v.v[0];
1230:  MOVFF  38E,391
.................... 
....................     return(new.Val);
1234:  MOVLB  3
1236:  MOVFF  390,01
123A:  MOVFF  391,02
123E:  MOVLB  0
1240:  RETURN 0
.................... }
.................... 
.................... DWORD swapl(DWORD_VAL v)
.................... {
....................     DWORD_VAL new;
.................... 
....................     new.v[0]=v.v[3];
*
2108:  MOVFF  37A,37B
....................     new.v[1]=v.v[2];
210C:  MOVFF  379,37C
....................     new.v[2]=v.v[1];
2110:  MOVFF  378,37D
....................     new.v[3]=v.v[0];
2114:  MOVFF  377,37E
.................... 
....................     return(new.Val);
2118:  MOVFF  37B,00
211C:  MOVFF  37C,01
2120:  MOVFF  37D,02
2124:  MOVFF  37E,03
2128:  RETURN 0
.................... }
.................... 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count)
.................... {
....................    WORD i;
....................    WORD *val;
.................... 
....................    union
....................    {
....................       DWORD Val;
....................       struct
....................       {
....................          WORD_VAL LSB;
....................          WORD_VAL MSB;
....................       } words;
....................    } tempSum, sum;
.................... 
....................    sum.Val = 0;
*
1E7C:  MOVLB  3
1E7E:  CLRF   x80
1E80:  CLRF   x7F
1E82:  CLRF   x7E
1E84:  CLRF   x7D
.................... 
....................    i = count >> 1;
1E86:  BCF    FD8.0
1E88:  RRCF   x74,W
1E8A:  MOVWF  x76
1E8C:  RRCF   x73,W
1E8E:  MOVWF  x75
....................    val = (WORD *)buffer;
1E90:  MOVFF  372,378
1E94:  MOVFF  371,377
.................... 
....................    while( i-- )
1E98:  MOVFF  376,03
1E9C:  MOVF   x75,W
1E9E:  BTFSC  FD8.2
1EA0:  DECF   x76,F
1EA2:  DECF   x75,F
1EA4:  IORWF  03,W
1EA6:  BZ    1ECE
....................       sum.Val += *val++;
1EA8:  MOVFF  378,FEA
1EAC:  MOVFF  377,FE9
1EB0:  MOVLW  02
1EB2:  ADDWF  x77,F
1EB4:  BTFSC  FD8.0
1EB6:  INCF   x78,F
1EB8:  MOVFF  FEC,03
1EBC:  MOVF   FED,F
1EBE:  MOVF   FEF,W
1EC0:  ADDWF  x7D,F
1EC2:  MOVF   03,W
1EC4:  ADDWFC x7E,F
1EC6:  MOVLW  00
1EC8:  ADDWFC x7F,F
1ECA:  ADDWFC x80,F
1ECC:  BRA    1E98
.................... 
....................    if ( count & 1 )
1ECE:  MOVF   x73,W
1ED0:  ANDLW  01
1ED2:  MOVWF  00
1ED4:  CLRF   03
1ED6:  MOVF   00,W
1ED8:  IORWF  03,W
1EDA:  BZ    1EF0
....................       sum.Val += *(BYTE *)val;
1EDC:  MOVFF  378,FEA
1EE0:  MOVFF  377,FE9
1EE4:  MOVF   FEF,W
1EE6:  ADDWF  x7D,F
1EE8:  MOVLW  00
1EEA:  ADDWFC x7E,F
1EEC:  ADDWFC x7F,F
1EEE:  ADDWFC x80,F
.................... 
....................    tempSum.Val = sum.Val;
1EF0:  MOVFF  380,37C
1EF4:  MOVFF  37F,37B
1EF8:  MOVFF  37E,37A
1EFC:  MOVFF  37D,379
.................... 
....................    while( (i = tempSum.words.MSB.Val) != 0u )
1F00:  MOVFF  37C,376
1F04:  MOVFF  37B,375
1F08:  MOVF   x75,F
1F0A:  BNZ   1F10
1F0C:  MOVF   x76,F
1F0E:  BZ    1F56
....................    {
....................       sum.words.MSB.Val = 0;
1F10:  CLRF   x80
1F12:  CLRF   x7F
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i;
1F14:  CLRF   x84
1F16:  CLRF   x83
1F18:  MOVFF  37E,382
1F1C:  MOVFF  37D,381
1F20:  MOVFF  375,00
1F24:  MOVFF  376,01
1F28:  CLRF   02
1F2A:  CLRF   03
1F2C:  MOVF   00,W
1F2E:  ADDWF  x7D,W
1F30:  MOVWF  x7D
1F32:  MOVF   01,W
1F34:  ADDWFC x7E,W
1F36:  MOVWF  x7E
1F38:  MOVF   02,W
1F3A:  ADDWFC x83,W
1F3C:  MOVWF  x7F
1F3E:  MOVF   03,W
1F40:  ADDWFC x84,W
1F42:  MOVWF  x80
....................       tempSum.Val = sum.Val;
1F44:  MOVFF  380,37C
1F48:  MOVFF  37F,37B
1F4C:  MOVFF  37E,37A
1F50:  MOVFF  37D,379
1F54:  BRA    1F00
....................    }
.................... 
....................    return (~sum.words.LSB.Val);
1F56:  MOVFF  37E,03
1F5A:  COMF   03,F
1F5C:  MOVF   x7D,W
1F5E:  XORLW  FF
1F60:  MOVWF  01
1F62:  MOVFF  03,02
1F66:  MOVLB  0
1F68:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        WORD CalcIPBufferChecksum(WORD len)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  MAC buffer pointer set to starting of buffer
....................  *
....................  * Input:           len     - Total number of bytes to calculate
....................  *                          checksum for.
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs checksum calculation in
....................  *                  MAC buffer itself.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #if !defined(MCHP_MAC)
.................... WORD CalcIPBufferChecksum(WORD len)
.................... {
....................     BOOL lbMSB;
....................     WORD_VAL checkSum;
....................     BYTE Checkbyte;
.................... 
....................     lbMSB = TRUE;
....................     checkSum.Val = 0;
.................... 
....................     while( len-- )
....................     {
....................         Checkbyte = MACGet();
.................... 
....................         if ( !lbMSB )
....................         {
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte)
....................             {
....................                 if ( ++checkSum.v[1] == 0 )
....................                     checkSum.v[0]++;
....................             }
....................         }
....................         else
....................         {
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte)
....................             {
....................                 if ( ++checkSum.v[0] == 0 )
....................                     checkSum.v[1]++;
....................             }
....................         }
.................... 
....................         lbMSB = !lbMSB;
....................     }
.................... 
....................     checkSum.v[1] = ~checkSum.v[1];
....................     checkSum.v[0] = ~checkSum.v[0];
....................     return checkSum.Val;
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void delay_s(int8 s) {
....................    while(s) {
....................       restart_wdt();
....................       delay_ms(1000);
....................       s--;
....................    }
.................... }
.................... 
.................... #include "tcpip/tick.c"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.c
....................  * Dependencies:    stackTSK.h
....................  *                  Tick.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt
....................  ********************************************************************/
.................... 
.................... #define TICK_INCLUDE
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... TICKTYPE TickCount = 0;  //increment every 100ms
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void)
.................... {
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16);
*
07BA:  MOVLW  83
07BC:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER);
07BE:  MOVLW  85
07C0:  MOVWF  FD7
07C2:  MOVLW  ED
07C4:  MOVWF  FD6
.................... 
....................     enable_interrupts(INT_TIMER0);
07C6:  BSF    FF2.5
....................     enable_interrupts(GLOBAL);
07C8:  MOVLW  C0
07CA:  IORWF  FF2,F
07CC:  GOTO   107A (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void)
.................... {
....................     int16 ret;
....................     disable_interrupts(INT_TIMER0);
*
24E0:  BCF    FF2.5
....................     ret=TickCount;
24E2:  MOVFF  54,333
24E6:  MOVFF  53,332
....................     enable_interrupts(INT_TIMER0);
24EA:  BSF    FF2.5
....................     return ret;
24EC:  MOVLB  3
24EE:  MOVFF  332,01
24F2:  MOVFF  333,02
24F6:  MOVLB  0
24F8:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... int8 second_counter=0;  //increment this every 1s
.................... int8 second_counter_intermediate=0;
.................... 
.................... #if STACK_USE_PPP
....................  int8 ppp_second_counter=0;
....................  int8 ppp_second_counter_intermediate=0;
.................... #endif
.................... 
.................... #int_timer0
.................... void Tick_Isr(void)
.................... {
....................         TickCount++;    //increment this every 100ms
*
00C2:  INCF   53,F
00C4:  BTFSC  FD8.2
00C6:  INCF   54,F
.................... 
....................         second_counter_intermediate++;
00C8:  INCF   56,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) {
00CA:  MOVF   56,W
00CC:  SUBLW  09
00CE:  BC    00D4
....................             second_counter++; //increment this ever 1s
00D0:  INCF   55,F
....................             second_counter_intermediate=0;
00D2:  CLRF   56
....................         }
.................... 
.................... 
....................        #if STACK_USE_PPP
....................         ppp_second_counter_intermediate++;
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) {
....................             ppp_second_counter_intermediate=0;
....................             ppp_second_counter++;
....................         }
....................        #endif
.................... 
.................... 
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms
00D4:  MOVLW  85
00D6:  MOVWF  FD7
00D8:  MOVLW  ED
00DA:  MOVWF  FD6
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //#define debug_stack  debug_printf
.................... #define debug_stack
.................... 
.................... #if STACK_USE_MAC
....................    #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
....................    #if STACK_USE_MCPENC
....................     #include "tcpip/enc28j60.c"
.................... /*********************************************************************
....................  *
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.c
....................  * Dependencies:    ENC28J60.h
....................  *                    MAC.h
....................  *                    string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                    Delay.h
....................  * Processor:       PIC18
....................  * Complier:        MCC18 v3.00 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date         Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder      6/28/04   Original
....................  * Howard Schlunder      10/8/04   Cleanup
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds
....................  * Howard Schlunder      1/09/06   Added comments and minor mods
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP
....................  * Darren Rook          7/11/06  CCS Port
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
.................... ********************************************************************/
.................... #define THIS_IS_MAC_LAYER
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/StackTsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/Helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/MAC.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ENC28J60.h"
.................... /*********************************************************************
....................  *
....................  *            ENC28J60 registers/bits
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.h
....................  * Description: 	Include file for ENC28J60 control registers
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder		06/01/04	Original
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a 
....................  *									couple of PHY register structs.
....................  * Howard Schlunder		09/29/04	Matched with data sheet
....................  * Howard Schlunder		01/04/06	Matched with new data sheet
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN
....................  * Howard Schlunder		07/21/06	Several bits removed to match now 
....................  *									reserved bits in rev. B data sheet 
....................  *									(DS39662B)
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef ENC28J60_H
.................... #define ENC28J60_H
.................... 
.................... typedef union {
.................... 	BYTE v[7];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 CollisionCount:4;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 Done:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 PacketDefer:1;
.................... 		int8 ExcessiveDefer:1;
.................... 		int8 MaximumCollisions:1;
.................... 		int8 LateCollision:1;
.................... 		int8 Giant:1;
.................... 		int8 Underrun:1;
.................... 		int16 	 BytesTransmittedOnWire;
.................... 		int8 ControlFrame:1;
.................... 		int8 PAUSEControlFrame:1;
.................... 		int8 BackpressureApplied:1;
.................... 		int8 VLANTaggedFrame:1;
.................... 		int8 Zeros:4;
.................... 	} bits;
.................... } TXSTATUS;
.................... 
.................... typedef union {
.................... 	char v[4];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 PreviouslyIgnored:1;
.................... 		int8 RXDCPreviouslySeen:1;
.................... 		int8 CarrierPreviouslySeen:1;
.................... 		int8 CodeViolation:1;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 ReceiveOk:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 DribbleNibble:1;
.................... 		int8 ControlFrame:1;
.................... 		int8 PauseControlFrame:1;
.................... 		int8 UnsupportedOpcode:1;
.................... 		int8 VLANType:1;
.................... 		int8 Zero:1;
.................... 	} bits;
.................... } RXSTATUS;
.................... 
.................... /******************************************************************************
.................... * Register locations
.................... ******************************************************************************/
.................... // Bank 0 registers --------
.................... #define ERDPTL		0x00
.................... #define ERDPTH		0x01
.................... #define EWRPTL		0x02
.................... #define EWRPTH		0x03
.................... #define ETXSTL		0x04
.................... #define ETXSTH		0x05
.................... #define ETXNDL		0x06
.................... #define ETXNDH		0x07
.................... #define ERXSTL		0x08
.................... #define ERXSTH		0x09
.................... #define ERXNDL		0x0A
.................... #define ERXNDH		0x0B
.................... #define ERXRDPTL	0x0C
.................... #define ERXRDPTH	0x0D
.................... #define ERXWRPTL	0x0E
.................... #define ERXWRPTH	0x0F
.................... #define EDMASTL		0x10
.................... #define EDMASTH		0x11
.................... #define EDMANDL		0x12
.................... #define EDMANDH		0x13
.................... #define EDMADSTL	0x14
.................... #define EDMADSTH	0x15
.................... #define EDMACSL		0x16
.................... #define EDMACSH		0x17
.................... //#define			0x18
.................... //#define			0x19
.................... //#define r			0x1A
.................... #define EIE			0x1B
.................... #define EIR			0x1C
.................... #define ESTAT		0x1D
.................... #define ECON2		0x1E
.................... #define ECON1		0x1F
.................... 
.................... // Bank 1 registers -----
.................... #define EHT0		0x100
.................... #define EHT1		0x101
.................... #define EHT2		0x102
.................... #define EHT3		0x103
.................... #define EHT4		0x104
.................... #define EHT5		0x105
.................... #define EHT6		0x106
.................... #define EHT7		0x107
.................... #define EPMM0		0x108
.................... #define EPMM1		0x109
.................... #define EPMM2		0x10A
.................... #define EPMM3		0x10B
.................... #define EPMM4		0x10C
.................... #define EPMM5		0x10D
.................... #define EPMM6		0x10E
.................... #define EPMM7		0x10F
.................... #define EPMCSL		0x110
.................... #define EPMCSH		0x111
.................... //#define			0x112
.................... //#define			0x113
.................... #define EPMOL		0x114
.................... #define EPMOH		0x115
.................... //#define r			0x116
.................... //#define r			0x117
.................... #define ERXFCON		0x118
.................... #define EPKTCNT		0x119
.................... //#define r			0x11A
.................... //#define EIE		0x11B
.................... //#define EIR		0x11C
.................... //#define ESTAT		0x11D
.................... //#define ECON2		0x11E
.................... //#define ECON1		0x11F
.................... 
.................... // Bank 2 registers -----
.................... #define MACON1		0x200
.................... #define MACON2    0x201
.................... //#define r			0x201
.................... #define MACON3		0x202
.................... #define MACON4		0x203
.................... #define MABBIPG		0x204
.................... //#define			0x205
.................... #define MAIPGL		0x206
.................... #define MAIPGH		0x207
.................... #define MACLCON1	0x208
.................... #define MACLCON2	0x209
.................... #define MAMXFLL		0x20A
.................... #define MAMXFLH		0x20B
.................... //#define r			0x20C
.................... //#define r			0x20D
.................... //#define r			0x20E
.................... //#define			0x20F
.................... //#define r			0x210
.................... //#define r			0x211
.................... #define MICMD		0x212
.................... //#define r			0x213
.................... #define MIREGADR	0x214
.................... //#define r			0x215
.................... #define MIWRL		0x216
.................... #define MIWRH		0x217
.................... #define MIRDL		0x218
.................... #define MIRDH		0x219
.................... //#define r			0x21A
.................... //#define EIE		0x21B
.................... //#define EIR		0x21C
.................... //#define ESTAT		0x21D
.................... //#define ECON2		0x21E
.................... //#define ECON1		0x21F
.................... 
.................... // Bank 3 registers -----
.................... #define MAADR5		0x300
.................... #define MAADR6		0x301
.................... #define MAADR3		0x302
.................... #define MAADR4		0x303
.................... #define MAADR1		0x304
.................... #define MAADR2		0x305
.................... #define EBSTSD		0x306
.................... #define EBSTCON		0x307
.................... #define EBSTCSL		0x308
.................... #define EBSTCSH		0x309
.................... #define MISTAT		0x30A
.................... //#define			0x30B
.................... //#define			0x30C
.................... //#define			0x30D
.................... //#define			0x30E
.................... //#define			0x30F
.................... //#define			0x310
.................... //#define			0x311
.................... #define EREVID		0x312
.................... //#define			0x313
.................... //#define			0x314
.................... #define ECOCON		0x315
.................... //#define 			0x316
.................... #define EFLOCON		0x317
.................... #define EPAUSL		0x318
.................... #define EPAUSH		0x319
.................... //#define r			0x31A
.................... //#define EIE		0x31B
.................... //#define EIR		0x31C
.................... //#define ESTAT		0x31D
.................... //#define ECON2		0x31E
.................... //#define ECON1		0x31F
.................... 
.................... 
.................... 
.................... // Structures
.................... typedef union _REG
.................... {
.................... 	char Val;
.................... 
.................... 	// EIE bits ----------
.................... 	struct {
.................... 		unsigned char RXERIE:1;
.................... 		unsigned char TXERIE:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIE:1;
.................... 		unsigned char LINKIE:1;
.................... 		unsigned char DMAIE:1;
.................... 		unsigned char PKTIE:1;
.................... 		unsigned char INTIE:1;
.................... 	} EIEbits;
.................... 
.................... 	// EIR bits ----------
.................... 	struct {
.................... 		unsigned char RXERIF:1;
.................... 		unsigned char TXERIF:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIF:1;
.................... 		unsigned char LINKIF:1;
.................... 		unsigned char DMAIF:1;
.................... 		unsigned char PKTIF:1;
.................... 		unsigned char blank1:1;
.................... 	} EIRbits;
.................... 
.................... 	// ESTAT bits ---------
.................... 	struct {
.................... 		unsigned char CLKRDY:1;
.................... 		unsigned char TXABRT:1;
.................... 		unsigned char RXBUSY:1;
.................... 		unsigned char blank1:1;
.................... 		unsigned char LATECOL:1;
.................... 		unsigned char blank2:2;
.................... 		unsigned char INTR:1;
.................... 	} ESTATbits;
.................... 
.................... 	// ECON2 bits --------
.................... 	struct {
.................... 		unsigned char blank3:3;
.................... 		unsigned char VRPS:1;
.................... 		unsigned char VRTP:1;
.................... 		unsigned char PWRSV:1;
.................... 		unsigned char PKTDEC:1;
.................... 		unsigned char AUTOINC:1;
.................... 	} ECON2bits;
.................... 
.................... 	// ECON1 bits --------
.................... 	struct {
.................... 		unsigned char BSEL0:1;
.................... 		unsigned char BSEL1:1;
.................... 		unsigned char RXEN:1;
.................... 		unsigned char TXRTS:1;
.................... 		unsigned char CSUMEN:1;
.................... 		unsigned char DMAST:1;
.................... 		unsigned char RXRST:1;
.................... 		unsigned char TXRST:1;
.................... 	} ECON1bits;
.................... 
.................... 	// ERXFCON bits ------
.................... 	struct {
.................... 		unsigned char BCEN:1;
.................... 		unsigned char MCEN:1;
.................... 		unsigned char HTEN:1;
.................... 		unsigned char MPEN:1;
.................... 		unsigned char PMEN:1;
.................... 		unsigned char CRCEN:1;
.................... 		unsigned char ANDOR:1;
.................... 		unsigned char UCEN:1;
.................... 	} ERXFCONbits;
.................... 
.................... 	// MACON1 bits --------
.................... 	struct {
.................... 		unsigned char MARXEN:1;
.................... 		unsigned char PASSALL:1;
.................... 		unsigned char RXPAUS:1;
.................... 		unsigned char TXPAUS:1;
.................... 		unsigned char :4;
.................... 	} MACON1bits;
.................... 
.................... 
.................... 	// MACON3 bits --------
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG0:1;
.................... 		unsigned char PADCFG1:1;
.................... 		unsigned char PADCFG2:1;
.................... 	} MACON3bits;
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG:3;
.................... 	} MACON3bits2;
.................... 
.................... 	// MACON4 bits --------
.................... 	struct {
.................... 		unsigned char :4;
.................... 		unsigned char NOBKOFF:1;
.................... 		unsigned char BPEN:1;
.................... 		unsigned char DEFER:1;
.................... 		unsigned char blank1:1;
.................... 	} MACON4bits;
.................... 
.................... 	// MICMD bits ---------
.................... 	struct {
.................... 		unsigned char MIIRD:1;
.................... 		unsigned char MIISCAN:1;
.................... 		unsigned char blank6:6;
.................... 	} MICMDbits;
.................... 
.................... 	// EBSTCON bits -----
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL0:1;
.................... 		unsigned char TMSEL1:1;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV0:1;
.................... 		unsigned char PSV1:1;
.................... 		unsigned char PSV2:1;
.................... 	} EBSTCONbits;
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL:2;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV:3;
.................... 	} EBSTCONbits2;
.................... 
.................... 	// MISTAT bits --------
.................... 	struct {
.................... 		unsigned char BUSY:1;
.................... 		unsigned char SCAN:1;
.................... 		unsigned char NVALID:1;
.................... 		unsigned char blank5:5;
.................... 	} MISTATbits;
.................... 
.................... 	// ECOCON bits -------
.................... 	struct {
.................... 		unsigned char COCON0:1;
.................... 		unsigned char COCON1:1;
.................... 		unsigned char COCON2:1;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits;
.................... 	struct {
.................... 		unsigned char COCON:3;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits2;
.................... 
.................... 	// EFLOCON bits -----
.................... 	struct {
.................... 		unsigned char FCEN0:1;
.................... 		unsigned char FCEN1:1;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits;
.................... 	struct {
.................... 		unsigned char FCEN:2;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits2;
.................... } REG;
.................... 
.................... 
.................... /******************************************************************************
.................... * PH Register Locations
.................... ******************************************************************************/
.................... #define PHCON1	0x00
.................... #define PHSTAT1	0x01
.................... #define PHID1	0x02
.................... #define PHID2	0x03
.................... #define PHCON2	0x10
.................... #define PHSTAT2	0x11
.................... #define PHIE	0x12
.................... #define PHIR	0x13
.................... #define PHLCON	0x14
.................... 
.................... 
.................... typedef union {
.................... 	int16 Val;
.................... 	WORD_VAL VAL;
.................... 
.................... 	// PHCON1 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 PDPXMD:1;
.................... 		int8 blank2:2;
.................... 		int8 PPWRSV:1;
.................... 		int8 blank22:2;
.................... 		int8 PLOOPBK:1;
.................... 		int8 PRST:1;
.................... 	} PHCON1bits;
.................... 
.................... 	// PHSTAT1 bits --------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 JBSTAT:1;
.................... 		int8 LLSTAT:1;
.................... 		int8 blank5:5;
.................... 		int8 blank3:3;
.................... 		int8 PHDPX:1;
.................... 		int8 PFDPX:1;
.................... 		int8 blank33:3;
.................... 	} PHSTAT1bits;
.................... 
.................... 	// PHID2 bits ----------
.................... 	struct {
.................... 		int8 PREV0:1;
.................... 		int8 PREV1:1;
.................... 		int8 PREV2:1;
.................... 		int8 PREV3:1;
.................... 		int8 PPN0:1;
.................... 		int8 PPN1:1;
.................... 		int8 PPN2:1;
.................... 		int8 PPN3:1;
.................... 		int8 PPN4:1;
.................... 		int8 PPN5:1;
.................... 		int8 PID19:1;
.................... 		int8 PID20:1;
.................... 		int8 PID21:1;
.................... 		int8 PID22:1;
.................... 		int8 PID23:1;
.................... 		int8 PID24:1;
.................... 	} PHID2bits;
.................... 	struct {
.................... 		int8 PREV:4;
.................... 		int8 PPNL:4;
.................... 		int8 PPNH:2;
.................... 		int8 PID:6;
.................... 	} PHID2bits2;
.................... 
.................... 	// PHCON2 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 HDLDIS:1;
.................... 		int8 blank1:1;
.................... 		int8 JABBER:1;
.................... 		int8 blank2:2;
.................... 		int8 TXDIS:1;
.................... 		int8 FRCLNK:1;
.................... 		int8 blank11:1;
.................... 	} PHCON2bits;
.................... 
.................... 	// PHSTAT2 bits --------
.................... 	struct {
.................... 		int8 blank5:5;
.................... 		int8 PLRITY:1;
.................... 		int8 blank2:2;
.................... 		int8 blank11:1;
.................... 		int8 DPXSTAT:1;
.................... 		int8 LSTAT:1;
.................... 		int8 COLSTAT:1;
.................... 		int8 RXSTAT:1;
.................... 		int8 TXSTAT:1;
.................... 		int8 blank22:2;
.................... 	} PHSTAT2bits;
.................... 
.................... 	// PHIE bits -----------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 PGEIE:1;
.................... 		int8 blank2:2;
.................... 		int8 PLNKIE:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIEbits;
.................... 
.................... 	// PHIR bits -----------
.................... 	struct {
.................... 		int8 blank2:2;
.................... 		int8 PGIF:1;
.................... 		int8 blank1:1;
.................... 		int8 PLNKIF:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIRbits;
.................... 
.................... 	// PHLCON bits -------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ0:1;
.................... 		int8 LFRQ1:1;
.................... 		int8 LBCFG0:1;
.................... 		int8 LBCFG1:1;
.................... 		int8 LBCFG2:1;
.................... 		int8 LBCFG3:1;
.................... 		int8 LACFG0:1;
.................... 		int8 LACFG1:1;
.................... 		int8 LACFG2:1;
.................... 		int8 LACFG3:1;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits;
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ:2;
.................... 		int8 LBCFG:4;
.................... 		int8 LACFG:4;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits2;
.................... } PHYREG;
.................... 
.................... 
.................... /******************************************************************************
.................... * Individual Register Bits
.................... ******************************************************************************/
.................... // ETH/MAC/MII bits
.................... 
.................... // EIE bits ----------
.................... #define	EIE_INTIE		(1<<7)
.................... #define	EIE_PKTIE		(1<<6)
.................... #define	EIE_DMAIE		(1<<5)
.................... #define	EIE_LINKIE		(1<<4)
.................... #define	EIE_TXIE		(1<<3)
.................... #define	EIE_TXERIE		(1<<1)
.................... #define	EIE_RXERIE		(1)
.................... 
.................... // EIR bits ----------
.................... #define	EIR_PKTIF		(1<<6)
.................... #define	EIR_DMAIF		(1<<5)
.................... #define	EIR_LINKIF		(1<<4)
.................... #define	EIR_TXIF		(1<<3)
.................... #define	EIR_TXERIF		(1<<1)
.................... #define	EIR_RXERIF		(1)
.................... 
.................... // ESTAT bits ---------
.................... #define	ESTAT_INT		(1<<7)
.................... #define ESTAT_BUFFER	(1<<6)
.................... #define	ESTAT_LATECOL	(1<<4)
.................... #define	ESTAT_RXBUSY	(1<<2)
.................... #define	ESTAT_TXABRT	(1<<1)
.................... #define	ESTAT_CLKRDY	(1)
.................... 
.................... // ECON2 bits --------
.................... #define	ECON2_AUTOINC	(1<<7)
.................... #define	ECON2_PKTDEC	(1<<6)
.................... #define	ECON2_PWRSV		(1<<5)
.................... #define	ECON2_VRPS		(1<<3)
.................... 
.................... // ECON1 bits --------
.................... #define	ECON1_TXRST		(1<<7)
.................... #define	ECON1_RXRST		(1<<6)
.................... #define	ECON1_DMAST		(1<<5)
.................... #define	ECON1_CSUMEN	(1<<4)
.................... #define	ECON1_TXRTS		(1<<3)
.................... #define	ECON1_RXEN		(1<<2)
.................... #define	ECON1_BSEL1		(1<<1)
.................... #define	ECON1_BSEL0		(1)
.................... 
.................... // ERXFCON bits ------
.................... #define	ERXFCON_UCEN	(1<<7)
.................... #define	ERXFCON_ANDOR	(1<<6)
.................... #define	ERXFCON_CRCEN	(1<<5)
.................... #define	ERXFCON_PMEN	(1<<4)
.................... #define	ERXFCON_MPEN	(1<<3)
.................... #define	ERXFCON_HTEN	(1<<2)
.................... #define	ERXFCON_MCEN	(1<<1)
.................... #define	ERXFCON_BCEN	(1)
.................... 
.................... // MACON1 bits --------
.................... #define	MACON1_TXPAUS	(1<<3)
.................... #define	MACON1_RXPAUS	(1<<2)
.................... #define	MACON1_PASSALL	(1<<1)
.................... #define	MACON1_MARXEN	(1)
.................... 
.................... // MACON3 bits --------
.................... #define	MACON3_PADCFG2	(1<<7)
.................... #define	MACON3_PADCFG1	(1<<6)
.................... #define	MACON3_PADCFG0	(1<<5)
.................... #define	MACON3_TXCRCEN	(1<<4)
.................... #define	MACON3_PHDRLEN	(1<<3)
.................... #define	MACON3_HFRMEN	(1<<2)
.................... #define	MACON3_FRMLNEN	(1<<1)
.................... #define	MACON3_FULDPX	(1)
.................... 
.................... // MACON4 bits --------
.................... #define	MACON4_DEFER	(1<<6)
.................... #define	MACON4_BPEN		(1<<5)
.................... #define	MACON4_NOBKOFF	(1<<4)
.................... 
.................... 
.................... // MICMD bits ---------
.................... #define	MICMD_MIISCAN	(1<<1)
.................... #define	MICMD_MIIRD		(1)
.................... 
.................... // EBSTCON bits -----
.................... #define	EBSTCON_PSV2	(1<<7)
.................... #define	EBSTCON_PSV1	(1<<6)
.................... #define	EBSTCON_PSV0	(1<<5)
.................... #define	EBSTCON_PSEL	(1<<4)
.................... #define	EBSTCON_TMSEL1	(1<<3)
.................... #define	EBSTCON_TMSEL0	(1<<2)
.................... #define	EBSTCON_TME		(1<<1)
.................... #define	EBSTCON_BISTST	(1)
.................... 
.................... // MISTAT bits --------
.................... #define	MISTAT_NVALID	(1<<2)
.................... #define	MISTAT_SCAN		(1<<1)
.................... #define	MISTAT_BUSY		(1)
.................... 
.................... // ECOCON bits -------
.................... #define	ECOCON_COCON2	(1<<2)
.................... #define	ECOCON_COCON1	(1<<1)
.................... #define	ECOCON_COCON0	(1)
.................... 
.................... // EFLOCON bits -----
.................... #define	EFLOCON_FULDPXS	(1<<2)
.................... #define	EFLOCON_FCEN1	(1<<1)
.................... #define	EFLOCON_FCEN0	(1)
.................... 
.................... 
.................... 
.................... // PHY bits
.................... 
.................... // PHCON1 bits ----------
.................... #define	PHCON1_PRST		(1ul<<15)
.................... #define	PHCON1_PLOOPBK	(1ul<<14)
.................... #define	PHCON1_PPWRSV	(1ul<<11)
.................... #define	PHCON1_PDPXMD	(1ul<<8)
.................... 
.................... // PHSTAT1 bits --------
.................... #define	PHSTAT1_PFDPX	(1ul<<12)
.................... #define	PHSTAT1_PHDPX	(1ul<<11)
.................... #define	PHSTAT1_LLSTAT	(1ul<<2)
.................... #define	PHSTAT1_JBSTAT	(1ul<<1)
.................... 
.................... // PHID2 bits --------
.................... #define	PHID2_PID24		(1ul<<15)
.................... #define	PHID2_PID23		(1ul<<14)
.................... #define	PHID2_PID22		(1ul<<13)
.................... #define	PHID2_PID21		(1ul<<12)
.................... #define	PHID2_PID20		(1ul<<11)
.................... #define	PHID2_PID19		(1ul<<10)
.................... #define	PHID2_PPN5		(1ul<<9)
.................... #define	PHID2_PPN4		(1ul<<8)
.................... #define	PHID2_PPN3		(1ul<<7)
.................... #define	PHID2_PPN2		(1ul<<6)
.................... #define	PHID2_PPN1		(1ul<<5)
.................... #define	PHID2_PPN0		(1ul<<4)
.................... #define	PHID2_PREV3		(1ul<<3)
.................... #define	PHID2_PREV2		(1ul<<2)
.................... #define	PHID2_PREV1		(1ul<<1)
.................... #define	PHID2_PREV0		(1ul)
.................... 
.................... // PHCON2 bits ----------
.................... #define	PHCON2_FRCLNK	(1ul<<14)
.................... #define	PHCON2_TXDIS	(1ul<<13)
.................... #define	PHCON2_JABBER	(1ul<<10)
.................... #define	PHCON2_HDLDIS	(1ul<<8)
.................... 
.................... // PHSTAT2 bits --------
.................... #define	PHSTAT2_TXSTAT	(1ul<<13)
.................... #define	PHSTAT2_RXSTAT	(1ul<<12)
.................... #define	PHSTAT2_COLSTAT	(1ul<<11)
.................... #define	PHSTAT2_LSTAT	(1ul<<10)
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9)
.................... #define	PHSTAT2_PLRITY	(1ul<<5)
.................... 
.................... // PHIE bits -----------
.................... #define	PHIE_PLNKIE		(1ul<<4)
.................... #define	PHIE_PGEIE		(1ul<<1)
.................... 
.................... // PHIR bits -----------
.................... #define	PHIR_PLNKIF		(1ul<<4)
.................... #define	PHIR_PGIF		(1ul<<2)
.................... 
.................... // PHLCON bits -------
.................... #define	PHLCON_LACFG3	(1ul<<11)
.................... #define	PHLCON_LACFG2	(1ul<<10)
.................... #define	PHLCON_LACFG1	(1ul<<9)
.................... #define	PHLCON_LACFG0	(1ul<<8)
.................... #define	PHLCON_LBCFG3	(1ul<<7)
.................... #define	PHLCON_LBCFG2	(1ul<<6)
.................... #define	PHLCON_LBCFG1	(1ul<<5)
.................... #define	PHLCON_LBCFG0	(1ul<<4)
.................... #define	PHLCON_LFRQ1	(1ul<<3)
.................... #define	PHLCON_LFRQ0	(1ul<<2)
.................... #define	PHLCON_STRCH	(1ul<<1)
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if STACK_USE_SLIP
.................... #error Unexpected module is detected.
.................... #error This file must be linked when SLIP module is not in use.
.................... #endif
.................... 
.................... #define debug_mac
.................... //#define debug_mac debug_printf
.................... 
....................    #ifndef PIN_ENC_MAC_SO
....................       #define PIN_ENC_MAC_SO  PIN_D7   // PIC <<<< ENC
....................       #define PIN_ENC_MAC_SI  PIN_D6   // PIC >>>> ENC
....................       #define PIN_ENC_MAC_CLK PIN_D5
....................       #define PIN_ENC_MAC_CS  PIN_D4
....................       #define PIN_ENC_MAC_RST PIN_D3
....................       #define PIN_ENC_MAC_INT PIN_D2
....................       #define PIN_ENC_MAC_WOL PIN_D1
....................       #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz!
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC
....................       #define mac_enc_spi_tris_init()  *0xF95= (0b10000110);
....................      #endif
.................... 
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs
.................... 
.................... /** D E F I N I T I O N S ****************************************************/
.................... /* Hardware interface to NIC. */
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these
.................... // The following SPI pins are used but are not configurable
.................... //   RC3 is used for the SCK pin and is an output
.................... //   RC4 is used for the SDI pin and is an input
.................... //   RC5 is used for the SDO pin and is an output
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is
.................... //      done using the SPI.
.................... 
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is
.................... // not compatible with most switches/routers.  If a dedicated network is used
.................... // where the duplex of the remote node can be manually configured, you may
.................... // change this configuration.  Otherwise, half duplex should always be used.
.................... #define HALF_DUPLEX
.................... //#define FULL_DUPLEX
.................... //#define LEDB_DUPLEX
.................... 
.................... // Pseudo Functions
.................... #define LOW(a)                (a & 0xFF)
.................... #define HIGH(a)             ((a>>8) & 0xFF)
.................... 
.................... // NIC RAM definitions
.................... #define RAMSIZE   8192ul
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul)))
.................... #define RXSTART   (0ul)                  // Should be an even memory address
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul)
.................... 
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address)
.................... #define   WCR (0b010<<5)         // Write Control Register command
.................... #define BFS (0b100<<5)         // Bit Field Set command
.................... #define   BFC (0b101<<5)         // Bit Field Clear command
.................... #define   RCR (0b000<<5)         // Read Control Register command
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address.
....................                         //   It requires 0x1F, however.
.................... 
.................... #define ETHER_IP   (0x00u)
.................... #define ETHER_ARP   (0x06u)
.................... 
00DC:  BCF    FF2.2
00DE:  GOTO   0060
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u)
.................... 
.................... // A generic structure representing the Ethernet header starting all Ethernet
.................... // frames
.................... typedef struct _ETHER_HEADER
.................... {
....................     MAC_ADDR        DestMACAddr;
....................     MAC_ADDR        SourceMACAddr;
....................     WORD_VAL        Type;
.................... } ETHER_HEADER;
.................... 
.................... // A header appended at the start of all RX frames by the hardware
.................... typedef struct _ENC_PREAMBLE
.................... {
....................     int16         NextPacketPointer;
....................     RXSTATUS      StatusVector;
.................... 
....................     MAC_ADDR        DestMACAddr;
....................     MAC_ADDR        SourceMACAddr;
....................     WORD_VAL        Type;
.................... } ENC_PREAMBLE;
.................... 
.................... typedef struct _DATA_BUFFER
.................... {
....................    WORD_VAL StartAddress;
....................    WORD_VAL EndAddress;
....................    struct
....................    {
....................       unsigned char bFree : 1;
....................       unsigned char bTransmitted : 1;
....................    } Flags;
.................... } DATA_BUFFER;
.................... 
.................... void MACSetDuplex(DUPLEX DuplexState);
.................... 
.................... // Prototypes of functions intended for MAC layer use only.
.................... static void BankSel(WORD Register);
.................... static REG ReadETHReg(BYTE Address);
.................... static REG ReadMACReg(BYTE Address);
.................... static void WriteReg(BYTE Address, BYTE Data);
.................... static void BFCReg(BYTE Address, BYTE Data);
.................... static void BFSReg(BYTE Address, BYTE Data);
.................... static void SendSystemReset(void);
.................... //static void GetRegs(void);
.................... #ifdef MAC_POWER_ON_TEST
.................... static BOOL TestMemory(void);
.................... #endif
.................... 
.................... /* Internal and externally used MAC level variables */
.................... #if MAC_TX_BUFFER_COUNT > 1
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT];
.................... #endif
.................... 
.................... // Internal and externally used MAC level variables.
.................... #if MAC_TX_BUFFER_COUNT > 1
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT];
.................... BUFFER LastTXedBuffer;
.................... #endif
.................... 
.................... 
.................... // Internal MAC level variables and flags.
.................... WORD_VAL NextPacketLocation;
.................... WORD_VAL CurrentPacketLocation;
.................... BOOL WasDiscarded;
.................... BYTE ENCRevID;
.................... 
.................... //ENCSPIInit() added by CCS.
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI
.................... void ENCSPIInit(void)
.................... {
.................... 
....................    #ifdef mac_enc_spi_tris_init
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0;
....................    #endif
.................... 
....................  #if ENC_MAC_USE_SPI
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4);
*
07D0:  BCF    FC6.5
07D2:  BCF    F94.7
07D4:  BSF    F93.0
07D6:  BCF    F93.1
07D8:  MOVLW  20
07DA:  MOVWF  FC6
07DC:  MOVLW  40
07DE:  MOVWF  FC7
....................  #else
....................    
....................    output_low(PIN_ENC_MAC_CLK);
....................    output_float(PIN_ENC_MAC_SO);
....................  #endif
....................    //
....................    // Set up the SPI module on the PIC for communications with the ENC28J60
....................    //
....................    SPIUnselectEthernet();
07E0:  BCF    F93.2
07E2:  BSF    F8A.2
.................... 
....................    // Deassert the nRESET pin on the ENC28J60.  The internal
....................    // weak pull on the nRESET pin will get the job done anyway,
....................    // so this isn't necessary, but it may provide extra noise immunity,
....................    // should someone put their finger on the pin or otherwise cause a leakage
....................    // path to ground on this pin.
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1;
07E4:  BCF    F93.3
07E6:  BSF    F8A.3
07E8:  GOTO   0ACA (RETURN)
.................... }
.................... 
.................... //ENCSPIXfer() added by CCS.
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI
.................... char ENCSPIXfer(char c)
.................... {
....................  #if ENC_MAC_USE_SPI
....................    return(spi_read(c));
07EC:  MOVF   FC9,W
07EE:  MOVFF  399,FC9
07F2:  RRCF   FC7,W
07F4:  BNC   07F2
07F6:  MOVFF  FC9,01
....................  #else
07FA:  RETURN 0
....................    int8 i, in;
....................    for (i=0;i<8;i++) {
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0));
....................       output_high(PIN_ENC_MAC_CLK);
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO));
....................       output_low(PIN_ENC_MAC_CLK);
....................    }
....................    return(in);
....................  #endif
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        void MACInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACInit sets up the PIC's SPI module and all the
....................  *               registers in the ENC28J60 so that normal operation can
....................  *               begin.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACInit(void)
.................... {
....................    BYTE i;
.................... 
....................    ENCSPIInit();
*
0AC8:  BRA    07D0
.................... 
....................    // Wait for CLKRDY to become set.
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that
....................    // means the part is in RESET or otherwise our SPI pin is being driven
....................    // incorrectly.  Make sure it is working before proceeding.
....................    do
....................    {
....................       i = ReadETHReg(ESTAT).Val;
0ACA:  MOVLW  1D
0ACC:  MOVLB  3
0ACE:  MOVWF  x8E
0AD0:  MOVLB  0
0AD2:  RCALL  07FC
0AD4:  MOVFF  01,2E0
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY));
0AD8:  MOVLB  2
0ADA:  BTFSS  xE0.3
0ADC:  BRA    0AE2
0ADE:  MOVLB  0
0AE0:  BRA    0ACA
0AE2:  MOVF   xE0,W
0AE4:  XORLW  FF
0AE6:  ANDLW  01
0AE8:  BTFSC  FD8.2
0AEA:  BRA    0AF0
0AEC:  MOVLB  0
0AEE:  BRA    0ACA
.................... 
.................... 
.................... #ifdef MAC_POWER_ON_TEST
....................    // Do the memory test and enter a while always trap if a hardware error
....................    // occured.  The LEDA and LEDB pins will be configured to blink
....................    // periodically in an abnormal manner to indicate to the user that the
....................    // error occured.
....................    if( !TestMemory() )
....................    {
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically
....................       while(1);
....................    }
.................... #endif
.................... 
....................    // RESET the entire ENC28J60, clearing all registers
....................    SendSystemReset();
0AF0:  MOVLB  0
0AF2:  BRA    0826
....................     delay_ms(1);
0AF4:  MOVLW  01
0AF6:  MOVLB  3
0AF8:  MOVWF  x13
0AFA:  MOVLB  0
0AFC:  RCALL  04DE
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
....................     // On Init, all transmit buffers are free.
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ )
....................     {
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8));
....................         TxBuffers[i].Flags.bFree = TRUE;
....................     }
.................... #endif
....................     CurrentTxBuffer = 0;
0AFE:  CLRF   52
.................... 
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers
....................    // and the buffer write protect pointer (receive buffer read pointer)
....................    WasDiscarded = TRUE;
0B00:  BSF    5B.0
....................    NextPacketLocation.Val = RXSTART;
0B02:  CLRF   58
0B04:  CLRF   57
....................    WriteReg(ERXSTL, LOW(RXSTART));
0B06:  MOVLW  08
0B08:  MOVLB  3
0B0A:  MOVWF  x94
0B0C:  CLRF   x95
0B0E:  MOVLB  0
0B10:  RCALL  083A
....................    WriteReg(ERXSTH, HIGH(RXSTART));
0B12:  MOVLW  09
0B14:  MOVLB  3
0B16:  MOVWF  x94
0B18:  CLRF   x95
0B1A:  MOVLB  0
0B1C:  RCALL  083A
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first
0B1E:  MOVLW  0C
0B20:  MOVLB  3
0B22:  MOVWF  x94
0B24:  MOVLW  F7
0B26:  MOVWF  x95
0B28:  MOVLB  0
0B2A:  RCALL  083A
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last
0B2C:  MOVLW  0D
0B2E:  MOVLB  3
0B30:  MOVWF  x94
0B32:  MOVLW  1B
0B34:  MOVWF  x95
0B36:  MOVLB  0
0B38:  RCALL  083A
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF
....................    WriteReg(ERXNDL, LOW(RXSTOP));
0B3A:  MOVLW  0A
0B3C:  MOVLB  3
0B3E:  MOVWF  x94
0B40:  MOVLW  F7
0B42:  MOVWF  x95
0B44:  MOVLB  0
0B46:  RCALL  083A
....................    WriteReg(ERXNDH, HIGH(RXSTOP));
0B48:  MOVLW  0B
0B4A:  MOVLB  3
0B4C:  MOVWF  x94
0B4E:  MOVLW  1B
0B50:  MOVWF  x95
0B52:  MOVLB  0
0B54:  RCALL  083A
.................... #endif
.................... #if TXSTART != 0      // The RESET default ETXST is 0
....................    WriteReg(ETXSTL, LOW(TXSTART));
0B56:  MOVLW  04
0B58:  MOVLB  3
0B5A:  MOVWF  x94
0B5C:  MOVLW  F8
0B5E:  MOVWF  x95
0B60:  MOVLB  0
0B62:  RCALL  083A
....................    WriteReg(ETXSTH, HIGH(TXSTART));
0B64:  MOVLW  05
0B66:  MOVLB  3
0B68:  MOVWF  x94
0B6A:  MOVLW  1B
0B6C:  MOVWF  x95
0B6E:  MOVLB  0
0B70:  RCALL  083A
.................... #endif
.................... 
....................    // Enter Bank 1 and configure Receive Filters
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is
....................    // acceptable)
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode
....................    //BankSel(ERXFCON);
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN);
.................... 
....................    // Enter Bank 2 and configure the MAC
....................    BankSel(MACON1);
0B72:  MOVLW  02
0B74:  MOVLB  3
0B76:  MOVWF  x92
0B78:  CLRF   x91
0B7A:  MOVLB  0
0B7C:  RCALL  0894
.................... 
....................    // Enable the receive portion of the MAC
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN);
0B7E:  MOVLB  3
0B80:  CLRF   x94
0B82:  MOVLW  0D
0B84:  MOVWF  x95
0B86:  MOVLB  0
0B88:  RCALL  083A
.................... 
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field.
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN);
0B8A:  MOVLW  02
0B8C:  MOVLB  3
0B8E:  MOVWF  x94
0B90:  MOVLW  32
0B92:  MOVWF  x95
0B94:  MOVLB  0
0B96:  RCALL  083A
.................... 
....................     // Allow infinite deferals if the medium is continuously busy
....................     // (do not time out a transmission if the half duplex medium is
....................     // completely saturated with other people's data)
....................     WriteReg((BYTE)MACON4, MACON4_DEFER);
0B98:  MOVLW  03
0B9A:  MOVLB  3
0B9C:  MOVWF  x94
0B9E:  MOVLW  40
0BA0:  MOVWF  x95
0BA2:  MOVLB  0
0BA4:  RCALL  083A
.................... 
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter)
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse
....................    // collisions will occur less often with a larger number.
....................     WriteReg((BYTE)MACLCON2, 63);
0BA6:  MOVLW  09
0BA8:  MOVLB  3
0BAA:  MOVWF  x94
0BAC:  MOVLW  3F
0BAE:  MOVWF  x95
0BB0:  MOVLB  0
0BB2:  RCALL  083A
.................... 
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called
....................    // later.
....................    WriteReg((BYTE)MAIPGL, 0x12);
0BB4:  MOVLW  06
0BB6:  MOVLB  3
0BB8:  MOVWF  x94
0BBA:  MOVLW  12
0BBC:  MOVWF  x95
0BBE:  MOVLB  0
0BC0:  RCALL  083A
....................    WriteReg((BYTE)MAIPGH, 0x0C);
0BC2:  MOVLW  07
0BC4:  MOVLB  3
0BC6:  MOVWF  x94
0BC8:  MOVLW  0C
0BCA:  MOVWF  x95
0BCC:  MOVLB  0
0BCE:  RCALL  083A
.................... 
....................    // Set the maximum packet size which the controller will accept
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC));
0BD0:  MOVLW  0A
0BD2:  MOVLB  3
0BD4:  MOVWF  x94
0BD6:  MOVLW  EE
0BD8:  MOVWF  x95
0BDA:  MOVLB  0
0BDC:  RCALL  083A
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC));
0BDE:  MOVLW  0B
0BE0:  MOVLB  3
0BE2:  MOVWF  x94
0BE4:  MOVLW  05
0BE6:  MOVWF  x95
0BE8:  MOVLB  0
0BEA:  RCALL  083A
.................... 
....................     // Enter Bank 3 and initialize physical MAC address registers
....................    BankSel(MAADR1);
0BEC:  MOVLW  03
0BEE:  MOVLB  3
0BF0:  MOVWF  x92
0BF2:  MOVLW  04
0BF4:  MOVWF  x91
0BF6:  MOVLB  0
0BF8:  RCALL  0894
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]);
0BFA:  MOVLW  04
0BFC:  MOVLB  3
0BFE:  MOVWF  x94
0C00:  MOVFF  21,395
0C04:  MOVLB  0
0C06:  RCALL  083A
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]);
0C08:  MOVLW  05
0C0A:  MOVLB  3
0C0C:  MOVWF  x94
0C0E:  MOVFF  22,395
0C12:  MOVLB  0
0C14:  RCALL  083A
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]);
0C16:  MOVLW  02
0C18:  MOVLB  3
0C1A:  MOVWF  x94
0C1C:  MOVFF  23,395
0C20:  MOVLB  0
0C22:  RCALL  083A
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]);
0C24:  MOVLW  03
0C26:  MOVLB  3
0C28:  MOVWF  x94
0C2A:  MOVFF  24,395
0C2E:  MOVLB  0
0C30:  RCALL  083A
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]);
0C32:  MOVLB  3
0C34:  CLRF   x94
0C36:  MOVFF  25,395
0C3A:  MOVLB  0
0C3C:  RCALL  083A
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]);
0C3E:  MOVLW  01
0C40:  MOVLB  3
0C42:  MOVWF  x94
0C44:  MOVFF  26,395
0C48:  MOVLB  0
0C4A:  RCALL  083A
.................... 
....................    // Get the Rev ID so that we can implement the correct errata workarounds
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val;
0C4C:  MOVLW  12
0C4E:  MOVLB  3
0C50:  MOVWF  x8E
0C52:  MOVLB  0
0C54:  RCALL  07FC
0C56:  MOVFF  01,5C
.................... 
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a
....................    // side effect.
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS);
0C5A:  MOVLW  10
0C5C:  MOVLB  2
0C5E:  MOVWF  xE5
0C60:  MOVLW  01
0C62:  MOVWF  xE7
0C64:  CLRF   xE6
0C66:  MOVLB  0
0C68:  RCALL  08F8
.................... 
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity
....................    SetLEDConfig(0x0472);
0C6A:  MOVLW  14
0C6C:  MOVLB  2
0C6E:  MOVWF  xE5
0C70:  MOVLW  04
0C72:  MOVWF  xE7
0C74:  MOVLW  72
0C76:  MOVWF  xE6
0C78:  MOVLB  0
0C7A:  RCALL  08F8
.................... 
....................    // Set the MAC and PHY into the proper duplex state
.................... #if defined(FULL_DUPLEX)
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected
.................... #elif defined(HALF_DUPLEX)
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected
0C7C:  MOVLB  2
0C7E:  CLRF   xE1
0C80:  MOVLB  0
0C82:  BRA    0A26
.................... #else
....................    // Use the external LEDB polarity to determine weather full or half duplex
....................    // communication mode should be set.
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected
.................... #endif
.................... 
....................    // Enable packet reception
....................    BFSReg(ECON1, ECON1_RXEN);
0C84:  MOVLW  1F
0C86:  MOVLB  3
0C88:  MOVWF  x96
0C8A:  MOVLW  04
0C8C:  MOVWF  x97
0C8E:  MOVLB  0
0C90:  RCALL  0876
0C92:  GOTO   107C (RETURN)
.................... }//end MACInit
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACIsLinked(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE: If the PHY reports that a link partner is present
....................  *                    and the link has been up continuously since the last
....................  *                    call to MACIsLinked()
....................  *               FALSE: If the PHY reports no link partner, or the link went
....................  *                     down momentarily since the last call to MACIsLinked()
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACIsLinked(void)
.................... {
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link
....................    // goes down and comes back up before a higher level stack program calls
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next
....................    // call to MACIsLinked() will return TRUE (unless the link goes down
....................    // again).
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT;
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit
....................  *                          FALSE: Check if a TX buffer is free
....................  *
....................  * Output:          TRUE: If no Ethernet transmission is in progress
....................  *               FALSE: If a previous transmission was started, and it has
....................  *                     not completed yet.  While FALSE, the data in the
....................  *                     transmit buffer and the TXST/TXND pointers must not
....................  *                     be changed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the ECON1.TXRTS bit
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACIsTxReady(BOOL HighPriority)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    BUFFER i;
.................... 
....................    if(HighPriority)
.................... #endif
....................    {
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS;
*
25EE:  MOVLW  1F
25F0:  MOVLB  3
25F2:  MOVWF  x8E
25F4:  MOVLB  0
25F6:  CALL   07FC
25FA:  MOVFF  01,370
25FE:  MOVLW  00
2600:  MOVLB  3
2602:  BTFSC  01.3
2604:  MOVLW  01
2606:  XORLW  00
2608:  BZ    260E
260A:  MOVLW  00
260C:  BRA    2610
260E:  MOVLW  01
2610:  MOVWF  01
....................    }
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
2612:  MOVLB  0
2614:  RETURN 0
.................... 
....................    // Check if the current buffer can be modified.  It cannot be modified if
....................    // the TX hardware is currently transmitting it.
....................    if(CurrentTxBuffer == LastTXedBuffer)
....................    {
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS;
....................    }
.................... 
....................    // Check if a buffer is available for a new packet
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++)
....................    {
....................       if(TxBuffers[i].Flags.bFree)
....................       {
....................          return TRUE;
....................       }
....................    }
.................... 
....................    return FALSE;
.................... #endif
.................... }
.................... 
.................... BUFFER MACGetTxBuffer(BOOL HighPriority)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    BUFFER i;
.................... 
....................    if(HighPriority)
.................... #endif
....................    {
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER;
*
1524:  MOVLW  1F
1526:  MOVLB  3
1528:  MOVWF  x8E
152A:  MOVLB  0
152C:  CALL   07FC
1530:  MOVFF  01,370
1534:  MOVLW  00
1536:  MOVLB  3
1538:  BTFSC  01.3
153A:  MOVLW  01
153C:  XORLW  00
153E:  BNZ   1544
1540:  MOVLW  00
1542:  BRA    1546
1544:  MOVLW  FF
1546:  MOVWF  01
....................    }
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
1548:  MOVLB  0
154A:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for
....................    // high priority messages that don't need to be acknowledged
....................    // before being discarded (TCP control packets, all ICMP
....................    // packets, all UDP packets, etc.)
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++)
....................    {
....................       // If this buffer is free, then mark it as used and return with it
....................       if(TxBuffers[i].Flags.bFree)
....................       {
....................          TxBuffers[i].Flags.bFree = FALSE;
....................          TxBuffers[i].Flags.bTransmitted = FALSE;
....................          return i;
....................       }
....................    }
.................... 
....................    return INVALID_BUFFER;
.................... #endif
.................... }
.................... 
.................... 
.................... void MACDiscardTx(BUFFER buffer)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
*
0004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0]))
....................    {
....................        TxBuffers[buffer].Flags.bFree = TRUE;
....................        CurrentTxBuffer = buffer;
....................    }
.................... #endif
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACDiscardRx(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Marks the last received packet (obtained using
....................  *               MACGetHeader())as being processed and frees the buffer
....................  *               memory associated with it
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACDiscardRx(void)
.................... {
....................    WORD_VAL NewRXRDLocation;
.................... 
....................    // Make sure the current packet was not already discarded
....................    if( WasDiscarded )
*
1160:  BTFSS  5B.0
1162:  BRA    1166
....................       return;
1164:  BRA    11CA
....................    WasDiscarded = TRUE;
1166:  BSF    5B.0
.................... 
....................    // Decrement the next packet pointer before writing it into
....................    // the ERXRDPT registers.  This is a silicon errata workaround.
....................    // RX buffer wrapping must be taken into account if the
....................    // NextPacketLocation is precisely RXSTART.
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1;
1168:  MOVLW  01
116A:  SUBWF  57,W
116C:  MOVLB  3
116E:  MOVWF  x32
1170:  MOVLW  00
1172:  SUBWFB 58,W
1174:  MOVWF  x33
.................... #if RXSTART == 0
....................    if(NewRXRDLocation.Val > RXSTOP)
1176:  MOVF   x33,W
1178:  SUBLW  1A
117A:  BC    118E
117C:  XORLW  FF
117E:  BNZ   1186
1180:  MOVF   x32,W
1182:  SUBLW  F7
1184:  BC    118E
.................... #else
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP)
.................... #endif
....................    {
....................       NewRXRDLocation.Val = RXSTOP;
1186:  MOVLW  1B
1188:  MOVWF  x33
118A:  MOVLW  F7
118C:  MOVWF  x32
....................    }
.................... 
....................    // Decrement the RX packet counter register, EPKTCNT
....................    BFSReg(ECON2, ECON2_PKTDEC);
118E:  MOVLW  1E
1190:  MOVWF  x96
1192:  MOVLW  40
1194:  MOVWF  x97
1196:  MOVLB  0
1198:  CALL   0876
.................... 
....................    // Move the receive read pointer to unwrite-protect the memory used by the
....................    // last packet.  The writing order is important: set the low byte first,
....................    // high byte last.
....................    BankSel(ERXRDPTL);
119C:  MOVLB  3
119E:  CLRF   x92
11A0:  MOVLW  0C
11A2:  MOVWF  x91
11A4:  MOVLB  0
11A6:  CALL   0894
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]);
11AA:  MOVLW  0C
11AC:  MOVLB  3
11AE:  MOVWF  x94
11B0:  MOVFF  332,395
11B4:  MOVLB  0
11B6:  CALL   083A
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]);
11BA:  MOVLW  0D
11BC:  MOVLB  3
11BE:  MOVWF  x94
11C0:  MOVFF  333,395
11C4:  MOVLB  0
11C6:  CALL   083A
11CA:  RETURN 0
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACGetFreeRxSize(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          A WORD estimate of how much RX buffer space is free at
....................  *               the present time.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACGetFreeRxSize(void)
.................... {
....................    WORD_VAL ReadPT, WritePT;
.................... 
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be
....................    // received at any time, it can change between reading the low and high
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair
....................    // is read.
....................    BankSel(EPKTCNT);
*
2616:  MOVLW  01
2618:  MOVLB  3
261A:  MOVWF  x92
261C:  MOVLW  19
261E:  MOVWF  x91
2620:  MOVLB  0
2622:  CALL   0894
....................    do {
....................       // Save EPKTCNT in a temporary location
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val;
2626:  MOVLW  19
2628:  MOVLB  3
262A:  MOVWF  x8E
262C:  MOVLB  0
262E:  CALL   07FC
2632:  MOVFF  01,36F
.................... 
....................       BankSel(ERXWRPTL);
2636:  MOVLB  3
2638:  CLRF   x92
263A:  MOVLW  0E
263C:  MOVWF  x91
263E:  MOVLB  0
2640:  CALL   0894
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val;
2644:  MOVLW  0E
2646:  MOVLB  3
2648:  MOVWF  x8E
264A:  MOVLB  0
264C:  CALL   07FC
2650:  MOVFF  01,371
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val;
2654:  MOVLW  0F
2656:  MOVLB  3
2658:  MOVWF  x8E
265A:  MOVLB  0
265C:  CALL   07FC
2660:  MOVFF  01,372
.................... 
....................       BankSel(EPKTCNT);
2664:  MOVLW  01
2666:  MOVLB  3
2668:  MOVWF  x92
266A:  MOVLW  19
266C:  MOVWF  x91
266E:  MOVLB  0
2670:  CALL   0894
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]);
2674:  MOVLW  19
2676:  MOVLB  3
2678:  MOVWF  x8E
267A:  MOVLB  0
267C:  CALL   07FC
2680:  MOVFF  01,373
2684:  MOVLB  3
2686:  MOVF   x6F,W
2688:  SUBWF  01,W
268A:  BTFSC  FD8.2
268C:  BRA    2692
268E:  MOVLB  0
2690:  BRA    2626
.................... 
....................    // Determine where the write protection pointer is
....................    BankSel(ERXRDPTL);
2692:  CLRF   x92
2694:  MOVLW  0C
2696:  MOVWF  x91
2698:  MOVLB  0
269A:  CALL   0894
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val;
269E:  MOVLW  0C
26A0:  MOVLB  3
26A2:  MOVWF  x8E
26A4:  MOVLB  0
26A6:  CALL   07FC
26AA:  MOVFF  01,36F
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val;
26AE:  MOVLW  0D
26B0:  MOVLB  3
26B2:  MOVWF  x8E
26B4:  MOVLB  0
26B6:  CALL   07FC
26BA:  MOVFF  01,370
.................... 
....................    // Calculate the difference between the pointers, taking care to account
....................    // for buffer wrapping conditions
....................    if ( WritePT.Val > ReadPT.Val )
26BE:  MOVLB  3
26C0:  MOVF   x70,W
26C2:  SUBWF  x72,W
26C4:  BNC   26F2
26C6:  BNZ   26CE
26C8:  MOVF   x71,W
26CA:  SUBWF  x6F,W
26CC:  BC    26F2
....................    {
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val);
26CE:  MOVF   x6F,W
26D0:  SUBWF  x71,W
26D2:  MOVWF  00
26D4:  MOVF   x70,W
26D6:  SUBWFB x72,W
26D8:  MOVWF  03
26DA:  MOVF   00,W
26DC:  XORLW  FF
26DE:  ADDLW  F8
26E0:  MOVWF  00
26E2:  MOVLW  1B
26E4:  SUBFWB 03,F
26E6:  MOVFF  00,01
26EA:  MOVFF  03,02
26EE:  BRA    2728
....................    }
26F0:  BRA    2728
....................    else if ( WritePT.Val == ReadPT.Val )
26F2:  MOVF   x6F,W
26F4:  SUBWF  x71,W
26F6:  BNZ   270A
26F8:  MOVF   x70,W
26FA:  SUBWF  x72,W
26FC:  BNZ   270A
....................    {
....................       return RXSIZE - 1;
26FE:  MOVLW  F7
2700:  MOVWF  01
2702:  MOVLW  1B
2704:  MOVWF  02
2706:  BRA    2728
....................    }
2708:  BRA    2728
....................    else
....................     {
....................       return ReadPT.Val - WritePT.Val - 1;
270A:  MOVF   x71,W
270C:  SUBWF  x6F,W
270E:  MOVWF  x73
2710:  MOVF   x72,W
2712:  SUBWFB x70,W
2714:  MOVWF  x74
2716:  MOVLW  01
2718:  SUBWF  x73,W
271A:  MOVWF  00
271C:  MOVLW  00
271E:  SUBWFB x74,W
2720:  MOVWF  03
2722:  MOVFF  00,01
2726:  MOVWF  02
....................    }
2728:  MOVLB  0
272A:  GOTO   29A6 (RETURN)
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           *remote: Location to store the Source MAC address of the
....................  *                      received frame.
....................  *               *type: Location of a BYTE to store the constant
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing
....................  *                     the contents of the Ethernet type field.
....................  *
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The
....................  *                    remote, and type values are updated.
....................  *               FALSE: If a packet was not pending.  remote and type are
....................  *                     not changed.
....................  *
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already
....................  *               been called.
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
.................... {
....................    ENC_PREAMBLE header;
.................... 
....................    // Test if at least one packet has been received and is waiting
....................    BankSel(EPKTCNT);
*
1242:  MOVLW  01
1244:  MOVLB  3
1246:  MOVWF  x92
1248:  MOVLW  19
124A:  MOVWF  x91
124C:  MOVLB  0
124E:  CALL   0894
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0)
1252:  MOVLW  19
1254:  MOVLB  3
1256:  MOVWF  x8E
1258:  MOVLB  0
125A:  CALL   07FC
125E:  MOVFF  01,2FE
1262:  MOVLB  2
1264:  MOVF   xFE,F
1266:  BNZ   126E
....................       return FALSE;
1268:  MOVLW  00
126A:  MOVWF  01
126C:  BRA    1380
.................... 
....................    // Make absolutely certain that any previous packet was discarded
....................    if(WasDiscarded == FALSE)
126E:  BTFSC  5B.0
1270:  BRA    127E
....................    {
....................       MACDiscardRx();
1272:  MOVLB  0
1274:  RCALL  1160
....................       return FALSE;
1276:  MOVLW  00
1278:  MOVWF  01
127A:  MOVLB  2
127C:  BRA    1380
....................    }
.................... 
....................    // Save the location of this packet
....................    CurrentPacketLocation.Val = NextPacketLocation.Val;
127E:  MOVFF  58,5A
1282:  MOVFF  57,59
.................... 
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet
....................    BankSel(ERDPTL);
1286:  MOVLB  3
1288:  CLRF   x92
128A:  CLRF   x91
128C:  MOVLB  0
128E:  CALL   0894
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]);
1292:  MOVLB  3
1294:  CLRF   x94
1296:  MOVFF  57,395
129A:  MOVLB  0
129C:  CALL   083A
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]);
12A0:  MOVLW  01
12A2:  MOVLB  3
12A4:  MOVWF  x94
12A6:  MOVFF  58,395
12AA:  MOVLB  0
12AC:  CALL   083A
.................... 
....................    // Obtain the MAC header from the Ethernet buffer
....................    MACGetArray((BYTE*)&header, sizeof(header));
12B0:  MOVLW  02
12B2:  MOVLB  2
12B4:  MOVWF  xFF
12B6:  MOVLW  EA
12B8:  MOVWF  xFE
12BA:  MOVFF  2FF,37E
12BE:  MOVFF  FE8,37D
12C2:  MOVLB  3
12C4:  CLRF   x80
12C6:  MOVLW  14
12C8:  MOVWF  x7F
12CA:  MOVLB  0
12CC:  RCALL  11CC
.................... 
....................    // The EtherType field, like most items transmitted on the Ethernet medium
....................    // are in big endian.
....................     header.Type.Val = swaps(header.Type.Val);
12CE:  MOVFF  2FD,38F
12D2:  MOVFF  2FC,38E
12D6:  RCALL  122C
12D8:  MOVFF  02,2FD
12DC:  MOVFF  01,2FC
.................... 
....................    // Validate the data returned from the ENC28J60.  Random data corruption,
....................    // such as if a single SPI bit error occurs while communicating or a
....................    // momentary power glitch could cause this to occur in rare circumstances.
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 ||
....................       header.StatusVector.bits.Zero ||
....................       header.StatusVector.bits.CRCError ||
....................       header.StatusVector.bits.ByteCount > 1518 ||
....................       !header.StatusVector.bits.ReceiveOk)
12E0:  MOVLB  2
12E2:  MOVF   xEB,W
12E4:  SUBLW  1A
12E6:  BC    12F2
12E8:  XORLW  FF
12EA:  BNZ   131E
12EC:  MOVF   xEA,W
12EE:  SUBLW  F7
12F0:  BNC   131E
12F2:  MOVLW  02
12F4:  MOVWF  xFF
12F6:  MOVLW  EA
12F8:  MOVWF  FE9
12FA:  MOVFF  2FF,FEA
12FE:  BTFSC  FEF.0
1300:  BRA    131E
1302:  BTFSC  xEF.7
1304:  BRA    131E
1306:  BTFSC  xEE.4
1308:  BRA    131E
130A:  MOVF   xED,W
130C:  SUBLW  04
130E:  BC    131A
1310:  XORLW  FF
1312:  BNZ   131E
1314:  MOVF   xEC,W
1316:  SUBLW  EE
1318:  BNC   131E
131A:  BTFSC  xEE.7
131C:  BRA    1320
....................    {
....................       //Reset();
....................       reset_cpu();
131E:  RESET
....................    }
.................... 
....................    // Save the location where the hardware will write the next packet to
....................    NextPacketLocation.Val = header.NextPacketPointer;
1320:  MOVFF  2EB,58
1324:  MOVFF  2EA,57
.................... 
....................    // Return the Ethernet frame's Source MAC address field to the caller
....................    // This parameter is useful for replying to requests without requiring an
....................    // ARP cycle.
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote));
1328:  MOVFF  2E6,01
132C:  MOVFF  2E7,03
1330:  MOVFF  01,2FE
1334:  MOVFF  03,2FF
1338:  MOVFF  03,FEA
133C:  MOVFF  01,FE9
1340:  MOVLW  02
1342:  MOVWF  FE2
1344:  MOVLW  F6
1346:  MOVWF  FE1
1348:  MOVLW  06
134A:  MOVWF  01
134C:  MOVFF  FE6,FEE
1350:  DECFSZ 01,F
1352:  BRA    134C
.................... 
....................    // Return a simplified version of the EtherType field to the caller
....................     *type = MAC_UNKNOWN;
1354:  MOVFF  2E9,FEA
1358:  MOVFF  2E8,FE9
135C:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) &&
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) )
135E:  MOVF   xFD,W
1360:  SUBLW  08
1362:  BNZ   137A
1364:  MOVF   xFC,F
1366:  BZ    136E
1368:  MOVF   xFC,W
136A:  SUBLW  06
136C:  BNZ   137A
....................     {
....................        *type = header.Type.v[0];
136E:  MOVFF  2E9,FEA
1372:  MOVFF  2E8,FE9
1376:  MOVFF  2FC,FEF
....................     }
.................... 
....................     // Mark this packet as discardable
....................     WasDiscarded = FALSE;
137A:  BCF    5B.0
....................    return TRUE;
137C:  MOVLW  01
137E:  MOVWF  01
1380:  MOVLB  0
1382:  GOTO   6C92 (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote,
....................  *                                    BYTE type,
....................  *                                   WORD dataLen)
....................  *
....................  * PreCondition:    MACIsTxReady() must return TRUE.
....................  *
....................  * Input:           *remote: Pointer to memory which contains the destination
....................  *                       MAC address (6 bytes)
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which
....................  *                    value to write into the Ethernet header's type field.
....................  *               dataLen: Length of the Ethernet data payload
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Because of the dataLen parameter, it is probably
....................  *               advantagous to call this function immediately before
....................  *               transmitting a packet rather than initially when the
....................  *               packet is first created.  The order in which the packet
....................  *               is constructed (header first or data first) is not
....................  *               important.
....................  *****************************************************************************/
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen)
.................... {
.................... 
....................    BankSel(EWRPTL);
*
164E:  MOVLB  3
1650:  CLRF   x92
1652:  MOVLW  02
1654:  MOVWF  x91
1656:  MOVLB  0
1658:  CALL   0894
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    // Set the SPI write pointer to the beginning of the transmit buffer
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]);
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]);
.................... 
....................    // Calculate where to put the TXND pointer
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val;
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen;
.................... #else
....................    // Set the SPI write pointer to the beginning of the transmit buffer
....................    WriteReg(EWRPTL, LOW(TXSTART));
165C:  MOVLW  02
165E:  MOVLB  3
1660:  MOVWF  x94
1662:  MOVLW  F8
1664:  MOVWF  x95
1666:  MOVLB  0
1668:  CALL   083A
....................    WriteReg(EWRPTH, HIGH(TXSTART));
166C:  MOVLW  03
166E:  MOVLB  3
1670:  MOVWF  x94
1672:  MOVLW  1B
1674:  MOVWF  x95
1676:  MOVLB  0
1678:  CALL   083A
.................... 
....................    // Calculate where to put the TXND pointer
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART;
167C:  MOVLW  06
167E:  MOVLB  3
1680:  ADDWF  x8F,F
1682:  MOVLW  1C
1684:  ADDWFC x90,F
.................... 
....................    // Write the TXND pointer into the registers, given the dataLen given
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]);
1686:  MOVLW  03
1688:  MOVWF  x92
168A:  MOVLW  8F
168C:  MOVWF  x91
168E:  MOVWF  FE9
1690:  MOVFF  392,FEA
1694:  MOVFF  FEF,395
1698:  MOVLW  06
169A:  MOVWF  x94
169C:  MOVLB  0
169E:  CALL   083A
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]);
16A2:  MOVLW  03
16A4:  MOVLB  3
16A6:  MOVWF  x92
16A8:  MOVLW  8F
16AA:  MOVWF  x91
16AC:  MOVLW  01
16AE:  ADDWF  x91,W
16B0:  MOVWF  FE9
16B2:  MOVLW  00
16B4:  ADDWFC x92,W
16B6:  MOVWF  FEA
16B8:  MOVFF  FEF,395
16BC:  MOVLW  07
16BE:  MOVWF  x94
16C0:  MOVLB  0
16C2:  CALL   083A
.................... #endif
.................... 
.................... 
....................    // Set the per-packet control byte and write the Ethernet destination
....................    // address
....................    MACPut(0x00);   // Use default control configuration
16C6:  MOVLB  3
16C8:  CLRF   x92
16CA:  MOVLB  0
16CC:  RCALL  15EA
....................     MACPutArray((BYTE*)remote, sizeof(*remote));
16CE:  MOVFF  38D,394
16D2:  MOVFF  38C,393
16D6:  MOVLB  3
16D8:  CLRF   x96
16DA:  MOVLW  06
16DC:  MOVWF  x95
16DE:  MOVLB  0
16E0:  RCALL  1608
.................... 
....................    // Write our MAC address in the Ethernet source field
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
16E2:  MOVLB  3
16E4:  MOVLW  21
16E6:  MOVWF  x91
16E8:  CLRF   x94
16EA:  MOVWF  x93
16EC:  CLRF   x96
16EE:  MOVLW  06
16F0:  MOVWF  x95
16F2:  MOVLB  0
16F4:  RCALL  1608
.................... 
....................    // Write the appropriate Ethernet Type WORD for the protocol being used
....................     MACPut(0x08);
16F6:  MOVLW  08
16F8:  MOVLB  3
16FA:  MOVWF  x92
16FC:  MOVLB  0
16FE:  RCALL  15EA
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP);
1700:  MOVLB  3
1702:  MOVF   x8E,F
1704:  BNZ   170A
1706:  MOVLW  00
1708:  BRA    170C
170A:  MOVLW  06
170C:  MOVWF  x91
170E:  MOVWF  x92
1710:  MOVLB  0
1712:  RCALL  15EA
1714:  RETURN 0
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        void MACFlush(void)
....................  *
....................  * PreCondition:    A packet has been created by calling MACPut() and
....................  *               MACPutHeader().
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACFlush causes the current TX packet to be sent out on
....................  *               the Ethernet medium.  The hardware MAC will take control
....................  *               and handle CRC generation, collision retransmission and
....................  *               other details.
....................  *
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE),
....................  *               the packet can be modified and transmitted again by calling
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is
....................  *               called (in the TX data area), the data in the TX buffer
....................  *               will not be corrupted.
....................  *****************************************************************************/
.................... void MACFlush(void)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    // Set the packet start and end address pointers
....................    BankSel(ETXSTL);
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]);
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]);
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]);
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]);
....................    LastTXedBuffer = CurrentTxBuffer;
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE;
.................... #endif
.................... 
....................    // Reset transmit logic if a TX Error has previously occured
....................    // This is a silicon errata workaround
....................    if(ReadETHReg(EIR).EIRbits.TXERIF)
1716:  MOVLW  1C
1718:  MOVLB  3
171A:  MOVWF  x8E
171C:  MOVLB  0
171E:  CALL   07FC
1722:  MOVFF  01,37B
1726:  MOVLW  00
1728:  MOVLB  3
172A:  BTFSC  01.1
172C:  MOVLW  01
172E:  XORLW  00
1730:  BZ    1752
....................    {
....................       BFSReg(ECON1, ECON1_TXRST);
1732:  MOVLW  1F
1734:  MOVWF  x96
1736:  MOVLW  80
1738:  MOVWF  x97
173A:  MOVLB  0
173C:  CALL   0876
....................       BFCReg(ECON1, ECON1_TXRST);
1740:  MOVLW  1F
1742:  MOVLB  3
1744:  MOVWF  x93
1746:  MOVLW  80
1748:  MOVWF  x94
174A:  MOVLB  0
174C:  CALL   0858
1750:  MOVLB  3
....................    }
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
1752:  MOVLW  1C
1754:  MOVWF  x93
1756:  MOVLW  0A
1758:  MOVWF  x94
175A:  MOVLB  0
175C:  CALL   0858
.................... 
....................    // Start the transmission
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet
....................    // can be modified and transmitted again by calling MACFlush() again.
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be
....................    // corrupted.
....................    BFSReg(ECON1, ECON1_TXRTS);
1760:  MOVLW  1F
1762:  MOVLB  3
1764:  MOVWF  x96
1766:  MOVLW  08
1768:  MOVWF  x97
176A:  MOVLB  0
176C:  CALL   0876
.................... 
....................    // Revision B5 silicon errata workaround
....................    if(ENCRevID == 0x05)
1770:  MOVF   5C,W
1772:  SUBLW  05
1774:  BTFSS  FD8.2
1776:  BRA    193C
....................    {
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)));
1778:  MOVLW  1C
177A:  MOVLB  3
177C:  MOVWF  x8E
177E:  MOVLB  0
1780:  CALL   07FC
1784:  MOVFF  01,37B
1788:  MOVLB  3
178A:  MOVF   01,W
178C:  ANDLW  0A
178E:  BTFSS  FD8.2
1790:  BRA    1796
1792:  MOVLB  0
1794:  BRA    1778
....................       if(ReadETHReg(EIR).EIRbits.TXERIF)
1796:  MOVLW  1C
1798:  MOVWF  x8E
179A:  MOVLB  0
179C:  CALL   07FC
17A0:  MOVFF  01,37B
17A4:  MOVLW  00
17A6:  MOVLB  3
17A8:  BTFSC  01.1
17AA:  MOVLW  01
17AC:  XORLW  00
17AE:  BTFSC  FD8.2
17B0:  BRA    193E
....................       {
....................          WORD_VAL ReadPtrSave;
....................          WORD_VAL TXEnd;
....................          TXSTATUS TXStatus;
....................          BYTE i;
.................... 
....................          // Cancel the previous transmission if it has become stuck set
....................          BFCReg(ECON1, ECON1_TXRTS);
17B2:  MOVLW  1F
17B4:  MOVWF  x93
17B6:  MOVLW  08
17B8:  MOVWF  x94
17BA:  MOVLB  0
17BC:  CALL   0858
.................... 
....................          // Save the current read pointer (controlled by application)
....................          BankSel(ERDPTL);
17C0:  MOVLB  3
17C2:  CLRF   x92
17C4:  CLRF   x91
17C6:  MOVLB  0
17C8:  CALL   0894
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val;
17CC:  MOVLB  3
17CE:  CLRF   x8E
17D0:  MOVLB  0
17D2:  CALL   07FC
17D6:  MOVFF  01,36F
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val;
17DA:  MOVLW  01
17DC:  MOVLB  3
17DE:  MOVWF  x8E
17E0:  MOVLB  0
17E2:  CALL   07FC
17E6:  MOVFF  01,370
.................... 
....................          // Get the location of the transmit status vector
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val;
17EA:  MOVLW  06
17EC:  MOVLB  3
17EE:  MOVWF  x8E
17F0:  MOVLB  0
17F2:  CALL   07FC
17F6:  MOVFF  01,371
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val;
17FA:  MOVLW  07
17FC:  MOVLB  3
17FE:  MOVWF  x8E
1800:  MOVLB  0
1802:  CALL   07FC
1806:  MOVFF  01,372
....................          TXEnd.Val++;
180A:  MOVLB  3
180C:  INCF   x71,F
180E:  BTFSC  FD8.2
1810:  INCF   x72,F
.................... 
....................          // Read the transmit status vector
....................          WriteReg(ERDPTL, TXEnd.v[0]);
1812:  CLRF   x94
1814:  MOVFF  371,395
1818:  MOVLB  0
181A:  CALL   083A
....................          WriteReg(ERDPTH, TXEnd.v[1]);
181E:  MOVLW  01
1820:  MOVLB  3
1822:  MOVWF  x94
1824:  MOVFF  372,395
1828:  MOVLB  0
182A:  CALL   083A
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus));
182E:  MOVLW  03
1830:  MOVLB  3
1832:  MOVWF  x7C
1834:  MOVLW  73
1836:  MOVWF  x7B
1838:  MOVFF  37C,37E
183C:  MOVWF  x7D
183E:  CLRF   x80
1840:  MOVLW  07
1842:  MOVWF  x7F
1844:  MOVLB  0
1846:  RCALL  11CC
.................... 
....................          // Implement retransmission if a late collision occured (this can
....................          // happen on B5 when certain link pulses arrive at the same time
....................          // as the transmission)
....................          for(i = 0; i < 16; i++)
1848:  MOVLB  3
184A:  CLRF   x7A
184C:  MOVF   x7A,W
184E:  SUBLW  0F
1850:  BNC   1920
....................          {
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision)
1852:  MOVLW  1C
1854:  MOVWF  x8E
1856:  MOVLB  0
1858:  CALL   07FC
185C:  MOVFF  01,37B
1860:  MOVLW  00
1862:  MOVLB  3
1864:  BTFSC  01.1
1866:  MOVLW  01
1868:  XORLW  00
186A:  BZ    1916
186C:  BTFSS  x76.5
186E:  BRA    1916
....................             {
....................                // Reset the TX logic
....................                BFSReg(ECON1, ECON1_TXRST);
1870:  MOVLW  1F
1872:  MOVWF  x96
1874:  MOVLW  80
1876:  MOVWF  x97
1878:  MOVLB  0
187A:  CALL   0876
....................                BFCReg(ECON1, ECON1_TXRST);
187E:  MOVLW  1F
1880:  MOVLB  3
1882:  MOVWF  x93
1884:  MOVLW  80
1886:  MOVWF  x94
1888:  MOVLB  0
188A:  CALL   0858
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
188E:  MOVLW  1C
1890:  MOVLB  3
1892:  MOVWF  x93
1894:  MOVLW  0A
1896:  MOVWF  x94
1898:  MOVLB  0
189A:  CALL   0858
.................... 
....................                // Transmit the packet again
....................                BFSReg(ECON1, ECON1_TXRTS);
189E:  MOVLW  1F
18A0:  MOVLB  3
18A2:  MOVWF  x96
18A4:  MOVLW  08
18A6:  MOVWF  x97
18A8:  MOVLB  0
18AA:  CALL   0876
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)));
18AE:  MOVLW  1C
18B0:  MOVLB  3
18B2:  MOVWF  x8E
18B4:  MOVLB  0
18B6:  CALL   07FC
18BA:  MOVFF  01,37B
18BE:  MOVLB  3
18C0:  MOVF   01,W
18C2:  ANDLW  0A
18C4:  BTFSS  FD8.2
18C6:  BRA    18CC
18C8:  MOVLB  0
18CA:  BRA    18AE
.................... 
....................                // Cancel the previous transmission if it has become stuck set
....................                BFCReg(ECON1, ECON1_TXRTS);
18CC:  MOVLW  1F
18CE:  MOVWF  x93
18D0:  MOVLW  08
18D2:  MOVWF  x94
18D4:  MOVLB  0
18D6:  CALL   0858
.................... 
....................                // Read transmit status vector
....................                WriteReg(ERDPTL, TXEnd.v[0]);
18DA:  MOVLB  3
18DC:  CLRF   x94
18DE:  MOVFF  371,395
18E2:  MOVLB  0
18E4:  CALL   083A
....................                WriteReg(ERDPTH, TXEnd.v[1]);
18E8:  MOVLW  01
18EA:  MOVLB  3
18EC:  MOVWF  x94
18EE:  MOVFF  372,395
18F2:  MOVLB  0
18F4:  CALL   083A
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus));
18F8:  MOVLW  03
18FA:  MOVLB  3
18FC:  MOVWF  x7C
18FE:  MOVLW  73
1900:  MOVWF  x7B
1902:  MOVFF  37C,37E
1906:  MOVWF  x7D
1908:  CLRF   x80
190A:  MOVLW  07
190C:  MOVWF  x7F
190E:  MOVLB  0
1910:  RCALL  11CC
....................             }
1912:  BRA    191A
1914:  MOVLB  3
....................             else
....................             {
....................                break;
1916:  BRA    1920
1918:  MOVLB  0
....................             }
191A:  MOVLB  3
191C:  INCF   x7A,F
191E:  BRA    184C
....................          }
.................... 
....................          // Restore the current read pointer
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]);
1920:  CLRF   x94
1922:  MOVFF  36F,395
1926:  MOVLB  0
1928:  CALL   083A
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]);
192C:  MOVLW  01
192E:  MOVLB  3
1930:  MOVWF  x94
1932:  MOVFF  370,395
1936:  MOVLB  0
1938:  CALL   083A
193C:  MOVLB  3
....................       }
....................    }
193E:  MOVLB  0
1940:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetRxBuffer(WORD offset)
....................  *
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and
....................  *               getting a TRUE result.
....................  *
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet
....................  *                     header's type field to relocate the SPI read and
....................  *                     write pointers.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SPI read and write pointers are updated.  All calls to
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(),
....................  *               and various other functions will use these new values.
....................  *
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for
....................  *               this function to work correctly.  In other words, do not
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory
....................  *               boundary.
....................  *****************************************************************************/
.................... void MACSetRxBuffer(WORD offset)
.................... {
....................    WORD_VAL ReadPT;
.................... 
....................    // Determine the address of the beginning of the entire packet
....................    // and adjust the address to the desired location
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset;
*
1C52:  MOVLW  14
1C54:  ADDWF  59,W
1C56:  MOVLB  3
1C58:  MOVWF  x1B
1C5A:  MOVLW  00
1C5C:  ADDWFC 5A,W
1C5E:  MOVWF  x1C
1C60:  MOVF   x17,W
1C62:  ADDWF  x1B,W
1C64:  MOVWF  x19
1C66:  MOVF   x18,W
1C68:  ADDWFC x1C,W
1C6A:  MOVWF  x1A
.................... 
....................    // Since the receive buffer is circular, adjust if a wraparound is needed
....................    if ( ReadPT.Val > RXSTOP )
1C6C:  MOVF   x1A,W
1C6E:  SUBLW  1A
1C70:  BC    1C84
1C72:  XORLW  FF
1C74:  BNZ   1C7C
1C76:  MOVF   x19,W
1C78:  SUBLW  F7
1C7A:  BC    1C84
....................       ReadPT.Val -= RXSIZE;
1C7C:  MOVLW  F8
1C7E:  SUBWF  x19,F
1C80:  MOVLW  1B
1C82:  SUBWFB x1A,F
.................... 
....................    // Set the SPI read and write pointers to the new calculated value
....................    BankSel(ERDPTL);
1C84:  CLRF   x92
1C86:  CLRF   x91
1C88:  MOVLB  0
1C8A:  CALL   0894
....................    WriteReg(ERDPTL, ReadPT.v[0]);
1C8E:  MOVLB  3
1C90:  CLRF   x94
1C92:  MOVFF  319,395
1C96:  MOVLB  0
1C98:  CALL   083A
....................    WriteReg(ERDPTH, ReadPT.v[1]);
1C9C:  MOVLW  01
1C9E:  MOVLB  3
1CA0:  MOVWF  x94
1CA2:  MOVFF  31A,395
1CA6:  MOVLB  0
1CA8:  CALL   083A
....................    WriteReg(EWRPTL, ReadPT.v[0]);
1CAC:  MOVLW  02
1CAE:  MOVLB  3
1CB0:  MOVWF  x94
1CB2:  MOVFF  319,395
1CB6:  MOVLB  0
1CB8:  CALL   083A
....................    WriteReg(EWRPTH, ReadPT.v[1]);
1CBC:  MOVLW  03
1CBE:  MOVLB  3
1CC0:  MOVWF  x94
1CC2:  MOVFF  31A,395
1CC6:  MOVLB  0
1CC8:  CALL   083A
1CCC:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this
....................  *                     parameter is not used.
....................  *               offset: WORD specifying how many bytes beyond the Ethernet
....................  *                     header's type field to relocate the SPI read and
....................  *                     write pointers.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SPI read and write pointers are updated.  All calls to
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(),
....................  *               and various other functions will use these new values.
....................  *
....................  * Note:         None
....................  *****************************************************************************/
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset)
.................... {
....................     CurrentTxBuffer = buffer;
*
154C:  MOVFF  388,52
.................... 
....................    // Calculate the proper address.  Since the TX memory area is not circular,
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of
....................    // the per packet control byte which preceeds the packet in the TX memory
....................    // area.
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER);
.................... #else
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER);
1550:  MOVLW  07
1552:  MOVLB  3
1554:  ADDWF  x89,F
1556:  MOVLW  1C
1558:  ADDWFC x8A,F
.................... #endif
.................... 
....................    // Set the SPI read and write pointers to the new calculated value
....................    BankSel(EWRPTL);
155A:  CLRF   x92
155C:  MOVLW  02
155E:  MOVWF  x91
1560:  MOVLB  0
1562:  CALL   0894
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]);
1566:  MOVLW  03
1568:  MOVLB  3
156A:  MOVWF  x8C
156C:  MOVLW  89
156E:  MOVWF  x8B
1570:  MOVWF  FE9
1572:  MOVFF  38C,FEA
1576:  MOVFF  FEF,395
157A:  CLRF   x94
157C:  MOVLB  0
157E:  CALL   083A
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]);
1582:  MOVLW  03
1584:  MOVLB  3
1586:  MOVWF  x8C
1588:  MOVLW  89
158A:  MOVWF  x8B
158C:  MOVLW  01
158E:  ADDWF  x8B,W
1590:  MOVWF  FE9
1592:  MOVLW  00
1594:  ADDWFC x8C,W
1596:  MOVWF  FEA
1598:  MOVFF  FEF,395
159C:  MOVLW  01
159E:  MOVWF  x94
15A0:  MOVLB  0
15A2:  CALL   083A
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]);
15A6:  MOVLW  03
15A8:  MOVLB  3
15AA:  MOVWF  x8C
15AC:  MOVLW  89
15AE:  MOVWF  x8B
15B0:  MOVWF  FE9
15B2:  MOVFF  38C,FEA
15B6:  MOVFF  FEF,395
15BA:  MOVLW  02
15BC:  MOVWF  x94
15BE:  MOVLB  0
15C0:  CALL   083A
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]);
15C4:  MOVLW  03
15C6:  MOVLB  3
15C8:  MOVWF  x8C
15CA:  MOVLW  89
15CC:  MOVWF  x8B
15CE:  MOVLW  01
15D0:  ADDWF  x8B,W
15D2:  MOVWF  FE9
15D4:  MOVLW  00
15D6:  ADDWFC x8C,W
15D8:  MOVWF  FEA
15DA:  MOVFF  FEF,395
15DE:  MOVLW  03
15E0:  MOVWF  x94
15E2:  MOVLB  0
15E4:  CALL   083A
15E8:  RETURN 0
.................... }
.................... 
.................... 
.................... #if defined(MCHP_MAC)
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate
.................... // checksums.  These two functions have been tested.
.................... /******************************************************************************
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           offset   - Number of bytes beyond the beginning of the
....................  *                     Ethernet data (first byte after the type field)
....................  *                     where the checksum should begin
....................  *               len      - Total number of bytes to include in the checksum
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself using the hardware DMA module
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACCalcRxChecksum(WORD offset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Add the offset requested by firmware plus the Ethernet header
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset;
*
1B4A:  MOVLW  14
1B4C:  ADDWF  59,W
1B4E:  MOVLB  3
1B50:  MOVWF  x45
1B52:  MOVLW  00
1B54:  ADDWFC 5A,W
1B56:  MOVWF  x46
1B58:  MOVF   x3F,W
1B5A:  ADDWF  x45,W
1B5C:  MOVWF  x43
1B5E:  MOVF   x40,W
1B60:  ADDWFC x46,W
1B62:  MOVWF  x44
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
1B64:  MOVF   x44,W
1B66:  SUBLW  1A
1B68:  BC    1B7C
1B6A:  XORLW  FF
1B6C:  BNZ   1B74
1B6E:  MOVF   x43,W
1B70:  SUBLW  F7
1B72:  BC    1B7C
....................    {
....................       temp.Val -= RXSIZE;
1B74:  MOVLW  F8
1B76:  SUBWF  x43,F
1B78:  MOVLW  1B
1B7A:  SUBWFB x44,F
....................    }
.................... 
....................    // Program the start address of the DMA
....................    BankSel(EDMASTL);
1B7C:  CLRF   x92
1B7E:  MOVLW  10
1B80:  MOVWF  x91
1B82:  MOVLB  0
1B84:  CALL   0894
....................    WriteReg(EDMASTL, temp.v[0]);
1B88:  MOVLW  10
1B8A:  MOVLB  3
1B8C:  MOVWF  x94
1B8E:  MOVFF  343,395
1B92:  MOVLB  0
1B94:  CALL   083A
....................    WriteReg(EDMASTH, temp.v[1]);
1B98:  MOVLW  11
1B9A:  MOVLB  3
1B9C:  MOVWF  x94
1B9E:  MOVFF  344,395
1BA2:  MOVLB  0
1BA4:  CALL   083A
.................... 
....................    // Calculate the end address, given the start address and len
....................    temp.Val += len-1;
1BA8:  MOVLW  01
1BAA:  MOVLB  3
1BAC:  SUBWF  x41,W
1BAE:  MOVWF  00
1BB0:  MOVLW  00
1BB2:  SUBWFB x42,W
1BB4:  MOVWF  03
1BB6:  MOVF   00,W
1BB8:  ADDWF  x43,F
1BBA:  MOVF   03,W
1BBC:  ADDWFC x44,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
1BBE:  MOVF   x44,W
1BC0:  SUBLW  1A
1BC2:  BC    1BD6
1BC4:  XORLW  FF
1BC6:  BNZ   1BCE
1BC8:  MOVF   x43,W
1BCA:  SUBLW  F7
1BCC:  BC    1BD6
....................    {
....................       temp.Val -= RXSIZE;
1BCE:  MOVLW  F8
1BD0:  SUBWF  x43,F
1BD2:  MOVLW  1B
1BD4:  SUBWFB x44,F
....................    }
.................... 
....................    // Program the end address of the DMA
....................    WriteReg(EDMANDL, temp.v[0]);
1BD6:  MOVLW  12
1BD8:  MOVWF  x94
1BDA:  MOVFF  343,395
1BDE:  MOVLB  0
1BE0:  CALL   083A
....................    WriteReg(EDMANDH, temp.v[1]);
1BE4:  MOVLW  13
1BE6:  MOVLB  3
1BE8:  MOVWF  x94
1BEA:  MOVFF  344,395
1BEE:  MOVLB  0
1BF0:  CALL   083A
.................... 
....................    // Do the checksum calculation
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
1BF4:  MOVLW  1F
1BF6:  MOVLB  3
1BF8:  MOVWF  x96
1BFA:  MOVLW  30
1BFC:  MOVWF  x97
1BFE:  MOVLB  0
1C00:  CALL   0876
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
1C04:  MOVLW  1F
1C06:  MOVLB  3
1C08:  MOVWF  x8E
1C0A:  MOVLB  0
1C0C:  CALL   07FC
1C10:  MOVFF  01,345
1C14:  MOVLW  00
1C16:  MOVLB  3
1C18:  BTFSC  01.5
1C1A:  MOVLW  01
1C1C:  XORLW  00
1C1E:  BTFSC  FD8.2
1C20:  BRA    1C26
1C22:  MOVLB  0
1C24:  BRA    1C04
.................... 
....................    // Swap endianness and return
....................    temp.v[1] = ReadETHReg(EDMACSL).Val;
1C26:  MOVLW  16
1C28:  MOVWF  x8E
1C2A:  MOVLB  0
1C2C:  CALL   07FC
1C30:  MOVFF  01,344
....................    temp.v[0] = ReadETHReg(EDMACSH).Val;
1C34:  MOVLW  17
1C36:  MOVLB  3
1C38:  MOVWF  x8E
1C3A:  MOVLB  0
1C3C:  CALL   07FC
1C40:  MOVFF  01,343
....................    return temp.Val;
1C44:  MOVLB  3
1C46:  MOVFF  343,01
1C4A:  MOVFF  344,02
1C4E:  MOVLB  0
1C50:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           offset   - Number of bytes beyond the beginning of the
....................  *                     Ethernet data (first byte after the type field)
....................  *                     where the checksum should begin
....................  *               len      - Total number of bytes to include in the checksum
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself using the hardware DMA module
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACCalcTxChecksum(WORD offset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Program the start address of the DMA, after adjusting for the Ethernet
....................    // header
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER)
....................             + offset + 1;   // +1 needed to account for per packet control byte
.................... #else
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER)
....................             + offset + 1;   // +1 needed to account for per packet control byte
*
272E:  MOVLW  06
2730:  MOVLB  3
2732:  ADDWF  x88,W
2734:  MOVWF  x8E
2736:  MOVLW  1C
2738:  ADDWFC x89,W
273A:  MOVWF  x8F
273C:  MOVLW  01
273E:  ADDWF  x8E,W
2740:  MOVWF  x8C
2742:  MOVLW  00
2744:  ADDWFC x8F,W
2746:  MOVWF  x8D
.................... #endif
....................    BankSel(EDMASTL);
2748:  CLRF   x92
274A:  MOVLW  10
274C:  MOVWF  x91
274E:  MOVLB  0
2750:  CALL   0894
....................    WriteReg(EDMASTL, temp.v[0]);
2754:  MOVLW  10
2756:  MOVLB  3
2758:  MOVWF  x94
275A:  MOVFF  38C,395
275E:  MOVLB  0
2760:  CALL   083A
....................    WriteReg(EDMASTH, temp.v[1]);
2764:  MOVLW  11
2766:  MOVLB  3
2768:  MOVWF  x94
276A:  MOVFF  38D,395
276E:  MOVLB  0
2770:  CALL   083A
.................... 
....................    // Program the end address of the DMA.
....................    temp.Val += len-1;
2774:  MOVLW  01
2776:  MOVLB  3
2778:  SUBWF  x8A,W
277A:  MOVWF  00
277C:  MOVLW  00
277E:  SUBWFB x8B,W
2780:  MOVWF  03
2782:  MOVF   00,W
2784:  ADDWF  x8C,F
2786:  MOVF   03,W
2788:  ADDWFC x8D,F
....................    WriteReg(EDMANDL, temp.v[0]);
278A:  MOVLW  12
278C:  MOVWF  x94
278E:  MOVFF  38C,395
2792:  MOVLB  0
2794:  CALL   083A
....................    WriteReg(EDMANDH, temp.v[1]);
2798:  MOVLW  13
279A:  MOVLB  3
279C:  MOVWF  x94
279E:  MOVFF  38D,395
27A2:  MOVLB  0
27A4:  CALL   083A
.................... 
....................    // Do the checksum calculation
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
27A8:  MOVLW  1F
27AA:  MOVLB  3
27AC:  MOVWF  x96
27AE:  MOVLW  30
27B0:  MOVWF  x97
27B2:  MOVLB  0
27B4:  CALL   0876
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
27B8:  MOVLW  1F
27BA:  MOVLB  3
27BC:  MOVWF  x8E
27BE:  MOVLB  0
27C0:  CALL   07FC
27C4:  MOVFF  01,38E
27C8:  MOVLW  00
27CA:  MOVLB  3
27CC:  BTFSC  01.5
27CE:  MOVLW  01
27D0:  XORLW  00
27D2:  BTFSC  FD8.2
27D4:  BRA    27DA
27D6:  MOVLB  0
27D8:  BRA    27B8
.................... 
....................    // Swap endianness and return
....................    temp.v[1] = ReadETHReg(EDMACSL).Val;
27DA:  MOVLW  16
27DC:  MOVWF  x8E
27DE:  MOVLB  0
27E0:  CALL   07FC
27E4:  MOVFF  01,38D
....................    temp.v[0] = ReadETHReg(EDMACSH).Val;
27E8:  MOVLW  17
27EA:  MOVLB  3
27EC:  MOVWF  x8E
27EE:  MOVLB  0
27F0:  CALL   07FC
27F4:  MOVFF  01,38C
....................    return temp.Val;
27F8:  MOVLB  3
27FA:  MOVFF  38C,01
27FE:  MOVFF  38D,02
2802:  MOVLB  0
2804:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD CalcIPBufferChecksum(WORD len)
....................  *
....................  * PreCondition:    Read buffer pointer set to starting of checksum data
....................  *
....................  * Input:           len: Total number of bytes to calculate the checksum over.
....................  *                   The first byte included in the checksum is the byte
....................  *                   pointed to by ERDPT, which is updated by calls to
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc.
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module
....................  *               which can calculate the checksum faster than software, so
....................  *               this function replaces the CaclIPBufferChecksum() function
....................  *               defined in the helpers.c file.  Through the use of
....................  *               preprocessor defines, this replacement is automatic.
....................  *
....................  * Note:            This function works either in the RX buffer area or the TX
....................  *               buffer area.  No validation is done on the len parameter.
....................  *****************************************************************************/
.................... WORD CalcIPBufferChecksum(WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Take care of special cases which the DMA cannot be used for
....................    if(len == 0u)
*
1F96:  MOVLB  3
1F98:  MOVF   x6F,F
1F9A:  BNZ   1FAA
1F9C:  MOVF   x70,F
1F9E:  BNZ   1FAA
....................    {
....................       return 0xFFFF;
1FA0:  MOVLW  FF
1FA2:  MOVWF  01
1FA4:  MOVWF  02
1FA6:  BRA    20EA
....................    }
1FA8:  BRA    1FD8
....................    else if(len == 1u)
1FAA:  DECFSZ x6F,W
1FAC:  BRA    1FD8
1FAE:  MOVF   x70,F
1FB0:  BNZ   1FD8
....................    {
....................       return ~(((WORD)MACGet())<<8);
1FB2:  MOVLB  0
1FB4:  RCALL  1F6A
1FB6:  MOVLB  3
1FB8:  CLRF   x74
1FBA:  MOVFF  01,373
1FBE:  MOVFF  01,03
1FC2:  MOVLW  00
1FC4:  CLRF   00
1FC6:  DECF   00,F
1FC8:  XORWF  00,F
1FCA:  MOVLW  FF
1FCC:  XORWF  03,F
1FCE:  MOVFF  00,01
1FD2:  MOVFF  03,02
1FD6:  BRA    20EA
....................    }
.................... 
.................... 
....................    // Set the DMA starting address to the SPI read pointer value
....................    BankSel(ERDPTL);
1FD8:  CLRF   x92
1FDA:  CLRF   x91
1FDC:  MOVLB  0
1FDE:  CALL   0894
....................    temp.v[0] = ReadETHReg(ERDPTL).Val;
1FE2:  MOVLB  3
1FE4:  CLRF   x8E
1FE6:  MOVLB  0
1FE8:  CALL   07FC
1FEC:  MOVFF  01,371
....................    temp.v[1] = ReadETHReg(ERDPTH).Val;
1FF0:  MOVLW  01
1FF2:  MOVLB  3
1FF4:  MOVWF  x8E
1FF6:  MOVLB  0
1FF8:  CALL   07FC
1FFC:  MOVFF  01,372
....................    WriteReg(EDMASTL, temp.v[0]);
2000:  MOVLW  10
2002:  MOVLB  3
2004:  MOVWF  x94
2006:  MOVFF  371,395
200A:  MOVLB  0
200C:  CALL   083A
....................    WriteReg(EDMASTH, temp.v[1]);
2010:  MOVLW  11
2012:  MOVLB  3
2014:  MOVWF  x94
2016:  MOVFF  372,395
201A:  MOVLB  0
201C:  CALL   083A
.................... 
....................    // See if we are calculating a checksum within the RX buffer (where
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are
....................    // not applied)
.................... #if RXSTART == 0
....................    if(temp.Val <= RXSTOP)
2020:  MOVLB  3
2022:  MOVF   x72,W
2024:  SUBLW  1B
2026:  BNC   205E
2028:  BNZ   2030
202A:  MOVF   x71,W
202C:  SUBLW  F7
202E:  BNC   205E
.................... #else
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP)
.................... #endif
....................    {
....................       // Calculate the DMA ending address given the starting address and len
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary.
....................       temp.Val += len-1;
2030:  MOVLW  01
2032:  SUBWF  x6F,W
2034:  MOVWF  00
2036:  MOVLW  00
2038:  SUBWFB x70,W
203A:  MOVWF  03
203C:  MOVF   00,W
203E:  ADDWF  x71,F
2040:  MOVF   03,W
2042:  ADDWFC x72,F
....................       if(temp.Val > RXSTOP)
2044:  MOVF   x72,W
2046:  SUBLW  1A
2048:  BC    205C
204A:  XORLW  FF
204C:  BNZ   2054
204E:  MOVF   x71,W
2050:  SUBLW  F7
2052:  BC    205C
....................       {
....................          temp.Val -= RXSIZE;
2054:  MOVLW  F8
2056:  SUBWF  x71,F
2058:  MOVLW  1B
205A:  SUBWFB x72,F
....................       }
....................    }
205C:  BRA    2072
....................    else
....................    {
....................       temp.Val += len-1;
205E:  MOVLW  01
2060:  SUBWF  x6F,W
2062:  MOVWF  00
2064:  MOVLW  00
2066:  SUBWFB x70,W
2068:  MOVWF  03
206A:  MOVF   00,W
206C:  ADDWF  x71,F
206E:  MOVF   03,W
2070:  ADDWFC x72,F
....................    }
.................... 
....................    // Write the DMA end address
....................    WriteReg(EDMANDL, temp.v[0]);
2072:  MOVLW  12
2074:  MOVWF  x94
2076:  MOVFF  371,395
207A:  MOVLB  0
207C:  CALL   083A
....................    WriteReg(EDMANDH, temp.v[1]);
2080:  MOVLW  13
2082:  MOVLB  3
2084:  MOVWF  x94
2086:  MOVFF  372,395
208A:  MOVLB  0
208C:  CALL   083A
.................... 
....................    // Begin the DMA checksum calculation and wait until it is finished
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
2090:  MOVLW  1F
2092:  MOVLB  3
2094:  MOVWF  x96
2096:  MOVLW  30
2098:  MOVWF  x97
209A:  MOVLB  0
209C:  CALL   0876
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
20A0:  MOVLW  1F
20A2:  MOVLB  3
20A4:  MOVWF  x8E
20A6:  MOVLB  0
20A8:  CALL   07FC
20AC:  MOVFF  01,373
20B0:  MOVLW  00
20B2:  MOVLB  3
20B4:  BTFSC  01.5
20B6:  MOVLW  01
20B8:  XORLW  00
20BA:  BTFSC  FD8.2
20BC:  BRA    20C2
20BE:  MOVLB  0
20C0:  BRA    20A0
.................... 
....................    // Return the resulting good stuff
....................    temp.v[0] = ReadETHReg(EDMACSL).Val;
20C2:  MOVLW  16
20C4:  MOVWF  x8E
20C6:  MOVLB  0
20C8:  CALL   07FC
20CC:  MOVFF  01,371
....................    temp.v[1] = ReadETHReg(EDMACSH).Val;
20D0:  MOVLW  17
20D2:  MOVLB  3
20D4:  MOVWF  x8E
20D6:  MOVLB  0
20D8:  CALL   07FC
20DC:  MOVFF  01,372
....................    return temp.Val;
20E0:  MOVLB  3
20E2:  MOVFF  371,01
20E6:  MOVFF  372,02
20EA:  MOVLB  0
20EC:  RETURN 0
.................... }
.................... #endif   // End of MCHP_MAC specific code
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of
....................  *                        destination MAC address) to copy from.
....................  *               TxOffset: Offset in the TX buffer (0=first byte of
....................  *                       destination MAC address) to copy to.
....................  *               len:     Number of bytes to copy
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is
....................  *               set), the hardware will wait until it is finished.  Then,
....................  *               the DMA module will copy the data from the receive buffer
....................  *               to the transmit buffer.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... // Remove this line if your application needs to use this
.................... // function.  This code has NOT been tested.
.................... #if 0
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE);
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
....................       temp.Val -= RXSIZE;
.................... 
....................    BankSel(EDMASTL);
....................    WriteReg(EDMASTL, temp.v[0]);
....................    WriteReg(EDMASTH, temp.v[1]);
.................... 
....................    temp.Val += len-1;
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
....................       temp.Val -= RXSIZE;
.................... 
....................    WriteReg(EDMANDL, temp.v[0]);
....................    WriteReg(EDMANDH, temp.v[1]);
.................... 
....................    TxOffset += TXSTART+1;
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]);
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]);
.................... 
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear
....................    // before starting the copy.
....................    BFCReg(ECON1, ECON1_CSUMEN);
....................    BFSReg(ECON1, ECON1_DMAST);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... }
.................... #endif
.................... 
.................... 
.................... #if defined(MAC_FILTER_BROADCASTS)
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation
.................... // of MAC_FILTER_BROADCASTS.
.................... /******************************************************************************
....................  * Function:        void MACSetPMFilter(BYTE *Pattern,
....................  *                              BYTE *PatternMask,
....................  *                              WORD PatternOffset)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                MACIsTxReady() must return TRUE
....................  *
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which
....................  *                          defines which bytes of the pattern are
....................  *                          important.  At least one bit must be set.
....................  *               PatternOffset: Offset from the beginning of the Ethernet
....................  *                           frame (1st byte of destination address), to
....................  *                           begin comparing with the given pattern.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Contents of the TX buffer space are overwritten
....................  *
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for:
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a
....................  *               subset of the broadcast packets which are normally
....................  *               received will be received.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACSetPMFilter(BYTE *Pattern,
....................                BYTE *PatternMask,
....................                WORD PatternOffset)
.................... {
....................    WORD_VAL i;
....................    BYTE *MaskPtr;
....................    BYTE UnmaskedPatternLen;
.................... 
....................    // Set the SPI write pointer and DMA startting address to the beginning of
....................    // the transmit buffer
....................    BankSel(EWRPTL);
....................    WriteReg(EWRPTL, LOW(TXSTART));
....................    WriteReg(EWRPTH, HIGH(TXSTART));
....................    WriteReg(EDMASTL, LOW(TXSTART));
....................    WriteReg(EDMASTH, HIGH(TXSTART));
.................... 
....................    // Fill the transmit buffer with the pattern to match against.  Only the
....................    // bytes which have a mask bit of 1 are written into the buffer and will
....................    // subsequently be used for checksum computation.
....................    MaskPtr = PatternMask;
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++)
....................    {
....................       if( *MaskPtr & i.v[1] )
....................       {
....................          MACPut(*Pattern);
....................          UnmaskedPatternLen++;
....................       }
....................       Pattern++;
.................... 
....................       i.v[1] <<= 1;
....................       if( i.v[1] == 0u )
....................       {
....................          i.v[1] = 0x01;
....................          MaskPtr++;
....................       }
....................    }
.................... 
....................    // Calculate and set the DMA end address
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1;
....................    WriteReg(EDMANDL, i.v[0]);
....................    WriteReg(EDMANDH, i.v[1]);
.................... 
....................    // Calculate the checksum on the given pattern using the DMA module
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Make certain that the PM filter isn't enabled while it is
....................    // being reconfigured.
....................    BankSel(ERXFCON);
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);
.................... 
....................    // Get the calculated DMA checksum and store it in the PM
....................    // checksum registers
....................    i.v[0] == ReadETHReg(EDMACSL).Val;
....................    i.v[1] == ReadETHReg(EDMACSH).Val;
....................    WriteReg(EPMCSL, i.v[0]);
....................    WriteReg(EPMCSH, i.v[0]);
.................... 
....................    // Set the Pattern Match offset and 8 byte mask
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]);
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]);
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++)
....................    {
....................       WriteReg(i.Val, *PatternMask++);
....................    }
.................... 
....................    // Begin using the new Pattern Match filter instead of the
....................    // broadcast filter
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN);
.................... }//end MACSetPMFilter
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACDisablePMFilter(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive
....................  *               filter (if enabled) and returns to the default filter
....................  *               configuration of: CRC AND (Unicast OR Broadcast).
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACDisablePMFilter(void)
.................... {
....................    BankSel(ERXFCON);
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);
....................    return;
.................... }//end MACDisablePMFilter
.................... #endif // end of MAC_FILTER_BROADCASTS specific code
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BYTE MACGet()
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                ERDPT must point to the place to read from.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Byte read from the ENC28J60's RAM
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and
....................  *               increments ERDPT so MACGet() can be called again.  The
....................  *               increment will follow the receive buffer wrapping boundary.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BYTE MACGet()
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = RBM;
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = 0;            // Send a dummy byte to receive the register
....................                      //   contents.
....................    while(!PIR1_SSPIF);      // Wait until register is received.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... 
....................    return SSPBUF;
.................... */
....................    char c;
.................... 
....................    SPISelectEthernet();
*
1F6A:  BCF    F93.2
1F6C:  BCF    F8A.2
....................    ENCSPIXfer(RBM);
1F6E:  MOVLW  3A
1F70:  MOVLB  3
1F72:  MOVWF  x99
1F74:  MOVLB  0
1F76:  CALL   07EC
....................    c=ENCSPIXfer(0);
1F7A:  MOVLB  3
1F7C:  CLRF   x99
1F7E:  MOVLB  0
1F80:  CALL   07EC
1F84:  MOVFF  01,373
....................    SPIUnselectEthernet();
1F88:  BCF    F93.2
1F8A:  BSF    F8A.2
....................    return(c);
1F8C:  MOVLB  3
1F8E:  MOVFF  373,01
1F92:  MOVLB  0
1F94:  RETURN 0
.................... }//end MACGet
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                ERDPT must point to the place to read from.
....................  *
....................  * Input:           *val: Pointer to storage location
....................  *               len:  Number of bytes to read from the data buffer.
....................  *
....................  * Output:          Byte(s) of data read from the data buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Burst reads several sequential bytes from the data buffer
....................  *               and places them into local memory.  With SPI burst support,
....................  *               it performs much faster than multiple MACGet() calls.
....................  *               ERDPT is incremented after each byte, following the same
....................  *               rules as MACGet().
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACGetArray(BYTE *val, WORD len)
*
11CC:  MOVLB  3
11CE:  CLRF   x82
11D0:  CLRF   x81
.................... {
.................... /*
....................    int16 i;
.................... 
....................    // Start the burst operation
....................    SPISelectEthernet();
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode.
....................    i = 0;
....................    val--;
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    // Read the data
....................    while(i<len)
....................    {
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte
....................       i++;
....................       val++;
....................       while(!PIR1_SSPIF);   // Wait until byte is received.
....................       PIR1_SSPIF = 0;
....................       *val = SSPBUF;
....................    };
.................... 
....................    // Terminate the burst operation
....................    SPIUnselectEthernet();
.................... 
....................    return i;
.................... */
.................... 
....................    int16 i=0;
.................... 
....................    SPISelectEthernet();
11D2:  BCF    F93.2
11D4:  BCF    F8A.2
....................    ENCSPIXfer(RBM);
11D6:  MOVLW  3A
11D8:  MOVWF  x99
11DA:  MOVLB  0
11DC:  CALL   07EC
....................    while(i<len)
11E0:  MOVLB  3
11E2:  MOVF   x82,W
11E4:  SUBWF  x80,W
11E6:  BNC   121C
11E8:  BNZ   11F0
11EA:  MOVF   x7F,W
11EC:  SUBWF  x81,W
11EE:  BC    121C
....................    {
....................       *val=ENCSPIXfer(0);
11F0:  MOVFF  37E,384
11F4:  MOVFF  37D,383
11F8:  CLRF   x99
11FA:  MOVLB  0
11FC:  CALL   07EC
1200:  MOVFF  384,FEA
1204:  MOVFF  383,FE9
1208:  MOVFF  01,FEF
....................       val++;
120C:  MOVLB  3
120E:  INCF   x7D,F
1210:  BTFSC  FD8.2
1212:  INCF   x7E,F
....................       i++;
1214:  INCF   x81,F
1216:  BTFSC  FD8.2
1218:  INCF   x82,F
121A:  BRA    11E2
....................    }
....................    SPIUnselectEthernet();
121C:  BCF    F93.2
121E:  BSF    F8A.2
.................... 
....................    return(i);
1220:  MOVFF  381,01
1224:  MOVFF  382,02
1228:  MOVLB  0
122A:  RETURN 0
.................... }//end MACGetArray
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPut(BYTE val)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                EWRPT must point to the location to begin writing.
....................  *
....................  * Input:           Byte to write into the ENC28J60 buffer memory
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant
....................  *               (8 bits) and data to write (8 bits) over the SPI.
....................  *               EWRPT is incremented after the write.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACPut(BYTE val)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = WBM;         // Send the opcode and constant.
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = val;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
15EA:  BCF    F93.2
15EC:  BCF    F8A.2
....................    ENCSPIXfer(WBM);
15EE:  MOVLW  7A
15F0:  MOVLB  3
15F2:  MOVWF  x99
15F4:  MOVLB  0
15F6:  CALL   07EC
....................    ENCSPIXfer(val);
15FA:  MOVFF  392,399
15FE:  CALL   07EC
....................    SPIUnselectEthernet();
1602:  BCF    F93.2
1604:  BSF    F8A.2
1606:  RETURN 0
.................... }//end MACPut
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPutArray(BYTE *val, WORD len)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                EWRPT must point to the location to begin writing.
....................  *
....................  * Input:           *val: Pointer to source of bytes to copy.
....................  *               len:  Number of bytes to write to the data buffer.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPutArray writes several sequential bytes to the
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut()
....................  *               calls.  EWRPT is incremented by len.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACPutArray(BYTE *val, WORD len)
.................... {
.................... /*
....................    // Select the chip and send the proper opcode
....................    SPISelectEthernet();
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    // Send the data
....................    while(len)
....................    {
....................       SSPBUF = *val;      // Start sending the byte
....................       val++;            // Increment after writing to SSPBUF to increase speed
....................       len--;            // Decrement after writing to SSPBUF to increase speed
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted
....................       PIR1_SSPIF = 0;
....................    };
.................... 
....................    // Terminate the burst operation
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
1608:  BCF    F93.2
160A:  BCF    F8A.2
....................    ENCSPIXfer(WBM);
160C:  MOVLW  7A
160E:  MOVLB  3
1610:  MOVWF  x99
1612:  MOVLB  0
1614:  CALL   07EC
....................    while(len--)
1618:  MOVLB  3
161A:  MOVFF  396,03
161E:  MOVF   x95,W
1620:  BTFSC  FD8.2
1622:  DECF   x96,F
1624:  DECF   x95,F
1626:  IORWF  03,W
1628:  BZ    1646
....................    {
....................       ENCSPIXfer(*val);
162A:  MOVFF  394,FEA
162E:  MOVFF  393,FE9
1632:  MOVFF  FEF,399
1636:  MOVLB  0
1638:  CALL   07EC
....................       val++;
163C:  MOVLB  3
163E:  INCF   x93,F
1640:  BTFSC  FD8.2
1642:  INCF   x94,F
1644:  BRA    161A
....................    }
....................    SPIUnselectEthernet();
1646:  BCF    F93.2
1648:  BSF    F8A.2
164A:  MOVLB  0
164C:  RETURN 0
.................... }//end MACPutArray
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        static void SendSystemReset(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SendSystemReset sends the System Reset SPI command to
....................  *               the Ethernet controller.  It resets all register contents
....................  *               (except for ECOCON) and returns the device to the power
....................  *               on default state.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... static void SendSystemReset(void)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = SR;
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
0826:  BCF    F93.2
0828:  BCF    F8A.2
....................    ENCSPIXfer(SR);
082A:  MOVLB  3
082C:  SETF   x99
082E:  MOVLB  0
0830:  RCALL  07EC
....................    SPIUnselectEthernet();
0832:  BCF    F93.2
0834:  BSF    F8A.2
0836:  GOTO   0AF4 (RETURN)
.................... }//end SendSystemReset
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        REG ReadETHReg(BYTE Address)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                to read from.
....................  *
....................  * Input:           5 bit address of the ETH control register to read from.
....................  *                 The top 3 bits must be 0.
....................  *
....................  * Output:          Byte read from the Ethernet controller's ETH register.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over
....................  *               the SPI and then retrives the register contents in the
....................  *               next 8 SPI clocks.
....................  *
....................  * Note:            This routine cannot be used to access MAC/MII or PHY
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that
....................  *               purpose.
....................  *****************************************************************************/
.................... static REG ReadETHReg(BYTE Address)
.................... {
....................    char c;
.................... /*
....................    // Select the chip and send the Read Control Register opcode/address
....................    SPISelectEthernet();
....................    SSPBUF = RCR | Address;
.................... 
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted
....................    PIR1_SSPIF = 0;
....................    SSPBUF = 0;            // Send a dummy byte to receive the register
....................                      //   contents
....................    while(!PIR1_SSPIF);      // Wait until the register is received
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... 
....................    return *((REG*)&SSPBUF);
....................    */
.................... 
....................    SPISelectEthernet();
*
07FC:  BCF    F93.2
07FE:  BCF    F8A.2
....................    ENCSPIXfer(RCR | Address);
0800:  MOVFF  38E,390
0804:  MOVFF  38E,399
0808:  MOVLB  0
080A:  RCALL  07EC
....................    c=ENCSPIXfer(0);
080C:  MOVLB  3
080E:  CLRF   x99
0810:  MOVLB  0
0812:  RCALL  07EC
0814:  MOVFF  01,38F
....................    SPIUnselectEthernet();
0818:  BCF    F93.2
081A:  BSF    F8A.2
....................    return(c);
081C:  MOVLB  3
081E:  MOVFF  38F,01
0822:  MOVLB  0
0824:  RETURN 0
.................... }//end ReadETHReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        REG ReadMACReg(BYTE Address)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                to read from.
....................  *
....................  * Input:           5 bit address of the MAC or MII register to read from.
....................  *                 The top 3 bits must be 0.
....................  *
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well
....................  *               as a dummy byte over the SPI and then retrives the
....................  *               register contents in the last 8 SPI clocks.
....................  *
....................  * Note:            This routine cannot be used to access ETH or PHY
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that
....................  *               purpose.
....................  *****************************************************************************/
.................... static REG ReadMACReg(BYTE Address)
.................... {
....................    char c;
.................... /*
....................    SPISelectEthernet();
.................... 
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and
....................                      //   address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    SSPBUF = 0;            // Send a dummy byte
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted
....................    PIR1_SSPIF = 0;
.................... 
....................    SSPBUF = 0;            // Send another dummy byte to receive the register
....................                      //   contents.
....................    while(!PIR1_SSPIF);      // Wait until register is received.
....................    PIR1_SSPIF = 0;
.................... 
....................    SPIUnselectEthernet();
.................... 
....................    return *((REG*)&SSPBUF);
.................... */
....................    SPISelectEthernet();
*
08C6:  BCF    F93.2
08C8:  BCF    F8A.2
.................... 
....................    ENCSPIXfer(RCR | Address);
08CA:  MOVFF  2E8,2EA
08CE:  MOVFF  2E8,399
08D2:  MOVLB  0
08D4:  RCALL  07EC
....................    ENCSPIXfer(0);
08D6:  MOVLB  3
08D8:  CLRF   x99
08DA:  MOVLB  0
08DC:  RCALL  07EC
....................    c=ENCSPIXfer(0);
08DE:  MOVLB  3
08E0:  CLRF   x99
08E2:  MOVLB  0
08E4:  RCALL  07EC
08E6:  MOVFF  01,2E9
.................... 
....................    SPIUnselectEthernet();
08EA:  BCF    F93.2
08EC:  BSF    F8A.2
.................... 
....................    return(c);
08EE:  MOVLB  2
08F0:  MOVFF  2E9,01
08F4:  MOVLB  0
08F6:  RETURN 0
.................... }//end ReadMACReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        ReadPHYReg
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Address of the PHY register to read from.
....................  *
....................  * Output:          16 bits of data read from the PHY register.
....................  *
....................  * Side Effects:    Alters bank bits to point to Bank 2
....................  *
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in
....................  *               progress, it simply polls the MII BUSY bit wasting time.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... PHYREG ReadPHYReg(BYTE Register)
.................... {
....................    PHYREG Result;
.................... 
....................    // Set the right address and start the register read operation
....................    BankSel(MIREGADR);
*
0988:  MOVLW  02
098A:  MOVLB  3
098C:  MOVWF  x92
098E:  MOVLW  14
0990:  MOVWF  x91
0992:  MOVLB  0
0994:  RCALL  0894
....................    WriteReg(MIREGADR, Register);
0996:  MOVLW  14
0998:  MOVLB  3
099A:  MOVWF  x94
099C:  MOVFF  2E5,395
09A0:  MOVLB  0
09A2:  RCALL  083A
....................    WriteReg(MICMD, MICMD_MIIRD);
09A4:  MOVLW  12
09A6:  MOVLB  3
09A8:  MOVWF  x94
09AA:  MOVLW  01
09AC:  MOVWF  x95
09AE:  MOVLB  0
09B0:  RCALL  083A
.................... 
....................    // Loop to wait until the PHY register has been read through the MII
....................    // This requires 10.24us
....................    BankSel(MISTAT);
09B2:  MOVLW  03
09B4:  MOVLB  3
09B6:  MOVWF  x92
09B8:  MOVLW  0A
09BA:  MOVWF  x91
09BC:  MOVLB  0
09BE:  RCALL  0894
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY);
09C0:  MOVLW  0A
09C2:  MOVLB  2
09C4:  MOVWF  xE8
09C6:  MOVLB  0
09C8:  RCALL  08C6
09CA:  MOVFF  01,2E8
09CE:  MOVLW  00
09D0:  MOVLB  2
09D2:  BTFSC  01.0
09D4:  MOVLW  01
09D6:  XORLW  00
09D8:  BTFSC  FD8.2
09DA:  BRA    09E0
09DC:  MOVLB  0
09DE:  BRA    09C0
.................... 
....................    // Stop reading
....................    BankSel(MIREGADR);
09E0:  MOVLW  02
09E2:  MOVLB  3
09E4:  MOVWF  x92
09E6:  MOVLW  14
09E8:  MOVWF  x91
09EA:  MOVLB  0
09EC:  RCALL  0894
....................    WriteReg(MICMD, 0x00);
09EE:  MOVLW  12
09F0:  MOVLB  3
09F2:  MOVWF  x94
09F4:  CLRF   x95
09F6:  MOVLB  0
09F8:  RCALL  083A
.................... 
....................    // Obtain results and return
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val;
09FA:  MOVLW  18
09FC:  MOVLB  2
09FE:  MOVWF  xE8
0A00:  MOVLB  0
0A02:  RCALL  08C6
0A04:  MOVFF  01,2E6
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val;
0A08:  MOVLW  19
0A0A:  MOVLB  2
0A0C:  MOVWF  xE8
0A0E:  MOVLB  0
0A10:  RCALL  08C6
0A12:  MOVFF  01,2E7
....................    return Result;
0A16:  MOVLB  2
0A18:  MOVFF  2E6,01
0A1C:  MOVFF  2E7,02
0A20:  MOVLB  0
0A22:  GOTO   0A3C (RETURN)
.................... }//end ReadPHYReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void WriteReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *               to modify.
....................  *
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify.
....................  *                 The top 3 bits must be 0.
....................  *               Byte to be written into the register.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the
....................  *               SPI and then sends the data to write in the next 8 SPI
....................  *               clocks.
....................  *
....................  * Note:            This routine is almost identical to the BFCReg() and
....................  *               BFSReg() functions.  It is seperate to maximize speed.
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg()
....................  *               can write to any ETH or MAC register.  Writing to PHY
....................  *               registers must be accomplished with WritePHYReg().
....................  *****************************************************************************/
.................... static void WriteReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = WCR | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
083A:  BCF    F93.2
083C:  BCF    F8A.2
....................    ENCSPIXfer(WCR | Address);
083E:  MOVLB  3
0840:  MOVF   x94,W
0842:  IORLW  40
0844:  MOVWF  x96
0846:  MOVWF  x99
0848:  MOVLB  0
084A:  RCALL  07EC
....................    ENCSPIXfer(Data);
084C:  MOVFF  395,399
0850:  RCALL  07EC
....................    SPIUnselectEthernet();
0852:  BCF    F93.2
0854:  BSF    F8A.2
0856:  RETURN 0
.................... }//end WriteReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void BFCReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                 to modify.
....................  *
....................  * Input:           5 bit address of the register to modify.  The top 3 bits
....................  *                 must be 0.
....................  *               Byte to be used with the Bit Field Clear operation.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the
....................  *               SPI and then sends the data in the next 8 SPI clocks.
....................  *
....................  * Note:            This routine is almost identical to the WriteReg() and
....................  *               BFSReg() functions.  It is separate to maximize speed.
....................  *               BFCReg() must only be used on ETH registers.
....................  *****************************************************************************/
.................... static void BFCReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = BFC | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
0858:  BCF    F93.2
085A:  BCF    F8A.2
....................    ENCSPIXfer(BFC | Address);
085C:  MOVLB  3
085E:  MOVF   x93,W
0860:  IORLW  A0
0862:  MOVWF  x95
0864:  MOVWF  x99
0866:  MOVLB  0
0868:  RCALL  07EC
....................    ENCSPIXfer(Data);
086A:  MOVFF  394,399
086E:  RCALL  07EC
....................    SPIUnselectEthernet();
0870:  BCF    F93.2
0872:  BSF    F8A.2
0874:  RETURN 0
.................... }//end BFCReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void BFSReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *               to modify.
....................  *
....................  * Input:           5 bit address of the register to modify.  The top 3 bits
....................  *                 must be 0.
....................  *               Byte to be used with the Bit Field Set operation.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the
....................  *               SPI and then sends the data in the next 8 SPI clocks.
....................  *
....................  * Note:            This routine is almost identical to the WriteReg() and
....................  *               BFCReg() functions.  It is separate to maximize speed.
....................  *               BFSReg() must only be used on ETH registers.
....................  *****************************************************************************/
.................... static void BFSReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = BFS | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
0876:  BCF    F93.2
0878:  BCF    F8A.2
....................    ENCSPIXfer(BFS | Address);
087A:  MOVLB  3
087C:  MOVF   x96,W
087E:  IORLW  80
0880:  MOVWF  x98
0882:  MOVWF  x99
0884:  MOVLB  0
0886:  RCALL  07EC
....................    ENCSPIXfer(Data);
0888:  MOVFF  397,399
088C:  RCALL  07EC
....................    SPIUnselectEthernet();
088E:  BCF    F93.2
0890:  BSF    F8A.2
0892:  RETURN 0
.................... }//end BFSReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WritePHYReg
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Address of the PHY register to write to.
....................  *               16 bits of data to write to PHY register.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Alters bank bits to point to Bank 3
....................  *
....................  * Overview:        WritePHYReg performs an MII write operation.  While in
....................  *               progress, it simply polls the MII BUSY bit wasting time.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void WritePHYReg(BYTE Register, WORD Data)
.................... {
....................    // Write the register address
....................    BankSel(MIREGADR);
*
08F8:  MOVLW  02
08FA:  MOVLB  3
08FC:  MOVWF  x92
08FE:  MOVLW  14
0900:  MOVWF  x91
0902:  MOVLB  0
0904:  RCALL  0894
....................    WriteReg(MIREGADR, Register);
0906:  MOVLW  14
0908:  MOVLB  3
090A:  MOVWF  x94
090C:  MOVFF  2E5,395
0910:  MOVLB  0
0912:  RCALL  083A
.................... 
....................    // Write the data
....................    // Order is important: write low byte first, high byte last
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]);
0914:  MOVLW  02
0916:  MOVLB  2
0918:  MOVWF  xE9
091A:  MOVLW  E6
091C:  MOVWF  xE8
091E:  MOVWF  FE9
0920:  MOVFF  2E9,FEA
0924:  MOVFF  FEF,395
0928:  MOVLW  16
092A:  MOVLB  3
092C:  MOVWF  x94
092E:  MOVLB  0
0930:  RCALL  083A
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]);
0932:  MOVLW  02
0934:  MOVLB  2
0936:  MOVWF  xE9
0938:  MOVLW  E6
093A:  MOVWF  xE8
093C:  MOVLW  01
093E:  ADDWF  xE8,W
0940:  MOVWF  FE9
0942:  MOVLW  00
0944:  ADDWFC xE9,W
0946:  MOVWF  FEA
0948:  MOVFF  FEF,395
094C:  MOVLW  17
094E:  MOVLB  3
0950:  MOVWF  x94
0952:  MOVLB  0
0954:  RCALL  083A
.................... 
....................    // Wait until the PHY register has been written
....................    BankSel(MISTAT);
0956:  MOVLW  03
0958:  MOVLB  3
095A:  MOVWF  x92
095C:  MOVLW  0A
095E:  MOVWF  x91
0960:  MOVLB  0
0962:  RCALL  0894
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY);
0964:  MOVLW  0A
0966:  MOVLB  2
0968:  MOVWF  xE8
096A:  MOVLB  0
096C:  RCALL  08C6
096E:  MOVFF  01,2E8
0972:  MOVLW  00
0974:  MOVLB  2
0976:  BTFSC  01.0
0978:  MOVLW  01
097A:  XORLW  00
097C:  BTFSC  FD8.2
097E:  BRA    0984
0980:  MOVLB  0
0982:  BRA    0964
0984:  MOVLB  0
0986:  RETURN 0
.................... }//end WritePHYReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BankSel
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Register address with the high byte containing the 2 bank
....................  *                 select 2 bits.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BankSel takes the high byte of a register address and
....................  *               changes the bank select bits in ETHCON1 to match.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... static void BankSel(WORD Register)
.................... {
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0);
*
0894:  MOVLW  1F
0896:  MOVLB  3
0898:  MOVWF  x93
089A:  MOVLW  03
089C:  MOVWF  x94
089E:  MOVLB  0
08A0:  RCALL  0858
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]);
08A2:  MOVLW  03
08A4:  MOVLB  3
08A6:  MOVWF  x94
08A8:  MOVLW  91
08AA:  MOVWF  x93
08AC:  MOVLW  01
08AE:  ADDWF  x93,W
08B0:  MOVWF  FE9
08B2:  MOVLW  00
08B4:  ADDWFC x94,W
08B6:  MOVWF  FEA
08B8:  MOVFF  FEF,397
08BC:  MOVLW  1F
08BE:  MOVWF  x96
08C0:  MOVLB  0
08C2:  RCALL  0876
08C4:  RETURN 0
.................... }//end BankSel
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        static BOOL TestMemory(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if the memory tests have passed
....................  *               FALSE if the BIST has detected a hardware fault
....................  *
....................  * Side Effects:    Alters the state of numerous control registers and all
....................  *               RAM bytes.
....................  *
....................  * Overview:        The internal BIST and DMA modules are used to fill the
....................  *               entire dual port memory and calculate a checksum of the
....................  *               data stored within.  Address and Random fill modes are
....................  *               used.
....................  *
....................  * Note:            For the Random Fill mode, the random number generator is
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer
....................  *               is running, additional confidence that the memory is
....................  *               working can be obtained by calling TestMemory multiple
....................  *               times.
....................  *****************************************************************************/
.................... #if defined(MAC_POWER_ON_TEST)
.................... static BOOL TestMemory(void)
.................... {
....................    #define RANDOM_FILL      0b0000
....................    #define ADDRESS_FILL   0b0100
....................    #define PATTERN_SHIFT   0b1000
.................... 
....................    WORD_VAL DMAChecksum, BISTChecksum;
.................... 
.................... 
....................    // Select Bank 0 and disable anything that could have been in progress
....................    WriteReg(ECON1, 0x00);
.................... 
....................    // Set up necessary pointers for the DMA to calculate over the entire
....................    // memory
....................    WriteReg(EDMASTL, 0x00);
....................    WriteReg(EDMASTH, 0x00);
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u));
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u));
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u));
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u));
.................... 
....................    // Enable Test Mode and do an Address Fill
....................    BankSel(EBSTCON);
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME |
....................                    EBSTCON_BISTST |
....................                    ADDRESS_FILL);
.................... 
.................... 
....................    // Wait for the BIST to complete and disable test mode before
....................    // starting any DMA operations.
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST);
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
.................... 
....................    // Begin reading the memory and calculating a checksum over it
....................    // Block until the checksum is generated
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    BankSel(EDMACSL);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Obtain the resulting DMA checksum and the expected BIST checksum
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val;
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val;
....................    BankSel(EBSTCSL);
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val;
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val;
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
....................    // Compare the results
....................    // 0xF807 should always be generated in Address fill mode
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) )
....................       return FALSE;
.................... 
....................    // Seed the random number generator and begin another Random Fill test
....................    // with the DMA and BIST memory access ports swapped.
.................... #ifdef __C30__
....................    WriteReg((BYTE)EBSTSD, TMR1);
.................... #else
....................    WriteReg((BYTE)EBSTSD, TMR0L);
.................... #endif
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME |
....................                  EBSTCON_PSEL |
....................                  EBSTCON_BISTST |
....................                  RANDOM_FILL);
.................... 
.................... 
....................    // Wait for the BIST to complete and disable test mode since
....................    // we won't be needing it anymore
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST);
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
.................... 
....................    // Begin reading the memory and calculating a checksum over it
....................    // Block until the checksum is generated
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    BankSel(EDMACSL);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Obtain the resulting DMA checksum and the expected BIST checksum
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val;
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val;
....................    BankSel(EBSTCSL);
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val;
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val;
.................... 
....................    return (DMAChecksum.Val == BISTChecksum.Val);
.................... }//end TestMemory
.................... #endif
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Member of DUPLEX enum:
....................  *                  FULL: Set full duplex mode
....................  *                  HALF: Set half duplex mode
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in
....................  *                         PHYCON.  This is controlled by LEDB on RESET.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Changes bank bits to Bank 2.
....................  *
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex
....................  *               operation, sets PHY up for full duplex operation, and
....................  *               reenables RX logic.  The back-to-back inter-packet gap
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap.
....................  *
....................  * Note:            If a packet is being transmitted or received while this
....................  *               function is called, it will be aborted.
....................  *****************************************************************************/
.................... void MACSetDuplex(DUPLEX DuplexState)
.................... {
....................    REG Register;
....................    PHYREG PhyReg;
.................... 
....................    // Disable receive logic and abort any packets currently being transmitted
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN);
*
0A26:  MOVLW  1F
0A28:  MOVLB  3
0A2A:  MOVWF  x93
0A2C:  MOVLW  0C
0A2E:  MOVWF  x94
0A30:  MOVLB  0
0A32:  RCALL  0858
.................... 
....................    // Set the PHY to the proper duplex mode
....................    PhyReg = ReadPHYReg(PHCON1);
0A34:  MOVLB  2
0A36:  CLRF   xE5
0A38:  MOVLB  0
0A3A:  BRA    0988
0A3C:  MOVFF  02,2E4
0A40:  MOVFF  01,2E3
....................    if(DuplexState == USE_PHY)
0A44:  MOVLB  2
0A46:  MOVF   xE1,W
0A48:  SUBLW  02
0A4A:  BNZ   0A54
....................    {
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD;
0A4C:  CLRF   xE1
0A4E:  BTFSC  xE4.0
0A50:  INCF   xE1,F
....................    }
0A52:  BRA    0A6A
....................    else
....................    {
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState;
0A54:  BCF    xE4.0
0A56:  BTFSC  xE1.0
0A58:  BSF    xE4.0
....................       WritePHYReg(PHCON1, PhyReg.Val);
0A5A:  CLRF   xE5
0A5C:  MOVFF  2E4,2E7
0A60:  MOVFF  2E3,2E6
0A64:  MOVLB  0
0A66:  RCALL  08F8
0A68:  MOVLB  2
....................    }
.................... 
....................    // Set the MAC to the proper duplex mode
....................    BankSel(MACON3);
0A6A:  MOVLW  02
0A6C:  MOVLB  3
0A6E:  MOVWF  x92
0A70:  MOVWF  x91
0A72:  MOVLB  0
0A74:  RCALL  0894
....................    Register = ReadMACReg(MACON3);
0A76:  MOVLW  02
0A78:  MOVLB  2
0A7A:  MOVWF  xE8
0A7C:  MOVLB  0
0A7E:  RCALL  08C6
0A80:  MOVFF  01,2E2
....................    Register.MACON3bits.FULDPX = DuplexState;
0A84:  MOVLB  2
0A86:  BCF    xE2.0
0A88:  BTFSC  xE1.0
0A8A:  BSF    xE2.0
....................    WriteReg(MACON3, Register.Val);
0A8C:  MOVLW  02
0A8E:  MOVLB  3
0A90:  MOVWF  x94
0A92:  MOVFF  2E2,395
0A96:  MOVLB  0
0A98:  RCALL  083A
.................... 
....................    // Set the back-to-back inter-packet gap time to IEEE specified
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex
....................    // state, so it must be updated in this function.
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12);
0A9A:  MOVLB  2
0A9C:  MOVF   xE1,F
0A9E:  BZ    0AA4
0AA0:  MOVLW  15
0AA2:  BRA    0AA6
0AA4:  MOVLW  12
0AA6:  MOVWF  xE5
0AA8:  MOVLW  04
0AAA:  MOVLB  3
0AAC:  MOVWF  x94
0AAE:  MOVFF  2E5,395
0AB2:  MOVLB  0
0AB4:  RCALL  083A
.................... 
....................    // Reenable receive logic
....................    BFSReg(ECON1, ECON1_RXEN);
0AB6:  MOVLW  1F
0AB8:  MOVLB  3
0ABA:  MOVWF  x96
0ABC:  MOVLW  04
0ABE:  MOVWF  x97
0AC0:  MOVLB  0
0AC2:  RCALL  0876
0AC4:  GOTO   0C84 (RETURN)
.................... }//end MACSetDuplex
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPowerDown(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In
....................  *               sleep mode, no packets can be transmitted or received.
....................  *               All MAC and PHY registers should not be accessed.
....................  *
....................  * Note:            If a packet is being transmitted while this function is
....................  *                called, this function will block until it is it complete.
....................  *               If anything is being received, it will be completed.
....................  *****************************************************************************/
.................... void MACPowerDown(void)
.................... {
....................    // Disable packet reception
....................    BFCReg(ECON1, ECON1_RXEN);
.................... 
....................    // Make sure any last packet which was in-progress when RXEN was cleared
....................    // is completed
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY);
.................... 
....................    // If a packet is being transmitted, wait for it to finish
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS);
.................... 
....................    // Enter sleep mode
....................    BFSReg(ECON2, ECON2_PWRSV);
.................... }//end MACPowerDown
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPowerUp(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation
....................  *               after a previous call to MACPowerDown().  Calling this
....................  *               function when already powered up will have no effect.
....................  *
....................  * Note:            The first packet transmitted may get lost at the RX end if
....................  *               you don't wait for the link to go up first.  MACIsLinked()
....................  *               can be called to determine if a link is established.
....................  *****************************************************************************/
.................... void MACPowerUp(void)
.................... {
....................    // Leave power down mode
....................    BFCReg(ECON2, ECON2_PWRSV);
.................... 
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This
....................    // delay is required for the PHY module to return to an operational state.
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY);
.................... 
....................    // Enable packet reception
....................    BFSReg(ECON1, ECON1_RXEN);
.................... }//end MACPowerUp
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void SetCLKOUT(BYTE NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low)
....................  *                        0x01: Divide by 1 (25 MHz)
....................  *                        0x02: Divide by 2 (12.5 MHz)
....................  *                        0x03: Divide by 3 (8.333333 MHz)
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default)
....................  *                        0x05: Divide by 8 (3.125 MHz)
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the ECOCON register.
....................  *               The CLKOUT pin will beginning outputting the new frequency
....................  *               immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... void SetCLKOUT(BYTE NewConfig)
.................... {
....................    BankSel(ECOCON);
....................    WriteReg(ECOCON, NewConfig);
.................... }//end SetCLKOUT
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BYTE GetCLKOUT(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low)
....................  *                     0x01: Divide by 1 (25 MHz)
....................  *                     0x02: Divide by 2 (12.5 MHz)
....................  *                     0x03: Divide by 3 (8.333333 MHz)
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default)
....................  *                     0x05: Divide by 8 (3.125 MHz)
....................  *                     0x06: Reserved
....................  *                     0x07: Reserved
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the ECOCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BYTE GetCLKOUT(void)
.................... {
....................    BankSel(ECOCON);
....................    return ReadETHReg(ECOCON).Val;
.................... }//end GetCLKOUT
.................... 
....................    #elif STACK_USE_MCPINC
....................     #include "tcpip/eth97j60.c"
....................    #else
....................     #include "tcpip/rtl8019AS.c"
....................    #endif
.................... #endif
.................... 
.................... #if STACK_USE_PPP
....................    #include "tcpip/modem.c"
....................    #include "tcpip/ppp.c"
....................    #include "tcpip/pppwrap.c"
.................... #endif
.................... 
.................... #if STACK_USE_SLIP
....................    #include "tcpip/slip.c"
.................... #ENDIF
.................... 
.................... #if STACK_USE_UDP
....................    #include "tcpip/udp.h"
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    #include "tcpip/dhcp.h"
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    #include "tcpip/smtp.h"
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    #include "tcpip/http.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///                                                                     ///
.................... ///                              HTTP.H                                 ///
.................... ///                                                                     ///
.................... /// Simple webserver for the Microchip TCP/IP stack.                    ///
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       ///
.................... ///                                                                     ///
.................... /// See HTTP.C for documenation                                         ///
.................... ///                                                                     ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef HTTP_USE_CHUNKS
.................... #define HTTP_USE_CHUNKS   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_CONTENT_TYPE
.................... #define HTTP_USE_CONTENT_TYPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_PORT
.................... #define HTTP_PORT             80
.................... #endif
.................... 
.................... #ifndef HTTP_NUM_SOCKETS
.................... #define HTTP_NUM_SOCKETS      1
.................... #endif
.................... 
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE
.................... #define HTTP_GET_PARAM_MAX_SIZE  254
.................... #endif
.................... 
.................... void HTTP_Init(void);
.................... void HTTP_Task(void);
.................... 
.................... //**** CALLBACKS START ******///
.................... 
.................... /// the following three functions are callbacks and
.................... /// must be written in your main application!!!  see the documentation above
.................... /// for more help.
.................... 
.................... #if HTTP_USE_CONTENT_TYPE
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... #else
....................  int32 http_get_page(char *file_str);
.................... #endif
.................... 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... void http_exec_cgi(int32 file, char *key, char *val);
.................... 
.................... //**** CALLBACKS END ******///
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP2
....................    #include "tcpip/http2.h"
.................... #endif
.................... 
.................... #if STACK_USE_DNS
....................    #include "tcpip/dns.h"
.................... #endif
.................... 
.................... #if STACK_USE_SNMP
....................    #include "tcpip/snmp.h"
.................... #endif
.................... 
.................... #if STACK_USE_MPFS
....................    #include "tcpip/mpfs.h"
.................... #endif
.................... 
.................... #include "tcpip/ip.c"
.................... /*********************************************************************
....................  *
....................  *                  PIC IP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.C
....................  * Dependencies:    string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                  IP.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail)
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // This is left shifted by 4.  Actual value is 0x04.
.................... #define IPv4                (0x40u)
.................... #define IP_VERSION          IPv4
.................... 
.................... #define debug_ip
.................... //#define debug_ip  debug_printf
.................... 
.................... // IHL (Internet Header Length) is # of DWORDs in a header.
.................... // Since, we do not support options, our IP header length will be
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5.
.................... #define IP_IHL              (0x05)
.................... 
.................... #define IP_SERVICE_NW_CTRL  (0x07)
.................... #define IP_SERVICE_IN_CTRL  (0x06)
.................... #define IP_SERVICE_ECP      (0x05)
.................... #define IP_SERVICE_OVR      (0x04)
.................... #define IP_SERVICE_FLASH    (0x03)
.................... #define IP_SERVICE_IMM      (0x02)
.................... #define IP_SERVICE_PRIOR    (0x01)
.................... #define IP_SERVICE_ROUTINE  (0x00)
.................... 
.................... #define IP_SERVICE_N_DELAY  (0x00)
.................... #define IP_SERCICE_L_DELAY  (0x08)
.................... #define IP_SERVICE_N_THRPT  (0x00)
.................... #define IP_SERVICE_H_THRPT  (0x10)
.................... #define IP_SERVICE_N_RELIB  (0x00)
.................... #define IP_SERVICE_H_RELIB  (0x20)
.................... 
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY)
.................... 
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds
.................... 
.................... 
.................... 
.................... 
.................... static WORD _Identifier = 0;
.................... static BYTE IPHeaderLen;
.................... 
.................... static void SwapIPHeader(IP_HEADER* h);
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len)
.................... {
....................     WORD_VAL    CalcChecksum;
....................     IP_HEADER   header;
.................... 
.................... #if !defined(MCHP_MAC)
....................     WORD_VAL    ReceivedChecksum;
....................     WORD        checksums[2];
....................     BYTE        optionsLen;
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791.
....................     BYTE        options[MAX_OPTIONS_LEN];
.................... #endif
.................... 
....................     // Read IP header.
....................     MACGetArray((BYTE*)&header, sizeof(header));
*
1D96:  MOVLW  02
1D98:  MOVLB  3
1D9A:  MOVWF  x05
1D9C:  MOVLW  F0
1D9E:  MOVWF  x04
1DA0:  MOVFF  305,37E
1DA4:  MOVWF  x7D
1DA6:  CLRF   x80
1DA8:  MOVLW  14
1DAA:  MOVWF  x7F
1DAC:  MOVLB  0
1DAE:  CALL   11CC
.................... 
....................     // Make sure that this is an IPv4 packet.
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION )
1DB2:  MOVLB  2
1DB4:  MOVF   xF0,W
1DB6:  ANDLW  F0
1DB8:  SUBLW  40
1DBA:  BZ    1DC2
....................     	return FALSE;
1DBC:  MOVLW  00
1DBE:  MOVWF  01
1DC0:  BRA    1E76
.................... 
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2;
1DC2:  MOVF   xF0,W
1DC4:  ANDLW  0F
1DC6:  MOVWF  00
1DC8:  RLCF   00,W
1DCA:  MOVWF  5F
1DCC:  RLCF   5F,F
1DCE:  MOVLW  FC
1DD0:  ANDWF  5F,F
.................... 
.................... #if defined(MCHP_MAC)
.................... 	// Validate the IP header.  If it is correct, the checksum
.................... 	// will come out to 0x0000 (because the header contains a
.................... 	// precomputed checksum).  A corrupt header will have a
.................... 	// nonzero checksum.
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen);
1DD2:  MOVLB  3
1DD4:  CLRF   x40
1DD6:  CLRF   x3F
1DD8:  CLRF   x42
1DDA:  MOVFF  5F,341
1DDE:  MOVLB  0
1DE0:  RCALL  1B4A
1DE2:  MOVFF  02,2EF
1DE6:  MOVFF  01,2EE
.................... 
.................... 	// Seek to the end of the IP header
.................... 	MACSetRxBuffer(IPHeaderLen);
1DEA:  MOVLB  3
1DEC:  CLRF   x18
1DEE:  MOVFF  5F,317
1DF2:  MOVLB  0
1DF4:  RCALL  1C52
.................... 
....................     if(CalcChecksum.Val)
1DF6:  MOVLB  2
1DF8:  MOVF   xEE,W
1DFA:  IORWF  xEF,W
1DFC:  BZ    1E04
.................... #else
.................... 
....................     // Calculate options length in this header, if there is any.
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual
....................     // length is 4 times IHL.
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header);
.................... 
....................     // If there is any option(s), read it so that we can include them
....................     // in checksum calculation.
....................     if ( optionsLen > MAX_OPTIONS_LEN )
....................         return FALSE;
.................... 
....................     if ( optionsLen > 0 )
....................         MACGetArray(options, optionsLen);
.................... 
....................     // Save header checksum; clear it and recalculate it ourselves.
....................     ReceivedChecksum.Val = header.HeaderChecksum;
....................     header.HeaderChecksum = 0;
.................... 
....................     // Calculate checksum of header including options bytes.
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header));
.................... 
....................     // Calculate Options checksum too, if they are present.
....................     if ( optionsLen > 0 )
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen);
....................     else
....................         checksums[1] = 0;
.................... 
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums,
....................                                             2 * sizeof(WORD));
.................... 
....................     // Make sure that checksum is correct
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val )
.................... #endif
....................     {
....................         // Bad packet. The function caller will be notified by means of the FALSE
....................         // return value and it should discard the packet.
....................         return FALSE;
1DFE:  MOVLW  00
1E00:  MOVWF  01
1E02:  BRA    1E76
....................     }
.................... 
....................     // Network to host conversion.
....................     SwapIPHeader(&header);
1E04:  MOVLW  02
1E06:  MOVLB  3
1E08:  MOVWF  x89
1E0A:  MOVLW  F0
1E0C:  MOVWF  x88
1E0E:  MOVLB  0
1E10:  RCALL  1CCE
.................... 
....................     // If caller is intrested, return destination IP address
....................     // as seen in this IP header.
....................     if ( localIP )
1E12:  MOVLB  2
1E14:  MOVF   xE6,W
1E16:  IORWF  xE7,W
1E18:  BZ    1E32
....................         localIP->Val    = header.DestAddress.Val;
1E1A:  MOVFF  2E6,FE9
1E1E:  MOVFF  2E7,FEA
1E22:  MOVFF  300,FEF
1E26:  MOVFF  301,FEC
1E2A:  MOVFF  302,FEC
1E2E:  MOVFF  303,FEC
.................... 
....................     remote->IPAddr.Val  = header.SourceAddress.Val;
1E32:  MOVLW  06
1E34:  ADDWF  xE8,W
1E36:  MOVWF  FE9
1E38:  MOVLW  00
1E3A:  ADDWFC xE9,W
1E3C:  MOVWF  FEA
1E3E:  MOVFF  2FC,FEF
1E42:  MOVFF  2FD,FEC
1E46:  MOVFF  2FE,FEC
1E4A:  MOVFF  2FF,FEC
....................     *protocol           = header.Protocol;
1E4E:  MOVFF  2EB,FEA
1E52:  MOVFF  2EA,FE9
1E56:  MOVFF  2F9,FEF
.................... #if defined(MCHP_MAC)
....................     *len 				= header.TotalLength - IPHeaderLen;
1E5A:  MOVFF  2ED,FEA
1E5E:  MOVFF  2EC,FE9
1E62:  MOVF   5F,W
1E64:  SUBWF  xF2,W
1E66:  MOVWF  00
1E68:  MOVLW  00
1E6A:  SUBWFB xF3,W
1E6C:  MOVFF  00,FEF
1E70:  MOVWF  FEC
.................... #else
....................     *len                = header.TotalLength - optionsLen -
....................                             sizeof(header);
.................... #endif
.................... 
....................     return TRUE;
1E72:  MOVLW  01
1E74:  MOVWF  01
1E76:  MOVLB  0
1E78:  GOTO   6CFA (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function: WORD IPPutHeader(NODE_INFO *remote,
....................  *           				  BYTE protocol,
....................  *                			  WORD len)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           *remote     - Destination node address
....................  *                  protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          (WORD)0
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  ********************************************************************/
.................... WORD IPPutHeader(NODE_INFO *remote,
....................                 BYTE protocol,
....................                 WORD    len)
.................... {
....................     IP_HEADER   header;
.................... 
....................     IPHeaderLen = sizeof(IP_HEADER);
*
2806:  MOVLW  14
2808:  MOVWF  5F
.................... 
....................     header.VersionIHL       = IP_VERSION | IP_IHL;
280A:  MOVLW  45
280C:  MOVLB  3
280E:  MOVWF  x74
....................     header.TypeOfService    = IP_SERVICE;
2810:  CLRF   x75
....................     header.TotalLength      = sizeof(header) + len;
2812:  MOVLW  14
2814:  ADDWF  x72,W
2816:  MOVWF  x76
2818:  MOVLW  00
281A:  ADDWFC x73,W
281C:  MOVWF  x77
....................     header.Identification   = ++_Identifier;
281E:  INCF   5D,F
2820:  BTFSC  FD8.2
2822:  INCF   5E,F
2824:  MOVFF  5E,379
2828:  MOVFF  5D,378
....................     header.FragmentInfo     = 0;
282C:  CLRF   x7B
282E:  CLRF   x7A
....................     header.TimeToLive       = MY_IP_TTL;
2830:  MOVLW  64
2832:  MOVWF  x7C
....................     header.Protocol         = protocol;
2834:  MOVFF  371,37D
....................     header.HeaderChecksum   = 0;
2838:  CLRF   x7F
283A:  CLRF   x7E
.................... 	header.SourceAddress = AppConfig.MyIPAddr;
283C:  MOVFF  20,383
2840:  MOVFF  1F,382
2844:  MOVFF  1E,381
2848:  MOVFF  1D,380
.................... 
....................     header.DestAddress.Val = remote->IPAddr.Val;
284C:  MOVLW  06
284E:  ADDWF  x6F,W
2850:  MOVWF  FE9
2852:  MOVLW  00
2854:  ADDWFC x70,W
2856:  MOVWF  FEA
2858:  MOVFF  FEF,384
285C:  MOVFF  FEC,385
2860:  MOVFF  FEC,386
2864:  MOVFF  FEC,387
.................... 
....................     SwapIPHeader(&header);
2868:  MOVLW  03
286A:  MOVWF  x89
286C:  MOVLW  74
286E:  MOVWF  x88
2870:  MOVLB  0
2872:  CALL   1CCE
.................... 
.................... #if !defined(MCHP_MAC)
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header,
....................                                                 sizeof(header));
.................... #endif
.................... 
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len));
2876:  MOVLB  3
2878:  MOVFF  36F,01
287C:  MOVFF  370,03
2880:  MOVFF  01,388
2884:  MOVFF  03,389
2888:  MOVLW  14
288A:  ADDWF  x72,W
288C:  MOVWF  x8A
288E:  MOVLW  00
2890:  ADDWFC x73,W
2892:  MOVWF  x8B
2894:  MOVFF  03,38D
2898:  MOVFF  01,38C
289C:  CLRF   x8E
289E:  MOVWF  x90
28A0:  MOVFF  38A,38F
28A4:  MOVLB  0
28A6:  CALL   164E
....................     MACPutArray((BYTE*)&header, sizeof(header));
28AA:  MOVLW  03
28AC:  MOVLB  3
28AE:  MOVWF  x89
28B0:  MOVLW  74
28B2:  MOVWF  x88
28B4:  MOVFF  389,394
28B8:  MOVWF  x93
28BA:  CLRF   x96
28BC:  MOVLW  14
28BE:  MOVWF  x95
28C0:  MOVLB  0
28C2:  CALL   1608
.................... 
.................... #if defined(MCHP_MAC)
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header));
28C6:  MOVLB  3
28C8:  CLRF   x89
28CA:  CLRF   x88
28CC:  CLRF   x8B
28CE:  MOVLW  14
28D0:  MOVWF  x8A
28D2:  MOVLB  0
28D4:  RCALL  272E
28D6:  MOVFF  02,37F
28DA:  MOVFF  01,37E
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member
28DE:  MOVFF  52,388
28E2:  MOVLB  3
28E4:  CLRF   x8A
28E6:  MOVLW  0A
28E8:  MOVWF  x89
28EA:  MOVLB  0
28EC:  CALL   154C
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2);
28F0:  MOVLW  03
28F2:  MOVLB  3
28F4:  MOVWF  x89
28F6:  MOVLW  7E
28F8:  MOVWF  x88
28FA:  MOVFF  389,394
28FE:  MOVWF  x93
2900:  CLRF   x96
2902:  MOVLW  02
2904:  MOVWF  x95
2906:  MOVLB  0
2908:  CALL   1608
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet
290C:  MOVFF  52,388
2910:  MOVLB  3
2912:  CLRF   x8A
2914:  MOVLW  14
2916:  MOVWF  x89
2918:  MOVLB  0
291A:  CALL   154C
.................... #endif
.................... 
....................     return 0x0;
291E:  MOVLW  00
2920:  MOVWF  01
2922:  MOVWF  02
2924:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset)
.................... {
.................... 	MACSetRxBuffer(Offset+IPHeaderLen);
*
20EE:  MOVF   5F,W
20F0:  MOVLB  3
20F2:  ADDWF  x13,W
20F4:  MOVWF  x15
20F6:  MOVLW  00
20F8:  ADDWFC x14,W
20FA:  MOVWF  x16
20FC:  MOVWF  x18
20FE:  MOVFF  315,317
2102:  MOVLB  0
2104:  RCALL  1C52
2106:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... static void SwapIPHeader(IP_HEADER* h)
.................... {
....................     h->TotalLength      = swaps(h->TotalLength);
*
1CCE:  MOVLW  02
1CD0:  MOVLB  3
1CD2:  ADDWF  x88,W
1CD4:  MOVWF  01
1CD6:  MOVLW  00
1CD8:  ADDWFC x89,W
1CDA:  MOVWF  03
1CDC:  MOVFF  01,38A
1CE0:  MOVWF  x8B
1CE2:  MOVLW  02
1CE4:  ADDWF  x88,W
1CE6:  MOVWF  FE9
1CE8:  MOVLW  00
1CEA:  ADDWFC x89,W
1CEC:  MOVWF  FEA
1CEE:  MOVFF  FEC,38F
1CF2:  MOVF   FED,F
1CF4:  MOVFF  FEF,38E
1CF8:  MOVLB  0
1CFA:  CALL   122C
1CFE:  MOVFF  38B,FEA
1D02:  MOVFF  38A,FE9
1D06:  MOVFF  02,FEC
1D0A:  MOVF   FED,F
1D0C:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification);
1D10:  MOVLW  04
1D12:  MOVLB  3
1D14:  ADDWF  x88,W
1D16:  MOVWF  01
1D18:  MOVLW  00
1D1A:  ADDWFC x89,W
1D1C:  MOVWF  03
1D1E:  MOVFF  01,38A
1D22:  MOVWF  x8B
1D24:  MOVLW  04
1D26:  ADDWF  x88,W
1D28:  MOVWF  FE9
1D2A:  MOVLW  00
1D2C:  ADDWFC x89,W
1D2E:  MOVWF  FEA
1D30:  MOVFF  FEC,38F
1D34:  MOVF   FED,F
1D36:  MOVFF  FEF,38E
1D3A:  MOVLB  0
1D3C:  CALL   122C
1D40:  MOVFF  38B,FEA
1D44:  MOVFF  38A,FE9
1D48:  MOVFF  02,FEC
1D4C:  MOVF   FED,F
1D4E:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum);
1D52:  MOVLW  0A
1D54:  MOVLB  3
1D56:  ADDWF  x88,W
1D58:  MOVWF  01
1D5A:  MOVLW  00
1D5C:  ADDWFC x89,W
1D5E:  MOVWF  03
1D60:  MOVFF  01,38A
1D64:  MOVWF  x8B
1D66:  MOVLW  0A
1D68:  ADDWF  x88,W
1D6A:  MOVWF  FE9
1D6C:  MOVLW  00
1D6E:  ADDWFC x89,W
1D70:  MOVWF  FEA
1D72:  MOVFF  FEC,38F
1D76:  MOVF   FED,F
1D78:  MOVFF  FEF,38E
1D7C:  MOVLB  0
1D7E:  CALL   122C
1D82:  MOVFF  38B,FEA
1D86:  MOVFF  38A,FE9
1D8A:  MOVFF  02,FEC
1D8E:  MOVF   FED,F
1D90:  MOVFF  01,FEF
1D94:  RETURN 0
.................... }
.................... 
.................... 
.................... #if STACK_USE_TCP
....................    #include "tcpip/tcp.c"
.................... /*********************************************************************
....................  *
....................  *                  TCP Module for Microchip TCP/IP Stack
....................  *               Based on RFC 793
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
.................... * FileName:        TCP.C
.................... * Dependencies:    string.h
.................... *                  StackTsk.h
.................... *                  Helpers.h
.................... *                  IP.h
.................... *                  MAC.h
.................... *                  ARP.h
.................... *                  Tick.h
.................... *                  TCP.h
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F
.................... * Complier:        CCS PCH
.................... * Company:         Microchip Technology, Inc.
.................... *
.................... * Software License Agreement
.................... *
.................... * This software is owned by Microchip Technology Inc. ("Microchip")
.................... * and is supplied to you for use exclusively as described in the
.................... * associated software agreement.  This software is protected by
.................... * software and other intellectual property laws.  Any use in
.................... * violation of the software license may subject the user to criminal
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip
.................... * Technology Inc.  All rights reserved.
.................... *
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special,
.................... * incidental, or consequential damages.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug.
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above)
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode.
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case)
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess()
....................  *                              to include localIP as third param.
....................  *                              This was done to allow this function
....................  *                              to calculate checksum correctly.
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix.
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected
....................  *                         discard problem identified by Richard
....................  *                         Shelquist.
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug
....................  *                        when using a Microchip Ethernet controller)
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable()
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check
....................  *                        reported by DouglasPunch on Microchip Forum.
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX
....................  *                        Buffers to be obtained but not
....................  *                        released when many web requests were
....................  *                        received concurrently.
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tcp.h"
.................... /*********************************************************************
....................  *
....................  *                  TCP Module Defs for Microchip TCP/IP Stack
....................  *
....................  *********************************************************************
....................  * FileName:        TCP.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F
....................  * Complier:        CCS PCH
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype.
....................  *                              See TCP.c for more information.
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef TCP_H
.................... #define TCP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef BYTE TCP_SOCKET;
.................... typedef WORD TCP_PORT;
.................... 
.................... #ifndef TCP_NO_WAIT_FOR_ACK
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE
.................... #endif
.................... 
.................... /*
....................  * Maximum number of times a connection be retried before
....................  * closing it down.
....................  */
.................... #define MAX_RETRY_COUNTS    (3)
.................... 
.................... #define INVALID_SOCKET      (0xfe)
.................... #define UNKNOWN_SOCKET      (0xff)
.................... 
.................... #define REMOTE_HOST(s)      (TCB[s].remote)
.................... 
.................... /*
....................  * TCP States as defined by rfc793
....................  */
.................... typedef enum _TCP_STATE
.................... {
....................     TCP_LISTEN = 0,
....................     TCP_SYN_SENT,
....................     TCP_SYN_RECEIVED,
....................     TCP_ESTABLISHED,
....................     TCP_FIN_WAIT_1,
....................     TCP_FIN_WAIT_2,
....................     TCP_CLOSING,
....................     TCP_TIME_WAIT,
.................... 	TCP_CLOSE_WAIT,
....................     TCP_LAST_ACK,
....................     TCP_CLOSED,
.................... } TCP_STATE;
.................... 
.................... /*
....................  * Socket info.
....................  * Union is used to create anonymous structure members.
....................  */
.................... typedef struct _SOCKET_INFO
.................... {
....................     TCP_STATE smState;
.................... 
....................     NODE_INFO remote;
....................     TCP_PORT localPort;
....................     TCP_PORT remotePort;
.................... 
....................     BUFFER TxBuffer;
....................     WORD TxCount;
....................     WORD RxCount;
.................... 	WORD RemoteWindow;
.................... 	
....................     DWORD SND_SEQ;
....................     DWORD SND_ACK;
.................... 
....................     BYTE RetryCount;
....................     TICKTYPE startTick;
....................     TICKTYPE TimeOut;
.................... 
....................     struct
....................     {
....................         int1 bServer        : 1;
....................         int1 bIsPutReady    : 1;
....................         int1 bFirstRead     : 1;
....................         int1 bIsGetReady    : 1;
....................         int1 bIsTxInProgress : 1;
....................         int1 bACKValid : 1;
....................     } Flags;
.................... 
.................... } SOCKET_INFO;
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TCP is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initialize all socket info.
....................  *
....................  * Note:            This function is called only one during lifetime
....................  *                  of the application.
....................  ********************************************************************/
.................... void        TCPInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           port    - A TCP port to be opened.
....................  *
....................  * Output:          Given port is opened and returned on success
....................  *                  INVALID_SOCKET if no more sockets left.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TCP_SOCKET  TCPListen(TCP_PORT port);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote,
....................  *                                      TCP_PORT remotePort)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           remote      - Remote node address info
....................  *                  remotePort  - remote port to be connected.
....................  *
....................  * Output:          A new socket is created, connection request is
....................  *                  sent and socket handle is returned.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket to be checked for connection.
....................  *
....................  * Output:          TRUE    if given socket is connected
....................  *                  FALSE   if given socket is not connected.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            A socket is said to be connected if it is not
....................  *                  in LISTEN and CLOSED mode.  Socket may be in
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket
....................  *                  data.
....................  ********************************************************************/
.................... BOOL        TCPIsConnected(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPDisconnect(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsPutReady(s) == TRUE
....................  *
....................  * Input:           s       - Socket to be disconnected.
....................  *
....................  * Output:          A disconnect request is sent for given socket.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void        TCPDisconnect(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' is free to transmit
....................  *                  FALSE if socket 's' is not free to transmit.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Each socket maintains only transmit buffer.
....................  *                  Hence until a data packet is acknowledeged by
....................  *                  remote node, socket will not be ready for
....................  *                  next transmission.
....................  *                  All control transmission such as Connect,
....................  *                  Disconnect do not consume/reserve any transmit
....................  *                  buffer.
....................  ********************************************************************/
.................... BOOL        TCPIsPutReady(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s       - socket to use
....................  *                  byte    - a data byte to send
....................  *
....................  * Output:          TRUE if given byte was put in transmit buffer
....................  *                  FALSE if transmit buffer is full.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket whose data is to be transmitted.
....................  *
....................  * Output:          All and any data associated with this socket
....................  *                  is marked as ready for transmission.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPFlush(TCP_SOCKET socket);
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' contains any data.
....................  *                  FALSE if socket 's' does not contain any data.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPIsGetReady(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  byte    - Pointer to a byte.
....................  *
....................  * Output:          TRUE if a byte was read.
....................  *                  FALSE if byte was not read.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer,
....................  *                                      WORD count)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  buffer  - Buffer to hold received data.
....................  *                  count   - Buffer length
....................  *
....................  * Output:          Number of bytes loaded into buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket
....................  *
....................  * Output:          TRUE if socket received data was discarded
....................  *                  FALSE if socket received data was already
....................  *                          discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPDiscard(TCP_SOCKET socket);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote,
....................  *                                  IP_ADDR *localIP,
....................  *                                  WORD len)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCP segment is ready in MAC buffer
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  len         - Total length of TCP semgent.
....................  *
....................  * Output:          TRUE if this function has completed its task
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPProcess(NODE_INFO *remote,
....................                        IP_ADDR *localIP,
....................                        WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPTick(void)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Each socket FSM is executed for any timeout
....................  *                  situation.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void        TCPTick(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u)
.................... //#define debug_tcp debug_printf
.................... 
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) -
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER)
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54)
.................... 
.................... // TCP Timeout value to begin with.
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3)
.................... 
.................... // TCP Flags defined in RFC
.................... #define FIN     (0x01)
.................... #define SYN     (0x02)
.................... #define RST     (0x04)
.................... #define PSH     (0x08)
.................... #define ACK     (0x10)
.................... #define URG     (0x20)
.................... 
.................... 
.................... // TCP Header
.................... typedef struct _TCP_HEADER
.................... {
....................     WORD    SourcePort;
....................     WORD    DestPort;
....................     DWORD   SeqNumber;
....................     DWORD   AckNumber;
.................... 
....................     struct
....................     {
....................        BYTE Reserved3:4;
....................        BYTE Val:4;
....................     } DataOffset;
.................... 
.................... 
....................     union
....................     {
....................         struct
....................         {
....................              int1 flagFIN    : 1;
....................              int1 flagSYN    : 1;
....................              int1 flagRST    : 1;
....................              int1 flagPSH    : 1;
....................              int1 flagACK    : 1;
....................              int1 flagURG    : 1;
....................              int1 Reserved2  : 2;
....................         } bits;
....................         BYTE b;
....................     } Flags;
.................... 
....................     WORD    Window;
....................     WORD    Checksum;
....................     WORD    UrgentPointer;
.................... } TCP_HEADER;
.................... 
.................... 
.................... // TCP Options as defined by RFC
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00)
.................... #define TCP_OPTIONS_NO_OP           (0x01)
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02)
.................... typedef struct _TCP_OPTIONS
.................... {
....................     BYTE        Kind;
....................     BYTE        Length;
....................     WORD_VAL    MaxSegSize;
.................... } TCP_OPTIONS;
.................... 
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength))
.................... 
.................... // IP pseudo header as defined by RFC 793
.................... typedef struct _PSEUDO_HEADER
.................... {
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
....................     BYTE Zero;
....................     BYTE Protocol;
....................     WORD TCPLength;
.................... } PSEUDO_HEADER;
.................... 
.................... #define LOCAL_PORT_START_NUMBER (1024)
.................... #define LOCAL_PORT_END_NUMBER   (5000)
.................... 
.................... // Local temp port numbers.
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER;
.................... 
.................... // The TCB array is very large.  With the C18 compiler, one must
.................... // modify the linker script to make an array that spans more than
.................... // one memory bank.  To do this, make the necessary changes to your
.................... // processor's linker script (.lkr).  Here is an example showing
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte
.................... // block used exclusively by the TCB_MEM data section:
.................... // ...
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF
.................... // ...
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b
.................... // ...
.................... //#pragma udata TCB_MEM   //not needed in ccs
.................... SOCKET_INFO TCB[MAX_SOCKETS];
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs
.................... 
.................... static void    HandleTCPSeg(TCP_SOCKET s,
....................                                NODE_INFO *remote,
....................                                TCP_HEADER *h,
....................                                WORD len);
.................... 
.................... static void TransmitTCP(NODE_INFO *remote,
....................                         TCP_PORT localPort,
....................                         TCP_PORT remotePort,
....................                         DWORD tseq,
....................                         DWORD tack,
....................                         BYTE flags,
....................                         BUFFER buff,
....................                         WORD len);
.................... 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h,
....................                                     NODE_INFO *remote);
.................... static void    SwapTCPHeader(TCP_HEADER* header);
.................... static void CloseSocket(SOCKET_INFO* ps);
.................... 
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \
....................                     INVALID_BUFFER, 0)
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPInit(void)
.................... *
.................... * PreCondition:    None
.................... *
.................... * Input:           None
.................... *
.................... * Output:          TCP is initialized.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        Initialize all socket states
.................... *
.................... * Note:            This function is called only once during lifetime
.................... *                  of the application.
.................... ********************************************************************/
.................... int16 TCPInit_RandSeed;
.................... void TCPInit(void)
.................... {
....................     TCP_SOCKET s;
....................     SOCKET_INFO* ps;
.................... 
.................... 
....................     // Initialize all sockets.
....................     for ( s = 0; s < MAX_SOCKETS; s++ )
*
0DDA:  MOVLB  2
0DDC:  CLRF   xE0
0DDE:  MOVF   xE0,W
0DE0:  SUBLW  04
0DE2:  BNC   0EB0
....................     {
....................         ps = &TCB[s];
0DE4:  MOVF   xE0,W
0DE6:  MULLW  24
0DE8:  MOVF   FF3,W
0DEA:  CLRF   03
0DEC:  ADDLW  88
0DEE:  MOVWF  01
0DF0:  MOVLW  00
0DF2:  ADDWFC 03,F
0DF4:  MOVFF  01,2E1
0DF8:  MOVFF  03,2E2
.................... 
....................         ps->smState             = TCP_CLOSED;
0DFC:  MOVFF  2E1,FE9
0E00:  MOVFF  2E2,FEA
0E04:  MOVLW  0A
0E06:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE;
0E08:  MOVLW  23
0E0A:  ADDWF  xE1,W
0E0C:  MOVWF  FE9
0E0E:  MOVLW  00
0E10:  ADDWFC xE2,W
0E12:  MOVWF  FEA
0E14:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE;
0E16:  MOVLW  23
0E18:  ADDWF  xE1,W
0E1A:  MOVWF  FE9
0E1C:  MOVLW  00
0E1E:  ADDWFC xE2,W
0E20:  MOVWF  FEA
0E22:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE;
0E24:  MOVLW  23
0E26:  ADDWF  xE1,W
0E28:  MOVWF  FE9
0E2A:  MOVLW  00
0E2C:  ADDWFC xE2,W
0E2E:  MOVWF  FEA
0E30:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE;
0E32:  MOVLW  23
0E34:  ADDWF  xE1,W
0E36:  MOVWF  FE9
0E38:  MOVLW  00
0E3A:  ADDWFC xE2,W
0E3C:  MOVWF  FEA
0E3E:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE;
0E40:  MOVLW  23
0E42:  ADDWF  xE1,W
0E44:  MOVWF  FE9
0E46:  MOVLW  00
0E48:  ADDWFC xE2,W
0E4A:  MOVWF  FEA
0E4C:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER)
0E4E:  MOVLW  0F
0E50:  ADDWF  xE1,W
0E52:  MOVWF  FE9
0E54:  MOVLW  00
0E56:  ADDWFC xE2,W
0E58:  MOVWF  FEA
0E5A:  INCFSZ FEF,W
0E5C:  BRA    0E60
0E5E:  BRA    0E86
....................       {
....................          MACDiscardTx(ps->TxBuffer);
0E60:  MOVLW  0F
0E62:  ADDWF  xE1,W
0E64:  MOVWF  FE9
0E66:  MOVLW  00
0E68:  ADDWFC xE2,W
0E6A:  MOVWF  FEA
0E6C:  MOVFF  FEF,333
0E70:  MOVLB  0
0E72:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER;
0E76:  MOVLW  0F
0E78:  MOVLB  2
0E7A:  ADDWF  xE1,W
0E7C:  MOVWF  FE9
0E7E:  MOVLW  00
0E80:  ADDWFC xE2,W
0E82:  MOVWF  FEA
0E84:  SETF   FEF
....................       }
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL;
0E86:  MOVLW  21
0E88:  ADDWF  xE1,W
0E8A:  MOVWF  FE9
0E8C:  MOVLW  00
0E8E:  ADDWFC xE2,W
0E90:  MOVWF  FEA
0E92:  CLRF   FEC
0E94:  MOVF   FED,F
0E96:  MOVLW  1E
0E98:  MOVWF  FEF
....................       ps->TxCount            = 0;
0E9A:  MOVLW  10
0E9C:  ADDWF  xE1,W
0E9E:  MOVWF  FE9
0EA0:  MOVLW  00
0EA2:  ADDWFC xE2,W
0EA4:  MOVWF  FEA
0EA6:  CLRF   FEC
0EA8:  MOVF   FED,F
0EAA:  CLRF   FEF
....................    }
.................... 
....................     //_NextPort = LOCAL_PORT_START_NUMBER;
....................     #if getenv("TIMER0")
0EAC:  INCF   xE0,F
0EAE:  BRA    0DDE
....................     TCPInit_RandSeed+=get_timer0();
0EB0:  MOVF   FD6,W
0EB2:  MOVLB  0
0EB4:  ADDWF  x62,F
0EB6:  MOVF   FD7,W
0EB8:  ADDWFC x63,F
....................     #endif
....................     #if getenv("TIMER1")
....................      TCPInit_RandSeed+=get_timer1();
0EBA:  MOVF   FCE,W
0EBC:  ADDWF  x62,F
0EBE:  MOVF   FCF,W
0EC0:  ADDWFC x63,F
....................     #endif
....................     #if getenv("TIMER2")
....................      TCPInit_RandSeed+=get_timer2();
0EC2:  MOVF   FCC,W
0EC4:  ADDWF  x62,F
0EC6:  MOVLW  00
0EC8:  ADDWFC x63,F
....................     #endif
....................     #if getenv("TIMER3")
....................      TCPInit_RandSeed+=get_timer3();
0ECA:  MOVF   FB2,W
0ECC:  ADDWF  x62,F
0ECE:  MOVF   FB3,W
0ED0:  ADDWFC x63,F
....................     #endif
....................     #if getenv("TIMER4")
....................      TCPInit_RandSeed+=get_timer4();
....................     #endif
....................     #if getenv("TIMER5")
....................      TCPInit_RandSeed+=get_timer5();
....................     #endif
....................     srand(TCPInit_RandSeed);
0ED2:  MOVLB  2
0ED4:  CLRF   xE6
0ED6:  CLRF   xE5
0ED8:  MOVFF  63,2E4
0EDC:  MOVFF  62,2E3
0EE0:  MOVLB  0
0EE2:  BRA    0CB0
....................     _NextPort=rand();
0EE4:  BRA    0D68
0EE6:  MOVFF  02,61
0EEA:  MOVFF  01,60
....................     _NextPort+=LOCAL_PORT_START_NUMBER;
0EEE:  MOVLW  04
0EF0:  ADDWF  x61,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;}
0EF2:  MOVF   x61,W
0EF4:  SUBLW  12
0EF6:  BC    0F0C
0EF8:  XORLW  FF
0EFA:  BNZ   0F02
0EFC:  MOVF   x60,W
0EFE:  SUBLW  87
0F00:  BC    0F0C
0F02:  MOVLW  88
0F04:  SUBWF  x60,F
0F06:  MOVLW  13
0F08:  SUBWFB x61,F
0F0A:  BRA    0EF2
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;}
0F0C:  MOVF   x61,W
0F0E:  SUBLW  03
0F10:  BNC   0F16
0F12:  MOVLW  04
0F14:  ADDWF  x61,F
0F16:  GOTO   1080 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           port    - A TCP port to be opened.
.................... *
.................... * Output:          Given port is opened and returned on success
.................... *                  INVALID_SOCKET if no more sockets left.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... TCP_SOCKET TCPListen(TCP_PORT port)
.................... {
....................    TCP_SOCKET s;
....................    SOCKET_INFO* ps;
.................... 
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port);
.................... 
....................    for(s = 0; s < MAX_SOCKETS; s++)
0F1A:  MOVLB  2
0F1C:  CLRF   xE5
0F1E:  MOVF   xE5,W
0F20:  SUBLW  04
0F22:  BNC   0FFC
....................    {
....................       ps = &TCB[s];
0F24:  MOVF   xE5,W
0F26:  MULLW  24
0F28:  MOVF   FF3,W
0F2A:  CLRF   03
0F2C:  ADDLW  88
0F2E:  MOVWF  01
0F30:  MOVLW  00
0F32:  ADDWFC 03,F
0F34:  MOVFF  01,2E6
0F38:  MOVFF  03,2E7
.................... 
....................       if(ps->smState == TCP_CLOSED)
0F3C:  MOVFF  2E6,FE9
0F40:  MOVFF  2E7,FEA
0F44:  MOVF   FEF,W
0F46:  SUBLW  0A
0F48:  BNZ   0FF8
....................       {
....................          // We have a CLOSED socket.
....................          // Initialize it with LISTENing state info.
....................          ps->smState             = TCP_LISTEN;
0F4A:  MOVFF  2E6,FE9
0F4E:  MOVFF  2E7,FEA
0F52:  CLRF   FEF
....................          ps->localPort           = port;
0F54:  MOVLW  0B
0F56:  ADDWF  xE6,W
0F58:  MOVWF  FE9
0F5A:  MOVLW  00
0F5C:  ADDWFC xE7,W
0F5E:  MOVWF  FEA
0F60:  MOVFF  2E4,FEC
0F64:  MOVF   FED,F
0F66:  MOVFF  2E3,FEF
....................          ps->remotePort          = 0;
0F6A:  MOVLW  0D
0F6C:  ADDWF  xE6,W
0F6E:  MOVWF  FE9
0F70:  MOVLW  00
0F72:  ADDWFC xE7,W
0F74:  MOVWF  FEA
0F76:  CLRF   FEC
0F78:  MOVF   FED,F
0F7A:  CLRF   FEF
.................... 
....................          // There is no remote node IP address info yet.
....................          ps->remote.IPAddr.Val   = 0x00;
0F7C:  MOVLW  07
0F7E:  ADDWF  xE6,W
0F80:  MOVWF  FE9
0F82:  MOVLW  00
0F84:  ADDWFC xE7,W
0F86:  MOVWF  FEA
0F88:  CLRF   FEF
0F8A:  CLRF   FEC
0F8C:  CLRF   FEC
0F8E:  CLRF   FEC
.................... 
....................          // If a socket is listened on, it is a SERVER.
....................          ps->Flags.bServer       = TRUE;
0F90:  MOVLW  23
0F92:  ADDWF  xE6,W
0F94:  MOVWF  FE9
0F96:  MOVLW  00
0F98:  ADDWFC xE7,W
0F9A:  MOVWF  FEA
0F9C:  BSF    FEF.0
.................... 
....................          ps->Flags.bIsGetReady   = FALSE;
0F9E:  MOVLW  23
0FA0:  ADDWF  xE6,W
0FA2:  MOVWF  FE9
0FA4:  MOVLW  00
0FA6:  ADDWFC xE7,W
0FA8:  MOVWF  FEA
0FAA:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER)
0FAC:  MOVLW  0F
0FAE:  ADDWF  xE6,W
0FB0:  MOVWF  FE9
0FB2:  MOVLW  00
0FB4:  ADDWFC xE7,W
0FB6:  MOVWF  FEA
0FB8:  INCFSZ FEF,W
0FBA:  BRA    0FBE
0FBC:  BRA    0FE4
....................          {
....................             MACDiscardTx(ps->TxBuffer);
0FBE:  MOVLW  0F
0FC0:  ADDWF  xE6,W
0FC2:  MOVWF  FE9
0FC4:  MOVLW  00
0FC6:  ADDWFC xE7,W
0FC8:  MOVWF  FEA
0FCA:  MOVFF  FEF,333
0FCE:  MOVLB  0
0FD0:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER;
0FD4:  MOVLW  0F
0FD6:  MOVLB  2
0FD8:  ADDWF  xE6,W
0FDA:  MOVWF  FE9
0FDC:  MOVLW  00
0FDE:  ADDWFC xE7,W
0FE0:  MOVWF  FEA
0FE2:  SETF   FEF
....................          }
....................          ps->Flags.bIsPutReady   = TRUE;
0FE4:  MOVLW  23
0FE6:  ADDWF  xE6,W
0FE8:  MOVWF  FE9
0FEA:  MOVLW  00
0FEC:  ADDWFC xE7,W
0FEE:  MOVWF  FEA
0FF0:  BSF    FEF.1
.................... 
....................          debug_tcp("SOCK=%U", s);
.................... 
....................          return s;
0FF2:  MOVFF  2E5,01
0FF6:  BRA    1000
....................       }
0FF8:  INCF   xE5,F
0FFA:  BRA    0F1E
....................    }
.................... 
....................    debug_tcp("FAIL");
.................... 
....................    return INVALID_SOCKET;
0FFC:  MOVLW  FE
0FFE:  MOVWF  01
1000:  MOVLB  0
1002:  GOTO   102C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote,
.................... *                                      TCP_PORT remotePort)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           remote      - Remote node address info
.................... *                  remotePort  - remote port to be connected.
.................... *
.................... * Output:          A new socket is created, connection request is
.................... *                  sent and socket handle is returned.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... ********************************************************************/
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort)
.................... {
....................    TCP_SOCKET s;
....................    SOCKET_INFO* ps;
....................    BOOL lbFound;
.................... 
.................... 
....................    lbFound = FALSE;
.................... 
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort);
.................... 
....................    // Find an available socket
....................    for(s = 0; s < MAX_SOCKETS; s++)
....................    {
....................       ps = &TCB[s];
....................       if(ps->smState == TCP_CLOSED)
....................       {
....................          lbFound = TRUE;
....................          break;
....................       }
....................    }
.................... 
....................    // If there is no socket available, return error.
....................    if(!lbFound)
....................       return INVALID_SOCKET;
.................... 
....................    // Each new socket that is opened by this node, gets
....................    // next sequential port number.
....................    ps->localPort = ++_NextPort;
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER)
....................       _NextPort = LOCAL_PORT_START_NUMBER-1;
.................... 
....................    // This is a client socket.
....................    ps->Flags.bServer = FALSE;
.................... 
....................    // This is the port, we are trying to connect to.
....................    ps->remotePort = remotePort;
.................... 
....................    // Each new socket that is opened by this node, will
....................    // start with next the next seqeuence number (essentially random)
....................    ps->SND_SEQ++;
....................    ps->SND_ACK = 0;
.................... 
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote));
.................... 
....................    // Send SYN message.
....................    SendTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       SYN);
.................... 
....................    ps->smState = TCP_SYN_SENT;
....................    ps->SND_SEQ++;
.................... 
....................    // Allow TCPTick() to operate properly
....................    ps->startTick = TickGet();
.................... 
....................    debug_tcp("SOCK=%U", s);
.................... 
....................    return s;
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket to be checked for connection.
....................  *
....................  * Output:          TRUE    if given socket is connected
....................  *                  FALSE   if given socket is not connected.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            A socket is said to be connected if it is not
....................  *                  in LISTEN and CLOSED mode.  Socket may be in
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket
....................  *                  data.
....................  ********************************************************************/
.................... BOOL TCPIsConnected(TCP_SOCKET s)
.................... {
....................     return ( TCB[s].smState == TCP_ESTABLISHED );
*
3E12:  MOVLB  2
3E14:  MOVF   xEE,W
3E16:  MULLW  24
3E18:  MOVF   FF3,W
3E1A:  CLRF   xF0
3E1C:  MOVWF  xEF
3E1E:  MOVLW  88
3E20:  ADDWF  xEF,W
3E22:  MOVWF  FE9
3E24:  MOVLW  00
3E26:  ADDWFC xF0,W
3E28:  MOVWF  FEA
3E2A:  MOVF   FEF,W
3E2C:  SUBLW  03
3E2E:  BZ    3E34
3E30:  MOVLW  00
3E32:  BRA    3E36
3E34:  MOVLW  01
3E36:  MOVWF  01
3E38:  MOVLB  0
3E3A:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPDisconnect(TCP_SOCKET s)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPIsPutReady(s) == TRUE
.................... *
.................... * Input:           s       - Socket to be disconnected.
.................... *
.................... * Output:          A disconnect request is sent for given socket.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... void TCPDisconnect(TCP_SOCKET s)
.................... {
....................    SOCKET_INFO *ps;
.................... 
....................    ps = &TCB[s];
*
5EFA:  MOVLB  2
5EFC:  MOVF   xEE,W
5EFE:  MULLW  24
5F00:  MOVF   FF3,W
5F02:  CLRF   03
5F04:  ADDLW  88
5F06:  MOVWF  01
5F08:  MOVLW  00
5F0A:  ADDWFC 03,F
5F0C:  MOVFF  01,2EF
5F10:  MOVFF  03,2F0
.................... 
....................    // If socket is not connected, may be it is already closed
....................    // or in the process of closing.  Since we have called this
....................    // explicitly, close it forcefully.
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED)
5F14:  MOVFF  2EF,FE9
5F18:  MOVFF  2F0,FEA
5F1C:  MOVF   FEF,W
5F1E:  SUBLW  03
5F20:  BZ    5F42
5F22:  MOVFF  2EF,FE9
5F26:  MOVFF  2F0,FEA
5F2A:  MOVF   FEF,W
5F2C:  SUBLW  02
5F2E:  BZ    5F42
....................    {
....................       CloseSocket(ps);
5F30:  MOVFF  2F0,331
5F34:  MOVFF  2EF,330
5F38:  MOVLB  0
5F3A:  CALL   24FA
....................       return;
5F3E:  BRA    6004
5F40:  MOVLB  2
....................    }
.................... 
....................    // Discard any outstanding data that is to be read.
....................    TCPDiscard(s);
5F42:  MOVFF  2EE,2F1
5F46:  MOVLB  0
5F48:  CALL   4F96
.................... 
....................    // Send FIN message.
....................    SendTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       FIN | ACK);
5F4C:  MOVLW  01
5F4E:  MOVLB  2
5F50:  ADDWF  xEF,W
5F52:  MOVWF  01
5F54:  MOVLW  00
5F56:  ADDWFC xF0,W
5F58:  MOVWF  03
5F5A:  MOVFF  01,2F1
5F5E:  MOVWF  xF2
5F60:  MOVLW  0B
5F62:  ADDWF  xEF,W
5F64:  MOVWF  FE9
5F66:  MOVLW  00
5F68:  ADDWFC xF0,W
5F6A:  MOVWF  FEA
5F6C:  MOVFF  FEC,33A
5F70:  MOVF   FED,F
5F72:  MOVFF  FEF,339
5F76:  MOVLW  0D
5F78:  ADDWF  xEF,W
5F7A:  MOVWF  FE9
5F7C:  MOVLW  00
5F7E:  ADDWFC xF0,W
5F80:  MOVWF  FEA
5F82:  MOVFF  FEC,33C
5F86:  MOVF   FED,F
5F88:  MOVFF  FEF,33B
5F8C:  MOVLW  16
5F8E:  ADDWF  xEF,W
5F90:  MOVWF  FE9
5F92:  MOVLW  00
5F94:  ADDWFC xF0,W
5F96:  MOVWF  FEA
5F98:  MOVFF  FEF,33D
5F9C:  MOVFF  FEC,33E
5FA0:  MOVFF  FEC,33F
5FA4:  MOVFF  FEC,340
5FA8:  MOVLW  1A
5FAA:  ADDWF  xEF,W
5FAC:  MOVWF  FE9
5FAE:  MOVLW  00
5FB0:  ADDWFC xF0,W
5FB2:  MOVWF  FEA
5FB4:  MOVFF  FEF,341
5FB8:  MOVFF  FEC,342
5FBC:  MOVFF  FEC,343
5FC0:  MOVFF  FEC,344
5FC4:  MOVFF  03,338
5FC8:  MOVFF  01,337
5FCC:  MOVLW  11
5FCE:  MOVLB  3
5FD0:  MOVWF  x45
5FD2:  SETF   x46
5FD4:  CLRF   x48
5FD6:  CLRF   x47
5FD8:  MOVLB  0
5FDA:  CALL   2926
....................    //DebugPrint(".");
.................... 
....................    ps->SND_SEQ++;
5FDE:  MOVLW  16
5FE0:  MOVLB  2
5FE2:  ADDWF  xEF,W
5FE4:  MOVWF  FE9
5FE6:  MOVLW  00
5FE8:  ADDWFC xF0,W
5FEA:  MOVWF  FEA
5FEC:  MOVLW  01
5FEE:  ADDWF  FEE,F
5FF0:  MOVLW  00
5FF2:  ADDWFC FEE,F
5FF4:  ADDWFC FEE,F
5FF6:  ADDWFC FED,F
.................... 
....................    ps->smState = TCP_FIN_WAIT_1;
5FF8:  MOVFF  2EF,FE9
5FFC:  MOVFF  2F0,FEA
6000:  MOVLW  04
6002:  MOVWF  FEF
6004:  MOVLB  0
.................... 
....................    return;
6006:  GOTO   6C32 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           s       - Socket whose data is to be transmitted.
.................... *
.................... * Output:          All and any data associated with this socket
.................... *                  is marked as ready for transmission.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... BOOL TCPFlush(TCP_SOCKET s)
.................... {
....................    SOCKET_INFO *ps;
.................... 
....................    ps = &TCB[s];
*
5088:  MOVLB  3
508A:  MOVF   x23,W
508C:  MULLW  24
508E:  MOVF   FF3,W
5090:  CLRF   03
5092:  ADDLW  88
5094:  MOVWF  01
5096:  MOVLW  00
5098:  ADDWFC 03,F
509A:  MOVFF  01,324
509E:  MOVFF  03,325
.................... 
....................    // Make sure that there is TxBuffer assigned to this socket.
....................    if ( ps->TxBuffer == INVALID_BUFFER )
50A2:  MOVLW  0F
50A4:  ADDWF  x24,W
50A6:  MOVWF  FE9
50A8:  MOVLW  00
50AA:  ADDWFC x25,W
50AC:  MOVWF  FEA
50AE:  INCFSZ FEF,W
50B0:  BRA    50B8
....................       return FALSE;
50B2:  MOVLW  00
50B4:  MOVWF  01
50B6:  BRA    5212
.................... 
....................    if ( ps->Flags.bIsPutReady == FALSE )
50B8:  MOVLW  23
50BA:  ADDWF  x24,W
50BC:  MOVWF  01
50BE:  MOVLW  00
50C0:  ADDWFC x25,W
50C2:  MOVWF  03
50C4:  MOVFF  01,FE9
50C8:  MOVWF  FEA
50CA:  BTFSC  FEF.1
50CC:  BRA    50D4
....................       return FALSE;
50CE:  MOVLW  00
50D0:  MOVWF  01
50D2:  BRA    5212
.................... 
....................    TransmitTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away
....................       ps->TxBuffer,
....................       ps->TxCount);
50D4:  MOVLW  01
50D6:  ADDWF  x24,W
50D8:  MOVWF  01
50DA:  MOVLW  00
50DC:  ADDWFC x25,W
50DE:  MOVWF  03
50E0:  MOVFF  01,326
50E4:  MOVWF  x27
50E6:  MOVLW  0B
50E8:  ADDWF  x24,W
50EA:  MOVWF  FE9
50EC:  MOVLW  00
50EE:  ADDWFC x25,W
50F0:  MOVWF  FEA
50F2:  MOVFF  FEC,33A
50F6:  MOVF   FED,F
50F8:  MOVFF  FEF,339
50FC:  MOVLW  0D
50FE:  ADDWF  x24,W
5100:  MOVWF  FE9
5102:  MOVLW  00
5104:  ADDWFC x25,W
5106:  MOVWF  FEA
5108:  MOVFF  FEC,33C
510C:  MOVF   FED,F
510E:  MOVFF  FEF,33B
5112:  MOVLW  16
5114:  ADDWF  x24,W
5116:  MOVWF  FE9
5118:  MOVLW  00
511A:  ADDWFC x25,W
511C:  MOVWF  FEA
511E:  MOVFF  FEF,33D
5122:  MOVFF  FEC,33E
5126:  MOVFF  FEC,33F
512A:  MOVFF  FEC,340
512E:  MOVLW  1A
5130:  ADDWF  x24,W
5132:  MOVWF  FE9
5134:  MOVLW  00
5136:  ADDWFC x25,W
5138:  MOVWF  FEA
513A:  MOVFF  FEF,341
513E:  MOVFF  FEC,342
5142:  MOVFF  FEC,343
5146:  MOVFF  FEC,344
514A:  MOVLW  0F
514C:  ADDWF  x24,W
514E:  MOVWF  FE9
5150:  MOVLW  00
5152:  ADDWFC x25,W
5154:  MOVWF  FEA
5156:  MOVFF  FEF,346
515A:  MOVLW  10
515C:  ADDWF  x24,W
515E:  MOVWF  FE9
5160:  MOVLW  00
5162:  ADDWFC x25,W
5164:  MOVWF  FEA
5166:  MOVFF  FEC,348
516A:  MOVF   FED,F
516C:  MOVFF  FEF,347
5170:  MOVFF  03,338
5174:  MOVFF  01,337
5178:  MOVLW  18
517A:  MOVWF  x45
517C:  MOVLB  0
517E:  CALL   2926
.................... 
....................    ps->SND_SEQ += (DWORD)ps->TxCount;
5182:  MOVLW  16
5184:  MOVLB  3
5186:  ADDWF  x24,W
5188:  MOVWF  01
518A:  MOVLW  00
518C:  ADDWFC x25,W
518E:  MOVWF  03
5190:  MOVFF  01,326
5194:  MOVWF  x27
5196:  MOVWF  FEA
5198:  MOVFF  01,FE9
519C:  MOVFF  FEF,328
51A0:  MOVFF  FEC,329
51A4:  MOVFF  FEC,32A
51A8:  MOVFF  FEC,32B
51AC:  MOVLW  10
51AE:  ADDWF  x24,W
51B0:  MOVWF  FE9
51B2:  MOVLW  00
51B4:  ADDWFC x25,W
51B6:  MOVWF  FEA
51B8:  MOVFF  FEC,03
51BC:  MOVF   FED,F
51BE:  MOVFF  FEF,00
51C2:  MOVFF  03,01
51C6:  CLRF   02
51C8:  CLRF   03
51CA:  MOVF   x28,W
51CC:  ADDWF  00,F
51CE:  MOVF   x29,W
51D0:  ADDWFC 01,F
51D2:  MOVF   x2A,W
51D4:  ADDWFC 02,F
51D6:  MOVF   x2B,W
51D8:  ADDWFC 03,F
51DA:  MOVFF  327,FEA
51DE:  MOVFF  326,FE9
51E2:  MOVFF  00,FEF
51E6:  MOVFF  01,FEC
51EA:  MOVFF  02,FEC
51EE:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE;
51F2:  MOVLW  23
51F4:  ADDWF  x24,W
51F6:  MOVWF  FE9
51F8:  MOVLW  00
51FA:  ADDWFC x25,W
51FC:  MOVWF  FEA
51FE:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE;
5200:  MOVLW  23
5202:  ADDWF  x24,W
5204:  MOVWF  FE9
5206:  MOVLW  00
5208:  ADDWFC x25,W
520A:  MOVWF  FEA
520C:  BCF    FEF.4
.................... 
.................... #if TCP_NO_WAIT_FOR_ACK
....................    if(ps->TxBuffer != INVALID_BUFFER)
....................    {
....................       MACDiscardTx(ps->TxBuffer);
....................       ps->TxBuffer        = INVALID_BUFFER;
....................    }
....................    ps->Flags.bIsPutReady       = TRUE;
.................... #endif
.................... 
....................    return TRUE;
520E:  MOVLW  01
5210:  MOVWF  01
5212:  MOVLB  0
5214:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' is free to transmit
....................  *                  FALSE if socket 's' is not free to transmit.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Each socket maintains only transmit buffer.
....................  *                  Hence until a data packet is acknowledeged by
....................  *                  remote node, socket will not be ready for
....................  *                  next transmission.
....................  *                  All control transmission such as Connect,
....................  *                  Disconnect do not consume/reserve any transmit
....................  *                  buffer.
....................  ********************************************************************/
.................... BOOL TCPIsPutReady(TCP_SOCKET s)
.................... {
....................    if(TCB[s].RemoteWindow == 0)
*
4FE4:  MOVLB  3
4FE6:  MOVF   x11,W
4FE8:  MULLW  24
4FEA:  MOVF   FF3,W
4FEC:  CLRF   x13
4FEE:  MOVWF  x12
4FF0:  MOVLW  14
4FF2:  ADDWF  x12,W
4FF4:  MOVWF  01
4FF6:  MOVLW  00
4FF8:  ADDWFC x13,W
4FFA:  MOVWF  03
4FFC:  MOVF   01,W
4FFE:  ADDLW  88
5000:  MOVWF  FE9
5002:  MOVLW  00
5004:  ADDWFC 03,W
5006:  MOVWF  FEA
5008:  MOVFF  FEC,313
500C:  MOVF   FED,F
500E:  MOVFF  FEF,312
5012:  MOVF   x12,F
5014:  BNZ   5020
5016:  MOVF   x13,F
5018:  BNZ   5020
....................       return FALSE;
501A:  MOVLW  00
501C:  MOVWF  01
501E:  BRA    507C
.................... 
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER )
5020:  MOVF   x11,W
5022:  MULLW  24
5024:  MOVF   FF3,W
5026:  CLRF   x13
5028:  MOVWF  x12
502A:  MOVLW  0F
502C:  ADDWF  x12,W
502E:  MOVWF  01
5030:  MOVLW  00
5032:  ADDWFC x13,W
5034:  MOVWF  03
5036:  MOVF   01,W
5038:  ADDLW  88
503A:  MOVWF  FE9
503C:  MOVLW  00
503E:  ADDWFC 03,W
5040:  MOVWF  FEA
5042:  INCFSZ FEF,W
5044:  BRA    5056
....................       return IPIsTxReady(FALSE);
5046:  CLRF   x6F
5048:  MOVLB  0
504A:  CALL   25EE
504E:  MOVF   01,W
5050:  MOVLB  3
5052:  BRA    507C
5054:  BRA    507C
....................    else
....................       return TCB[s].Flags.bIsPutReady;
5056:  MOVF   x11,W
5058:  MULLW  24
505A:  MOVF   FF3,W
505C:  CLRF   x13
505E:  MOVWF  x12
5060:  MOVLW  23
5062:  ADDWF  x12,F
5064:  MOVLW  00
5066:  ADDWFC x13,F
5068:  MOVLW  88
506A:  ADDWF  x12,W
506C:  MOVWF  FE9
506E:  MOVLW  00
5070:  ADDWFC x13,W
5072:  MOVWF  FEA
5074:  MOVLW  00
5076:  BTFSC  FEF.1
5078:  MOVLW  01
507A:  MOVWF  01
507C:  MOVLB  0
507E:  RETURN 0
.................... }
.................... 
.................... 
.................... int16 TCPPutAvailable(TCP_SOCKET s)
.................... {
....................    int16 txCount, txAvail;
.................... 
....................    if (!TCPIsPutReady(s))
*
54AA:  MOVFF  30C,311
54AE:  RCALL  4FE4
54B0:  MOVF   01,F
54B2:  BNZ   54BC
....................       return(0);
54B4:  MOVLW  00
54B6:  MOVWF  01
54B8:  MOVWF  02
54BA:  BRA    55A0
.................... 
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER )
54BC:  MOVLB  3
54BE:  MOVF   x0C,W
54C0:  MULLW  24
54C2:  MOVF   FF3,W
54C4:  CLRF   x12
54C6:  MOVWF  x11
54C8:  MOVLW  0F
54CA:  ADDWF  x11,W
54CC:  MOVWF  01
54CE:  MOVLW  00
54D0:  ADDWFC x12,W
54D2:  MOVWF  03
54D4:  MOVF   01,W
54D6:  ADDLW  88
54D8:  MOVWF  FE9
54DA:  MOVLW  00
54DC:  ADDWFC 03,W
54DE:  MOVWF  FEA
54E0:  INCFSZ FEF,W
54E2:  BRA    54EA
....................       txCount = 0;
54E4:  CLRF   x0E
54E6:  CLRF   x0D
54E8:  BRA    5516
....................    else
....................       txCount = TCB[s].TxCount;
54EA:  MOVF   x0C,W
54EC:  MULLW  24
54EE:  MOVF   FF3,W
54F0:  CLRF   x12
54F2:  MOVWF  x11
54F4:  MOVLW  10
54F6:  ADDWF  x11,W
54F8:  MOVWF  01
54FA:  MOVLW  00
54FC:  ADDWFC x12,W
54FE:  MOVWF  03
5500:  MOVF   01,W
5502:  ADDLW  88
5504:  MOVWF  FE9
5506:  MOVLW  00
5508:  ADDWFC 03,W
550A:  MOVWF  FEA
550C:  MOVFF  FEC,30E
5510:  MOVF   FED,F
5512:  MOVFF  FEF,30D
.................... 
....................    txAvail = MAX_TCP_DATA_LEN - txCount;
5516:  MOVLW  CA
5518:  BSF    FD8.0
551A:  SUBFWB x0D,W
551C:  MOVWF  x0F
551E:  MOVLW  03
5520:  SUBFWB x0E,W
5522:  MOVWF  x10
.................... 
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail;
5524:  MOVF   x0C,W
5526:  MULLW  24
5528:  MOVF   FF3,W
552A:  CLRF   x12
552C:  MOVWF  x11
552E:  MOVLW  14
5530:  ADDWF  x11,W
5532:  MOVWF  01
5534:  MOVLW  00
5536:  ADDWFC x12,W
5538:  MOVWF  03
553A:  MOVF   01,W
553C:  ADDLW  88
553E:  MOVWF  FE9
5540:  MOVLW  00
5542:  ADDWFC 03,W
5544:  MOVWF  FEA
5546:  MOVFF  FEC,03
554A:  MOVF   FED,F
554C:  MOVFF  FEF,01
5550:  MOVF   03,W
5552:  SUBWF  x10,W
5554:  BNC   558A
5556:  BNZ   555E
5558:  MOVF   x0F,W
555A:  SUBWF  01,W
555C:  BC    558A
555E:  MOVF   x0C,W
5560:  MULLW  24
5562:  MOVF   FF3,W
5564:  CLRF   x12
5566:  MOVWF  x11
5568:  MOVLW  14
556A:  ADDWF  x11,W
556C:  MOVWF  01
556E:  MOVLW  00
5570:  ADDWFC x12,W
5572:  MOVWF  03
5574:  MOVF   01,W
5576:  ADDLW  88
5578:  MOVWF  FE9
557A:  MOVLW  00
557C:  ADDWFC 03,W
557E:  MOVWF  FEA
5580:  MOVFF  FEC,03
5584:  MOVF   FED,F
5586:  MOVF   FEF,W
5588:  BRA    5590
558A:  MOVFF  310,03
558E:  MOVF   x0F,W
5590:  MOVWF  x0F
5592:  MOVFF  03,310
.................... 
....................    return(txAvail);
5596:  MOVFF  30F,01
559A:  MOVFF  310,02
559E:  MOVLB  0
55A0:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s      - socket to use
....................  *                  ptr    - Block of data to send over TCP
....................  *                  len    - number of bytes to send over TCP
....................  *
....................  * Output:          Total number of bytes written to TCP.  If this value
....................  *                  is not equal len that means we ran out of space in the
....................  *                  TX buffer -OR- we ran out of space in the remote node's
....................  *                  window.  In either case you will have to continue later.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len)
.................... {
....................    SOCKET_INFO* ps;
....................    WORD n;
.................... 
....................    ps = &TCB[s];
.................... 
....................    // Make sure that the remote node is able to accept our data
....................    if(ps->RemoteWindow == 0)
....................       return 0;
.................... 
....................    if(ps->TxBuffer == INVALID_BUFFER)
....................    {
....................       ps->TxBuffer = MACGetTxBuffer(FALSE);
.................... 
....................       // Check to make sure that we received a TX Buffer
....................       if(ps->TxBuffer == INVALID_BUFFER)
....................          return 0;
.................... 
....................       ps->TxCount = 0;
.................... 
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER));
....................    }
.................... 
....................    n = TCPPutAvailable(s);
.................... 
....................    ps->Flags.bIsTxInProgress = TRUE;
.................... 
....................    while (n--)
....................    {
....................       MACPut(*ptr++);
....................       ps->RemoteWindow -= 1;
....................       ps->TxCount += 1;
....................    }
.................... 
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN)
....................       TCPFlush(s);
.................... 
....................    return(len);
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s      - socket to use
....................  *                  ptr    - Block of data to send over TCP
....................  *                  len    - number of bytes to send over TCP
....................  *
....................  * Output:          Total number of bytes written to TCP.  If this value
....................  *                  is not equal len that means we ran out of space in the
....................  *                  TX buffer and you will have to continue later.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte)
.................... {
....................    SOCKET_INFO* ps;
....................    WORD tempCount;
.................... 
....................    ps = &TCB[s];
*
5216:  MOVLB  3
5218:  MOVF   x1D,W
521A:  MULLW  24
521C:  MOVF   FF3,W
521E:  CLRF   03
5220:  ADDLW  88
5222:  MOVWF  01
5224:  MOVLW  00
5226:  ADDWFC 03,F
5228:  MOVFF  01,31F
522C:  MOVFF  03,320
.................... 
....................    // Make sure that the remote node is able to accept our data
....................    if(ps->RemoteWindow == 0)
5230:  MOVLW  14
5232:  ADDWF  x1F,W
5234:  MOVWF  FE9
5236:  MOVLW  00
5238:  ADDWFC x20,W
523A:  MOVWF  FEA
523C:  MOVFF  FEC,324
5240:  MOVF   FED,F
5242:  MOVFF  FEF,323
5246:  MOVF   x23,F
5248:  BNZ   5254
524A:  MOVF   x24,F
524C:  BNZ   5254
....................       return FALSE;
524E:  MOVLW  00
5250:  MOVWF  01
5252:  BRA    5352
.................... 
....................    if(ps->TxBuffer == INVALID_BUFFER)
5254:  MOVLW  0F
5256:  ADDWF  x1F,W
5258:  MOVWF  FE9
525A:  MOVLW  00
525C:  ADDWFC x20,W
525E:  MOVWF  FEA
5260:  INCFSZ FEF,W
5262:  BRA    52D2
....................    {
....................       ps->TxBuffer = MACGetTxBuffer(FALSE);
5264:  MOVLW  0F
5266:  ADDWF  x1F,W
5268:  MOVWF  01
526A:  MOVLW  00
526C:  ADDWFC x20,W
526E:  MOVWF  03
5270:  MOVFF  01,323
5274:  MOVWF  x24
5276:  CLRF   x6F
5278:  MOVLB  0
527A:  CALL   1524
527E:  MOVFF  324,FEA
5282:  MOVFF  323,FE9
5286:  MOVFF  01,FEF
.................... 
....................       // Check to make sure that we received a TX Buffer
....................       if(ps->TxBuffer == INVALID_BUFFER)
528A:  MOVLW  0F
528C:  MOVLB  3
528E:  ADDWF  x1F,W
5290:  MOVWF  FE9
5292:  MOVLW  00
5294:  ADDWFC x20,W
5296:  MOVWF  FEA
5298:  INCFSZ FEF,W
529A:  BRA    52A2
....................          return FALSE;
529C:  MOVLW  00
529E:  MOVWF  01
52A0:  BRA    5352
.................... 
....................       ps->TxCount = 0;
52A2:  MOVLW  10
52A4:  ADDWF  x1F,W
52A6:  MOVWF  FE9
52A8:  MOVLW  00
52AA:  ADDWFC x20,W
52AC:  MOVWF  FEA
52AE:  CLRF   FEC
52B0:  MOVF   FED,F
52B2:  CLRF   FEF
.................... 
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER));
52B4:  MOVLW  0F
52B6:  ADDWF  x1F,W
52B8:  MOVWF  FE9
52BA:  MOVLW  00
52BC:  ADDWFC x20,W
52BE:  MOVWF  FEA
52C0:  MOVFF  FEF,388
52C4:  CLRF   x8A
52C6:  MOVLW  28
52C8:  MOVWF  x89
52CA:  MOVLB  0
52CC:  CALL   154C
52D0:  MOVLB  3
....................    }
.................... 
....................    ps->Flags.bIsTxInProgress = TRUE;
52D2:  MOVLW  23
52D4:  ADDWF  x1F,W
52D6:  MOVWF  FE9
52D8:  MOVLW  00
52DA:  ADDWFC x20,W
52DC:  MOVWF  FEA
52DE:  BSF    FEF.4
.................... 
....................    MACPut(byte);
52E0:  MOVFF  31E,392
52E4:  MOVLB  0
52E6:  CALL   15EA
....................    ps->RemoteWindow--;
52EA:  MOVLW  14
52EC:  MOVLB  3
52EE:  ADDWF  x1F,W
52F0:  MOVWF  FE9
52F2:  MOVLW  00
52F4:  ADDWFC x20,W
52F6:  MOVWF  FEA
52F8:  MOVLW  FF
52FA:  ADDWF  FEF,F
52FC:  BC    5302
52FE:  MOVF   FEE,F
5300:  DECF   FED,F
.................... 
....................    tempCount = ps->TxCount;
5302:  MOVLW  10
5304:  ADDWF  x1F,W
5306:  MOVWF  FE9
5308:  MOVLW  00
530A:  ADDWFC x20,W
530C:  MOVWF  FEA
530E:  MOVFF  FEC,322
5312:  MOVF   FED,F
5314:  MOVFF  FEF,321
....................    tempCount++;
5318:  INCF   x21,F
531A:  BTFSC  FD8.2
531C:  INCF   x22,F
....................    ps->TxCount = tempCount;
531E:  MOVLW  10
5320:  ADDWF  x1F,W
5322:  MOVWF  FE9
5324:  MOVLW  00
5326:  ADDWFC x20,W
5328:  MOVWF  FEA
532A:  MOVFF  322,FEC
532E:  MOVF   FED,F
5330:  MOVFF  321,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN)
5334:  MOVF   x22,W
5336:  SUBLW  02
5338:  BC    534E
533A:  XORLW  FF
533C:  BNZ   5344
533E:  MOVF   x21,W
5340:  SUBLW  C9
5342:  BC    534E
....................       TCPFlush(s);
5344:  MOVFF  31D,323
5348:  MOVLB  0
534A:  RCALL  5088
534C:  MOVLB  3
.................... 
....................    return TRUE;
534E:  MOVLW  01
5350:  MOVWF  01
5352:  MOVLB  0
5354:  GOTO   5362 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket
....................  *
....................  * Output:          TRUE if socket received data was discarded
....................  *                  FALSE if socket received data was already
....................  *                          discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPDiscard(TCP_SOCKET s)
.................... {
....................     SOCKET_INFO* ps;
.................... 
....................     ps = &TCB[s];
*
4F96:  MOVLB  2
4F98:  MOVF   xF1,W
4F9A:  MULLW  24
4F9C:  MOVF   FF3,W
4F9E:  CLRF   03
4FA0:  ADDLW  88
4FA2:  MOVWF  01
4FA4:  MOVLW  00
4FA6:  ADDWFC 03,F
4FA8:  MOVFF  01,2F2
4FAC:  MOVFF  03,2F3
.................... 
....................     // This socket must contain data for it to be discarded.
....................     if ( !ps->Flags.bIsGetReady )
4FB0:  MOVLW  23
4FB2:  ADDWF  xF2,W
4FB4:  MOVWF  FE9
4FB6:  MOVLW  00
4FB8:  ADDWFC xF3,W
4FBA:  MOVWF  FEA
4FBC:  BTFSC  FEF.3
4FBE:  BRA    4FC6
....................         return FALSE;
4FC0:  MOVLW  00
4FC2:  MOVWF  01
4FC4:  BRA    4FE0
.................... 
....................     MACDiscardRx();
4FC6:  MOVLB  0
4FC8:  CALL   1160
....................     ps->Flags.bIsGetReady = FALSE;
4FCC:  MOVLW  23
4FCE:  MOVLB  2
4FD0:  ADDWF  xF2,W
4FD2:  MOVWF  FE9
4FD4:  MOVLW  00
4FD6:  ADDWFC xF3,W
4FD8:  MOVWF  FEA
4FDA:  BCF    FEF.3
.................... 
....................     return TRUE;
4FDC:  MOVLW  01
4FDE:  MOVWF  01
4FE0:  MOVLB  0
4FE2:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer,
....................  *                                      WORD count)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  buffer  - Buffer to hold received data.
....................  *                  count   - Buffer length
....................  *
....................  * Output:          Number of bytes loaded into buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count)
.................... {
....................     SOCKET_INFO *ps;
.................... 
....................     ps = &TCB[s];
.................... 
....................     if ( ps->Flags.bIsGetReady )
....................     {
....................         if ( ps->Flags.bFirstRead )
....................         {
....................          // Position read pointer to begining of TCP data
....................             IPSetRxBuffer(sizeof(TCP_HEADER));
.................... 
....................             ps->Flags.bFirstRead = FALSE;
....................         }
.................... 
....................         ps->Flags.bIsTxInProgress = TRUE;
.................... 
....................         return MACGetArray(buff, count);
....................     }
....................     else
....................         return 0;
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  byte    - Pointer to a byte.
....................  *
....................  * Output:          TRUE if a byte was read.
....................  *                  FALSE if byte was not read.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data)
.................... {
....................     SOCKET_INFO* ps;
.................... 
....................     ps = &TCB[s];
*
3E68:  MOVLB  2
3E6A:  MOVF   xEE,W
3E6C:  MULLW  24
3E6E:  MOVF   FF3,W
3E70:  CLRF   03
3E72:  ADDLW  88
3E74:  MOVWF  01
3E76:  MOVLW  00
3E78:  ADDWFC 03,F
3E7A:  MOVFF  01,2F1
3E7E:  MOVFF  03,2F2
.................... 
....................     if ( ps->Flags.bIsGetReady )
3E82:  MOVLW  23
3E84:  ADDWF  xF1,W
3E86:  MOVWF  FE9
3E88:  MOVLW  00
3E8A:  ADDWFC xF2,W
3E8C:  MOVWF  FEA
3E8E:  BTFSS  FEF.3
3E90:  BRA    3F32
....................     {
....................         if ( ps->Flags.bFirstRead )
3E92:  MOVLW  23
3E94:  ADDWF  xF1,W
3E96:  MOVWF  FE9
3E98:  MOVLW  00
3E9A:  ADDWFC xF2,W
3E9C:  MOVWF  FEA
3E9E:  BTFSS  FEF.2
3EA0:  BRA    3EC0
....................         {
....................             // Position read pointer to begining of correct
....................             // buffer.
....................             IPSetRxBuffer(sizeof(TCP_HEADER));
3EA2:  MOVLB  3
3EA4:  CLRF   x14
3EA6:  MOVLW  14
3EA8:  MOVWF  x13
3EAA:  MOVLB  0
3EAC:  CALL   20EE
.................... 
....................             ps->Flags.bFirstRead = FALSE;
3EB0:  MOVLW  23
3EB2:  MOVLB  2
3EB4:  ADDWF  xF1,W
3EB6:  MOVWF  FE9
3EB8:  MOVLW  00
3EBA:  ADDWFC xF2,W
3EBC:  MOVWF  FEA
3EBE:  BCF    FEF.2
....................         }
.................... 
....................         if ( ps->RxCount == 0 )
3EC0:  MOVLW  12
3EC2:  ADDWF  xF1,W
3EC4:  MOVWF  FE9
3EC6:  MOVLW  00
3EC8:  ADDWFC xF2,W
3ECA:  MOVWF  FEA
3ECC:  MOVFF  FEC,2F4
3ED0:  MOVF   FED,F
3ED2:  MOVFF  FEF,2F3
3ED6:  MOVF   xF3,F
3ED8:  BNZ   3EFA
3EDA:  MOVF   xF4,F
3EDC:  BNZ   3EFA
....................         {
....................             MACDiscardRx();
3EDE:  MOVLB  0
3EE0:  CALL   1160
....................             ps->Flags.bIsGetReady = FALSE;
3EE4:  MOVLW  23
3EE6:  MOVLB  2
3EE8:  ADDWF  xF1,W
3EEA:  MOVWF  FE9
3EEC:  MOVLW  00
3EEE:  ADDWFC xF2,W
3EF0:  MOVWF  FEA
3EF2:  BCF    FEF.3
....................             return FALSE;
3EF4:  MOVLW  00
3EF6:  MOVWF  01
3EF8:  BRA    3F36
....................         }
.................... 
....................          ps->RxCount--;
3EFA:  MOVLW  12
3EFC:  ADDWF  xF1,W
3EFE:  MOVWF  FE9
3F00:  MOVLW  00
3F02:  ADDWFC xF2,W
3F04:  MOVWF  FEA
3F06:  MOVLW  FF
3F08:  ADDWF  FEF,F
3F0A:  BC    3F10
3F0C:  MOVF   FEE,F
3F0E:  DECF   FED,F
....................          *data = MACGet();
3F10:  MOVFF  2F0,2F4
3F14:  MOVFF  2EF,2F3
3F18:  MOVLB  0
3F1A:  CALL   1F6A
3F1E:  MOVFF  2F4,FEA
3F22:  MOVFF  2F3,FE9
3F26:  MOVFF  01,FEF
....................         return TRUE;
3F2A:  MOVLW  01
3F2C:  MOVWF  01
3F2E:  MOVLB  2
3F30:  BRA    3F36
....................     }
....................     return FALSE;
3F32:  MOVLW  00
3F34:  MOVWF  01
3F36:  MOVLB  0
3F38:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' contains any data.
....................  *                  FALSE if socket 's' does not contain any data.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPIsGetReady(TCP_SOCKET s)
.................... {
....................     /*
....................      * A socket is said to be "Get" ready when it has already
....................      * received some data.  Sometime, a socket may be closed,
....................      * but it still may contain data.  Thus in order to ensure
....................      * reuse of a socket, caller must make sure that it reads
....................      * a socket, if is ready.
....................      */
....................     return (TCB[s].Flags.bIsGetReady );
*
3E3C:  MOVLB  2
3E3E:  MOVF   xEE,W
3E40:  MULLW  24
3E42:  MOVF   FF3,W
3E44:  CLRF   xF0
3E46:  MOVWF  xEF
3E48:  MOVLW  23
3E4A:  ADDWF  xEF,F
3E4C:  MOVLW  00
3E4E:  ADDWFC xF0,F
3E50:  MOVLW  88
3E52:  ADDWF  xEF,W
3E54:  MOVWF  FE9
3E56:  MOVLW  00
3E58:  ADDWFC xF0,W
3E5A:  MOVWF  FEA
3E5C:  MOVLW  00
3E5E:  BTFSC  FEF.3
3E60:  MOVLW  01
3E62:  MOVWF  01
3E64:  MOVLB  0
3E66:  RETURN 0
.................... }
.................... 
.................... //// internal functions /////
.................... 
.................... void DebugTCPDisplayState(TCP_STATE st)
.................... {
....................    switch(st)
....................    {
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break;
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break;
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break;
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break;
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break;
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break;
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break;
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break;
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break;
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break;
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break;
....................       default:                debug_tcp("UNKNOWN %U",st); break;
....................    }
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPTick(void)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           None
.................... *
.................... * Output:          Each socket FSM is executed for any timeout
.................... *                  situation.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... void TCPTick(void)
.................... {
....................    TCP_SOCKET s;
....................    TICKTYPE diffTicks;
....................    TICKTYPE tick;
....................    SOCKET_INFO* ps;
....................    DWORD seq;
....................    BYTE flags;
....................    //BYTE debugLastState;
.................... 
....................    flags = 0x00;
*
3998:  MOVLB  2
399A:  CLRF   xF1
....................    // Periodically all "not closed" sockets must perform timed operations
....................    for(s = 0; s < MAX_SOCKETS; s++)
399C:  CLRF   xE6
399E:  MOVF   xE6,W
39A0:  SUBLW  04
39A2:  BTFSS  FD8.0
39A4:  BRA    3DE0
....................    {
....................       ps = &TCB[s];
39A6:  MOVF   xE6,W
39A8:  MULLW  24
39AA:  MOVF   FF3,W
39AC:  CLRF   03
39AE:  ADDLW  88
39B0:  MOVWF  01
39B2:  MOVLW  00
39B4:  ADDWFC 03,F
39B6:  MOVFF  01,2EB
39BA:  MOVFF  03,2EC
.................... 
....................       //debugLastState = TCB[s].smState;
.................... 
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress )
39BE:  MOVLW  23
39C0:  ADDWF  xEB,W
39C2:  MOVWF  FE9
39C4:  MOVLW  00
39C6:  ADDWFC xEC,W
39C8:  MOVWF  FEA
39CA:  BTFSC  FEF.3
39CC:  BRA    39DE
39CE:  MOVLW  23
39D0:  ADDWF  xEB,W
39D2:  MOVWF  FE9
39D4:  MOVLW  00
39D6:  ADDWFC xEC,W
39D8:  MOVWF  FEA
39DA:  BTFSS  FEF.4
39DC:  BRA    39E0
....................          continue;
39DE:  BRA    3DDC
.................... 
.................... 
....................       // Closed or Passively Listening socket do not care
....................       // about timeout conditions.
....................       if ( (ps->smState == TCP_CLOSED) ||
....................          (ps->smState == TCP_LISTEN &&
....................          ps->Flags.bServer == TRUE) )
39E0:  MOVFF  2EB,FE9
39E4:  MOVFF  2EC,FEA
39E8:  MOVF   FEF,W
39EA:  SUBLW  0A
39EC:  BZ    3A10
39EE:  MOVFF  2EB,FE9
39F2:  MOVFF  2EC,FEA
39F6:  MOVF   FEF,F
39F8:  BNZ   3A12
39FA:  MOVLW  23
39FC:  ADDWF  xEB,W
39FE:  MOVWF  01
3A00:  MOVLW  00
3A02:  ADDWFC xEC,W
3A04:  MOVWF  03
3A06:  MOVFF  01,FE9
3A0A:  MOVWF  FEA
3A0C:  BTFSS  FEF.0
3A0E:  BRA    3A12
....................          continue;
3A10:  BRA    3DDC
.................... 
....................       //TODO: review this
....................       //DSR ADD 063004
....................         //i do this because if i am a server, i don't want to timeout.
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) )
3A12:  MOVFF  2EB,FE9
3A16:  MOVFF  2EC,FEA
3A1A:  MOVF   FEF,W
3A1C:  SUBLW  03
3A1E:  BNZ   3A38
3A20:  MOVLW  23
3A22:  ADDWF  xEB,W
3A24:  MOVWF  01
3A26:  MOVLW  00
3A28:  ADDWFC xEC,W
3A2A:  MOVWF  03
3A2C:  MOVFF  01,FE9
3A30:  MOVWF  FEA
3A32:  BTFSS  FEF.0
3A34:  BRA    3A38
....................          continue;
3A36:  BRA    3DDC
.................... 
.................... 
....................       tick = TickGet();
3A38:  MOVLB  0
3A3A:  CALL   24E0
3A3E:  MOVFF  02,2EA
3A42:  MOVFF  01,2E9
.................... 
....................       // Calculate timeout value for this socket.
....................       diffTicks = TickGetDiff(tick, ps->startTick);
3A46:  MOVLW  1F
3A48:  MOVLB  2
3A4A:  ADDWF  xEB,W
3A4C:  MOVWF  FE9
3A4E:  MOVLW  00
3A50:  ADDWFC xEC,W
3A52:  MOVWF  FEA
3A54:  MOVFF  FEC,03
3A58:  MOVF   FED,F
3A5A:  MOVFF  FEF,01
3A5E:  MOVF   xEA,W
3A60:  SUBWF  03,W
3A62:  BNC   3A6C
3A64:  BNZ   3A70
3A66:  MOVF   01,W
3A68:  SUBWF  xE9,W
3A6A:  BNC   3A70
3A6C:  MOVLW  00
3A6E:  BRA    3A72
3A70:  MOVLW  01
3A72:  CLRF   03
3A74:  IORWF  03,W
3A76:  BZ    3AAE
3A78:  MOVLW  1F
3A7A:  ADDWF  xEB,W
3A7C:  MOVWF  FE9
3A7E:  MOVLW  00
3A80:  ADDWFC xEC,W
3A82:  MOVWF  FEA
3A84:  MOVFF  FEC,03
3A88:  MOVF   FED,F
3A8A:  MOVF   FEF,W
3A8C:  SUBLW  FF
3A8E:  MOVWF  xF2
3A90:  MOVLW  FF
3A92:  SUBFWB 03,W
3A94:  MOVWF  xF3
3A96:  MOVF   xE9,W
3A98:  ADDWF  xF2,F
3A9A:  MOVF   xEA,W
3A9C:  ADDWFC xF3,F
3A9E:  MOVLW  01
3AA0:  ADDWF  xF2,W
3AA2:  MOVWF  01
3AA4:  MOVLW  00
3AA6:  ADDWFC xF3,W
3AA8:  MOVWF  03
3AAA:  MOVF   01,W
3AAC:  BRA    3ACE
3AAE:  MOVLW  1F
3AB0:  ADDWF  xEB,W
3AB2:  MOVWF  FE9
3AB4:  MOVLW  00
3AB6:  ADDWFC xEC,W
3AB8:  MOVWF  FEA
3ABA:  MOVFF  FEC,03
3ABE:  MOVF   FED,F
3AC0:  MOVF   FEF,W
3AC2:  SUBWF  xE9,W
3AC4:  MOVWF  00
3AC6:  MOVF   03,W
3AC8:  SUBWFB xEA,W
3ACA:  MOVWF  03
3ACC:  MOVF   00,W
3ACE:  MOVWF  xE7
3AD0:  MOVFF  03,2E8
.................... 
....................       // If timeout has not occured, do not do anything.
....................       if(diffTicks <= ps->TimeOut)
3AD4:  MOVLW  21
3AD6:  ADDWF  xEB,W
3AD8:  MOVWF  FE9
3ADA:  MOVLW  00
3ADC:  ADDWFC xEC,W
3ADE:  MOVWF  FEA
3AE0:  MOVFF  FEC,03
3AE4:  MOVF   FED,F
3AE6:  MOVFF  FEF,01
3AEA:  MOVF   xE8,W
3AEC:  SUBWF  03,W
3AEE:  BNC   3AFA
3AF0:  BNZ   3AF8
3AF2:  MOVF   xE7,W
3AF4:  SUBWF  01,W
3AF6:  BNC   3AFA
....................          continue;
3AF8:  BRA    3DDC
.................... 
....................       // Most states require retransmission, so check for transmitter
....................       // availability right here - common for all.
....................       if(!IPIsTxReady(TRUE))
3AFA:  MOVLW  01
3AFC:  MOVLB  3
3AFE:  MOVWF  x6F
3B00:  MOVLB  0
3B02:  CALL   25EE
3B06:  MOVF   01,F
3B08:  BNZ   3B0C
....................          return;
3B0A:  BRA    3DE0
.................... 
....................       // Restart timeout reference.
....................       ps->startTick = TickGet();
3B0C:  MOVLW  1F
3B0E:  MOVLB  2
3B10:  ADDWF  xEB,W
3B12:  MOVWF  01
3B14:  MOVLW  00
3B16:  ADDWFC xEC,W
3B18:  MOVWF  03
3B1A:  MOVFF  01,2F2
3B1E:  MOVWF  xF3
3B20:  MOVLB  0
3B22:  CALL   24E0
3B26:  MOVFF  2F3,FEA
3B2A:  MOVFF  2F2,FE9
3B2E:  MOVFF  02,FEC
3B32:  MOVF   FED,F
3B34:  MOVFF  01,FEF
.................... 
....................       // Update timeout value if there is need to wait longer.
....................       ps->TimeOut <<= 1;
3B38:  MOVLW  21
3B3A:  MOVLB  2
3B3C:  ADDWF  xEB,W
3B3E:  MOVWF  FE9
3B40:  MOVLW  00
3B42:  ADDWFC xEC,W
3B44:  MOVWF  FEA
3B46:  BCF    FD8.0
3B48:  RLCF   FEF,W
3B4A:  MOVWF  02
3B4C:  RLCF   FEC,W
3B4E:  MOVWF  03
3B50:  MOVF   02,W
3B52:  MOVF   FED,F
3B54:  MOVWF  FEF
3B56:  MOVFF  03,FEC
.................... 
....................       // This will be one more attempt.
....................       ps->RetryCount++;
3B5A:  MOVLW  1E
3B5C:  ADDWF  xEB,W
3B5E:  MOVWF  FE9
3B60:  MOVLW  00
3B62:  ADDWFC xEC,W
3B64:  MOVWF  FEA
3B66:  INCF   FEF,F
.................... 
....................       // A timeout has occured.  Respond to this timeout condition
....................       // depending on what state this socket is in.
....................       switch(ps->smState)
3B68:  MOVFF  2EB,FE9
3B6C:  MOVFF  2EC,FEA
3B70:  MOVLW  01
3B72:  SUBWF  FEF,W
3B74:  ADDLW  F7
3B76:  BTFSC  FD8.0
3B78:  BRA    3D02
3B7A:  ADDLW  09
3B7C:  MOVLB  0
3B7E:  GOTO   3DE6
....................       {
....................       case TCP_SYN_SENT:
....................          // Keep sending SYN until we hear from remote node.
....................          // This may be for infinite time, in that case
....................          // caller must detect it and do something.
....................          // Bug Fix: 11/1/02
....................          flags = SYN;
3B82:  MOVLW  02
3B84:  MOVLB  2
3B86:  MOVWF  xF1
....................          break;
3B88:  BRA    3D02
.................... 
....................       case TCP_SYN_RECEIVED:
....................          // We must receive ACK before timeout expires.
....................          // If not, resend SYN+ACK.
....................          // Abort, if maximum attempts counts are reached.
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3B8A:  MOVLW  1E
3B8C:  MOVLB  2
3B8E:  ADDWF  xEB,W
3B90:  MOVWF  FE9
3B92:  MOVLW  00
3B94:  ADDWFC xEC,W
3B96:  MOVWF  FEA
3B98:  MOVF   FEF,W
3B9A:  SUBLW  03
3B9C:  BNC   3BA4
....................          {
....................             flags = SYN | ACK;
3B9E:  MOVLW  12
3BA0:  MOVWF  xF1
....................          }
3BA2:  BRA    3BD0
....................          else
....................          {
....................             if(ps->Flags.bServer)
3BA4:  MOVLW  23
3BA6:  ADDWF  xEB,W
3BA8:  MOVWF  FE9
3BAA:  MOVLW  00
3BAC:  ADDWFC xEC,W
3BAE:  MOVWF  FEA
3BB0:  BTFSS  FEF.0
3BB2:  BRA    3BC0
....................             {
....................                ps->smState = TCP_LISTEN;
3BB4:  MOVFF  2EB,FE9
3BB8:  MOVFF  2EC,FEA
3BBC:  CLRF   FEF
....................             }
3BBE:  BRA    3BD0
....................             else
....................             {
....................                flags = SYN;
3BC0:  MOVLW  02
3BC2:  MOVWF  xF1
....................                ps->smState = TCP_SYN_SENT;
3BC4:  MOVFF  2EB,FE9
3BC8:  MOVFF  2EC,FEA
3BCC:  MOVLW  01
3BCE:  MOVWF  FEF
....................             }
....................          }
....................          break;
3BD0:  BRA    3D02
.................... 
....................       case TCP_ESTABLISHED:
.................... #if !TCP_NO_WAIT_FOR_ACK
....................          // Don't let this connection idle for very long time.
....................          // If we did not receive or send any message before timeout
....................          // expires, close this connection.
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3BD2:  MOVLW  1E
3BD4:  MOVLB  2
3BD6:  ADDWF  xEB,W
3BD8:  MOVWF  FE9
3BDA:  MOVLW  00
3BDC:  ADDWFC xEC,W
3BDE:  MOVWF  FEA
3BE0:  MOVF   FEF,W
3BE2:  SUBLW  03
3BE4:  BNC   3C26
....................          {
....................             if(ps->TxBuffer != INVALID_BUFFER)
3BE6:  MOVLW  0F
3BE8:  ADDWF  xEB,W
3BEA:  MOVWF  FE9
3BEC:  MOVLW  00
3BEE:  ADDWFC xEC,W
3BF0:  MOVWF  FEA
3BF2:  INCFSZ FEF,W
3BF4:  BRA    3BF8
3BF6:  BRA    3C1C
....................             {
....................                MACSetTxBuffer(ps->TxBuffer, 0);
3BF8:  MOVLW  0F
3BFA:  ADDWF  xEB,W
3BFC:  MOVWF  FE9
3BFE:  MOVLW  00
3C00:  ADDWFC xEC,W
3C02:  MOVWF  FEA
3C04:  MOVFF  FEF,388
3C08:  MOVLB  3
3C0A:  CLRF   x8A
3C0C:  CLRF   x89
3C0E:  MOVLB  0
3C10:  CALL   154C
....................                MACFlush();
3C14:  CALL   1716
....................             }
3C18:  BRA    3C22
3C1A:  MOVLB  2
....................             else
....................                flags = ACK;
3C1C:  MOVLW  10
3C1E:  MOVWF  xF1
3C20:  MOVLB  0
....................          }
3C22:  BRA    3C70
3C24:  MOVLB  2
....................          else
....................          {
....................             // Forget about previous transmission.
....................             if(ps->TxBuffer != INVALID_BUFFER)
3C26:  MOVLW  0F
3C28:  ADDWF  xEB,W
3C2A:  MOVWF  FE9
3C2C:  MOVLW  00
3C2E:  ADDWFC xEC,W
3C30:  MOVWF  FEA
3C32:  INCFSZ FEF,W
3C34:  BRA    3C38
3C36:  BRA    3C5E
....................             {
....................                MACDiscardTx(ps->TxBuffer);
3C38:  MOVLW  0F
3C3A:  ADDWF  xEB,W
3C3C:  MOVWF  FE9
3C3E:  MOVLW  00
3C40:  ADDWFC xEC,W
3C42:  MOVWF  FEA
3C44:  MOVFF  FEF,333
3C48:  MOVLB  0
3C4A:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER;
3C4E:  MOVLW  0F
3C50:  MOVLB  2
3C52:  ADDWF  xEB,W
3C54:  MOVWF  FE9
3C56:  MOVLW  00
3C58:  ADDWFC xEC,W
3C5A:  MOVWF  FEA
3C5C:  SETF   FEF
....................             }
.................... 
.................... #endif
....................             // Request closure.
....................             flags = FIN | ACK;
3C5E:  MOVLW  11
3C60:  MOVWF  xF1
....................             //DebugPrint("!");
.................... 
....................             ps->smState = TCP_FIN_WAIT_1;
3C62:  MOVFF  2EB,FE9
3C66:  MOVFF  2EC,FEA
3C6A:  MOVLW  04
3C6C:  MOVWF  FEF
3C6E:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK
....................          }
.................... #endif
....................          break;
3C70:  MOVLB  2
3C72:  BRA    3D02
.................... 
....................       case TCP_FIN_WAIT_1:
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3C74:  MOVLW  1E
3C76:  MOVLB  2
3C78:  ADDWF  xEB,W
3C7A:  MOVWF  FE9
3C7C:  MOVLW  00
3C7E:  ADDWFC xEC,W
3C80:  MOVWF  FEA
3C82:  MOVF   FEF,W
3C84:  SUBLW  03
3C86:  BNC   3C8E
....................          {
....................                // Send another FIN
....................                flags = FIN;
3C88:  MOVLW  01
3C8A:  MOVWF  xF1
....................          }
3C8C:  BRA    3C9E
....................          else
....................          {
....................             // Close on our own, we can't seem to communicate
....................             // with the remote node anymore
....................             CloseSocket(ps);
3C8E:  MOVFF  2EC,331
3C92:  MOVFF  2EB,330
3C96:  MOVLB  0
3C98:  CALL   24FA
3C9C:  MOVLB  2
....................          }
....................          break;
3C9E:  BRA    3D02
.................... 
....................       case TCP_FIN_WAIT_2:
....................       case TCP_CLOSING:
....................          // Close on our own, we can't seem to communicate
....................          // with the remote node anymore
....................          CloseSocket(ps);
3CA0:  MOVFF  2EC,331
3CA4:  MOVFF  2EB,330
3CA8:  CALL   24FA
....................          break;
3CAC:  MOVLB  2
3CAE:  BRA    3D02
.................... 
....................       case TCP_TIME_WAIT:
....................          // Wait around for a while (2MSL) and then goto closed state
....................          CloseSocket(ps);
3CB0:  MOVFF  2EC,331
3CB4:  MOVFF  2EB,330
3CB8:  CALL   24FA
....................          break;
3CBC:  MOVLB  2
3CBE:  BRA    3D02
.................... 
....................       case TCP_CLOSE_WAIT:
....................          flags = FIN;
3CC0:  MOVLW  01
3CC2:  MOVLB  2
3CC4:  MOVWF  xF1
....................          ps->smState = TCP_LAST_ACK;
3CC6:  MOVFF  2EB,FE9
3CCA:  MOVFF  2EC,FEA
3CCE:  MOVLW  09
3CD0:  MOVWF  FEF
....................          break;
3CD2:  BRA    3D02
.................... 
....................       case TCP_LAST_ACK:
....................          // Send some more FINs or close anyway
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3CD4:  MOVLW  1E
3CD6:  MOVLB  2
3CD8:  ADDWF  xEB,W
3CDA:  MOVWF  FE9
3CDC:  MOVLW  00
3CDE:  ADDWFC xEC,W
3CE0:  MOVWF  FEA
3CE2:  MOVF   FEF,W
3CE4:  SUBLW  03
3CE6:  BNC   3CEE
....................             flags = FIN;
3CE8:  MOVLW  01
3CEA:  MOVWF  xF1
3CEC:  BRA    3CFE
....................          else
....................             CloseSocket(ps);
3CEE:  MOVFF  2EC,331
3CF2:  MOVFF  2EB,330
3CF6:  MOVLB  0
3CF8:  CALL   24FA
3CFC:  MOVLB  2
....................          break;
3CFE:  BRA    3D02
3D00:  MOVLB  2
....................       }
.................... 
.................... 
....................       if(flags)
3D02:  MOVF   xF1,F
3D04:  BZ    3DDC
....................       {
....................          if(flags & ACK)
3D06:  BTFSS  xF1.4
3D08:  BRA    3D28
....................             seq = ps->SND_SEQ;
3D0A:  MOVLW  16
3D0C:  ADDWF  xEB,W
3D0E:  MOVWF  FE9
3D10:  MOVLW  00
3D12:  ADDWFC xEC,W
3D14:  MOVWF  FEA
3D16:  MOVFF  FEF,2ED
3D1A:  MOVFF  FEC,2EE
3D1E:  MOVFF  FEC,2EF
3D22:  MOVFF  FEC,2F0
3D26:  BRA    3D56
....................          else
....................             seq = ps->SND_SEQ++;
3D28:  MOVLW  16
3D2A:  ADDWF  xEB,W
3D2C:  MOVWF  FE9
3D2E:  MOVLW  00
3D30:  ADDWFC xEC,W
3D32:  MOVWF  FEA
3D34:  MOVF   FEE,F
3D36:  MOVF   FEE,F
3D38:  MOVF   FEE,F
3D3A:  MOVFF  FED,2F0
3D3E:  MOVFF  FED,2EF
3D42:  MOVFF  FED,2EE
3D46:  MOVFF  FEF,2ED
3D4A:  MOVLW  01
3D4C:  ADDWF  FEE,F
3D4E:  MOVLW  00
3D50:  ADDWFC FEE,F
3D52:  ADDWFC FEE,F
3D54:  ADDWFC FED,F
.................... 
....................          SendTCP(&ps->remote,
....................             ps->localPort,
....................             ps->remotePort,
....................             seq,
....................             ps->SND_ACK,
....................             flags);
3D56:  MOVLW  01
3D58:  ADDWF  xEB,W
3D5A:  MOVWF  01
3D5C:  MOVLW  00
3D5E:  ADDWFC xEC,W
3D60:  MOVWF  03
3D62:  MOVFF  01,2F2
3D66:  MOVWF  xF3
3D68:  MOVLW  0B
3D6A:  ADDWF  xEB,W
3D6C:  MOVWF  FE9
3D6E:  MOVLW  00
3D70:  ADDWFC xEC,W
3D72:  MOVWF  FEA
3D74:  MOVFF  FEC,33A
3D78:  MOVF   FED,F
3D7A:  MOVFF  FEF,339
3D7E:  MOVLW  0D
3D80:  ADDWF  xEB,W
3D82:  MOVWF  FE9
3D84:  MOVLW  00
3D86:  ADDWFC xEC,W
3D88:  MOVWF  FEA
3D8A:  MOVFF  FEC,33C
3D8E:  MOVF   FED,F
3D90:  MOVFF  FEF,33B
3D94:  MOVLW  1A
3D96:  ADDWF  xEB,W
3D98:  MOVWF  FE9
3D9A:  MOVLW  00
3D9C:  ADDWFC xEC,W
3D9E:  MOVWF  FEA
3DA0:  MOVFF  FEF,341
3DA4:  MOVFF  FEC,342
3DA8:  MOVFF  FEC,343
3DAC:  MOVFF  FEC,344
3DB0:  MOVFF  2F3,338
3DB4:  MOVFF  2F2,337
3DB8:  MOVFF  2F0,340
3DBC:  MOVFF  2EF,33F
3DC0:  MOVFF  2EE,33E
3DC4:  MOVFF  2ED,33D
3DC8:  MOVFF  2F1,345
3DCC:  MOVLB  3
3DCE:  SETF   x46
3DD0:  CLRF   x48
3DD2:  CLRF   x47
3DD4:  MOVLB  0
3DD6:  CALL   2926
3DDA:  MOVLB  2
....................       }
3DDC:  INCF   xE6,F
3DDE:  BRA    399E
3DE0:  MOVLB  0
.................... 
....................       /*if (debugLastState != ps->smState)
....................       {
....................          debug_tcp("\r\nTCP TICK %u - ", s);
....................          DebugTCPDisplayState(debugLastState);
....................          debug_tcp(" -> ");
....................          DebugTCPDisplayState(ps->smState);
....................       }*/
....................    }
3DE2:  GOTO   6E14 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote,
.................... *                                  IP_ADDR *localIP,
.................... *                                  WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCP segment is ready in MAC buffer
.................... *
.................... * Input:           remote      - Remote node info
.................... *                  len         - Total length of TCP semgent.
.................... *
.................... * Output:          TRUE if this function has completed its task
.................... *                  FALSE otherwise
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len)
.................... {
....................    TCP_HEADER      TCPHeader;
....................    PSEUDO_HEADER   pseudoHeader;
....................    TCP_SOCKET      socket;
....................    WORD_VAL        checksum1;
....................    WORD_VAL        checksum2;
....................    BYTE            optionsSize;
....................   
....................    // Calculate IP pseudoheader checksum.
....................    pseudoHeader.SourceAddress      = remote->IPAddr;
*
3544:  MOVLW  06
3546:  MOVLB  2
3548:  ADDWF  xE6,W
354A:  MOVWF  FE9
354C:  MOVLW  00
354E:  ADDWFC xE7,W
3550:  MOVWF  FEA
3552:  MOVFF  FEF,300
3556:  MOVFF  FEC,301
355A:  MOVFF  FEC,302
355E:  MOVFF  FEC,303
....................    pseudoHeader.DestAddress        = *localIP;
3562:  MOVFF  2E9,FEA
3566:  MOVFF  2E8,FE9
356A:  MOVFF  FEF,304
356E:  MOVFF  FEC,305
3572:  MOVFF  FEC,306
3576:  MOVFF  FEC,307
....................    pseudoHeader.Zero               = 0x0;
357A:  MOVLB  3
357C:  CLRF   x08
....................    pseudoHeader.Protocol           = IP_PROT_TCP;
357E:  MOVLW  06
3580:  MOVWF  x09
....................    pseudoHeader.TCPLength          = len;
3582:  MOVFF  2EB,30B
3586:  MOVFF  2EA,30A
.................... 
....................    SwapPseudoTCPHeader(pseudoHeader);
358A:  MOVFF  30B,38F
358E:  MOVFF  30A,38E
3592:  MOVLB  0
3594:  CALL   122C
3598:  MOVFF  02,30B
359C:  MOVFF  01,30A
.................... 
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader,
....................       sizeof(pseudoHeader));
35A0:  MOVLW  03
35A2:  MOVLB  3
35A4:  MOVWF  x13
35A6:  MOVWF  x72
35A8:  CLRF   x71
35AA:  CLRF   x74
35AC:  MOVLW  0C
35AE:  MOVWF  x73
35B0:  MOVLB  0
35B2:  CALL   1E7C
35B6:  MOVFF  01,30D
35BA:  MOVLB  3
35BC:  COMF   x0D,F
35BE:  MOVFF  02,30E
35C2:  COMF   x0E,F
.................... 
.................... 
....................    // Now calculate TCP packet checksum in NIC RAM - should match
....................    // pesudo header checksum
....................    checksum2.Val = CalcIPBufferChecksum(len);
35C4:  MOVFF  2EB,370
35C8:  MOVFF  2EA,36F
35CC:  MOVLB  0
35CE:  CALL   1F96
35D2:  MOVFF  02,310
35D6:  MOVFF  01,30F
.................... 
....................    // Compare checksums.  Note that the endianness is different.
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0])
35DA:  MOVLB  3
35DC:  MOVF   x10,W
35DE:  SUBWF  x0D,W
35E0:  BNZ   35E8
35E2:  MOVF   x0F,W
35E4:  SUBWF  x0E,W
35E6:  BZ    35F6
....................    {
....................       MACDiscardRx();
35E8:  MOVLB  0
35EA:  CALL   1160
....................       return TRUE;
35EE:  MOVLW  01
35F0:  MOVWF  01
35F2:  BRA    36E2
35F4:  MOVLB  3
....................    }
.................... 
....................    // Retrieve TCP header.
....................    IPSetRxBuffer(0);
35F6:  CLRF   x14
35F8:  CLRF   x13
35FA:  MOVLB  0
35FC:  CALL   20EE
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader));
3600:  MOVLW  02
3602:  MOVLB  3
3604:  MOVWF  x13
3606:  MOVLW  EC
3608:  MOVWF  x12
360A:  MOVFF  313,37E
360E:  MOVWF  x7D
3610:  CLRF   x80
3612:  MOVLW  14
3614:  MOVWF  x7F
3616:  MOVLB  0
3618:  CALL   11CC
....................    SwapTCPHeader(&TCPHeader);
361C:  MOVLW  02
361E:  MOVLB  3
3620:  MOVWF  x70
3622:  MOVLW  EC
3624:  MOVWF  x6F
3626:  MOVLB  0
3628:  CALL   212A
.................... 
.................... 
....................    // Skip over options and retrieve all data bytes.
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)-
....................       sizeof(TCPHeader));
362C:  MOVFF  2F8,00
3630:  SWAPF  00,W
3632:  ANDLW  0F
3634:  MOVWF  00
3636:  RLCF   00,F
3638:  RLCF   00,F
363A:  MOVLW  FC
363C:  ANDWF  00,F
363E:  MOVF   00,W
3640:  ADDLW  EC
3642:  MOVLB  3
3644:  MOVWF  x11
....................    len = len - optionsSize - sizeof(TCPHeader);
3646:  MOVF   x11,W
3648:  MOVLB  2
364A:  SUBWF  xEA,W
364C:  MOVLB  3
364E:  MOVWF  x12
3650:  MOVLW  00
3652:  MOVLB  2
3654:  SUBWFB xEB,W
3656:  MOVLB  3
3658:  MOVWF  x13
365A:  MOVLW  14
365C:  SUBWF  x12,W
365E:  MOVLB  2
3660:  MOVWF  xEA
3662:  MOVLW  00
3664:  MOVLB  3
3666:  SUBWFB x13,W
3668:  MOVLB  2
366A:  MOVWF  xEB
.................... 
....................    // Position packet read pointer to start of data area.
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2));
366C:  MOVFF  2F8,00
3670:  SWAPF  00,W
3672:  ANDLW  0F
3674:  MOVWF  00
3676:  RLCF   00,W
3678:  MOVLB  3
367A:  MOVWF  x12
367C:  RLCF   x12,F
367E:  MOVLW  FC
3680:  ANDWF  x12,F
3682:  CLRF   x14
3684:  MOVFF  312,313
3688:  MOVLB  0
368A:  CALL   20EE
.................... 
....................    // Find matching socket.
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote);
368E:  MOVLW  02
3690:  MOVLB  3
3692:  MOVWF  x13
3694:  MOVLW  EC
3696:  MOVWF  x12
3698:  MOVFF  2E7,315
369C:  MOVFF  2E6,314
36A0:  MOVLB  0
36A2:  GOTO   2302
36A6:  MOVFF  01,30C
....................    if(socket != INVALID_SOCKET)
36AA:  MOVLB  3
36AC:  MOVF   x0C,W
36AE:  SUBLW  FE
36B0:  BZ    36D8
....................    {
....................       HandleTCPSeg(socket, remote, &TCPHeader, len);
36B2:  MOVFF  30C,312
36B6:  MOVFF  2E7,314
36BA:  MOVFF  2E6,313
36BE:  MOVLW  02
36C0:  MOVWF  x16
36C2:  MOVLW  EC
36C4:  MOVWF  x15
36C6:  MOVFF  2EB,318
36CA:  MOVFF  2EA,317
36CE:  MOVLB  0
36D0:  GOTO   2B4A
....................    }
36D4:  BRA    36DE
36D6:  MOVLB  3
....................    else
....................    {
....................       // If this is an unknown socket, or we don't have any
....................       // listening sockets available, discard it we can't
....................       // process it right now
....................       MACDiscardRx();
36D8:  MOVLB  0
36DA:  CALL   1160
.................... 
.................... //      // Send a RESET to the remote node is it knows that we
.................... //      // are not available
.................... //      TCPHeader.AckNumber += len;
.................... //      if( TCPHeader.Flags.bits.flagSYN ||
.................... //         TCPHeader.Flags.bits.flagFIN )
.................... //         TCPHeader.AckNumber++;
.................... //
.................... //      SendTCP(remote,
.................... //         TCPHeader.DestPort,
.................... //         TCPHeader.SourcePort,
.................... //         TCPHeader.AckNumber,
.................... //         TCPHeader.SeqNumber,
.................... //         RST);
....................    }
.................... 
....................    return TRUE;
36DE:  MOVLW  01
36E0:  MOVWF  01
36E2:  GOTO   6D52 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        static void TransmitTCP(NODE_INFO* remote
.................... *                                          TCP_PORT localPort,
.................... *                                          TCP_PORT remotePort,
.................... *                                          DWORD seq,
.................... *                                          DWORD ack,
.................... *                                          BYTE flags,
.................... *                                          BUFFER buffer,
.................... *                                          WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPIsPutReady() == TRUE
.................... *
.................... * Input:           remote      - Remote node info
.................... *                  localPort   - Source port number
.................... *                  remotePort  - Destination port number
.................... *                  seq         - Segment sequence number
.................... *                  ack         - Segment acknowledge number
.................... *                  flags       - Segment flags
.................... *                  buffer      - Buffer to which this segment
.................... *                                is to be transmitted
.................... *                  len         - Total data length for this segment.
.................... *
.................... * Output:          A TCP segment is assembled and put to transmit.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... static void TransmitTCP(NODE_INFO *remote,
....................                   TCP_PORT localPort,
....................                   TCP_PORT remotePort,
....................                   DWORD tseq,
....................                   DWORD tack,
....................                   BYTE flags,
....................                   BUFFER buff,
....................                   WORD len)
.................... {
....................    WORD_VAL        checkSum;
....................    TCP_HEADER      header;
....................    TCP_OPTIONS     options;
....................    PSEUDO_HEADER   pseudoHeader;
.................... 
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X",
....................       localPort,
....................       remotePort,
....................       tseq,
....................       tack,
....................       len,
....................       flags
....................    );
.................... 
....................    //  Make sure that this Tx buffer isn't currently being transmitted
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false
*
2926:  MOVLW  01
2928:  MOVLB  3
292A:  MOVWF  x6F
292C:  MOVLB  0
292E:  RCALL  25EE
2930:  MOVF   01,F
2932:  BZ    2926
.................... 
....................    // Obtain an AutoFree buffer if this packet is a control packet
....................    // only (contains no application data in an already allocated
....................    // buffer)
....................    if(buff == INVALID_BUFFER)
2934:  MOVLB  3
2936:  INCFSZ x46,W
2938:  BRA    294A
....................       buff = MACGetTxBuffer(TRUE);
293A:  MOVLW  01
293C:  MOVWF  x6F
293E:  MOVLB  0
2940:  CALL   1524
2944:  MOVFF  01,346
2948:  MOVLB  3
.................... 
....................    if(buff == INVALID_BUFFER)
294A:  INCFSZ x46,W
294C:  BRA    2950
....................       return;
294E:  BRA    2B46
.................... 
....................    IPSetTxBuffer(buff, 0);
2950:  MOVFF  346,388
2954:  CLRF   x8A
2956:  MOVLW  14
2958:  MOVWF  x89
295A:  MOVLB  0
295C:  CALL   154C
.................... 
....................    header.SourcePort           = localPort;
2960:  MOVFF  33A,34C
2964:  MOVFF  339,34B
....................    header.DestPort             = remotePort;
2968:  MOVFF  33C,34E
296C:  MOVFF  33B,34D
....................    header.SeqNumber            = tseq;
2970:  MOVFF  340,352
2974:  MOVFF  33F,351
2978:  MOVFF  33E,350
297C:  MOVFF  33D,34F
....................    header.AckNumber            = tack;
2980:  MOVFF  344,356
2984:  MOVFF  343,355
2988:  MOVFF  342,354
298C:  MOVFF  341,353
....................    header.Flags.bits.Reserved2 = 0;
2990:  MOVLW  3F
2992:  MOVLB  3
2994:  ANDWF  x58,W
2996:  MOVWF  x58
....................    header.DataOffset.Reserved3 = 0;
2998:  MOVLW  F0
299A:  ANDWF  x57,W
299C:  MOVWF  x57
....................    header.Flags.b              = flags;
299E:  MOVFF  345,358
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20)
....................    //                  - ETHERNET header (14 if using NIC) .
....................    header.Window               = MACGetFreeRxSize();
29A2:  MOVLB  0
29A4:  BRA    2616
29A6:  MOVFF  02,35A
29AA:  MOVFF  01,359
.................... #if !defined(STACK_USE_SLIP)
....................    /*
....................    * Limit one segment at a time from remote host.
....................    * This limit increases overall throughput as remote host does not
....................    * flood us with packets and later retry with significant delay.
....................    */
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE )
....................       header.Window = MAC_RX_BUFFER_SIZE;
.................... 
....................    else if ( header.Window > 54 )
....................    {
....................       header.Window -= 54;
....................    }
....................    else
....................       header.Window = 0;
.................... #else
....................    if ( header.Window > 40 )
29AE:  MOVLB  3
29B0:  MOVF   x5A,F
29B2:  BNZ   29BA
29B4:  MOVF   x59,W
29B6:  SUBLW  28
29B8:  BC    29C4
....................    {
....................       header.Window -= 40;
29BA:  MOVLW  28
29BC:  SUBWF  x59,F
29BE:  MOVLW  00
29C0:  SUBWFB x5A,F
....................    }
29C2:  BRA    29C8
....................    else
....................       header.Window = 0;
29C4:  CLRF   x5A
29C6:  CLRF   x59
.................... #endif
.................... 
....................    header.Checksum             = 0;
29C8:  CLRF   x5C
29CA:  CLRF   x5B
....................    header.UrgentPointer        = 0;
29CC:  CLRF   x5E
29CE:  CLRF   x5D
.................... 
....................    SwapTCPHeader(&header);
29D0:  MOVLW  03
29D2:  MOVWF  x70
29D4:  MOVLW  4B
29D6:  MOVWF  x6F
29D8:  MOVLB  0
29DA:  CALL   212A
.................... 
....................    len += sizeof(header);
29DE:  MOVLW  14
29E0:  MOVLB  3
29E2:  ADDWF  x47,F
29E4:  MOVLW  00
29E6:  ADDWFC x48,F
.................... 
....................    if ( flags & SYN )
29E8:  BTFSS  x45.1
29EA:  BRA    2A0A
....................    {
....................       len += sizeof(options);
29EC:  MOVLW  04
29EE:  ADDWF  x47,F
29F0:  MOVLW  00
29F2:  ADDWFC x48,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
29F4:  MOVLW  02
29F6:  MOVWF  x5F
....................       options.Length = 0x04;
29F8:  MOVLW  04
29FA:  MOVWF  x60
.................... 
....................       // Load MSS in already swapped order.
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05;
29FC:  MOVWF  x61
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4;
29FE:  CLRF   x62
.................... 
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2;
2A00:  MOVLW  0F
2A02:  ANDWF  x57,W
2A04:  IORLW  60
2A06:  MOVWF  x57
....................    }
2A08:  BRA    2A12
....................    else
....................       header.DataOffset.Val   = sizeof(header) >> 2;
2A0A:  MOVLW  0F
2A0C:  ANDWF  x57,W
2A0E:  IORLW  50
2A10:  MOVWF  x57
.................... 
.................... 
....................    // Calculate IP pseudoheader checksum.
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr;
2A12:  MOVFF  20,366
2A16:  MOVFF  1F,365
2A1A:  MOVFF  1E,364
2A1E:  MOVFF  1D,363
....................    pseudoHeader.DestAddress    = remote->IPAddr;
2A22:  MOVLW  06
2A24:  ADDWF  x37,W
2A26:  MOVWF  FE9
2A28:  MOVLW  00
2A2A:  ADDWFC x38,W
2A2C:  MOVWF  FEA
2A2E:  MOVFF  FEF,367
2A32:  MOVFF  FEC,368
2A36:  MOVFF  FEC,369
2A3A:  MOVFF  FEC,36A
....................    pseudoHeader.Zero           = 0x0;
2A3E:  CLRF   x6B
....................    pseudoHeader.Protocol       = IP_PROT_TCP;
2A40:  MOVLW  06
2A42:  MOVWF  x6C
....................    pseudoHeader.TCPLength      = len;
2A44:  MOVFF  348,36E
2A48:  MOVFF  347,36D
.................... 
....................    SwapPseudoTCPHeader(pseudoHeader);
2A4C:  MOVFF  36E,38F
2A50:  MOVFF  36D,38E
2A54:  MOVLB  0
2A56:  CALL   122C
2A5A:  MOVFF  02,36E
2A5E:  MOVFF  01,36D
.................... 
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader,
....................       sizeof(pseudoHeader));
2A62:  MOVLW  03
2A64:  MOVLB  3
2A66:  MOVWF  x70
2A68:  MOVLW  63
2A6A:  MOVWF  x6F
2A6C:  MOVFF  370,372
2A70:  MOVWF  x71
2A72:  CLRF   x74
2A74:  MOVLW  0C
2A76:  MOVWF  x73
2A78:  MOVLB  0
2A7A:  CALL   1E7C
2A7E:  MOVFF  01,35B
2A82:  MOVLB  3
2A84:  COMF   x5B,F
2A86:  MOVFF  02,35C
2A8A:  COMF   x5C,F
....................    checkSum.Val = header.Checksum;
2A8C:  MOVFF  35C,34A
2A90:  MOVFF  35B,349
.................... 
....................    // Write IP header.
....................    IPPutHeader(remote, IP_PROT_TCP, len);
2A94:  MOVFF  338,370
2A98:  MOVFF  337,36F
2A9C:  MOVLW  06
2A9E:  MOVWF  x71
2AA0:  MOVFF  348,373
2AA4:  MOVFF  347,372
2AA8:  MOVLB  0
2AAA:  RCALL  2806
....................    IPPutArray((BYTE*)&header, sizeof(header));
2AAC:  MOVLW  03
2AAE:  MOVLB  3
2AB0:  MOVWF  x70
2AB2:  MOVLW  4B
2AB4:  MOVWF  x6F
2AB6:  MOVFF  370,394
2ABA:  MOVWF  x93
2ABC:  CLRF   x96
2ABE:  MOVLW  14
2AC0:  MOVWF  x95
2AC2:  MOVLB  0
2AC4:  CALL   1608
.................... 
....................    if ( flags & SYN )
2AC8:  MOVLB  3
2ACA:  BTFSS  x45.1
2ACC:  BRA    2AEA
....................       IPPutArray((BYTE*)&options, sizeof(options));
2ACE:  MOVLW  03
2AD0:  MOVWF  x70
2AD2:  MOVLW  5F
2AD4:  MOVWF  x6F
2AD6:  MOVFF  370,394
2ADA:  MOVWF  x93
2ADC:  CLRF   x96
2ADE:  MOVLW  04
2AE0:  MOVWF  x95
2AE2:  MOVLB  0
2AE4:  CALL   1608
2AE8:  MOVLB  3
.................... 
....................    IPSetTxBuffer(buff, 0);
2AEA:  MOVFF  346,388
2AEE:  CLRF   x8A
2AF0:  MOVLW  14
2AF2:  MOVWF  x89
2AF4:  MOVLB  0
2AF6:  CALL   154C
.................... 
....................    checkSum.Val = CalcIPBufferChecksum(len);
2AFA:  MOVFF  348,370
2AFE:  MOVFF  347,36F
2B02:  CALL   1F96
2B06:  MOVFF  02,34A
2B0A:  MOVFF  01,349
.................... 
....................    // Update the checksum.
....................    IPSetTxBuffer(buff, 16);
2B0E:  MOVFF  346,388
2B12:  MOVLB  3
2B14:  CLRF   x8A
2B16:  MOVLW  24
2B18:  MOVWF  x89
2B1A:  MOVLB  0
2B1C:  CALL   154C
....................    MACPut(checkSum.v[1]);
2B20:  MOVFF  34A,392
2B24:  CALL   15EA
....................    MACPut(checkSum.v[0]);
2B28:  MOVFF  349,392
2B2C:  CALL   15EA
....................    MACSetTxBuffer(buff, 0);
2B30:  MOVFF  346,388
2B34:  MOVLB  3
2B36:  CLRF   x8A
2B38:  CLRF   x89
2B3A:  MOVLB  0
2B3C:  CALL   154C
.................... 
....................    MACFlush();
2B40:  CALL   1716
2B44:  MOVLB  3
.................... 
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/
....................    // If we send the packet again, the remote node might think that we timed
....................    // out and retransmitted.  It could thus immediately send back an ACK and
....................    // dramatically improve throuput.
....................    //while(!IPIsTxReady(TRUE));
....................    //MACFlush();
.................... #endif
2B46:  MOVLB  0
2B48:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h,
....................  *                                      NODE_INFO* remote)
....................  *
....................  * PreCondition:    TCPInit() is already called
....................  *
....................  * Input:           h           - TCP Header to be matched against.
....................  *                  remote      - Node who sent this header.
....................  *
....................  * Output:          A socket that matches with given header and remote
....................  *                  node is searched.
....................  *                  If such socket is found, its index is returned
....................  *                  else INVALID_SOCKET is returned.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote)
.................... {
....................    SOCKET_INFO *ps;
....................    TCP_SOCKET s;
....................    TCP_SOCKET partialMatch;
.................... 
....................    partialMatch = INVALID_SOCKET;
*
2302:  MOVLW  FE
2304:  MOVLB  3
2306:  MOVWF  x19
.................... 
....................    for ( s = 0; s < MAX_SOCKETS; s++ )
2308:  CLRF   x18
230A:  MOVF   x18,W
230C:  SUBLW  04
230E:  BTFSS  FD8.0
2310:  BRA    2406
....................    {
....................       ps = &TCB[s];
2312:  MOVF   x18,W
2314:  MULLW  24
2316:  MOVF   FF3,W
2318:  CLRF   03
231A:  ADDLW  88
231C:  MOVWF  01
231E:  MOVLW  00
2320:  ADDWFC 03,F
2322:  MOVFF  01,316
2326:  MOVFF  03,317
.................... 
....................       if ( ps->smState != TCP_CLOSED )
232A:  MOVFF  316,FE9
232E:  MOVFF  317,FEA
2332:  MOVF   FEF,W
2334:  SUBLW  0A
2336:  BZ    2402
....................       {
....................          if ( ps->localPort == h->DestPort )
2338:  MOVLW  0B
233A:  ADDWF  x16,W
233C:  MOVWF  FE9
233E:  MOVLW  00
2340:  ADDWFC x17,W
2342:  MOVWF  FEA
2344:  MOVFF  FEC,31B
2348:  MOVF   FED,F
234A:  MOVFF  FEF,31A
234E:  MOVLW  02
2350:  ADDWF  x12,W
2352:  MOVWF  FE9
2354:  MOVLW  00
2356:  ADDWFC x13,W
2358:  MOVWF  FEA
235A:  MOVFF  FEC,03
235E:  MOVF   FED,F
2360:  MOVF   FEF,W
2362:  SUBWF  x1A,W
2364:  BNZ   2402
2366:  MOVF   03,W
2368:  SUBWF  x1B,W
236A:  BNZ   2402
....................          {
....................             if ( ps->smState == TCP_LISTEN )
236C:  MOVFF  316,FE9
2370:  MOVFF  317,FEA
2374:  MOVF   FEF,F
2376:  BNZ   237C
....................                partialMatch = s;
2378:  MOVFF  318,319
.................... 
....................             if ( ps->remotePort == h->SourcePort &&
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val )
237C:  MOVLW  0D
237E:  ADDWF  x16,W
2380:  MOVWF  FE9
2382:  MOVLW  00
2384:  ADDWFC x17,W
2386:  MOVWF  FEA
2388:  MOVFF  FEC,31B
238C:  MOVF   FED,F
238E:  MOVFF  FEF,31A
2392:  MOVFF  312,FE9
2396:  MOVFF  313,FEA
239A:  MOVFF  FEC,03
239E:  MOVF   FED,F
23A0:  MOVF   FEF,W
23A2:  SUBWF  x1A,W
23A4:  BNZ   2402
23A6:  MOVF   03,W
23A8:  SUBWF  x1B,W
23AA:  BNZ   2402
23AC:  MOVLW  07
23AE:  ADDWF  x16,W
23B0:  MOVWF  FE9
23B2:  MOVLW  00
23B4:  ADDWFC x17,W
23B6:  MOVWF  FEA
23B8:  MOVFF  FEF,31A
23BC:  MOVFF  FEC,31B
23C0:  MOVFF  FEC,31C
23C4:  MOVFF  FEC,31D
23C8:  MOVLW  06
23CA:  ADDWF  x14,W
23CC:  MOVWF  FE9
23CE:  MOVLW  00
23D0:  ADDWFC x15,W
23D2:  MOVWF  FEA
23D4:  MOVFF  FEF,00
23D8:  MOVFF  FEC,01
23DC:  MOVFF  FEC,02
23E0:  MOVFF  FEC,03
23E4:  MOVF   00,W
23E6:  SUBWF  x1A,W
23E8:  BNZ   2402
23EA:  MOVF   01,W
23EC:  SUBWF  x1B,W
23EE:  BNZ   2402
23F0:  MOVF   02,W
23F2:  SUBWF  x1C,W
23F4:  BNZ   2402
23F6:  MOVF   03,W
23F8:  SUBWF  x1D,W
23FA:  BNZ   2402
....................             {
....................                return s;
23FC:  MOVFF  318,01
2400:  BRA    24DA
....................             }
....................          }
....................       }
2402:  INCF   x18,F
2404:  BRA    230A
....................    }
.................... 
....................    // We are not listening on this port
....................    if(partialMatch == INVALID_SOCKET)
2406:  MOVF   x19,W
2408:  SUBLW  FE
240A:  BNZ   2412
....................       return INVALID_SOCKET;
240C:  MOVLW  FE
240E:  MOVWF  01
2410:  BRA    24DA
.................... 
....................    // Copy the remote node IP/MAC address and source TCP port
....................    // number into our TCB and return this socket to the caller
....................    ps = &TCB[partialMatch];
2412:  MOVF   x19,W
2414:  MULLW  24
2416:  MOVF   FF3,W
2418:  CLRF   03
241A:  ADDLW  88
241C:  MOVWF  01
241E:  MOVLW  00
2420:  ADDWFC 03,F
2422:  MOVFF  01,316
2426:  MOVFF  03,317
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote));
242A:  MOVLW  01
242C:  ADDWF  x16,W
242E:  MOVWF  01
2430:  MOVLW  00
2432:  ADDWFC x17,W
2434:  MOVWF  03
2436:  MOVFF  01,31A
243A:  MOVWF  x1B
243C:  MOVWF  FEA
243E:  MOVFF  01,FE9
2442:  MOVFF  315,FE2
2446:  MOVFF  314,FE1
244A:  MOVLW  0A
244C:  MOVWF  01
244E:  MOVFF  FE6,FEE
2452:  DECFSZ 01,F
2454:  BRA    244E
....................    ps->remotePort          = h->SourcePort;
2456:  MOVLW  0D
2458:  ADDWF  x16,W
245A:  MOVWF  01
245C:  MOVLW  00
245E:  ADDWFC x17,W
2460:  MOVFF  312,FE9
2464:  MOVFF  313,FEA
2468:  MOVFF  FEC,03
246C:  MOVF   FED,F
246E:  MOVFF  FEF,31C
2472:  MOVWF  FEA
2474:  MOVFF  01,FE9
2478:  MOVFF  03,FEC
247C:  MOVF   FED,F
247E:  MOVFF  31C,FEF
....................    ps->Flags.bIsGetReady   = FALSE;
2482:  MOVLW  23
2484:  ADDWF  x16,W
2486:  MOVWF  FE9
2488:  MOVLW  00
248A:  ADDWFC x17,W
248C:  MOVWF  FEA
248E:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER)
2490:  MOVLW  0F
2492:  ADDWF  x16,W
2494:  MOVWF  FE9
2496:  MOVLW  00
2498:  ADDWFC x17,W
249A:  MOVWF  FEA
249C:  INCFSZ FEF,W
249E:  BRA    24A2
24A0:  BRA    24C8
....................    {
....................       MACDiscardTx(ps->TxBuffer);
24A2:  MOVLW  0F
24A4:  ADDWF  x16,W
24A6:  MOVWF  FE9
24A8:  MOVLW  00
24AA:  ADDWFC x17,W
24AC:  MOVWF  FEA
24AE:  MOVFF  FEF,333
24B2:  MOVLB  0
24B4:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER;
24B8:  MOVLW  0F
24BA:  MOVLB  3
24BC:  ADDWF  x16,W
24BE:  MOVWF  FE9
24C0:  MOVLW  00
24C2:  ADDWFC x17,W
24C4:  MOVWF  FEA
24C6:  SETF   FEF
....................    }
....................    ps->Flags.bIsPutReady   = TRUE;
24C8:  MOVLW  23
24CA:  ADDWF  x16,W
24CC:  MOVWF  FE9
24CE:  MOVLW  00
24D0:  ADDWFC x17,W
24D2:  MOVWF  FEA
24D4:  BSF    FEF.1
.................... 
....................    return partialMatch;
24D6:  MOVFF  319,01
24DA:  MOVLB  0
24DC:  GOTO   36A6 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           header      - TCP Header to be swapped.
....................  *
....................  * Output:          Given header is swapped.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void SwapTCPHeader(TCP_HEADER* header)
.................... {
....................     header->SourcePort      = swaps(header->SourcePort);
*
212A:  MOVFF  36F,01
212E:  MOVFF  370,372
2132:  MOVFF  01,371
2136:  MOVFF  36F,FE9
213A:  MOVFF  370,FEA
213E:  MOVFF  FEC,38F
2142:  MOVF   FED,F
2144:  MOVFF  FEF,38E
2148:  MOVLB  0
214A:  CALL   122C
214E:  MOVFF  372,FEA
2152:  MOVFF  371,FE9
2156:  MOVFF  02,FEC
215A:  MOVF   FED,F
215C:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort);
2160:  MOVLW  02
2162:  MOVLB  3
2164:  ADDWF  x6F,W
2166:  MOVWF  01
2168:  MOVLW  00
216A:  ADDWFC x70,W
216C:  MOVWF  03
216E:  MOVFF  01,371
2172:  MOVWF  x72
2174:  MOVLW  02
2176:  ADDWF  x6F,W
2178:  MOVWF  FE9
217A:  MOVLW  00
217C:  ADDWFC x70,W
217E:  MOVWF  FEA
2180:  MOVFF  FEC,38F
2184:  MOVF   FED,F
2186:  MOVFF  FEF,38E
218A:  MOVLB  0
218C:  CALL   122C
2190:  MOVFF  372,FEA
2194:  MOVFF  371,FE9
2198:  MOVFF  02,FEC
219C:  MOVF   FED,F
219E:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber);
21A2:  MOVLW  04
21A4:  MOVLB  3
21A6:  ADDWF  x6F,W
21A8:  MOVWF  01
21AA:  MOVLW  00
21AC:  ADDWFC x70,W
21AE:  MOVWF  03
21B0:  MOVFF  01,371
21B4:  MOVWF  x72
21B6:  MOVLW  04
21B8:  ADDWF  x6F,W
21BA:  MOVWF  FE9
21BC:  MOVLW  00
21BE:  ADDWFC x70,W
21C0:  MOVWF  FEA
21C2:  MOVFF  FEF,377
21C6:  MOVFF  FEC,378
21CA:  MOVFF  FEC,379
21CE:  MOVFF  FEC,37A
21D2:  MOVLB  0
21D4:  RCALL  2108
21D6:  MOVFF  372,FEA
21DA:  MOVFF  371,FE9
21DE:  MOVFF  00,FEF
21E2:  MOVFF  01,FEC
21E6:  MOVFF  02,FEC
21EA:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber);
21EE:  MOVLW  08
21F0:  MOVLB  3
21F2:  ADDWF  x6F,W
21F4:  MOVWF  01
21F6:  MOVLW  00
21F8:  ADDWFC x70,W
21FA:  MOVWF  03
21FC:  MOVFF  01,371
2200:  MOVWF  x72
2202:  MOVLW  08
2204:  ADDWF  x6F,W
2206:  MOVWF  FE9
2208:  MOVLW  00
220A:  ADDWFC x70,W
220C:  MOVWF  FEA
220E:  MOVFF  FEF,377
2212:  MOVFF  FEC,378
2216:  MOVFF  FEC,379
221A:  MOVFF  FEC,37A
221E:  MOVLB  0
2220:  RCALL  2108
2222:  MOVFF  372,FEA
2226:  MOVFF  371,FE9
222A:  MOVFF  00,FEF
222E:  MOVFF  01,FEC
2232:  MOVFF  02,FEC
2236:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window);
223A:  MOVLW  0E
223C:  MOVLB  3
223E:  ADDWF  x6F,W
2240:  MOVWF  01
2242:  MOVLW  00
2244:  ADDWFC x70,W
2246:  MOVWF  03
2248:  MOVFF  01,371
224C:  MOVWF  x72
224E:  MOVLW  0E
2250:  ADDWF  x6F,W
2252:  MOVWF  FE9
2254:  MOVLW  00
2256:  ADDWFC x70,W
2258:  MOVWF  FEA
225A:  MOVFF  FEC,38F
225E:  MOVF   FED,F
2260:  MOVFF  FEF,38E
2264:  MOVLB  0
2266:  CALL   122C
226A:  MOVFF  372,FEA
226E:  MOVFF  371,FE9
2272:  MOVFF  02,FEC
2276:  MOVF   FED,F
2278:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum);
227C:  MOVLW  10
227E:  MOVLB  3
2280:  ADDWF  x6F,W
2282:  MOVWF  01
2284:  MOVLW  00
2286:  ADDWFC x70,W
2288:  MOVWF  03
228A:  MOVFF  01,371
228E:  MOVWF  x72
2290:  MOVLW  10
2292:  ADDWF  x6F,W
2294:  MOVWF  FE9
2296:  MOVLW  00
2298:  ADDWFC x70,W
229A:  MOVWF  FEA
229C:  MOVFF  FEC,38F
22A0:  MOVF   FED,F
22A2:  MOVFF  FEF,38E
22A6:  MOVLB  0
22A8:  CALL   122C
22AC:  MOVFF  372,FEA
22B0:  MOVFF  371,FE9
22B4:  MOVFF  02,FEC
22B8:  MOVF   FED,F
22BA:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer);
22BE:  MOVLW  12
22C0:  MOVLB  3
22C2:  ADDWF  x6F,W
22C4:  MOVWF  01
22C6:  MOVLW  00
22C8:  ADDWFC x70,W
22CA:  MOVWF  03
22CC:  MOVFF  01,371
22D0:  MOVWF  x72
22D2:  MOVLW  12
22D4:  ADDWF  x6F,W
22D6:  MOVWF  FE9
22D8:  MOVLW  00
22DA:  ADDWFC x70,W
22DC:  MOVWF  FEA
22DE:  MOVFF  FEC,38F
22E2:  MOVF   FED,F
22E4:  MOVFF  FEF,38E
22E8:  MOVLB  0
22EA:  CALL   122C
22EE:  MOVFF  372,FEA
22F2:  MOVFF  371,FE9
22F6:  MOVFF  02,FEC
22FA:  MOVF   FED,F
22FC:  MOVFF  01,FEF
2300:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps)
....................  *
....................  * PreCondition:    TCPInit() is already called
....................  *
....................  * Input:           ps  - Pointer to a socket info that is to be
....................  *                          closed.
....................  *
....................  * Output:          Given socket information is reset and any
....................  *                  buffer held by this socket is discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void CloseSocket(SOCKET_INFO* ps)
.................... {
....................    debug_tcp("\r\nTCP SOCKET CLOSED");
.................... 
....................     if ( ps->TxBuffer != INVALID_BUFFER )
*
24FA:  MOVLW  0F
24FC:  MOVLB  3
24FE:  ADDWF  x30,W
2500:  MOVWF  FE9
2502:  MOVLW  00
2504:  ADDWFC x31,W
2506:  MOVWF  FEA
2508:  INCFSZ FEF,W
250A:  BRA    250E
250C:  BRA    2542
....................     {
....................         MACDiscardTx(ps->TxBuffer);
250E:  MOVLW  0F
2510:  ADDWF  x30,W
2512:  MOVWF  FE9
2514:  MOVLW  00
2516:  ADDWFC x31,W
2518:  MOVWF  FEA
251A:  MOVFF  FEF,333
251E:  MOVLB  0
2520:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER;
2524:  MOVLW  0F
2526:  MOVLB  3
2528:  ADDWF  x30,W
252A:  MOVWF  FE9
252C:  MOVLW  00
252E:  ADDWFC x31,W
2530:  MOVWF  FEA
2532:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE;
2534:  MOVLW  23
2536:  ADDWF  x30,W
2538:  MOVWF  FE9
253A:  MOVLW  00
253C:  ADDWFC x31,W
253E:  MOVWF  FEA
2540:  BSF    FEF.1
....................     }
.................... 
....................     ps->remote.IPAddr.Val = 0x00;
2542:  MOVLW  07
2544:  ADDWF  x30,W
2546:  MOVWF  FE9
2548:  MOVLW  00
254A:  ADDWFC x31,W
254C:  MOVWF  FEA
254E:  CLRF   FEF
2550:  CLRF   FEC
2552:  CLRF   FEC
2554:  CLRF   FEC
....................     ps->remotePort = 0x00;
2556:  MOVLW  0D
2558:  ADDWF  x30,W
255A:  MOVWF  FE9
255C:  MOVLW  00
255E:  ADDWFC x31,W
2560:  MOVWF  FEA
2562:  CLRF   FEC
2564:  MOVF   FED,F
2566:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady )
2568:  MOVLW  23
256A:  ADDWF  x30,W
256C:  MOVWF  FE9
256E:  MOVLW  00
2570:  ADDWFC x31,W
2572:  MOVWF  FEA
2574:  BTFSS  FEF.3
2576:  BRA    2580
....................     {
....................         MACDiscardRx();
2578:  MOVLB  0
257A:  CALL   1160
257E:  MOVLB  3
....................     }
....................     ps->Flags.bIsGetReady       = FALSE;
2580:  MOVLW  23
2582:  ADDWF  x30,W
2584:  MOVWF  FE9
2586:  MOVLW  00
2588:  ADDWFC x31,W
258A:  MOVWF  FEA
258C:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL;
258E:  MOVLW  21
2590:  ADDWF  x30,W
2592:  MOVWF  FE9
2594:  MOVLW  00
2596:  ADDWFC x31,W
2598:  MOVWF  FEA
259A:  CLRF   FEC
259C:  MOVF   FED,F
259E:  MOVLW  1E
25A0:  MOVWF  FEF
.................... 
....................     ps->Flags.bIsTxInProgress   = FALSE;
25A2:  MOVLW  23
25A4:  ADDWF  x30,W
25A6:  MOVWF  FE9
25A8:  MOVLW  00
25AA:  ADDWFC x31,W
25AC:  MOVWF  FEA
25AE:  BCF    FEF.4
.................... 
....................     if ( ps->Flags.bServer )
25B0:  MOVLW  23
25B2:  ADDWF  x30,W
25B4:  MOVWF  FE9
25B6:  MOVLW  00
25B8:  ADDWFC x31,W
25BA:  MOVWF  FEA
25BC:  BTFSS  FEF.0
25BE:  BRA    25CC
....................     {
....................         ps->smState = TCP_LISTEN;
25C0:  MOVFF  330,FE9
25C4:  MOVFF  331,FEA
25C8:  CLRF   FEF
....................     }
25CA:  BRA    25D8
....................     else
....................     {
....................         ps->smState = TCP_CLOSED;
25CC:  MOVFF  330,FE9
25D0:  MOVFF  331,FEA
25D4:  MOVLW  0A
25D6:  MOVWF  FEF
....................     }
.................... 
....................    ps->TxCount = 0;
25D8:  MOVLW  10
25DA:  ADDWF  x30,W
25DC:  MOVWF  FE9
25DE:  MOVLW  00
25E0:  ADDWFC x31,W
25E2:  MOVWF  FEA
25E4:  CLRF   FEC
25E6:  MOVF   FED,F
25E8:  CLRF   FEF
.................... 
....................     return;
25EA:  MOVLB  0
25EC:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s,
.................... *                                      NODE_INFO *remote,
.................... *                                      TCP_HEADER* h,
.................... *                                      WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPProcess() is the caller.
.................... *
.................... * Input:           s           - Socket that owns this segment
.................... *                  remote      - Remote node info
.................... *                  h           - TCP Header
.................... *                  len         - Total buffer length.
.................... *
.................... * Output:          TCP FSM is executed on given socket with
.................... *                  given TCP segment.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... static void HandleTCPSeg(TCP_SOCKET s,
....................                    NODE_INFO *remote,
....................                    TCP_HEADER *h,
....................                    WORD len)
.................... {
....................    DWORD ack;
....................    DWORD seq;
....................    DWORD prevAck, prevSeq;
....................    SOCKET_INFO *ps;
....................    BYTE flags;
....................    //BYTE debugLastState;
....................    signed int32 temp;
.................... 
....................    ps = &TCB[s];
*
2B4A:  MOVLB  3
2B4C:  MOVF   x12,W
2B4E:  MULLW  24
2B50:  MOVF   FF3,W
2B52:  CLRF   03
2B54:  ADDLW  88
2B56:  MOVWF  01
2B58:  MOVLW  00
2B5A:  ADDWFC 03,F
2B5C:  MOVFF  01,329
2B60:  MOVFF  03,32A
....................    //debugLastState = TCB[s].smState;
.................... 
....................    flags = 0x00;
2B64:  CLRF   x2B
.................... 
....................    // Clear timeout info
....................    ps->RetryCount  = 0;
2B66:  MOVLW  1E
2B68:  ADDWF  x29,W
2B6A:  MOVWF  FE9
2B6C:  MOVLW  00
2B6E:  ADDWFC x2A,W
2B70:  MOVWF  FEA
2B72:  CLRF   FEF
....................    ps->startTick   = TickGet();
2B74:  MOVLW  1F
2B76:  ADDWF  x29,W
2B78:  MOVWF  01
2B7A:  MOVLW  00
2B7C:  ADDWFC x2A,W
2B7E:  MOVWF  03
2B80:  MOVFF  01,330
2B84:  MOVWF  x31
2B86:  MOVLB  0
2B88:  RCALL  24E0
2B8A:  MOVFF  331,FEA
2B8E:  MOVFF  330,FE9
2B92:  MOVFF  02,FEC
2B96:  MOVF   FED,F
2B98:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL;
2B9C:  MOVLW  21
2B9E:  MOVLB  3
2BA0:  ADDWF  x29,W
2BA2:  MOVWF  FE9
2BA4:  MOVLW  00
2BA6:  ADDWFC x2A,W
2BA8:  MOVWF  FEA
2BAA:  CLRF   FEC
2BAC:  MOVF   FED,F
2BAE:  MOVLW  1E
2BB0:  MOVWF  FEF
.................... 
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n",
....................       h->SourcePort,
....................       h->DestPort,
....................       h->SeqNumber,
....................       h->AckNumber,
....................       len,
....................       h->Flags
....................    );
.................... 
.................... 
....................    // Reset FSM, if RST is received.
....................    if(h->Flags.bits.flagRST)
2BB2:  MOVLW  0D
2BB4:  ADDWF  x15,W
2BB6:  MOVWF  FE9
2BB8:  MOVLW  00
2BBA:  ADDWFC x16,W
2BBC:  MOVWF  FEA
2BBE:  BTFSS  FEF.2
2BC0:  BRA    2BF6
....................    {
....................       MACDiscardRx();
2BC2:  MOVLB  0
2BC4:  CALL   1160
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT;
2BC8:  MOVLB  3
2BCA:  MOVFF  329,330
2BCE:  MOVFF  32A,331
2BD2:  MOVLW  23
2BD4:  ADDWF  x29,W
2BD6:  MOVWF  FE9
2BD8:  MOVLW  00
2BDA:  ADDWFC x2A,W
2BDC:  MOVWF  FEA
2BDE:  BTFSS  FEF.0
2BE0:  BRA    2BE6
2BE2:  MOVLW  00
2BE4:  BRA    2BE8
2BE6:  MOVLW  01
2BE8:  MOVFF  331,FEA
2BEC:  MOVFF  330,FE9
2BF0:  MOVWF  FEF
....................       return;
2BF2:  GOTO   353E
....................    }
.................... 
....................    seq = ps->SND_SEQ;
2BF6:  MOVLW  16
2BF8:  ADDWF  x29,W
2BFA:  MOVWF  FE9
2BFC:  MOVLW  00
2BFE:  ADDWFC x2A,W
2C00:  MOVWF  FEA
2C02:  MOVFF  FEF,31D
2C06:  MOVFF  FEC,31E
2C0A:  MOVFF  FEC,31F
2C0E:  MOVFF  FEC,320
.................... 
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount;
2C12:  MOVLW  0E
2C14:  ADDWF  x15,W
2C16:  MOVWF  FE9
2C18:  MOVLW  00
2C1A:  ADDWFC x16,W
2C1C:  MOVWF  FEA
2C1E:  MOVFF  FEC,331
2C22:  MOVF   FED,F
2C24:  MOVFF  FEF,330
2C28:  CLRF   x32
2C2A:  CLRF   x33
2C2C:  MOVLW  08
2C2E:  ADDWF  x15,W
2C30:  MOVWF  FE9
2C32:  MOVLW  00
2C34:  ADDWFC x16,W
2C36:  MOVWF  FEA
2C38:  MOVFF  FEF,00
2C3C:  MOVFF  FEC,01
2C40:  MOVFF  FEC,02
2C44:  MOVFF  FEC,03
2C48:  MOVF   00,W
2C4A:  SUBWF  x1D,W
2C4C:  MOVWF  00
2C4E:  MOVF   01,W
2C50:  SUBWFB x1E,W
2C52:  MOVWF  01
2C54:  MOVF   02,W
2C56:  SUBWFB x1F,W
2C58:  MOVWF  02
2C5A:  MOVF   03,W
2C5C:  SUBWFB x20,W
2C5E:  MOVWF  03
2C60:  MOVF   00,W
2C62:  SUBWF  x30,F
2C64:  MOVF   01,W
2C66:  SUBWFB x31,F
2C68:  MOVF   02,W
2C6A:  SUBWFB x32,F
2C6C:  MOVF   03,W
2C6E:  SUBWFB x33,F
2C70:  MOVLW  10
2C72:  ADDWF  x29,W
2C74:  MOVWF  FE9
2C76:  MOVLW  00
2C78:  ADDWFC x2A,W
2C7A:  MOVWF  FEA
2C7C:  MOVFF  FEC,03
2C80:  MOVF   FED,F
2C82:  MOVFF  FEF,00
2C86:  MOVFF  03,01
2C8A:  CLRF   02
2C8C:  CLRF   03
2C8E:  MOVF   00,W
2C90:  SUBWF  x30,W
2C92:  MOVWF  x2C
2C94:  MOVF   01,W
2C96:  SUBWFB x31,W
2C98:  MOVWF  x2D
2C9A:  MOVF   02,W
2C9C:  SUBWFB x32,W
2C9E:  MOVWF  x2E
2CA0:  MOVF   03,W
2CA2:  SUBWFB x33,W
2CA4:  MOVWF  x2F
....................    if(temp < 0)
2CA6:  BTFSS  x2F.7
2CA8:  BRA    2CBE
....................    {
....................       ps->RemoteWindow = 0;
2CAA:  MOVLW  14
2CAC:  ADDWF  x29,W
2CAE:  MOVWF  FE9
2CB0:  MOVLW  00
2CB2:  ADDWFC x2A,W
2CB4:  MOVWF  FEA
2CB6:  CLRF   FEC
2CB8:  MOVF   FED,F
2CBA:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n",
....................             ps->RemoteWindow,
....................             temp,
....................             h->Window,
....................             seq,
....................             h->AckNumber,
....................             ps->TxCount
....................          );
....................    }
2CBC:  BRA    2CD2
....................    else
....................    {
....................       ps->RemoteWindow = ack;
2CBE:  MOVLW  14
2CC0:  ADDWF  x29,W
2CC2:  MOVWF  FE9
2CC4:  MOVLW  00
2CC6:  ADDWFC x2A,W
2CC8:  MOVWF  FEA
2CCA:  MOVFF  319,FEF
2CCE:  MOVFF  31A,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow);
....................    }
.................... 
....................    // Handle TCP_SYN_SENT state
....................    // The TCP_SYN_SENT state occurs when an application
....................    // calls TCPConnect().  After an initial SYN is sent,
....................    // we expect a SYN + ACK before establishing the
....................    // connection.
....................    if(ps->smState == TCP_SYN_SENT)
2CD2:  MOVFF  329,FE9
2CD6:  MOVFF  32A,FEA
2CDA:  DECFSZ FEF,W
2CDC:  BRA    2E48
....................    {
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot
....................       // handle any other packet types.
....................       if(!h->Flags.bits.flagSYN)
2CDE:  MOVLW  0D
2CE0:  ADDWF  x15,W
2CE2:  MOVWF  FE9
2CE4:  MOVLW  00
2CE6:  ADDWFC x16,W
2CE8:  MOVWF  FEA
2CEA:  BTFSC  FEF.1
2CEC:  BRA    2D12
....................       {
....................          MACDiscardRx();
2CEE:  MOVLB  0
2CF0:  CALL   1160
.................... 
....................          // Send out a RESET if the remote node thinks a connection is already established
....................           if(h->Flags.bits.flagACK)
2CF4:  MOVLW  0D
2CF6:  MOVLB  3
2CF8:  ADDWF  x15,W
2CFA:  MOVWF  FE9
2CFC:  MOVLW  00
2CFE:  ADDWFC x16,W
2D00:  MOVWF  FEA
2D02:  BTFSS  FEF.4
2D04:  BRA    2D0E
....................           {
....................             flags = RST;
2D06:  MOVLW  04
2D08:  MOVWF  x2B
....................             goto SendTCPControlPacket;
2D0A:  GOTO   34D6
....................            }
.................... 
....................          return;
2D0E:  GOTO   353E
....................       }
.................... 
....................       // We now have a sequence number for the remote node
....................       ps->SND_ACK = h->SeqNumber + len + 1;
2D12:  MOVLW  1A
2D14:  ADDWF  x29,W
2D16:  MOVWF  01
2D18:  MOVLW  00
2D1A:  ADDWFC x2A,W
2D1C:  MOVFF  01,330
2D20:  MOVWF  x31
2D22:  MOVLW  04
2D24:  ADDWF  x15,W
2D26:  MOVWF  FE9
2D28:  MOVLW  00
2D2A:  ADDWFC x16,W
2D2C:  MOVWF  FEA
2D2E:  MOVFF  FEF,332
2D32:  MOVFF  FEC,333
2D36:  MOVFF  FEC,334
2D3A:  MOVFF  FEC,335
2D3E:  MOVF   x17,W
2D40:  ADDWF  x32,F
2D42:  MOVF   x18,W
2D44:  ADDWFC x33,F
2D46:  MOVLW  00
2D48:  ADDWFC x34,F
2D4A:  ADDWFC x35,F
2D4C:  MOVLW  01
2D4E:  ADDWF  x32,W
2D50:  MOVWF  00
2D52:  MOVLW  00
2D54:  ADDWFC x33,W
2D56:  MOVWF  01
2D58:  MOVLW  00
2D5A:  ADDWFC x34,W
2D5C:  MOVWF  02
2D5E:  MOVLW  00
2D60:  ADDWFC x35,W
2D62:  MOVFF  331,FEA
2D66:  MOVFF  330,FE9
2D6A:  MOVFF  00,FEF
2D6E:  MOVFF  01,FEC
2D72:  MOVFF  02,FEC
2D76:  MOVWF  FEC
....................       ack = ps->SND_ACK;
2D78:  MOVLW  1A
2D7A:  ADDWF  x29,W
2D7C:  MOVWF  FE9
2D7E:  MOVLW  00
2D80:  ADDWFC x2A,W
2D82:  MOVWF  FEA
2D84:  MOVFF  FEF,319
2D88:  MOVFF  FEC,31A
2D8C:  MOVFF  FEC,31B
2D90:  MOVFF  FEC,31C
.................... 
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK,
....................       // we can establish the connection now.
....................       if(!h->Flags.bits.flagACK)
2D94:  MOVLW  0D
2D96:  ADDWF  x15,W
2D98:  MOVWF  FE9
2D9A:  MOVLW  00
2D9C:  ADDWFC x16,W
2D9E:  MOVWF  FEA
2DA0:  BTFSC  FEF.4
2DA2:  BRA    2DBE
....................       {
....................          ps->smState = TCP_SYN_RECEIVED;
2DA4:  MOVFF  329,FE9
2DA8:  MOVFF  32A,FEA
2DAC:  MOVLW  02
2DAE:  MOVWF  FEF
....................          MACDiscardRx();
2DB0:  MOVLB  0
2DB2:  CALL   1160
....................          // Send out a SYN+ACK for simultaneous connection open
....................          flags = SYN | ACK;
2DB6:  MOVLW  12
2DB8:  MOVLB  3
2DBA:  MOVWF  x2B
....................          goto SendTCPControlPacket;
2DBC:  BRA    34D6
....................       }
.................... 
....................       // We received SYN+ACK, establish the connection now
....................       ps->smState = TCP_ESTABLISHED;
2DBE:  MOVFF  329,FE9
2DC2:  MOVFF  32A,FEA
2DC6:  MOVLW  03
2DC8:  MOVWF  FEF
....................       // Send out an ACK
....................       flags = ACK;
2DCA:  MOVLW  10
2DCC:  MOVWF  x2B
.................... 
....................       ps->RemoteWindow = h->Window;
2DCE:  MOVLW  14
2DD0:  ADDWF  x29,W
2DD2:  MOVWF  01
2DD4:  MOVLW  00
2DD6:  ADDWFC x2A,W
2DD8:  MOVWF  03
2DDA:  MOVWF  x31
2DDC:  MOVLW  0E
2DDE:  ADDWF  x15,W
2DE0:  MOVWF  FE9
2DE2:  MOVLW  00
2DE4:  ADDWFC x16,W
2DE6:  MOVWF  FEA
2DE8:  MOVFF  FEC,03
2DEC:  MOVF   FED,F
2DEE:  MOVFF  FEF,332
2DF2:  MOVFF  331,FEA
2DF6:  MOVFF  01,FE9
2DFA:  MOVFF  03,FEC
2DFE:  MOVF   FED,F
2E00:  MOVFF  332,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow);
.................... 
....................       // Check for application data and make it
....................       // available, if present
....................       if(len)
2E04:  MOVF   x17,W
2E06:  IORWF  x18,W
2E08:  BZ    2E3E
....................       {
....................          ps->Flags.bIsGetReady   = TRUE;
2E0A:  MOVLW  23
2E0C:  ADDWF  x29,W
2E0E:  MOVWF  FE9
2E10:  MOVLW  00
2E12:  ADDWFC x2A,W
2E14:  MOVWF  FEA
2E16:  BSF    FEF.3
....................          ps->RxCount             = len;
2E18:  MOVLW  12
2E1A:  ADDWF  x29,W
2E1C:  MOVWF  FE9
2E1E:  MOVLW  00
2E20:  ADDWFC x2A,W
2E22:  MOVWF  FEA
2E24:  MOVFF  318,FEC
2E28:  MOVF   FED,F
2E2A:  MOVFF  317,FEF
....................          ps->Flags.bFirstRead    = TRUE;
2E2E:  MOVLW  23
2E30:  ADDWF  x29,W
2E32:  MOVWF  FE9
2E34:  MOVLW  00
2E36:  ADDWFC x2A,W
2E38:  MOVWF  FEA
2E3A:  BSF    FEF.2
....................       }
2E3C:  BRA    2E46
....................       else   // No application data in this packet
....................       {
....................          MACDiscardRx();
2E3E:  MOVLB  0
2E40:  CALL   1160
2E44:  MOVLB  3
....................       }
....................       goto SendTCPControlPacket;
2E46:  BRA    34D6
....................    }
.................... 
....................    // Handle TCP_LISTEN state
....................    if(ps->smState == TCP_LISTEN )
2E48:  MOVFF  329,FE9
2E4C:  MOVFF  32A,FEA
2E50:  MOVF   FEF,F
2E52:  BTFSS  FD8.2
2E54:  BRA    2FC4
....................    {
....................       MACDiscardRx();
2E56:  MOVLB  0
2E58:  CALL   1160
.................... 
....................       // Send a RST if this isn't a SYN packet
....................       if(!h->Flags.bits.flagSYN)
2E5C:  MOVLW  0D
2E5E:  MOVLB  3
2E60:  ADDWF  x15,W
2E62:  MOVWF  FE9
2E64:  MOVLW  00
2E66:  ADDWFC x16,W
2E68:  MOVWF  FEA
2E6A:  BTFSC  FEF.1
2E6C:  BRA    2E74
....................       {
....................          flags = RST;
2E6E:  MOVLW  04
2E70:  MOVWF  x2B
....................          goto SendTCPControlPacket;
2E72:  BRA    34D6
....................       }
.................... 
....................       ps->SND_ACK = h->SeqNumber + len + 1;
2E74:  MOVLW  1A
2E76:  ADDWF  x29,W
2E78:  MOVWF  01
2E7A:  MOVLW  00
2E7C:  ADDWFC x2A,W
2E7E:  MOVFF  01,330
2E82:  MOVWF  x31
2E84:  MOVLW  04
2E86:  ADDWF  x15,W
2E88:  MOVWF  FE9
2E8A:  MOVLW  00
2E8C:  ADDWFC x16,W
2E8E:  MOVWF  FEA
2E90:  MOVFF  FEF,332
2E94:  MOVFF  FEC,333
2E98:  MOVFF  FEC,334
2E9C:  MOVFF  FEC,335
2EA0:  MOVF   x17,W
2EA2:  ADDWF  x32,F
2EA4:  MOVF   x18,W
2EA6:  ADDWFC x33,F
2EA8:  MOVLW  00
2EAA:  ADDWFC x34,F
2EAC:  ADDWFC x35,F
2EAE:  MOVLW  01
2EB0:  ADDWF  x32,W
2EB2:  MOVWF  00
2EB4:  MOVLW  00
2EB6:  ADDWFC x33,W
2EB8:  MOVWF  01
2EBA:  MOVLW  00
2EBC:  ADDWFC x34,W
2EBE:  MOVWF  02
2EC0:  MOVLW  00
2EC2:  ADDWFC x35,W
2EC4:  MOVFF  331,FEA
2EC8:  MOVFF  330,FE9
2ECC:  MOVFF  00,FEF
2ED0:  MOVFF  01,FEC
2ED4:  MOVFF  02,FEC
2ED8:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window;
2EDA:  MOVLW  14
2EDC:  ADDWF  x29,W
2EDE:  MOVWF  01
2EE0:  MOVLW  00
2EE2:  ADDWFC x2A,W
2EE4:  MOVWF  03
2EE6:  MOVWF  x31
2EE8:  MOVLW  0E
2EEA:  ADDWF  x15,W
2EEC:  MOVWF  FE9
2EEE:  MOVLW  00
2EF0:  ADDWFC x16,W
2EF2:  MOVWF  FEA
2EF4:  MOVFF  FEC,03
2EF8:  MOVF   FED,F
2EFA:  MOVFF  FEF,332
2EFE:  MOVFF  331,FEA
2F02:  MOVFF  01,FE9
2F06:  MOVFF  03,FEC
2F0A:  MOVF   FED,F
2F0C:  MOVFF  332,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow);
.................... 
....................       // This socket has received connection request (SYN).
....................       // Remember calling node, assign next segment seq. number
....................       // for this potential connection.
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote));
2F10:  MOVLW  01
2F12:  ADDWF  x29,W
2F14:  MOVWF  01
2F16:  MOVLW  00
2F18:  ADDWFC x2A,W
2F1A:  MOVWF  03
2F1C:  MOVFF  01,330
2F20:  MOVWF  x31
2F22:  MOVWF  FEA
2F24:  MOVFF  01,FE9
2F28:  MOVFF  314,FE2
2F2C:  MOVFF  313,FE1
2F30:  MOVLW  0A
2F32:  MOVWF  01
2F34:  MOVFF  FE6,FEE
2F38:  DECFSZ 01,F
2F3A:  BRA    2F34
....................       ps->remotePort = h->SourcePort;
2F3C:  MOVLW  0D
2F3E:  ADDWF  x29,W
2F40:  MOVWF  01
2F42:  MOVLW  00
2F44:  ADDWFC x2A,W
2F46:  MOVFF  315,FE9
2F4A:  MOVFF  316,FEA
2F4E:  MOVFF  FEC,03
2F52:  MOVF   FED,F
2F54:  MOVFF  FEF,332
2F58:  MOVWF  FEA
2F5A:  MOVFF  01,FE9
2F5E:  MOVFF  03,FEC
2F62:  MOVF   FED,F
2F64:  MOVFF  332,FEF
.................... 
....................       // Grant connection request.
....................       ps->smState = TCP_SYN_RECEIVED;
2F68:  MOVFF  329,FE9
2F6C:  MOVFF  32A,FEA
2F70:  MOVLW  02
2F72:  MOVWF  FEF
....................       seq = ps->SND_SEQ++;
2F74:  MOVLW  16
2F76:  ADDWF  x29,W
2F78:  MOVWF  FE9
2F7A:  MOVLW  00
2F7C:  ADDWFC x2A,W
2F7E:  MOVWF  FEA
2F80:  MOVF   FEE,F
2F82:  MOVF   FEE,F
2F84:  MOVF   FEE,F
2F86:  MOVFF  FED,320
2F8A:  MOVFF  FED,31F
2F8E:  MOVFF  FED,31E
2F92:  MOVFF  FEF,31D
2F96:  MOVLW  01
2F98:  ADDWF  FEE,F
2F9A:  MOVLW  00
2F9C:  ADDWFC FEE,F
2F9E:  ADDWFC FEE,F
2FA0:  ADDWFC FED,F
....................       ack =  ps->SND_ACK;
2FA2:  MOVLW  1A
2FA4:  ADDWF  x29,W
2FA6:  MOVWF  FE9
2FA8:  MOVLW  00
2FAA:  ADDWFC x2A,W
2FAC:  MOVWF  FEA
2FAE:  MOVFF  FEF,319
2FB2:  MOVFF  FEC,31A
2FB6:  MOVFF  FEC,31B
2FBA:  MOVFF  FEC,31C
....................       flags = SYN | ACK;
2FBE:  MOVLW  12
2FC0:  MOVWF  x2B
....................       goto SendTCPControlPacket;
2FC2:  BRA    34D6
....................    }
.................... 
.................... 
....................    // Remember current seq and ack for our connection so that if
....................    // we have to silently discard this packet, we can go back to
....................    // previous ack and seq numbers.
....................    prevAck = ps->SND_ACK;
2FC4:  MOVLW  1A
2FC6:  ADDWF  x29,W
2FC8:  MOVWF  FE9
2FCA:  MOVLW  00
2FCC:  ADDWFC x2A,W
2FCE:  MOVWF  FEA
2FD0:  MOVFF  FEF,321
2FD4:  MOVFF  FEC,322
2FD8:  MOVFF  FEC,323
2FDC:  MOVFF  FEC,324
....................    prevSeq = ps->SND_SEQ;
2FE0:  MOVLW  16
2FE2:  ADDWF  x29,W
2FE4:  MOVWF  FE9
2FE6:  MOVLW  00
2FE8:  ADDWFC x2A,W
2FEA:  MOVWF  FEA
2FEC:  MOVFF  FEF,325
2FF0:  MOVFF  FEC,326
2FF4:  MOVFF  FEC,327
2FF8:  MOVFF  FEC,328
.................... 
....................    ack = h->SeqNumber;
2FFC:  MOVLW  04
2FFE:  ADDWF  x15,W
3000:  MOVWF  FE9
3002:  MOVLW  00
3004:  ADDWFC x16,W
3006:  MOVWF  FEA
3008:  MOVFF  FEF,319
300C:  MOVFF  FEC,31A
3010:  MOVFF  FEC,31B
3014:  MOVFF  FEC,31C
....................    ack += (DWORD)len;
3018:  MOVFF  317,00
301C:  MOVFF  318,01
3020:  CLRF   02
3022:  CLRF   03
3024:  MOVF   00,W
3026:  ADDWF  x19,F
3028:  MOVF   01,W
302A:  ADDWFC x1A,F
302C:  MOVF   02,W
302E:  ADDWFC x1B,F
3030:  MOVF   03,W
3032:  ADDWFC x1C,F
....................    seq = ps->SND_SEQ;
3034:  MOVLW  16
3036:  ADDWF  x29,W
3038:  MOVWF  FE9
303A:  MOVLW  00
303C:  ADDWFC x2A,W
303E:  MOVWF  FEA
3040:  MOVFF  FEF,31D
3044:  MOVFF  FEC,31E
3048:  MOVFF  FEC,31F
304C:  MOVFF  FEC,320
.................... 
....................    // State is something other than TCP_LISTEN, handle it.
....................    {
....................       // Check to see if the incomming sequence number is what
....................       // we expect (last transmitted ACK value).  Throw this packet
....................       // away if it is wrong.
....................       if(h->SeqNumber == prevAck)
3050:  MOVLW  04
3052:  ADDWF  x15,W
3054:  MOVWF  FE9
3056:  MOVLW  00
3058:  ADDWFC x16,W
305A:  MOVWF  FEA
305C:  MOVFF  FEF,330
3060:  MOVFF  FEC,331
3064:  MOVFF  FEC,332
3068:  MOVFF  FEC,333
306C:  MOVF   x21,W
306E:  SUBWF  x30,W
3070:  BTFSS  FD8.2
3072:  BRA    34BA
3074:  MOVF   x22,W
3076:  SUBWF  x31,W
3078:  BTFSS  FD8.2
307A:  BRA    34BA
307C:  MOVF   x23,W
307E:  SUBWF  x32,W
3080:  BTFSS  FD8.2
3082:  BRA    34BA
3084:  MOVF   x24,W
3086:  SUBWF  x33,W
3088:  BTFSS  FD8.2
308A:  BRA    34BA
....................       {
....................          // After receiving a SYNchronization request, we expect an
....................          // ACK to our transmitted SYN
....................          if(ps->smState == TCP_SYN_RECEIVED)
308C:  MOVFF  329,FE9
3090:  MOVFF  32A,FEA
3094:  MOVF   FEF,W
3096:  SUBLW  02
3098:  BNZ   3120
....................          {
....................             if(h->Flags.bits.flagACK)
309A:  MOVLW  0D
309C:  ADDWF  x15,W
309E:  MOVWF  FE9
30A0:  MOVLW  00
30A2:  ADDWFC x16,W
30A4:  MOVWF  FEA
30A6:  BTFSS  FEF.4
30A8:  BRA    3116
....................             {
....................                // ACK received as expected, this connection is
....................                // now established
....................                ps->SND_ACK = ack;
30AA:  MOVLW  1A
30AC:  ADDWF  x29,W
30AE:  MOVWF  FE9
30B0:  MOVLW  00
30B2:  ADDWFC x2A,W
30B4:  MOVWF  FEA
30B6:  MOVFF  319,FEF
30BA:  MOVFF  31A,FEC
30BE:  MOVFF  31B,FEC
30C2:  MOVFF  31C,FEC
....................                ps->smState = TCP_ESTABLISHED;
30C6:  MOVFF  329,FE9
30CA:  MOVFF  32A,FEA
30CE:  MOVLW  03
30D0:  MOVWF  FEF
.................... 
....................                // Check if this first packet has application data
....................                // in it.  Make it available if so.
....................                if(len)
30D2:  MOVF   x17,W
30D4:  IORWF  x18,W
30D6:  BZ    310C
....................                {
....................                   ps->Flags.bIsGetReady   = TRUE;
30D8:  MOVLW  23
30DA:  ADDWF  x29,W
30DC:  MOVWF  FE9
30DE:  MOVLW  00
30E0:  ADDWFC x2A,W
30E2:  MOVWF  FEA
30E4:  BSF    FEF.3
....................                   ps->RxCount             = len;
30E6:  MOVLW  12
30E8:  ADDWF  x29,W
30EA:  MOVWF  FE9
30EC:  MOVLW  00
30EE:  ADDWFC x2A,W
30F0:  MOVWF  FEA
30F2:  MOVFF  318,FEC
30F6:  MOVF   FED,F
30F8:  MOVFF  317,FEF
....................                   ps->Flags.bFirstRead    = TRUE;
30FC:  MOVLW  23
30FE:  ADDWF  x29,W
3100:  MOVWF  FE9
3102:  MOVLW  00
3104:  ADDWFC x2A,W
3106:  MOVWF  FEA
3108:  BSF    FEF.2
....................                }
310A:  BRA    3114
....................                else
....................                   MACDiscardRx();
310C:  MOVLB  0
310E:  CALL   1160
3112:  MOVLB  3
....................             }
3114:  BRA    311E
....................             else   // No ACK to our SYN
....................             {
....................                MACDiscardRx();
3116:  MOVLB  0
3118:  CALL   1160
311C:  MOVLB  3
....................             }
....................          }
311E:  BRA    34B8
....................          // Connection is established, closing, or otherwise
....................          else
....................          {
.................... 
....................             // Save the seq+len value of the packet for our future
....................             // ACK transmission, and so out of sequence packets
....................             // can be detected in the future.
....................             ps->SND_ACK = ack;
3120:  MOVLW  1A
3122:  ADDWF  x29,W
3124:  MOVWF  FE9
3126:  MOVLW  00
3128:  ADDWFC x2A,W
312A:  MOVWF  FEA
312C:  MOVFF  319,FEF
3130:  MOVFF  31A,FEC
3134:  MOVFF  31B,FEC
3138:  MOVFF  31C,FEC
.................... 
....................             // Handle packets received while connection established.
....................             if(ps->smState == TCP_ESTABLISHED)
313C:  MOVFF  329,FE9
3140:  MOVFF  32A,FEA
3144:  MOVF   FEF,W
3146:  SUBLW  03
3148:  BTFSS  FD8.2
314A:  BRA    32EA
....................             {
....................                // If this packet has the ACK set, mark all
....................                // previous TX packets as no longer needed for
....................                // possible retransmission.
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability.
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady)
314C:  MOVLW  0D
314E:  ADDWF  x15,W
3150:  MOVWF  FE9
3152:  MOVLW  00
3154:  ADDWFC x16,W
3156:  MOVWF  FEA
3158:  BTFSS  FEF.4
315A:  BRA    31B2
315C:  MOVLW  23
315E:  ADDWF  x29,W
3160:  MOVWF  FE9
3162:  MOVLW  00
3164:  ADDWFC x2A,W
3166:  MOVWF  FEA
3168:  BTFSC  FEF.1
316A:  BRA    31B2
....................                {
....................                   if(ps->TxBuffer != INVALID_BUFFER)
316C:  MOVLW  0F
316E:  ADDWF  x29,W
3170:  MOVWF  FE9
3172:  MOVLW  00
3174:  ADDWFC x2A,W
3176:  MOVWF  FEA
3178:  INCFSZ FEF,W
317A:  BRA    317E
317C:  BRA    31B2
....................                   {
....................                      MACDiscardTx(ps->TxBuffer);
317E:  MOVLW  0F
3180:  ADDWF  x29,W
3182:  MOVWF  FE9
3184:  MOVLW  00
3186:  ADDWFC x2A,W
3188:  MOVWF  FEA
318A:  MOVFF  FEF,333
318E:  MOVLB  0
3190:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER;
3194:  MOVLW  0F
3196:  MOVLB  3
3198:  ADDWF  x29,W
319A:  MOVWF  FE9
319C:  MOVLW  00
319E:  ADDWFC x2A,W
31A0:  MOVWF  FEA
31A2:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE;
31A4:  MOVLW  23
31A6:  ADDWF  x29,W
31A8:  MOVWF  FE9
31AA:  MOVLW  00
31AC:  ADDWFC x2A,W
31AE:  MOVWF  FEA
31B0:  BSF    FEF.1
....................                   }
....................                }
.................... 
....................                // Check if the remote node is closing the connection
....................                if(h->Flags.bits.flagFIN)
31B2:  MOVLW  0D
31B4:  ADDWF  x15,W
31B6:  MOVWF  FE9
31B8:  MOVLW  00
31BA:  ADDWFC x16,W
31BC:  MOVWF  FEA
31BE:  BTFSS  FEF.0
31C0:  BRA    3252
....................                {
....................                   //DebugPrint("|");
....................                   flags = FIN | ACK;
31C2:  MOVLW  11
31C4:  MOVWF  x2B
....................                   seq = ps->SND_SEQ++;
31C6:  MOVLW  16
31C8:  ADDWF  x29,W
31CA:  MOVWF  FE9
31CC:  MOVLW  00
31CE:  ADDWFC x2A,W
31D0:  MOVWF  FEA
31D2:  MOVF   FEE,F
31D4:  MOVF   FEE,F
31D6:  MOVF   FEE,F
31D8:  MOVFF  FED,320
31DC:  MOVFF  FED,31F
31E0:  MOVFF  FED,31E
31E4:  MOVFF  FEF,31D
31E8:  MOVLW  01
31EA:  ADDWF  FEE,F
31EC:  MOVLW  00
31EE:  ADDWFC FEE,F
31F0:  ADDWFC FEE,F
31F2:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
31F4:  MOVLW  1A
31F6:  ADDWF  x29,W
31F8:  MOVWF  FE9
31FA:  MOVLW  00
31FC:  ADDWFC x2A,W
31FE:  MOVWF  FEA
3200:  MOVLW  01
3202:  ADDWF  FEF,W
3204:  MOVWF  00
3206:  MOVLW  00
3208:  ADDWFC FEC,W
320A:  MOVWF  01
320C:  MOVLW  00
320E:  ADDWFC FEC,W
3210:  MOVWF  02
3212:  MOVLW  00
3214:  ADDWFC FEC,W
3216:  MOVF   FED,F
3218:  MOVF   FED,F
321A:  MOVF   FED,F
321C:  MOVFF  00,FEF
3220:  MOVFF  01,FEC
3224:  MOVFF  02,FEC
3228:  MOVWF  FEC
....................               ack = ps->SND_ACK;
322A:  MOVLW  1A
322C:  ADDWF  x29,W
322E:  MOVWF  FE9
3230:  MOVLW  00
3232:  ADDWFC x2A,W
3234:  MOVWF  FEA
3236:  MOVFF  FEF,319
323A:  MOVFF  FEC,31A
323E:  MOVFF  FEC,31B
3242:  MOVFF  FEC,31C
....................                   ps->smState = TCP_LAST_ACK;
3246:  MOVFF  329,FE9
324A:  MOVFF  32A,FEA
324E:  MOVLW  09
3250:  MOVWF  FEF
....................                }
.................... 
....................                // Check if there is any application data in
....................                // this packet.
....................                if(len)
3252:  MOVF   x17,W
3254:  IORWF  x18,W
3256:  BZ    32E0
....................                {
....................                   // There is data.  Make it available if we
....................                   // don't already have data available.
....................                   if(!ps->Flags.bIsGetReady)
3258:  MOVLW  23
325A:  ADDWF  x29,W
325C:  MOVWF  FE9
325E:  MOVLW  00
3260:  ADDWFC x2A,W
3262:  MOVWF  FEA
3264:  BTFSC  FEF.3
3266:  BRA    329E
....................                   {
....................                      ps->Flags.bIsGetReady   = TRUE;
3268:  MOVLW  23
326A:  ADDWF  x29,W
326C:  MOVWF  FE9
326E:  MOVLW  00
3270:  ADDWFC x2A,W
3272:  MOVWF  FEA
3274:  BSF    FEF.3
....................                      ps->RxCount             = len;
3276:  MOVLW  12
3278:  ADDWF  x29,W
327A:  MOVWF  FE9
327C:  MOVLW  00
327E:  ADDWFC x2A,W
3280:  MOVWF  FEA
3282:  MOVFF  318,FEC
3286:  MOVF   FED,F
3288:  MOVFF  317,FEF
....................                      ps->Flags.bFirstRead    = TRUE;
328C:  MOVLW  23
328E:  ADDWF  x29,W
3290:  MOVWF  FE9
3292:  MOVLW  00
3294:  ADDWFC x2A,W
3296:  MOVWF  FEA
3298:  BSF    FEF.2
.................... 
....................                      // 4/1/02
....................                      flags |= ACK;
329A:  BSF    x2B.4
....................                   }
329C:  BRA    32DE
....................                   // There is data, but we cannot handle it at this time.
....................                   else
....................                   {
....................                      //DebugPrint("D");
....................                      // Since we cannot accept this packet,
....................                      // restore to previous seq and ack.
....................                      // and do not send anything back.
....................                      // Host has to resend this packet when
....................                      // we are ready.
....................                      ps->SND_SEQ = prevSeq;
329E:  MOVLW  16
32A0:  ADDWF  x29,W
32A2:  MOVWF  FE9
32A4:  MOVLW  00
32A6:  ADDWFC x2A,W
32A8:  MOVWF  FEA
32AA:  MOVFF  325,FEF
32AE:  MOVFF  326,FEC
32B2:  MOVFF  327,FEC
32B6:  MOVFF  328,FEC
....................                      ps->SND_ACK = prevAck;
32BA:  MOVLW  1A
32BC:  ADDWF  x29,W
32BE:  MOVWF  FE9
32C0:  MOVLW  00
32C2:  ADDWFC x2A,W
32C4:  MOVWF  FEA
32C6:  MOVFF  321,FEF
32CA:  MOVFF  322,FEC
32CE:  MOVFF  323,FEC
32D2:  MOVFF  324,FEC
.................... 
....................                      MACDiscardRx();
32D6:  MOVLB  0
32D8:  CALL   1160
32DC:  MOVLB  3
....................                   }
....................                }
32DE:  BRA    32E8
....................                // There is no data in this packet, and thus it
....................                // can be thrown away.
....................                else
....................                {
....................                   MACDiscardRx();
32E0:  MOVLB  0
32E2:  CALL   1160
32E6:  MOVLB  3
....................                }
....................             }
32E8:  BRA    34B8
....................             // Connection is not established; check if we've sent
....................             // a FIN and expect our last ACK
....................             else if(ps->smState == TCP_LAST_ACK)
32EA:  MOVFF  329,FE9
32EE:  MOVFF  32A,FEA
32F2:  MOVF   FEF,W
32F4:  SUBLW  09
32F6:  BNZ   3322
....................             {
....................                MACDiscardRx();
32F8:  MOVLB  0
32FA:  CALL   1160
.................... 
....................                if(h->Flags.bits.flagACK)
32FE:  MOVLW  0D
3300:  MOVLB  3
3302:  ADDWF  x15,W
3304:  MOVWF  FE9
3306:  MOVLW  00
3308:  ADDWFC x16,W
330A:  MOVWF  FEA
330C:  BTFSS  FEF.4
330E:  BRA    3320
....................                {
....................                   CloseSocket(ps);
3310:  MOVFF  32A,331
3314:  MOVFF  329,330
3318:  MOVLB  0
331A:  CALL   24FA
331E:  MOVLB  3
....................                }
....................             }
3320:  BRA    34B8
....................             else if(ps->smState == TCP_FIN_WAIT_1)
3322:  MOVFF  329,FE9
3326:  MOVFF  32A,FEA
332A:  MOVF   FEF,W
332C:  SUBLW  04
332E:  BNZ   33F4
....................             {
....................                MACDiscardRx();
3330:  MOVLB  0
3332:  CALL   1160
.................... 
....................                if(h->Flags.bits.flagFIN)
3336:  MOVLW  0D
3338:  MOVLB  3
333A:  ADDWF  x15,W
333C:  MOVWF  FE9
333E:  MOVLW  00
3340:  ADDWFC x16,W
3342:  MOVWF  FEA
3344:  BTFSS  FEF.0
3346:  BRA    33D2
....................                {
....................                   flags = ACK;
3348:  MOVLW  10
334A:  MOVWF  x2B
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
334C:  MOVLW  1A
334E:  ADDWF  x29,W
3350:  MOVWF  FE9
3352:  MOVLW  00
3354:  ADDWFC x2A,W
3356:  MOVWF  FEA
3358:  MOVLW  01
335A:  ADDWF  FEF,W
335C:  MOVWF  00
335E:  MOVLW  00
3360:  ADDWFC FEC,W
3362:  MOVWF  01
3364:  MOVLW  00
3366:  ADDWFC FEC,W
3368:  MOVWF  02
336A:  MOVLW  00
336C:  ADDWFC FEC,W
336E:  MOVF   FED,F
3370:  MOVF   FED,F
3372:  MOVF   FED,F
3374:  MOVFF  00,FEF
3378:  MOVFF  01,FEC
337C:  MOVFF  02,FEC
3380:  MOVWF  FEC
....................               ack = ps->SND_ACK;
3382:  MOVLW  1A
3384:  ADDWF  x29,W
3386:  MOVWF  FE9
3388:  MOVLW  00
338A:  ADDWFC x2A,W
338C:  MOVWF  FEA
338E:  MOVFF  FEF,319
3392:  MOVFF  FEC,31A
3396:  MOVFF  FEC,31B
339A:  MOVFF  FEC,31C
....................                   if(h->Flags.bits.flagACK)
339E:  MOVLW  0D
33A0:  ADDWF  x15,W
33A2:  MOVWF  FE9
33A4:  MOVLW  00
33A6:  ADDWFC x16,W
33A8:  MOVWF  FEA
33AA:  BTFSS  FEF.4
33AC:  BRA    33C0
....................                   {
....................                      CloseSocket(ps);
33AE:  MOVFF  32A,331
33B2:  MOVFF  329,330
33B6:  MOVLB  0
33B8:  CALL   24FA
....................                   }
33BC:  BRA    33CE
33BE:  MOVLB  3
....................                   else
....................                   {
....................                      ps->smState = TCP_CLOSING;
33C0:  MOVFF  329,FE9
33C4:  MOVFF  32A,FEA
33C8:  MOVLW  06
33CA:  MOVWF  FEF
33CC:  MOVLB  0
....................                   }
....................                }
33CE:  BRA    33F0
33D0:  MOVLB  3
....................                else if(h->Flags.bits.flagACK)
33D2:  MOVLW  0D
33D4:  ADDWF  x15,W
33D6:  MOVWF  FE9
33D8:  MOVLW  00
33DA:  ADDWFC x16,W
33DC:  MOVWF  FEA
33DE:  BTFSS  FEF.4
33E0:  BRA    33EE
....................                {
....................                   ps->smState = TCP_FIN_WAIT_2;
33E2:  MOVFF  329,FE9
33E6:  MOVFF  32A,FEA
33EA:  MOVLW  05
33EC:  MOVWF  FEF
33EE:  MOVLB  0
....................                }
....................             }
33F0:  BRA    34B6
33F2:  MOVLB  3
....................             else if(ps->smState == TCP_FIN_WAIT_2)
33F4:  MOVFF  329,FE9
33F8:  MOVFF  32A,FEA
33FC:  MOVF   FEF,W
33FE:  SUBLW  05
3400:  BNZ   3482
....................             {
....................                MACDiscardRx();
3402:  MOVLB  0
3404:  CALL   1160
.................... 
....................                if(h->Flags.bits.flagFIN)
3408:  MOVLW  0D
340A:  MOVLB  3
340C:  ADDWF  x15,W
340E:  MOVWF  FE9
3410:  MOVLW  00
3412:  ADDWFC x16,W
3414:  MOVWF  FEA
3416:  BTFSS  FEF.0
3418:  BRA    3480
....................                {
....................                   flags = ACK;
341A:  MOVLW  10
341C:  MOVWF  x2B
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
341E:  MOVLW  1A
3420:  ADDWF  x29,W
3422:  MOVWF  FE9
3424:  MOVLW  00
3426:  ADDWFC x2A,W
3428:  MOVWF  FEA
342A:  MOVLW  01
342C:  ADDWF  FEF,W
342E:  MOVWF  00
3430:  MOVLW  00
3432:  ADDWFC FEC,W
3434:  MOVWF  01
3436:  MOVLW  00
3438:  ADDWFC FEC,W
343A:  MOVWF  02
343C:  MOVLW  00
343E:  ADDWFC FEC,W
3440:  MOVF   FED,F
3442:  MOVF   FED,F
3444:  MOVF   FED,F
3446:  MOVFF  00,FEF
344A:  MOVFF  01,FEC
344E:  MOVFF  02,FEC
3452:  MOVWF  FEC
....................               ack = ps->SND_ACK;
3454:  MOVLW  1A
3456:  ADDWF  x29,W
3458:  MOVWF  FE9
345A:  MOVLW  00
345C:  ADDWFC x2A,W
345E:  MOVWF  FEA
3460:  MOVFF  FEF,319
3464:  MOVFF  FEC,31A
3468:  MOVFF  FEC,31B
346C:  MOVFF  FEC,31C
....................                   CloseSocket(ps);
3470:  MOVFF  32A,331
3474:  MOVFF  329,330
3478:  MOVLB  0
347A:  CALL   24FA
347E:  MOVLB  3
....................                }
....................             }
3480:  BRA    34B8
....................             else if ( ps->smState == TCP_CLOSING )
3482:  MOVFF  329,FE9
3486:  MOVFF  32A,FEA
348A:  MOVF   FEF,W
348C:  SUBLW  06
348E:  BNZ   34B8
....................             {
....................                MACDiscardRx();
3490:  MOVLB  0
3492:  CALL   1160
.................... 
....................                if ( h->Flags.bits.flagACK )
3496:  MOVLW  0D
3498:  MOVLB  3
349A:  ADDWF  x15,W
349C:  MOVWF  FE9
349E:  MOVLW  00
34A0:  ADDWFC x16,W
34A2:  MOVWF  FEA
34A4:  BTFSS  FEF.4
34A6:  BRA    34B8
....................                {
....................                   CloseSocket(ps);
34A8:  MOVFF  32A,331
34AC:  MOVFF  329,330
34B0:  MOVLB  0
34B2:  CALL   24FA
34B6:  MOVLB  3
....................                }
....................             }
....................          }
....................       }
34B8:  BRA    34D6
....................       // This packet's sequence number does not match what we were
....................       // expecting (the last value we ACKed).  Throw this packet
....................       // away.  This may happen if packets are delivered out of order.
....................       // Not enough memory is available on our PIC or Ethernet
....................       // controller to implement a robust stream reconstruction
....................       // buffer.  As a result, the remote node will just have to
....................       // retransmit its packets starting with the proper sequence number.
....................       else
....................       {
....................          MACDiscardRx();
34BA:  MOVLB  0
34BC:  CALL   1160
.................... 
....................          // Send a new ACK out in case if the previous one was lost
....................          // (ACKs aren't ACKed).  This is required to prevent an
....................          // unlikely but possible situation which would cause the
....................          // connection to time out if the ACK was lost and the
....................          // remote node keeps sending us older data than we are
....................          // expecting.
....................          flags = ACK;
34C0:  MOVLW  10
34C2:  MOVLB  3
34C4:  MOVWF  x2B
....................          ack = prevAck;
34C6:  MOVFF  324,31C
34CA:  MOVFF  323,31B
34CE:  MOVFF  322,31A
34D2:  MOVFF  321,319
....................       }
....................    }
.................... 
.................... SendTCPControlPacket:
....................    if(flags)
34D6:  MOVLB  3
34D8:  MOVF   x2B,F
34DA:  BZ    353E
....................    {
....................       SendTCP(remote,
....................          h->DestPort,
....................          h->SourcePort,
....................          seq,
....................          ack,
....................          flags);
34DC:  MOVLW  02
34DE:  ADDWF  x15,W
34E0:  MOVWF  FE9
34E2:  MOVLW  00
34E4:  ADDWFC x16,W
34E6:  MOVWF  FEA
34E8:  MOVFF  FEC,33A
34EC:  MOVF   FED,F
34EE:  MOVFF  FEF,339
34F2:  MOVFF  315,FE9
34F6:  MOVFF  316,FEA
34FA:  MOVFF  FEC,33C
34FE:  MOVF   FED,F
3500:  MOVFF  FEF,33B
3504:  MOVFF  314,338
3508:  MOVFF  313,337
350C:  MOVFF  320,340
3510:  MOVFF  31F,33F
3514:  MOVFF  31E,33E
3518:  MOVFF  31D,33D
351C:  MOVFF  31C,344
3520:  MOVFF  31B,343
3524:  MOVFF  31A,342
3528:  MOVFF  319,341
352C:  MOVFF  32B,345
3530:  SETF   x46
3532:  CLRF   x48
3534:  CLRF   x47
3536:  MOVLB  0
3538:  CALL   2926
353C:  MOVLB  3
....................    }
353E:  MOVLB  0
3540:  GOTO   36D4 (RETURN)
.................... 
....................    /*if (debugLastState != ps->smState)
....................    {
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s);
....................       DebugTCPDisplayState(debugLastState);
....................       debug_tcp(" -> ");
....................       DebugTCPDisplayState(ps->smState);
....................    }*/
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_ICMP
....................    #include "tcpip/icmp.c"
.................... /*********************************************************************
....................  *
....................  *                  ICMP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ICMP.C
....................  * Dependencies:    ICMP.h
....................  *                  string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                  IP.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/icmp.h"
.................... /*********************************************************************
....................  *
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ICMP.h
....................  * Dependencies:    StackTsk.h
....................  *                  IP.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef ICMP_H
.................... #define ICMP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes.
.................... //#define MAX_ICMP_DATA       (32)
.................... #define MAX_ICMP_DATA       (64)
.................... 
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA)
.................... 
.................... 
.................... typedef enum _ICMP_CODE
.................... {
....................     ICMP_ECHO_REPLY = 0,
....................     ICMP_ECHO_REQUEST = 8
.................... } ICMP_CODE, ICMP_REQUESTS;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPIsTxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is ready
....................  *                  FALSE if transmit buffer is not ready
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ICMPPut(NODE_INFO *remote,
....................  *                               ICMP_CODE code,
....................  *                               BYTE *data,
....................  *                               BYTE len,
....................  *                               WORD id,
....................  *                               WORD seq)
....................  *
....................  * PreCondition:    ICMPIsTxReady() == TRUE
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST
....................  *                  data        - Data bytes
....................  *                  len         - Number of bytes to send
....................  *                  id          - ICMP identifier
....................  *                  seq         - ICMP sequence number
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            A ICMP packet is created and put on MAC.
....................  *
....................  ********************************************************************/
.................... void ICMPPut(NODE_INFO *remote,
....................              ICMP_CODE code,
....................              BYTE *data,
....................              BYTE len,
....................              WORD id,
....................              WORD seq);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code,
....................  *                              BYTE *data,
....................  *                              BYTE *len,
....................  *                              WORD *id,
....................  *                              WORD *seq)
....................  *
....................  * PreCondition:    MAC buffer contains ICMP type packet.
....................  *
....................  * Input:           code    - Buffer to hold ICMP code value
....................  *                  data    - Buffer to hold ICMP data
....................  *                  len     - Buffer to hold ICMP data length
....................  *                  id      - Buffer to hold ICMP id
....................  *                  seq     - Buffer to hold ICMP seq
....................  *
....................  * Output:          TRUE if valid ICMP packet was received
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ICMPGet(ICMP_CODE *code,
....................              BYTE *data,
....................              BYTE *len,
....................              WORD *id,
....................              WORD *seq);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define debug_icmp
.................... //#define debug_icmp   debug_printf
.................... 
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h
.................... 
.................... /*
....................  * ICMP packet definition
....................  */
.................... typedef struct _ICMP_PACKET
.................... {
....................     BYTE    Type;
....................     BYTE    Code;
....................     WORD    Checksum;
....................     WORD    Identifier;
....................     WORD    SequenceNumber;
....................     BYTE    Data[MAX_ICMP_DATA];
.................... } ICMP_PACKET;
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA)
.................... 
.................... static void SwapICMPPacket(ICMP_PACKET* p);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code,
....................  *                              BYTE *data,
....................  *                              BYTE *len,
....................  *                              WORD *id,
....................  *                              WORD *seq)
....................  *
....................  * PreCondition:    MAC buffer contains ICMP type packet.
....................  *
....................  * Input:           code    - Buffer to hold ICMP code value
....................  *                  data    - Buffer to hold ICMP data
....................  *                  len     - Buffer to hold ICMP data length
....................  *                  id      - Buffer to hold ICMP id
....................  *                  seq     - Buffer to hold ICMP seq
....................  *
....................  * Output:          TRUE if valid ICMP packet was received
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ICMPGet(ICMP_CODE *code,
....................              BYTE *data,
....................              BYTE *len,
....................              WORD *id,
....................              WORD *seq)
.................... {
....................     ICMP_PACKET packet;
....................     WORD CalcChecksum;
....................     WORD ReceivedChecksum;
.................... #if !defined(MCHP_MAC)
....................     WORD checksums[2];
.................... #endif
.................... 
.................... //    debug_icmp("\r\nICMP GET ");
.................... 
....................     // Obtain the ICMP Header
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE);
*
37AE:  MOVLW  02
37B0:  MOVLB  3
37B2:  MOVWF  x3F
37B4:  MOVLW  F2
37B6:  MOVWF  x3E
37B8:  MOVFF  33F,37E
37BC:  MOVWF  x7D
37BE:  CLRF   x80
37C0:  MOVLW  08
37C2:  MOVWF  x7F
37C4:  MOVLB  0
37C6:  CALL   11CC
.................... 
.................... 
.................... #if defined(MCHP_MAC)
....................    // Calculate the checksum using the Microchip MAC's DMA module
....................    // The checksum data includes the precomputed checksum in the
....................    // header, so a valid packet will always have a checksum of
....................    // 0x0000 if the packet is not disturbed.
....................    ReceivedChecksum = 0x0000;
37CA:  MOVLB  3
37CC:  CLRF   x3D
37CE:  CLRF   x3C
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len);
37D0:  MOVFF  2ED,FEA
37D4:  MOVFF  2EC,FE9
37D8:  MOVFF  FEF,341
37DC:  MOVLB  3
37DE:  CLRF   x40
37E0:  MOVLW  14
37E2:  MOVWF  x3F
37E4:  CLRF   x42
37E6:  MOVLB  0
37E8:  CALL   1B4A
37EC:  MOVFF  02,33B
37F0:  MOVFF  01,33A
.................... #endif
.................... 
....................    // Obtain the ICMP data payload
....................     *len -= ICMP_HEADER_SIZE;
37F4:  MOVFF  2ED,FEA
37F8:  MOVLB  2
37FA:  MOVFF  2EC,FE9
37FE:  MOVLW  08
3800:  SUBWF  FEF,W
3802:  MOVWF  FEF
....................     MACGetArray(data, *len);
3804:  MOVFF  2ED,FEA
3808:  MOVFF  2EC,FE9
380C:  MOVFF  FEF,37F
3810:  MOVFF  2EB,37E
3814:  MOVFF  2EA,37D
3818:  MOVLB  3
381A:  CLRF   x80
381C:  MOVLB  0
381E:  CALL   11CC
.................... 
.................... 
.................... #if !defined(MCHP_MAC)
....................    // Calculte the checksum in local memory without hardware help
....................     ReceivedChecksum = packet.Checksum;
....................     packet.Checksum = 0;
.................... 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE);
....................     checksums[1] = ~CalcIPChecksum(data, *len);
.................... 
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD));
.................... #endif
.................... 
....................     SwapICMPPacket(&packet);
3822:  MOVLW  02
3824:  MOVLB  3
3826:  MOVWF  x3F
3828:  MOVLW  F2
382A:  MOVWF  x3E
382C:  MOVLB  0
382E:  RCALL  36E6
.................... 
....................     *code = packet.Type;
3830:  MOVFF  2E9,FEA
3834:  MOVLB  2
3836:  MOVFF  2E8,FE9
383A:  MOVFF  2F2,FEF
....................     *id = packet.Identifier;
383E:  MOVFF  2EF,FEA
3842:  MOVFF  2EE,FE9
3846:  MOVFF  2F7,FEC
384A:  MOVF   FED,F
384C:  MOVFF  2F6,FEF
....................     *seq = packet.SequenceNumber;
3850:  MOVFF  2F1,FEA
3854:  MOVFF  2F0,FE9
3858:  MOVFF  2F9,FEC
385C:  MOVF   FED,F
385E:  MOVFF  2F8,FEF
.................... 
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum);
.................... 
....................     return ( CalcChecksum == ReceivedChecksum );
3862:  MOVLB  3
3864:  MOVF   x3C,W
3866:  SUBWF  x3A,W
3868:  BNZ   3870
386A:  MOVF   x3D,W
386C:  SUBWF  x3B,W
386E:  BZ    3874
3870:  MOVLW  00
3872:  BRA    3876
3874:  MOVLW  01
3876:  MOVWF  01
3878:  MOVLB  0
387A:  GOTO   6DA4 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void ICMPPut(NODE_INFO *remote,
....................  *                               ICMP_CODE code,
....................  *                               BYTE *data,
....................  *                               BYTE len,
....................  *                               WORD id,
....................  *                               WORD seq)
....................  *
....................  * PreCondition:    ICMPIsTxReady() == TRUE
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST
....................  *                  data        - Data bytes
....................  *                  len         - Number of bytes to send
....................  *                  id          - ICMP identifier
....................  *                  seq         - ICMP sequence number
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            A ICMP packet is created and put on MAC.
....................  *
....................  ********************************************************************/
.................... void ICMPPut(NODE_INFO *remote,
....................              ICMP_CODE code,
....................              BYTE *data,
....................              BYTE len,
....................              WORD id,
....................              WORD seq)
.................... {
....................     ICMP_PACKET   packet;
....................     WORD ICMPLen;
....................    BUFFER MyTxBuffer;
....................    MyTxBuffer = MACGetTxBuffer(TRUE);
387E:  MOVLW  01
3880:  MOVLB  3
3882:  MOVWF  x6F
3884:  MOVLB  0
3886:  CALL   1524
388A:  MOVFF  01,33A
.................... 
....................    // Abort if there is no where in the Ethernet controller to
....................    // store this packet.
....................    if(MyTxBuffer == INVALID_BUFFER)
388E:  MOVLB  3
3890:  INCFSZ x3A,W
3892:  BRA    3896
....................       return;
3894:  BRA    3992
.................... 
....................    IPSetTxBuffer(MyTxBuffer, 0);
3896:  MOVFF  33A,388
389A:  CLRF   x8A
389C:  MOVLW  14
389E:  MOVWF  x89
38A0:  MOVLB  0
38A2:  CALL   154C
.................... 
.................... 
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len;
38A6:  CLRF   03
38A8:  MOVLB  2
38AA:  MOVF   xEB,W
38AC:  ADDLW  08
38AE:  MOVLB  3
38B0:  MOVWF  x38
38B2:  MOVLW  00
38B4:  ADDWFC 03,W
38B6:  MOVWF  x39
.................... 
....................     packet.Code             = 0;
38B8:  MOVLB  2
38BA:  CLRF   xF1
....................     packet.Type             = code;
38BC:  MOVFF  2E8,2F0
....................     packet.Checksum         = 0;
38C0:  CLRF   xF3
38C2:  CLRF   xF2
....................     packet.Identifier       = id;
38C4:  MOVFF  2ED,2F5
38C8:  MOVFF  2EC,2F4
....................     packet.SequenceNumber   = seq;
38CC:  MOVFF  2EF,2F7
38D0:  MOVFF  2EE,2F6
.................... 
....................     memcpy((void*)packet.Data, (void*)data, len);
38D4:  MOVLW  02
38D6:  MOVWF  FEA
38D8:  MOVLW  F8
38DA:  MOVWF  FE9
38DC:  MOVFF  2EA,FE2
38E0:  MOVFF  2E9,FE1
38E4:  MOVF   xEB,W
38E6:  MOVWF  01
38E8:  BZ    38F2
38EA:  MOVFF  FE6,FEE
38EE:  DECFSZ 01,F
38F0:  BRA    38EA
.................... 
....................     SwapICMPPacket(&packet);
38F2:  MOVLW  02
38F4:  MOVLB  3
38F6:  MOVWF  x3F
38F8:  MOVLW  F0
38FA:  MOVWF  x3E
38FC:  MOVLB  0
38FE:  RCALL  36E6
.................... 
.................... #if !defined(MCHP_MAC)
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet,
....................                                     ICMPLen);
.................... #endif
.................... 
....................     IPPutHeader(remote,
....................                 IP_PROT_ICMP,
....................                 (WORD)(ICMP_HEADER_SIZE + len));
3900:  MOVLW  08
3902:  MOVLB  2
3904:  ADDWF  xEB,W
3906:  MOVLB  3
3908:  MOVWF  x3B
390A:  MOVFF  2E7,370
390E:  MOVFF  2E6,36F
3912:  MOVLW  01
3914:  MOVWF  x71
3916:  CLRF   x73
3918:  MOVFF  33B,372
391C:  MOVLB  0
391E:  CALL   2806
.................... 
....................     IPPutArray((BYTE*)&packet, ICMPLen);
3922:  MOVLW  02
3924:  MOVLB  3
3926:  MOVWF  x3C
3928:  MOVLW  F0
392A:  MOVWF  x3B
392C:  MOVFF  33C,394
3930:  MOVWF  x93
3932:  MOVFF  339,396
3936:  MOVFF  338,395
393A:  MOVLB  0
393C:  CALL   1608
.................... 
.................... #if defined(MCHP_MAC)
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen);
3940:  MOVLB  3
3942:  CLRF   x89
3944:  MOVLW  14
3946:  MOVWF  x88
3948:  MOVFF  339,38B
394C:  MOVFF  338,38A
3950:  MOVLB  0
3952:  CALL   272E
3956:  MOVFF  02,2F3
395A:  MOVFF  01,2F2
....................    IPSetTxBuffer(MyTxBuffer, 2);
395E:  MOVFF  33A,388
3962:  MOVLB  3
3964:  CLRF   x8A
3966:  MOVLW  16
3968:  MOVWF  x89
396A:  MOVLB  0
396C:  CALL   154C
....................    MACPutArray((BYTE*)&packet.Checksum, 2);
3970:  MOVLW  02
3972:  MOVLB  3
3974:  MOVWF  x3C
3976:  MOVLW  F2
3978:  MOVWF  x3B
397A:  MOVFF  33C,394
397E:  MOVWF  x93
3980:  CLRF   x96
3982:  MOVLW  02
3984:  MOVWF  x95
3986:  MOVLB  0
3988:  CALL   1608
.................... #endif
.................... 
.................... 
....................     MACFlush();
398C:  CALL   1716
3990:  MOVLB  3
3992:  MOVLB  0
3994:  GOTO   6DFE (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           p - ICMP packet header
....................  *
....................  * Output:          ICMP packet is swapped
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void SwapICMPPacket(ICMP_PACKET* p)
.................... {
....................     p->Identifier           = swaps(p->Identifier);
*
36E6:  MOVLW  04
36E8:  MOVLB  3
36EA:  ADDWF  x3E,W
36EC:  MOVWF  01
36EE:  MOVLW  00
36F0:  ADDWFC x3F,W
36F2:  MOVWF  03
36F4:  MOVFF  01,340
36F8:  MOVWF  x41
36FA:  MOVLW  04
36FC:  ADDWF  x3E,W
36FE:  MOVWF  FE9
3700:  MOVLW  00
3702:  ADDWFC x3F,W
3704:  MOVWF  FEA
3706:  MOVFF  FEC,38F
370A:  MOVF   FED,F
370C:  MOVFF  FEF,38E
3710:  MOVLB  0
3712:  CALL   122C
3716:  MOVFF  341,FEA
371A:  MOVFF  340,FE9
371E:  MOVFF  02,FEC
3722:  MOVF   FED,F
3724:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber);
3728:  MOVLW  06
372A:  MOVLB  3
372C:  ADDWF  x3E,W
372E:  MOVWF  01
3730:  MOVLW  00
3732:  ADDWFC x3F,W
3734:  MOVWF  03
3736:  MOVFF  01,340
373A:  MOVWF  x41
373C:  MOVLW  06
373E:  ADDWF  x3E,W
3740:  MOVWF  FE9
3742:  MOVLW  00
3744:  ADDWFC x3F,W
3746:  MOVWF  FEA
3748:  MOVFF  FEC,38F
374C:  MOVF   FED,F
374E:  MOVFF  FEF,38E
3752:  MOVLB  0
3754:  CALL   122C
3758:  MOVFF  341,FEA
375C:  MOVFF  340,FE9
3760:  MOVFF  02,FEC
3764:  MOVF   FED,F
3766:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum);
376A:  MOVLW  02
376C:  MOVLB  3
376E:  ADDWF  x3E,W
3770:  MOVWF  01
3772:  MOVLW  00
3774:  ADDWFC x3F,W
3776:  MOVWF  03
3778:  MOVFF  01,340
377C:  MOVWF  x41
377E:  MOVLW  02
3780:  ADDWF  x3E,W
3782:  MOVWF  FE9
3784:  MOVLW  00
3786:  ADDWFC x3F,W
3788:  MOVWF  FEA
378A:  MOVFF  FEC,38F
378E:  MOVF   FED,F
3790:  MOVFF  FEF,38E
3794:  MOVLB  0
3796:  CALL   122C
379A:  MOVFF  341,FEA
379E:  MOVFF  340,FE9
37A2:  MOVFF  02,FEC
37A6:  MOVF   FED,F
37A8:  MOVFF  01,FEF
37AC:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_UDP
....................    #include "tcpip/udp.c"
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    #include "tcpip/dhcp.c"
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    #include "tcpip/telnet2.c"
.................... #endif
.................... 
.................... #if STACK_USE_ARP
....................    #include "tcpip/arptsk.c"
.................... /*********************************************************************
....................  *
....................  *                  ARP Server Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARPTsk.c
....................  * Dependencies:    compiler.h
....................  *                  string.h
....................  *                  ARP.h
....................  *                  ARPTsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case)
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes].
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP.
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/arp.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.h
....................  * Dependencies:    Stacktsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... #ifndef ARP_H
.................... #define ARP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................  * Following codes are must be used with ARPGet/Put functions.
....................  */
.................... #define ARP_REPLY       (0x00)
.................... #define ARP_REQUEST     (0x01)
.................... #define ARP_UNKNOWN     (0x02)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           ARPIsRxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if ARP receive buffer is full.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE)
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    MACIsTxReady() == TRUE
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode);
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/arptsk.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Server Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARPTsk.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes].
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef ARP_TSK_H
.................... #define ARP_TSK_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP Cache is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void ARPInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPProcess(void)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPProcess(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr  - IP Address to be resolved.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        An ARP request is sent.
....................  *
....................  * Note:
....................  ********************************************************************/
.................... void ARPResolve(IP_ADDR *IPAddr);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr,
....................  *                                      MAC_ADDR *MACAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr      - IPAddress to be resolved.
....................  *                  MACAddr     - Buffer to hold corresponding
....................  *                                MAC Address.
....................  *
....................  * Output:          TRUE if given IP Address has been resolved.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_arptask
.................... //#define debug_arptask   debug_printf
.................... 
.................... /*
....................  * ARP Task FSM States
....................  */
.................... typedef enum _ARP_STATE
.................... {
....................     SM_ARP_IDLE,
....................     SM_ARP_REPLY
.................... } ARP_STATE;
.................... 
.................... 
.................... /*
....................  * This ARP task caches one ARP response.
....................  */
.................... static ARP_STATE smARP;
.................... 
.................... static NODE_INFO Cache;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP Cache is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void ARPInit(void)
.................... {
....................     smARP = SM_ARP_IDLE;
*
0C96:  BCF    5B.1
.................... 
....................     Cache.MACAddr.v[0] = 0xff;
0C98:  SETF   x64
....................     Cache.MACAddr.v[1] = 0xff;
0C9A:  SETF   x65
....................     Cache.MACAddr.v[2] = 0xff;
0C9C:  SETF   x66
....................     Cache.MACAddr.v[3] = 0xff;
0C9E:  SETF   x67
....................     Cache.MACAddr.v[4] = 0xff;
0CA0:  SETF   x68
....................     Cache.MACAddr.v[5] = 0xff;
0CA2:  SETF   x69
.................... 
....................     Cache.IPAddr.Val = 0x0;
0CA4:  CLRF   x6D
0CA6:  CLRF   x6C
0CA8:  CLRF   x6B
0CAA:  CLRF   x6A
0CAC:  GOTO   107E (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPProcess(void)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPProcess(void)
.................... {
....................     NODE_INFO remoteNode;
....................     BYTE opCode;
.................... 
....................     switch(smARP)
*
1ABC:  MOVLW  00
1ABE:  BTFSC  5B.1
1AC0:  MOVLW  01
1AC2:  XORLW  00
1AC4:  BZ    1AC8
1AC6:  BRA    1B24
....................     {
....................     case SM_ARP_IDLE:
....................         if ( !ARPGet(&remoteNode, &opCode) )
1AC8:  MOVLW  02
1ACA:  MOVLB  2
1ACC:  MOVWF  xF2
1ACE:  MOVLW  E6
1AD0:  MOVWF  xF1
1AD2:  MOVLW  02
1AD4:  MOVWF  xF4
1AD6:  MOVLW  F0
1AD8:  MOVWF  xF3
1ADA:  MOVLB  0
1ADC:  BRA    143C
1ADE:  MOVF   01,F
1AE0:  BNZ   1AE4
....................             break;
1AE2:  BRA    1B42
.................... 
....................          //dsr add 071204
....................          //dsr fix 071206
....................          MACDiscardRx();
1AE4:  CALL   1160
.................... 
....................         if ( opCode == ARP_REPLY )
1AE8:  MOVLB  2
1AEA:  MOVF   xF0,F
1AEC:  BNZ   1B20
....................         {
.................... 			Cache.MACAddr = remoteNode.MACAddr;
1AEE:  CLRF   FEA
1AF0:  MOVLW  64
1AF2:  MOVWF  FE9
1AF4:  MOVLW  02
1AF6:  MOVWF  FE2
1AF8:  MOVLW  E6
1AFA:  MOVWF  FE1
1AFC:  MOVLW  06
1AFE:  MOVWF  01
1B00:  MOVFF  FE6,FEE
1B04:  DECFSZ 01,F
1B06:  BRA    1B00
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val;
1B08:  MOVFF  2EF,6D
1B0C:  MOVFF  2EE,6C
1B10:  MOVFF  2ED,6B
1B14:  MOVFF  2EC,6A
....................             break;
1B18:  MOVLB  0
1B1A:  BRA    1B42
....................         }
1B1C:  BRA    1B24
1B1E:  MOVLB  2
....................         else
....................             smARP = SM_ARP_REPLY;
1B20:  BSF    5B.1
1B22:  MOVLB  0
.................... 
....................     default:
.................... 		if(ARPPut(&remoteNode, ARP_REPLY))
1B24:  MOVLW  02
1B26:  MOVLB  2
1B28:  MOVWF  xF2
1B2A:  MOVLW  E6
1B2C:  MOVWF  xF1
1B2E:  CLRF   xF3
1B30:  MOVLB  0
1B32:  BRA    1942
1B34:  MOVF   01,F
1B36:  BZ    1B3C
.................... 		{
.................... 			smARP = SM_ARP_IDLE;
1B38:  BCF    5B.1
.................... 		}
1B3A:  BRA    1B42
....................         else
....................             return FALSE;
1B3C:  MOVLW  00
1B3E:  MOVWF  01
1B40:  BRA    1B46
....................         break;
.................... 
....................     }
....................     return TRUE;
1B42:  MOVLW  01
1B44:  MOVWF  01
1B46:  GOTO   6CC4 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr)
....................  *
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE
....................  *
....................  * Input:           IPAddr  - IP Address to be resolved.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        An ARP request is sent.
....................  ********************************************************************/
.................... void ARPResolve(IP_ADDR *IPAddr)
.................... {
....................     NODE_INFO remoteNode;
.................... 
....................     remoteNode.IPAddr = *IPAddr;
.................... 
....................     ARPPut(&remoteNode, ARP_REQUEST);
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr,
....................  *                                      MAC_ADDR *MACAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr      - IPAddress to be resolved.
....................  *                  MACAddr     - Buffer to hold corresponding
....................  *                                MAC Address.
....................  *
....................  * Output:          TRUE if given IP Address has been resolved.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr)
.................... {
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val)
....................     {
....................         *MACAddr = Cache.MACAddr;
....................         return TRUE;
....................     }
....................     return FALSE;
.................... }
.................... 
.................... 
.................... 
....................    #include "tcpip/arp.c"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.c
....................  * Dependencies:    string.h
....................  *                  stacktsk.h
....................  *                  helpers.h
....................  *                  arp.h
....................  *                  mac.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/arp.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.h
....................  * Dependencies:    Stacktsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... #ifndef ARP_H
.................... #define ARP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... #include "tcpip/mac.h"
.................... 
.................... /*
....................  * Following codes are must be used with ARPGet/Put functions.
....................  */
.................... #define ARP_REPLY       (0x00)
.................... #define ARP_REQUEST     (0x01)
.................... #define ARP_UNKNOWN     (0x02)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           ARPIsRxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if ARP receive buffer is full.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE)
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    MACIsTxReady() == TRUE
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode);
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_arp
.................... //#define debug_arp debug_printf
.................... 
.................... // ARP Operation codes.
.................... #define ARP_OPERATION_REQ       0x01u
.................... #define ARP_OPERATION_RESP      0x02u
.................... 
.................... // ETHERNET packet type as defined by IEEE 802.3
.................... #define HW_ETHERNET             (0x0001u)
.................... #define ARP_IP                  (0x0800u)
.................... 
.................... 
.................... 
.................... // ARP packet
.................... typedef struct _ARP_PACKET
.................... {
....................     WORD        HardwareType;
....................     WORD        Protocol;
....................     BYTE        MACAddrLen;
....................     BYTE        ProtocolLen;
....................     WORD        Operation;
....................     MAC_ADDR    SenderMACAddr;
....................     IP_ADDR     SenderIPAddr;
....................     MAC_ADDR    TargetMACAddr;
....................     IP_ADDR     TargetIPAddr;
.................... } ARP_PACKET;
.................... 
.................... // Helper function
.................... static void SwapARPPacket(ARP_PACKET *p);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode)
.................... {
....................     ARP_PACKET packet;
.................... 
....................     //MACGetArray((int8*)&packet, sizeof(packet));
....................     MACGetArray(&packet, sizeof(ARP_PACKET));
*
143C:  MOVLW  02
143E:  MOVLB  3
1440:  MOVWF  x7E
1442:  MOVLW  F5
1444:  MOVWF  x7D
1446:  CLRF   x80
1448:  MOVLW  1C
144A:  MOVWF  x7F
144C:  MOVLB  0
144E:  RCALL  11CC
.................... 
....................     MACDiscardRx();
1450:  RCALL  1160
.................... 
....................     SwapARPPacket(&packet);
1452:  MOVLW  02
1454:  MOVLB  3
1456:  MOVWF  x12
1458:  MOVLW  F5
145A:  MOVWF  x11
145C:  MOVLB  0
145E:  RCALL  1386
.................... 
....................    //debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U",
....................      // packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen,
....................      // packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1],
....................      // packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3],
....................      // packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]);
.................... 
....................     if ( packet.HardwareType != HW_ETHERNET     ||
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  ||
....................          packet.ProtocolLen != sizeof(IP_ADDR) )
1460:  MOVLB  2
1462:  DECFSZ xF5,W
1464:  BRA    1476
1466:  MOVF   xF6,F
1468:  BNZ   1476
146A:  MOVF   xF9,W
146C:  SUBLW  06
146E:  BNZ   1476
1470:  MOVF   xFA,W
1472:  SUBLW  04
1474:  BZ    147C
....................          return FALSE;
1476:  MOVLW  00
1478:  MOVWF  01
147A:  BRA    151E
.................... 
....................     if ( packet.Operation == ARP_OPERATION_RESP )
147C:  MOVF   xFB,W
147E:  SUBLW  02
1480:  BNZ   1492
1482:  MOVF   xFC,F
1484:  BNZ   1492
....................         *opCode = ARP_REPLY;
1486:  MOVFF  2F4,FEA
148A:  MOVFF  2F3,FE9
148E:  CLRF   FEF
1490:  BRA    14BA
....................     else if ( packet.Operation == ARP_OPERATION_REQ )
1492:  DECFSZ xFB,W
1494:  BRA    14A8
1496:  MOVF   xFC,F
1498:  BNZ   14A8
....................         *opCode = ARP_REQUEST;
149A:  MOVFF  2F4,FEA
149E:  MOVFF  2F3,FE9
14A2:  MOVLW  01
14A4:  MOVWF  FEF
14A6:  BRA    14BA
....................     else
....................     {
....................         *opCode = ARP_UNKNOWN;
14A8:  MOVFF  2F4,FEA
14AC:  MOVFF  2F3,FE9
14B0:  MOVLW  02
14B2:  MOVWF  FEF
....................         return FALSE;
14B4:  MOVLW  00
14B6:  MOVWF  01
14B8:  BRA    151E
....................     }
.................... 
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val)
14BA:  MOVF   1D,W
14BC:  MOVLB  3
14BE:  SUBWF  x0D,W
14C0:  BNZ   1518
14C2:  MOVF   1E,W
14C4:  SUBWF  x0E,W
14C6:  BNZ   1518
14C8:  MOVF   1F,W
14CA:  SUBWF  x0F,W
14CC:  BNZ   1518
14CE:  MOVF   20,W
14D0:  SUBWF  x10,W
14D2:  BNZ   1518
....................     {
....................         remote->MACAddr     = packet.SenderMACAddr;
14D4:  MOVLB  2
14D6:  MOVFF  2F1,FE9
14DA:  MOVFF  2F2,FEA
14DE:  MOVLW  02
14E0:  MOVWF  FE2
14E2:  MOVLW  FD
14E4:  MOVWF  FE1
14E6:  MOVLW  06
14E8:  MOVWF  01
14EA:  MOVFF  FE6,FEE
14EE:  DECFSZ 01,F
14F0:  BRA    14EA
....................         remote->IPAddr      = packet.SenderIPAddr;
14F2:  MOVLW  06
14F4:  ADDWF  xF1,W
14F6:  MOVWF  FE9
14F8:  MOVLW  00
14FA:  ADDWFC xF2,W
14FC:  MOVWF  FEA
14FE:  MOVFF  303,FEF
1502:  MOVFF  304,FEC
1506:  MOVFF  305,FEC
150A:  MOVFF  306,FEC
....................         return TRUE;
150E:  MOVLW  01
1510:  MOVWF  01
1512:  BRA    151E
....................     }
1514:  BRA    151E
1516:  MOVLB  3
....................     else
....................         return FALSE;
1518:  MOVLW  00
151A:  MOVWF  01
151C:  MOVLB  2
151E:  MOVLB  0
1520:  GOTO   1ADE (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          TRUE - The ARP packet was generated properly
....................  *               FALSE - Unable to allocate a TX buffer
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode)
.................... {
....................     ARP_PACKET packet;
.................... 
....................    BUFFER MyTxBuffer;
....................    MyTxBuffer = MACGetTxBuffer(TRUE);
*
1942:  MOVLW  01
1944:  MOVLB  3
1946:  MOVWF  x6F
1948:  MOVLB  0
194A:  RCALL  1524
194C:  MOVFF  01,310
....................    
....................    // Do not respond if there is no room to generate the ARP reply
....................    if(MyTxBuffer == INVALID_BUFFER)
1950:  MOVLB  3
1952:  INCFSZ x10,W
1954:  BRA    195C
....................       return FALSE;
1956:  MOVLW  00
1958:  MOVWF  01
195A:  BRA    1AB6
.................... 
....................    MACSetTxBuffer(MyTxBuffer, 0);
195C:  MOVFF  310,388
1960:  CLRF   x8A
1962:  CLRF   x89
1964:  MOVLB  0
1966:  RCALL  154C
....................    
....................    
....................     packet.HardwareType             = HW_ETHERNET;
1968:  MOVLB  2
196A:  CLRF   xF5
196C:  MOVLW  01
196E:  MOVWF  xF4
....................     packet.Protocol                 = ARP_IP;
1970:  MOVLW  08
1972:  MOVWF  xF7
1974:  CLRF   xF6
....................     packet.MACAddrLen               = sizeof(MAC_ADDR);
1976:  MOVLW  06
1978:  MOVWF  xF8
....................     packet.ProtocolLen              = sizeof(IP_ADDR);
197A:  MOVLW  04
197C:  MOVWF  xF9
.................... 
....................     if ( opCode == ARP_REQUEST )
197E:  DECFSZ xF3,W
1980:  BRA    199A
....................     {
....................         packet.Operation            = ARP_OPERATION_REQ;
1982:  CLRF   xFB
1984:  MOVLW  01
1986:  MOVWF  xFA
....................         packet.TargetMACAddr.v[0]   = 0xff;
1988:  MOVLB  3
198A:  SETF   x06
....................         packet.TargetMACAddr.v[1]   = 0xff;
198C:  SETF   x07
....................         packet.TargetMACAddr.v[2]   = 0xff;
198E:  SETF   x08
....................         packet.TargetMACAddr.v[3]   = 0xff;
1990:  SETF   x09
....................         packet.TargetMACAddr.v[4]   = 0xff;
1992:  SETF   x0A
....................         packet.TargetMACAddr.v[5]   = 0xff;
1994:  SETF   x0B
....................     }
1996:  BRA    19BC
1998:  MOVLB  2
....................     else
....................     {
....................         packet.Operation            = ARP_OPERATION_RESP;
199A:  CLRF   xFB
199C:  MOVLW  02
199E:  MOVWF  xFA
....................         packet.TargetMACAddr        = remote->MACAddr;
19A0:  MOVFF  2F1,FE1
19A4:  MOVFF  2F2,FE2
19A8:  MOVLW  03
19AA:  MOVWF  FEA
19AC:  MOVLW  06
19AE:  MOVWF  FE9
19B0:  MOVWF  01
19B2:  MOVFF  FE6,FEE
19B6:  DECFSZ 01,F
19B8:  BRA    19B2
19BA:  MOVLB  3
....................     }
.................... 
....................     packet.SenderMACAddr = AppConfig.MyMACAddr;
19BC:  MOVLW  02
19BE:  MOVWF  FEA
19C0:  MOVLW  FC
19C2:  MOVWF  FE9
19C4:  CLRF   FE2
19C6:  MOVLW  21
19C8:  MOVWF  FE1
19CA:  MOVLW  06
19CC:  MOVWF  01
19CE:  MOVFF  FE6,FEE
19D2:  DECFSZ 01,F
19D4:  BRA    19CE
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr;
19D6:  MOVFF  20,305
19DA:  MOVFF  1F,304
19DE:  MOVFF  1E,303
19E2:  MOVFF  1D,302
.................... 
.................... 
....................     // Check to see if target is on same subnet, if not, find Gateway MAC.
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway.
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val)
19E6:  MOVLW  06
19E8:  MOVLB  2
19EA:  ADDWF  xF1,W
19EC:  MOVWF  FE9
19EE:  MOVLW  00
19F0:  ADDWFC xF2,W
19F2:  MOVWF  FEA
19F4:  MOVFF  FEF,00
19F8:  MOVFF  FEC,01
19FC:  MOVFF  FEC,02
1A00:  MOVFF  FEC,03
1A04:  MOVF   00,W
1A06:  MOVLB  3
1A08:  XORWF  x02,W
1A0A:  MOVWF  x11
1A0C:  MOVF   01,W
1A0E:  XORWF  x03,W
1A10:  MOVWF  x12
1A12:  MOVF   02,W
1A14:  XORWF  x04,W
1A16:  MOVWF  x13
1A18:  MOVF   03,W
1A1A:  XORWF  x05,W
1A1C:  MOVWF  x14
1A1E:  MOVF   x11,W
1A20:  ANDWF  27,W
1A22:  MOVWF  00
1A24:  MOVF   x12,W
1A26:  ANDWF  28,W
1A28:  MOVWF  01
1A2A:  MOVF   x13,W
1A2C:  ANDWF  29,W
1A2E:  MOVWF  02
1A30:  MOVF   x14,W
1A32:  ANDWF  2A,W
1A34:  MOVWF  03
1A36:  MOVF   00,F
1A38:  BNZ   1A46
1A3A:  MOVF   01,F
1A3C:  BNZ   1A46
1A3E:  MOVF   02,F
1A40:  BNZ   1A46
1A42:  MOVF   03,F
1A44:  BZ    1A58
....................     {
....................       packet.TargetIPAddr = AppConfig.MyGateway;
1A46:  MOVFF  2E,30F
1A4A:  MOVFF  2D,30E
1A4E:  MOVFF  2C,30D
1A52:  MOVFF  2B,30C
....................     }
1A56:  BRA    1A78
....................     else
....................         packet.TargetIPAddr             = remote->IPAddr;
1A58:  MOVLW  06
1A5A:  MOVLB  2
1A5C:  ADDWF  xF1,W
1A5E:  MOVWF  FE9
1A60:  MOVLW  00
1A62:  ADDWFC xF2,W
1A64:  MOVWF  FEA
1A66:  MOVFF  FEF,30C
1A6A:  MOVFF  FEC,30D
1A6E:  MOVFF  FEC,30E
1A72:  MOVFF  FEC,30F
1A76:  MOVLB  3
.................... 
....................     SwapARPPacket(&packet);
1A78:  MOVLW  02
1A7A:  MOVWF  x12
1A7C:  MOVLW  F4
1A7E:  MOVWF  x11
1A80:  MOVLB  0
1A82:  RCALL  1386
.................... 
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet));
1A84:  MOVLW  03
1A86:  MOVLB  3
1A88:  MOVWF  x8D
1A8A:  MOVLW  06
1A8C:  MOVWF  x8C
1A8E:  MOVWF  x8E
1A90:  CLRF   x90
1A92:  MOVLW  1C
1A94:  MOVWF  x8F
1A96:  MOVLB  0
1A98:  RCALL  164E
.................... 
....................     //MACPutArray((int8*)&packet, sizeof(packet));
....................     MACPutArray(&packet, sizeof(ARP_PACKET));
1A9A:  MOVLW  02
1A9C:  MOVLB  3
1A9E:  MOVWF  x94
1AA0:  MOVLW  F4
1AA2:  MOVWF  x93
1AA4:  CLRF   x96
1AA6:  MOVLW  1C
1AA8:  MOVWF  x95
1AAA:  MOVLB  0
1AAC:  RCALL  1608
.................... 
....................     MACFlush();
1AAE:  RCALL  1716
....................    
....................    return TRUE;
1AB0:  MOVLW  01
1AB2:  MOVWF  01
1AB4:  MOVLB  3
1AB6:  MOVLB  0
1AB8:  GOTO   1B34 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           p   - ARP packet to be swapped.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void SwapARPPacket(ARP_PACKET *p)
.................... {
....................     p->HardwareType     = swaps(p->HardwareType);
*
1386:  MOVFF  311,01
138A:  MOVFF  312,314
138E:  MOVFF  01,313
1392:  MOVFF  311,FE9
1396:  MOVFF  312,FEA
139A:  MOVFF  FEC,38F
139E:  MOVF   FED,F
13A0:  MOVFF  FEF,38E
13A4:  MOVLB  0
13A6:  RCALL  122C
13A8:  MOVFF  314,FEA
13AC:  MOVFF  313,FE9
13B0:  MOVFF  02,FEC
13B4:  MOVF   FED,F
13B6:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol);
13BA:  MOVLW  02
13BC:  MOVLB  3
13BE:  ADDWF  x11,W
13C0:  MOVWF  01
13C2:  MOVLW  00
13C4:  ADDWFC x12,W
13C6:  MOVWF  03
13C8:  MOVFF  01,313
13CC:  MOVWF  x14
13CE:  MOVLW  02
13D0:  ADDWF  x11,W
13D2:  MOVWF  FE9
13D4:  MOVLW  00
13D6:  ADDWFC x12,W
13D8:  MOVWF  FEA
13DA:  MOVFF  FEC,38F
13DE:  MOVF   FED,F
13E0:  MOVFF  FEF,38E
13E4:  MOVLB  0
13E6:  RCALL  122C
13E8:  MOVFF  314,FEA
13EC:  MOVFF  313,FE9
13F0:  MOVFF  02,FEC
13F4:  MOVF   FED,F
13F6:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation);
13FA:  MOVLW  06
13FC:  MOVLB  3
13FE:  ADDWF  x11,W
1400:  MOVWF  01
1402:  MOVLW  00
1404:  ADDWFC x12,W
1406:  MOVWF  03
1408:  MOVFF  01,313
140C:  MOVWF  x14
140E:  MOVLW  06
1410:  ADDWF  x11,W
1412:  MOVWF  FE9
1414:  MOVLW  00
1416:  ADDWFC x12,W
1418:  MOVWF  FEA
141A:  MOVFF  FEC,38F
141E:  MOVF   FED,F
1420:  MOVFF  FEF,38E
1424:  MOVLB  0
1426:  RCALL  122C
1428:  MOVFF  314,FEA
142C:  MOVFF  313,FE9
1430:  MOVFF  02,FEC
1434:  MOVF   FED,F
1436:  MOVFF  01,FEF
143A:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    #include "tcpip/http.c"
.................... //////////////////////////////////////////////////////////////////////////////
.................... ///
.................... ///                              HTTP.C
.................... ///
.................... /// Simple webserver for the Microchip TCP/IP stack.
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES
.................... ///
.................... /// **** CONFIGURATION ****
.................... ///
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c
.................... ///        in your application.  Defining this to be true will cause
.................... ///        the stack to include the HTTP portion and execute the init
.................... ///        and process any HTTP tasks.
.................... ///
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP
.................... ///        connections.
.................... ///
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the
.................... ///        HTTP server.  You probably will be fine with just 1.  The
.................... ///        more sockets you use the more RAM is used to hold buffers
.................... ///        and state configuration.
.................... ///
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several
.................... ///        buffers.  This limits the size of your GET or POST requests
.................... ///        and all CGI POST data:
.................... ///            If using GET, then max amount of cgi data is this value
.................... ///            minus everything else on the initial GET command (which
.................... ///            also includes the filename).  I believe the max specified
.................... ///            by W3C is 255.
.................... ///            If using POST, then this is the maximum size for one
.................... ///            key=value pair (including the '=' sign).
.................... ///        These values do not inlude any escape characters.
.................... ///
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE.
.................... ///
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have
.................... ///      two escape characters after the %.  An example of each:
.................... ///         If FALSE: %A
.................... ///         If TRUE: %0A
.................... ///
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third
.................... ///      parameter which is the content-type of the requested page.
.................... ///
.................... /// **** HOW IT WORKS ****
.................... ///
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will
.................... /// then listen for GET or POST requests.  When it gets a GET or POST
.................... /// request it passes the page request to the callback function
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or
.................... /// a pointer to the constant memory area that holds the page in program
.................... /// memory.  If it was a POST request it waits until the HTTP header is
.................... /// done and then saves the POST data into a buffer, and passes the
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will
.................... /// parse the CGI post data and act upon it.  When done, the HTTP
.................... /// server then responds by sending the page.  If the page is to have
.................... /// variable data, it can be represented by an escape code - %0 or %1
.................... /// for example.  When the HTTP stack sees such an escape code it calls
.................... /// the callback function http_format_char() to format the escape code
.................... /// into the needed variable data (such as ADC readings).  After the
.................... /// HTTP stack is done sending the request it will close the port.
.................... /// If the page didn't exist in program memory it will send a 404 File
.................... /// not found error.  If there was a problem/timeout parsing the request
.................... /// the HTTP stack will send a 500 Internal Server Error response.
.................... ///
.................... /// **** CALL BACK FUNCTIONS ****
.................... ///
.................... /// Your main application must provide the following callback functions to
.................... /// fill application dependent needs:
.................... ///
.................... /// http_get_page(char *file);
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else,
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph.
.................... ///    A call-back function provided by your application that finds the
.................... ///    required file.  If the file exists, returns address to page in
.................... ///    program memory.  If it doesn't exist, returns 0.
.................... ///
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else,
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph.
.................... ///    A call-back function provided by your application that finds the
.................... ///    required file.  If the file exists, saves value to retAddress.  If
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the
.................... ///    content-type (text/html, text/xml, etc).
.................... ///
.................... /// http_exec_cgi(int32 file, char *key, char *val);
.................... ///    A call-back function provided by your application that processes incoming
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is
.................... ///    the file address as returned by http_get_page().
.................... ///
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... ///    Given an escaped character in the program memory HTTP file, convert to
.................... ///    variable data.  id is the escaped character, *str is where to save the
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str.
.................... ///    Returns the number of bytes written to *str.  file is
.................... ///    the file address as returned by http_get_page().
.................... ///
.................... /// **** LIMITATIONS ****
.................... ///
.................... /// When creating web pages with forms, keep your form names (keys) simple
.................... /// because the HTTP stack does not format the escape characters.  For example,
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord".
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving
.................... /// the value, but not the key.  Therefore keep your keys simple.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// * Author         Date           Comment
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.................... ///
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST
.................... ///
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix
.................... ///                                 many bugs.  The biggest bug is that
.................... ///                                 it can send pages and receive CGI that
.................... ///                                 is larger than 1 TCP packet.  Also
.................... ///                                 added the HTTP_USE_CHUNKS,
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #include "tcpip/http.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///                                                                     ///
.................... ///                              HTTP.H                                 ///
.................... ///                                                                     ///
.................... /// Simple webserver for the Microchip TCP/IP stack.                    ///
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       ///
.................... ///                                                                     ///
.................... /// See HTTP.C for documenation                                         ///
.................... ///                                                                     ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef HTTP_USE_CHUNKS
.................... #define HTTP_USE_CHUNKS   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_CONTENT_TYPE
.................... #define HTTP_USE_CONTENT_TYPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_PORT
.................... #define HTTP_PORT             80
.................... #endif
.................... 
.................... #ifndef HTTP_NUM_SOCKETS
.................... #define HTTP_NUM_SOCKETS      1
.................... #endif
.................... 
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE
.................... #define HTTP_GET_PARAM_MAX_SIZE  254
.................... #endif
.................... 
.................... void HTTP_Init(void);
.................... void HTTP_Task(void);
.................... 
.................... //**** CALLBACKS START ******///
.................... 
.................... /// the following three functions are callbacks and
.................... /// must be written in your main application!!!  see the documentation above
.................... /// for more help.
.................... 
.................... #if HTTP_USE_CONTENT_TYPE
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... #else
....................  int32 http_get_page(char *file_str);
.................... #endif
.................... 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... void http_exec_cgi(int32 file, char *key, char *val);
.................... 
.................... //**** CALLBACKS END ******///
.................... 
.................... 
.................... //#define debug_http   debug_printf
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u)
.................... 
.................... const char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>";
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>";
.................... 
.................... //key=val pair string, & delimited
.................... void http_parse_cgi_str(int32 file, char *cgistr);
.................... 
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET};
.................... 
.................... enum {
....................    HTTP_DISABLED = 0xFF,
....................    HTTP_IGNORE,
....................    HTTP_LISTEN_WAIT,
....................    HTTP_CONNECTED,
....................    HTTP_GET_HEADERS,
....................    HTTP_GET_POST,
....................    HTTP_GET_POST_CONTINUE,
....................    HTTP_SEND_RESPONSE,
....................    HTTP_SEND_RESPONSE_CONTINUE,
....................    HTTP_CLOSE,
....................    HTTP_CLOSE_WAITING,
....................    HTTP_CLOSED
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE};
.................... 
.................... //strips out any escape characters that the HTTP client may have inserted.
.................... // (+ is replaced with space)
.................... // (%xx is replaced with character representation of xx)
.................... char * http_escape_chars(char *str)
.................... {
....................    char *ostr;
....................    char new[3];
....................    char c;
....................    char val;
.................... 
....................    new[2]=0;
*
46BA:  MOVLB  3
46BC:  CLRF   x07
.................... 
....................    ostr = str;
46BE:  MOVFF  302,304
46C2:  MOVFF  301,303
.................... 
....................    while((c=*str) != 0)
46C6:  MOVFF  302,FEA
46CA:  MOVFF  301,FE9
46CE:  MOVFF  FEF,308
46D2:  MOVF   x08,F
46D4:  BZ    478E
....................    {
....................       if (c=='+')
46D6:  MOVF   x08,W
46D8:  SUBLW  2B
46DA:  BNZ   46F0
....................          *str++=' ';
46DC:  MOVFF  302,FEA
46E0:  MOVF   x01,W
46E2:  INCF   x01,F
46E4:  BTFSC  FD8.2
46E6:  INCF   x02,F
46E8:  MOVWF  FE9
46EA:  MOVLW  20
46EC:  MOVWF  FEF
46EE:  BRA    478A
....................       else if (c=='%')
46F0:  MOVF   x08,W
46F2:  SUBLW  25
46F4:  BNZ   4784
....................       {
....................          memcpy(new, str + 1, 2);
46F6:  MOVLW  01
46F8:  ADDWF  x01,W
46FA:  MOVWF  x0A
46FC:  MOVLW  00
46FE:  ADDWFC x02,W
4700:  MOVWF  FE2
4702:  MOVFF  30A,FE1
4706:  MOVFF  FE6,305
470A:  MOVFF  FE6,306
....................          val = strtoul(new, 0, 16);
470E:  MOVLW  03
4710:  MOVWF  x0B
4712:  MOVLW  05
4714:  MOVWF  x0A
4716:  CLRF   x0D
4718:  CLRF   x0C
471A:  MOVLW  10
471C:  MOVWF  x0E
471E:  MOVLB  0
4720:  BRA    41FA
4722:  MOVFF  01,309
....................          *str++ = val;
4726:  MOVLB  3
4728:  MOVFF  302,FEA
472C:  MOVF   x01,W
472E:  INCF   x01,F
4730:  BTFSC  FD8.2
4732:  INCF   x02,F
4734:  MOVWF  FE9
4736:  MOVFF  309,FEF
....................          memmove(str, str + 2, strlen(str) - 1);
473A:  MOVLW  02
473C:  ADDWF  x01,W
473E:  MOVWF  x0A
4740:  MOVLW  00
4742:  ADDWFC x02,W
4744:  MOVWF  x0B
4746:  MOVFF  302,31E
474A:  MOVFF  301,31D
474E:  MOVLB  0
4750:  RCALL  404C
4752:  MOVFF  02,30D
4756:  MOVFF  01,30C
475A:  MOVLW  01
475C:  MOVLB  3
475E:  SUBWF  x0C,F
4760:  MOVLW  00
4762:  SUBWFB x0D,F
4764:  MOVFF  302,30F
4768:  MOVFF  301,30E
476C:  MOVFF  30B,311
4770:  MOVFF  30A,310
4774:  MOVFF  30D,313
4778:  MOVFF  30C,312
477C:  MOVLB  0
477E:  BRA    45DC
....................       }
4780:  BRA    478A
4782:  MOVLB  3
....................       else
....................          str++;
4784:  INCF   x01,F
4786:  BTFSC  FD8.2
4788:  INCF   x02,F
478A:  MOVLB  3
478C:  BRA    46C6
....................    }
.................... 
....................    return(ostr);
478E:  MOVFF  303,01
4792:  MOVFF  304,02
4796:  MOVLB  0
4798:  RETURN 0
.................... }
.................... 
.................... void http_parse_cgi_string(int32 file, char *ptr)
.................... {
....................    char *pKey, *pValue, c;
.................... 
....................    pKey=ptr;
*
4CAE:  MOVFF  2FB,2FD
4CB2:  MOVFF  2FA,2FC
....................    pValue=0;
4CB6:  MOVLB  2
4CB8:  CLRF   xFF
4CBA:  CLRF   xFE
.................... 
....................    while(TRUE)
....................    {
....................       c = *ptr;
4CBC:  MOVFF  2FB,FEA
4CC0:  MOVFF  2FA,FE9
4CC4:  MOVFF  FEF,300
....................       if ((c=='&') || (c==0))
4CC8:  MOVLB  3
4CCA:  MOVF   x00,W
4CCC:  SUBLW  26
4CCE:  BZ    4CD4
4CD0:  MOVF   x00,F
4CD2:  BNZ   4D34
....................       {
....................          *ptr=0;
4CD4:  MOVFF  2FB,FEA
4CD8:  MOVLB  2
4CDA:  MOVFF  2FA,FE9
4CDE:  CLRF   FEF
....................          http_escape_chars(pKey);
4CE0:  MOVFF  2FD,302
4CE4:  MOVFF  2FC,301
4CE8:  MOVLB  0
4CEA:  RCALL  46BA
....................          http_escape_chars(pValue);
4CEC:  MOVFF  2FF,302
4CF0:  MOVFF  2FE,301
4CF4:  RCALL  46BA
....................          http_exec_cgi(file, pKey, pValue);
4CF6:  MOVFF  2F9,304
4CFA:  MOVFF  2F8,303
4CFE:  MOVFF  2F7,302
4D02:  MOVFF  2F6,301
4D06:  MOVFF  2FD,306
4D0A:  MOVFF  2FC,305
4D0E:  MOVFF  2FF,308
4D12:  MOVFF  2FE,307
4D16:  BRA    4B88
....................          pKey=ptr+1;
4D18:  MOVLW  01
4D1A:  MOVLB  2
4D1C:  ADDWF  xFA,W
4D1E:  MOVWF  xFC
4D20:  MOVLW  00
4D22:  ADDWFC xFB,W
4D24:  MOVWF  xFD
....................          pValue=0;
4D26:  CLRF   xFF
4D28:  CLRF   xFE
....................          if (c==0)
4D2A:  MOVLB  3
4D2C:  MOVF   x00,F
4D2E:  BNZ   4D32
....................             break;
4D30:  BRA    4D60
....................       }
4D32:  BRA    4D54
....................       else if (c=='=')
4D34:  MOVF   x00,W
4D36:  SUBLW  3D
4D38:  BNZ   4D54
....................       {
....................          *ptr=0;
4D3A:  MOVFF  2FB,FEA
4D3E:  MOVLB  2
4D40:  MOVFF  2FA,FE9
4D44:  CLRF   FEF
....................          pValue=ptr+1;
4D46:  MOVLW  01
4D48:  ADDWF  xFA,W
4D4A:  MOVWF  xFE
4D4C:  MOVLW  00
4D4E:  ADDWFC xFB,W
4D50:  MOVWF  xFF
4D52:  MOVLB  3
....................       }
....................       ptr++;
4D54:  MOVLB  2
4D56:  INCF   xFA,F
4D58:  BTFSC  FD8.2
4D5A:  INCF   xFB,F
4D5C:  BRA    4CBC
4D5E:  MOVLB  3
....................    }
4D60:  MOVLB  0
4D62:  RETURN 0
.................... }
.................... 
.................... int8 _httpPutcSocket;
.................... 
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket)
.................... 
.................... void set_tcp_http_putc(int8 newSocket)
.................... {
....................    _httpPutcSocket=newSocket;
*
5080:  MOVFF  2FE,71
5084:  GOTO   5BA4 (RETURN)
.................... }
.................... 
.................... int tcp_http_putc(char c)
.................... {
....................    return(TCPPut(_httpPutcSocket,c));
*
5358:  MOVFF  71,31D
535C:  MOVFF  31C,31E
5360:  BRA    5216
5362:  MOVF   01,W
5364:  RETURN 0
.................... }
.................... 
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS];
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS];
.................... 
.................... #if HTTP_USE_CHUNKS
.................... void TCPPutFileChunkStart(int16 count)
.................... {
....................    printf(tcp_http_putc, "%04LX\r\n", count);
.................... }
.................... 
.................... void TCPPutFileChunkStop(void)
.................... {
....................    tcp_http_putc('\r');
....................    tcp_http_putc('\n');
.................... }
.................... #else
....................  #define TCPPutFileChunkStart(x)
....................  #define TCPPutFileChunkStop()
.................... #endif
.................... 
.................... typedef enum
.................... {
....................    TCP_PUT_CONST_EC_FINISH = 0,
....................    TCP_PUT_CONST_EC_CONTINUE,
....................    TCP_PUT_CONST_EC_ESCAPE
.................... } TCP_PUT_CONST_EC;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileVarChunk(ptr)
.................... //
.................... // send a chunked response from ram
.................... //
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated
.................... //          with the continue position before exit.
.................... //
.................... // Returns a status code:
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr)
.................... //because of a compiler error i had to make this double pointer an int16, when
.................... //it should be a char.
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr)
.................... {
....................    int16 txLeft, n;
....................    char *ptr, ec;
.................... 
....................    ptr=*retPtr;
*
55A2:  MOVFF  301,FEA
55A6:  MOVLB  3
55A8:  MOVFF  300,FE9
55AC:  MOVFF  FEC,307
55B0:  MOVF   FED,F
55B2:  MOVFF  FEF,306
.................... 
....................    n=strlen(ptr);
55B6:  MOVFF  307,31E
55BA:  MOVFF  306,31D
55BE:  MOVLB  0
55C0:  CALL   404C
55C4:  MOVFF  02,305
55C8:  MOVFF  01,304
.................... 
....................    if (!n)
55CC:  MOVLB  3
55CE:  MOVF   x04,W
55D0:  IORWF  x05,W
55D2:  BNZ   55DA
....................       return(TCP_PUT_CONST_EC_FINISH);
55D4:  MOVLW  00
55D6:  MOVWF  01
55D8:  BRA    5656
.................... 
....................    txLeft = tcp_http_tx_left();
55DA:  MOVFF  71,30C
55DE:  MOVLB  0
55E0:  RCALL  54AA
55E2:  MOVFF  02,303
55E6:  MOVFF  01,302
.................... 
....................   #if HTTP_USE_CHUNKS
....................    if (txLeft > 8)
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars
....................    else
....................       return(TCP_PUT_CONST_EC_CONTINUE);
....................   #else
....................    if (!txLeft)
55EA:  MOVLB  3
55EC:  MOVF   x02,W
55EE:  IORWF  x03,W
55F0:  BNZ   55F8
....................       return(TCP_PUT_CONST_EC_CONTINUE);
55F2:  MOVLW  01
55F4:  MOVWF  01
55F6:  BRA    5656
....................   #endif
.................... 
....................    if (n > txLeft)
55F8:  MOVF   x03,W
55FA:  SUBWF  x05,W
55FC:  BNC   560C
55FE:  BNZ   5606
5600:  MOVF   x04,W
5602:  SUBWF  x02,W
5604:  BC    560C
....................    {
....................       ec = TCP_PUT_CONST_EC_CONTINUE;
5606:  MOVLW  01
5608:  MOVWF  x08
....................    }
560A:  BRA    5616
....................    else
....................    {
....................       txLeft = n;
560C:  MOVFF  305,303
5610:  MOVFF  304,302
....................       ec = TCP_PUT_CONST_EC_FINISH;
5614:  CLRF   x08
....................    }
.................... 
....................    TCPPutFileChunkStart(txLeft);
.................... 
....................    while (txLeft--)
5616:  MOVFF  303,03
561A:  MOVF   x02,W
561C:  BTFSC  FD8.2
561E:  DECF   x03,F
5620:  DECF   x02,F
5622:  IORWF  03,W
5624:  BZ    5640
....................    {
....................       tcp_http_putc(*ptr++);
5626:  MOVFF  307,FEA
562A:  MOVF   x06,W
562C:  INCF   x06,F
562E:  BTFSC  FD8.2
5630:  INCF   x07,F
5632:  MOVWF  FE9
5634:  MOVFF  FEF,31C
5638:  MOVLB  0
563A:  RCALL  5358
563C:  MOVLB  3
563E:  BRA    5616
....................    }
.................... 
....................    TCPPutFileChunkStop();
.................... 
....................    *retPtr=ptr;
5640:  MOVFF  301,FEA
5644:  MOVFF  300,FE9
5648:  MOVFF  307,FEC
564C:  MOVF   FED,F
564E:  MOVFF  306,FEF
.................... 
....................    return(ec);
5652:  MOVFF  308,01
5656:  MOVLB  0
5658:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileParseConst(addy, n, doSend)
.................... //
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence,
.................... // n chars or an end of file
.................... //
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address
.................... //        will be updated for the next call.
.................... //
.................... // n - max number of chars to read from file.  will save the total number
.................... //    of chars passed to this pointer.
.................... //
.................... // doSend - if TRUE, then send data to TCP socket
.................... //
.................... // returns the last char read
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend)
*
5678:  MOVLB  3
567A:  CLRF   x14
567C:  CLRF   x13
567E:  BSF    x1B.0
.................... {
....................    char stopC, checkC;
....................    int16 fileSize = 0, max;
....................    int32 addy;
....................    int1 premature = TRUE;
.................... 
....................    max = *n;
5680:  MOVFF  30F,FEA
5684:  MOVFF  30E,FE9
5688:  MOVFF  FEC,316
568C:  MOVF   FED,F
568E:  MOVFF  FEF,315
....................    addy = *retAddy;
5692:  MOVFF  30D,FEA
5696:  MOVFF  30C,FE9
569A:  MOVFF  FEF,317
569E:  MOVFF  FEC,318
56A2:  MOVFF  FEC,319
56A6:  MOVFF  FEC,31A
.................... 
....................    while (TRUE)
....................    {
....................       read_program_memory(addy++, &stopC, 1);
56AA:  MOVFF  31A,31F
56AE:  MOVFF  319,02
56B2:  MOVFF  318,01
56B6:  MOVFF  317,00
56BA:  MOVLW  01
56BC:  ADDWF  x17,F
56BE:  BTFSC  FD8.0
56C0:  INCF   x18,F
56C2:  BTFSC  FD8.2
56C4:  INCF   x19,F
56C6:  BTFSC  FD8.2
56C8:  INCF   x1A,F
56CA:  MOVFF  02,31E
56CE:  MOVFF  01,31D
56D2:  MOVFF  00,31C
56D6:  MOVFF  02,FF8
56DA:  MOVFF  01,FF7
56DE:  MOVFF  00,FF6
56E2:  MOVLW  03
56E4:  MOVWF  FEA
56E6:  MOVLW  11
56E8:  MOVWF  FE9
56EA:  CLRF   x21
56EC:  MOVLW  01
56EE:  MOVWF  x20
56F0:  MOVLB  0
56F2:  RCALL  565A
....................       if (stopC == '%')
56F4:  MOVLB  3
56F6:  MOVF   x11,W
56F8:  SUBLW  25
56FA:  BNZ   577A
....................       {
....................          read_program_memory(addy++, &checkC, 1);
56FC:  MOVFF  31A,31F
5700:  MOVFF  319,02
5704:  MOVFF  318,01
5708:  MOVFF  317,00
570C:  MOVLW  01
570E:  ADDWF  x17,F
5710:  BTFSC  FD8.0
5712:  INCF   x18,F
5714:  BTFSC  FD8.2
5716:  INCF   x19,F
5718:  BTFSC  FD8.2
571A:  INCF   x1A,F
571C:  MOVFF  02,31E
5720:  MOVFF  01,31D
5724:  MOVFF  00,31C
5728:  MOVFF  02,FF8
572C:  MOVFF  01,FF7
5730:  MOVFF  00,FF6
5734:  MOVLW  03
5736:  MOVWF  FEA
5738:  MOVLW  12
573A:  MOVWF  FE9
573C:  CLRF   x21
573E:  MOVLW  01
5740:  MOVWF  x20
5742:  MOVLB  0
5744:  RCALL  565A
....................          if (checkC == '%')
5746:  MOVLB  3
5748:  MOVF   x12,W
574A:  SUBLW  25
574C:  BNZ   5776
....................          {
....................             if (fileSize < max)
574E:  MOVF   x14,W
5750:  SUBWF  x16,W
5752:  BNC   5772
5754:  BNZ   575C
5756:  MOVF   x15,W
5758:  SUBWF  x13,W
575A:  BC    5772
....................             {
....................                if (doSend)
575C:  MOVF   x10,F
575E:  BZ    576A
....................                   tcp_http_putc('%');
5760:  MOVLW  25
5762:  MOVWF  x1C
5764:  MOVLB  0
5766:  RCALL  5358
5768:  MOVLB  3
....................                fileSize++;
576A:  INCF   x13,F
576C:  BTFSC  FD8.2
576E:  INCF   x14,F
....................             }
5770:  BRA    5774
....................             else
....................                break;
5772:  BRA    57AC
....................          }
5774:  BRA    5778
....................          else
....................             break;   //ESCAPE
5776:  BRA    57AC
....................       }
5778:  BRA    57AA
....................       else if (stopC)
577A:  MOVF   x11,F
577C:  BZ    57A6
....................       {
....................          if (fileSize < max)
577E:  MOVF   x14,W
5780:  SUBWF  x16,W
5782:  BNC   57A2
5784:  BNZ   578C
5786:  MOVF   x15,W
5788:  SUBWF  x13,W
578A:  BC    57A2
....................          {
....................             if (doSend)
578C:  MOVF   x10,F
578E:  BZ    579A
....................                tcp_http_putc(stopC);
5790:  MOVFF  311,31C
5794:  MOVLB  0
5796:  RCALL  5358
5798:  MOVLB  3
....................             fileSize++;
579A:  INCF   x13,F
579C:  BTFSC  FD8.2
579E:  INCF   x14,F
....................          }
57A0:  BRA    57A4
....................          else
....................             break;
57A2:  BRA    57AC
....................       }
57A4:  BRA    57AA
....................       else
....................       {
....................          premature = FALSE;
57A6:  BCF    x1B.0
....................          break;   //EOF (stopC == 0)
57A8:  BRA    57AC
....................       }
57AA:  BRA    56AA
....................    }
.................... 
....................    if (premature)
57AC:  BTFSS  x1B.0
57AE:  BRA    57C0
....................       addy--;
57B0:  MOVLW  FF
57B2:  ADDWF  x17,F
57B4:  BTFSS  FD8.0
57B6:  ADDWF  x18,F
57B8:  BTFSS  FD8.0
57BA:  ADDWF  x19,F
57BC:  BTFSS  FD8.0
57BE:  ADDWF  x1A,F
.................... 
....................    *n = fileSize;
57C0:  MOVFF  30F,FEA
57C4:  MOVFF  30E,FE9
57C8:  MOVFF  314,FEC
57CC:  MOVF   FED,F
57CE:  MOVFF  313,FEF
....................    *retAddy = addy;
57D2:  MOVFF  30D,FEA
57D6:  MOVFF  30C,FE9
57DA:  MOVFF  317,FEF
57DE:  MOVFF  318,FEC
57E2:  MOVFF  319,FEC
57E6:  MOVFF  31A,FEC
.................... 
....................    return(stopC);
57EA:  MOVFF  311,01
57EE:  MOVLB  0
57F0:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileConstChunk(*addy)
.................... //
.................... // send a chunked response from constant memory
.................... //
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address
.................... //        will be updated for the next call.
.................... //
.................... // returns a response:
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue
.................... //                            from this position on next call.
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file.
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy)
57F2:  MOVLB  3
57F4:  CLRF   x08
57F6:  CLRF   x07
.................... {
....................    char stopC;
....................    int32 addy;
....................    int16 fileSize = 0, txLeft;
....................    TCP_PUT_CONST_EC ec;
.................... 
....................    txLeft = tcp_http_tx_left();
57F8:  MOVFF  71,30C
57FC:  MOVLB  0
57FE:  RCALL  54AA
5800:  MOVFF  02,30A
5804:  MOVFF  01,309
.................... 
....................  #if HTTP_USE_CHUNKS
....................    if (txLeft > 8)
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars
....................    else
....................       return(TCP_PUT_CONST_EC_CONTINUE);
....................  #else
....................    if (!txLeft)
5808:  MOVLB  3
580A:  MOVF   x09,W
580C:  IORWF  x0A,W
580E:  BNZ   5816
....................       return(TCP_PUT_CONST_EC_CONTINUE);
5810:  MOVLW  01
5812:  MOVWF  01
5814:  BRA    58AE
....................  #endif
.................... 
....................    addy = *retAddy;
5816:  MOVFF  301,FEA
581A:  MOVFF  300,FE9
581E:  MOVFF  FEF,303
5822:  MOVFF  FEC,304
5826:  MOVFF  FEC,305
582A:  MOVFF  FEC,306
.................... 
....................    fileSize = 0xFFFF;
582E:  SETF   x08
5830:  SETF   x07
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE);
5832:  MOVLW  03
5834:  MOVWF  x0D
5836:  MOVWF  x0C
5838:  MOVWF  x0F
583A:  MOVLW  07
583C:  MOVWF  x0E
583E:  CLRF   x10
5840:  MOVLB  0
5842:  RCALL  5678
5844:  MOVFF  01,302
.................... 
....................    if (!fileSize && (stopC!='%'))
5848:  MOVLB  3
584A:  MOVF   x07,W
584C:  IORWF  x08,W
584E:  BNZ   585C
5850:  MOVF   x02,W
5852:  SUBLW  25
5854:  BZ    585C
....................       return(TCP_PUT_CONST_EC_FINISH);
5856:  MOVLW  00
5858:  MOVWF  01
585A:  BRA    58AE
.................... 
....................    //TODO: optimize
....................    if (fileSize > txLeft)
585C:  MOVF   x0A,W
585E:  SUBWF  x08,W
5860:  BNC   5878
5862:  BNZ   586A
5864:  MOVF   x07,W
5866:  SUBWF  x09,W
5868:  BC    5878
....................    {
....................       fileSize = txLeft;
586A:  MOVFF  30A,308
586E:  MOVFF  309,307
.................... //      if (stopC == '%')
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE;
.................... //      else
....................          ec = TCP_PUT_CONST_EC_CONTINUE;
5872:  MOVLW  01
5874:  MOVWF  x0B
....................    }
5876:  BRA    5890
....................    else
....................    {
....................       if (stopC == '%')
5878:  MOVF   x02,W
587A:  SUBLW  25
587C:  BNZ   5884
....................          ec = TCP_PUT_CONST_EC_ESCAPE;
587E:  MOVLW  02
5880:  MOVWF  x0B
5882:  BRA    5890
....................       else if (stopC)
5884:  MOVF   x02,F
5886:  BZ    588E
....................          ec = TCP_PUT_CONST_EC_CONTINUE;
5888:  MOVLW  01
588A:  MOVWF  x0B
588C:  BRA    5890
....................       else
....................          ec = TCP_PUT_CONST_EC_FINISH;
588E:  CLRF   x0B
....................    }
.................... 
....................    TCPPutFileChunkStart(fileSize);
.................... 
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE);
5890:  MOVFF  301,30D
5894:  MOVFF  300,30C
5898:  MOVLW  03
589A:  MOVWF  x0F
589C:  MOVLW  07
589E:  MOVWF  x0E
58A0:  MOVLW  01
58A2:  MOVWF  x10
58A4:  MOVLB  0
58A6:  RCALL  5678
.................... 
....................    TCPPutFileChunkStop();
.................... 
....................    return(ec);
58A8:  MOVLB  3
58AA:  MOVFF  30B,01
58AE:  MOVLB  0
58B0:  GOTO   5DAC (RETURN)
.................... }
.................... 
.................... int TCPPutFileConstGetEscape(int32 addy)
.................... {
.................... #if HTTP_USE_DOUBLE_ESCAPE
....................    char str[3];
....................    int ret;
.................... 
....................    read_program_memory(addy, &str[0], 2);
....................    str[2] = 0;
....................    ret = strtol(str, 0, 16);
.................... #else
....................    char ret;
....................    read_program_memory(addy, &ret, 1);
58B4:  MOVFF  304,FF8
58B8:  MOVFF  303,FF7
58BC:  MOVFF  302,FF6
58C0:  MOVLW  03
58C2:  MOVWF  FEA
58C4:  MOVLW  06
58C6:  MOVWF  FE9
58C8:  MOVLB  3
58CA:  CLRF   x21
58CC:  MOVLW  01
58CE:  MOVWF  x20
58D0:  MOVLB  0
58D2:  RCALL  565A
.................... #endif
.................... 
....................    return(ret);
58D4:  MOVLB  3
58D6:  MOVFF  306,01
58DA:  MOVLB  0
58DC:  GOTO   5DE0 (RETURN)
.................... }
.................... 
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType)
.................... {
....................    static char str[40];
....................    int8 socket;
....................    char ec;
....................    int escaped;
.................... 
....................    static enum
....................    {
....................       HTTP_PUT_FILE_INIT = 0,
....................       HTTP_PUT_FILE_CONTINUE,
....................       HTTP_PUT_FILE_CHUNK_END,
....................       HTTP_PUT_FILE_DONE
....................    } status;
.................... 
....................    socket=http_socket[which];
*
5B86:  CLRF   03
5B88:  MOVLB  2
5B8A:  MOVF   xF2,W
5B8C:  ADDLW  6E
5B8E:  MOVWF  FE9
5B90:  MOVLW  00
5B92:  ADDWFC 03,W
5B94:  MOVWF  FEA
5B96:  MOVFF  FEF,2FB
.................... 
....................    set_tcp_http_putc(socket);
5B9A:  MOVFF  2FB,2FE
5B9E:  MOVLB  0
5BA0:  GOTO   5080
.................... 
....................    if (lastHTTPPutConstPos[which] == 0)
5BA4:  MOVLB  2
5BA6:  MOVF   xF2,W
5BA8:  MULLW  04
5BAA:  MOVF   FF3,W
5BAC:  CLRF   03
5BAE:  ADDLW  72
5BB0:  MOVWF  FE9
5BB2:  MOVLW  00
5BB4:  ADDWFC 03,W
5BB6:  MOVWF  FEA
5BB8:  MOVFF  FEF,2FE
5BBC:  MOVFF  FEC,2FF
5BC0:  MOVFF  FEC,300
5BC4:  MOVFF  FEC,301
5BC8:  MOVF   xFE,F
5BCA:  BTFSS  FD8.2
5BCC:  BRA    5D1A
5BCE:  MOVF   xFF,F
5BD0:  BTFSS  FD8.2
5BD2:  BRA    5D1A
5BD4:  MOVLB  3
5BD6:  MOVF   x00,F
5BD8:  BTFSC  FD8.2
5BDA:  BRA    5BE0
5BDC:  MOVLB  2
5BDE:  BRA    5D1A
5BE0:  MOVF   x01,F
5BE2:  BTFSC  FD8.2
5BE4:  BRA    5BEA
5BE6:  MOVLB  2
5BE8:  BRA    5D1A
....................    {
....................       lastHTTPPutVarPos[which] = 0;
5BEA:  CLRF   03
5BEC:  MOVLB  2
5BEE:  MOVFF  2F2,02
5BF2:  BCF    FD8.0
5BF4:  RLCF   02,F
5BF6:  RLCF   03,F
5BF8:  MOVF   02,W
5BFA:  ADDLW  76
5BFC:  MOVWF  FE9
5BFE:  MOVLW  00
5C00:  ADDWFC 03,W
5C02:  MOVWF  FEA
5C04:  CLRF   FEC
5C06:  MOVF   FED,F
5C08:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file;
5C0A:  MOVF   xF2,W
5C0C:  MULLW  04
5C0E:  MOVF   FF3,W
5C10:  CLRF   03
5C12:  ADDLW  72
5C14:  MOVWF  FE9
5C16:  MOVLW  00
5C18:  ADDWFC 03,W
5C1A:  MOVWF  FEA
5C1C:  MOVFF  2F5,FEF
5C20:  MOVFF  2F6,FEC
5C24:  MOVFF  2F7,FEC
5C28:  MOVFF  2F8,FEC
....................       status = HTTP_PUT_FILE_CONTINUE;
5C2C:  MOVLW  01
5C2E:  MOVLB  0
5C30:  MOVWF  x78
.................... 
....................     #if HTTP_USE_CHUNKS
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode);
....................     #else
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode);
5C32:  MOVLW  70
5C34:  MOVWF  FF6
5C36:  MOVLW  01
5C38:  MOVWF  FF7
5C3A:  MOVLW  09
5C3C:  MOVLB  2
5C3E:  MOVWF  xFE
5C40:  MOVLB  0
5C42:  GOTO   5366
5C46:  MOVLW  10
5C48:  MOVWF  FE9
5C4A:  MOVFF  2F4,2FF
5C4E:  MOVFF  2F3,2FE
5C52:  GOTO   5390
5C56:  MOVLW  20
5C58:  MOVLB  3
5C5A:  MOVWF  x1C
5C5C:  MOVLB  0
5C5E:  CALL   5358
....................     #endif
.................... 
....................       switch(errorCode)
5C62:  MOVLB  2
5C64:  MOVF   xF3,W
5C66:  MOVWF  00
5C68:  MOVF   xF4,W
5C6A:  MOVWF  03
5C6C:  MOVF   03,W
5C6E:  BNZ   5C7A
5C70:  MOVLW  C8
5C72:  SUBWF  00,W
5C74:  MOVLB  0
5C76:  BZ    5C9C
5C78:  MOVLB  2
5C7A:  MOVLW  01
5C7C:  SUBWF  03,W
5C7E:  BNZ   5C8A
5C80:  MOVLW  94
5C82:  SUBWF  00,W
5C84:  MOVLB  0
5C86:  BZ    5CB6
5C88:  MOVLB  2
5C8A:  MOVLW  01
5C8C:  SUBWF  03,W
5C8E:  BNZ   5C9A
5C90:  MOVLW  F4
5C92:  SUBWF  00,W
5C94:  MOVLB  0
5C96:  BZ    5CC4
5C98:  MOVLB  2
5C9A:  BRA    5CD4
....................       {
....................          case 200:
....................             printf(tcp_http_putc,"OK");
5C9C:  MOVLW  4F
5C9E:  MOVLB  3
5CA0:  MOVWF  x1C
5CA2:  MOVLB  0
5CA4:  CALL   5358
5CA8:  MOVLW  4B
5CAA:  MOVLB  3
5CAC:  MOVWF  x1C
5CAE:  MOVLB  0
5CB0:  CALL   5358
....................             break;
5CB4:  BRA    5CD6
....................          case 404:
....................             printf(tcp_http_putc,"Not found");
5CB6:  MOVLW  7E
5CB8:  MOVWF  FF6
5CBA:  MOVLW  01
5CBC:  MOVWF  FF7
5CBE:  CALL   5464
....................             break;
5CC2:  BRA    5CD6
....................          case 500:
....................             printf(tcp_http_putc,"Server Error");
5CC4:  MOVLW  88
5CC6:  MOVWF  FF6
5CC8:  MOVLW  01
5CCA:  MOVWF  FF7
5CCC:  CALL   5464
....................             break;
5CD0:  BRA    5CD6
5CD2:  MOVLB  2
....................          default:
....................             break;
5CD4:  MOVLB  0
....................       }
.................... 
....................       printf(tcp_http_putc, "\r\nContent-Type: ");
5CD6:  MOVLW  96
5CD8:  MOVWF  FF6
5CDA:  MOVLW  01
5CDC:  MOVWF  FF7
5CDE:  CALL   5464
....................       if (contentType)
5CE2:  MOVLB  2
5CE4:  MOVF   xF9,W
5CE6:  IORWF  xFA,W
5CE8:  BZ    5CFE
....................          printf(tcp_http_putc, "%s", contentType);
5CEA:  MOVFF  2FA,FEA
5CEE:  MOVFF  2F9,FE9
5CF2:  MOVLB  0
5CF4:  GOTO   5484
5CF8:  MOVLB  0
5CFA:  BRA    5D0C
5CFC:  MOVLB  2
....................       else
....................          printf(tcp_http_putc,"text/html");
5CFE:  MOVLW  A8
5D00:  MOVWF  FF6
5D02:  MOVLW  01
5D04:  MOVWF  FF7
5D06:  MOVLB  0
5D08:  CALL   5464
.................... 
....................     #if HTTP_USE_CHUNKS
....................       printf(tcp_http_putc, "\r\nConnection: close");
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked");
....................     #endif
.................... 
....................       printf(tcp_http_putc, "\r\n\r\n");
5D0C:  MOVLW  B2
5D0E:  MOVWF  FF6
5D10:  MOVLW  01
5D12:  MOVWF  FF7
5D14:  CALL   5464
5D18:  MOVLB  2
....................    }
.................... 
....................    if (lastHTTPPutVarPos[which])
5D1A:  CLRF   03
5D1C:  MOVFF  2F2,02
5D20:  BCF    FD8.0
5D22:  RLCF   02,F
5D24:  RLCF   03,F
5D26:  MOVF   02,W
5D28:  ADDLW  76
5D2A:  MOVWF  FE9
5D2C:  MOVLW  00
5D2E:  ADDWFC 03,W
5D30:  MOVWF  FEA
5D32:  MOVF   FEF,F
5D34:  BZ    5D80
....................    {
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]);
5D36:  CLRF   03
5D38:  MOVFF  2F2,02
5D3C:  BCF    FD8.0
5D3E:  RLCF   02,F
5D40:  RLCF   03,F
5D42:  MOVF   02,W
5D44:  ADDLW  76
5D46:  MOVWF  01
5D48:  MOVLW  00
5D4A:  ADDWFC 03,F
5D4C:  MOVFF  01,2FE
5D50:  MOVFF  03,2FF
5D54:  MOVFF  03,301
5D58:  MOVFF  01,300
5D5C:  MOVLB  0
5D5E:  RCALL  55A2
....................       lastHTTPPutVarPos[which] = 0;
5D60:  CLRF   03
5D62:  MOVLB  2
5D64:  MOVFF  2F2,02
5D68:  BCF    FD8.0
5D6A:  RLCF   02,F
5D6C:  RLCF   03,F
5D6E:  MOVF   02,W
5D70:  ADDLW  76
5D72:  MOVWF  FE9
5D74:  MOVLW  00
5D76:  ADDWFC 03,W
5D78:  MOVWF  FEA
5D7A:  CLRF   FEC
5D7C:  MOVF   FED,F
5D7E:  CLRF   FEF
....................    }
.................... 
....................    if (status == HTTP_PUT_FILE_CONTINUE)
5D80:  MOVLB  0
5D82:  DECFSZ x78,W
5D84:  BRA    5ED8
....................    {
....................       do {
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]);
5D86:  MOVLB  2
5D88:  MOVF   xF2,W
5D8A:  MULLW  04
5D8C:  MOVF   FF3,W
5D8E:  CLRF   03
5D90:  ADDLW  72
5D92:  MOVWF  01
5D94:  MOVLW  00
5D96:  ADDWFC 03,F
5D98:  MOVFF  01,2FE
5D9C:  MOVFF  03,2FF
5DA0:  MOVFF  03,301
5DA4:  MOVFF  01,300
5DA8:  MOVLB  0
5DAA:  BRA    57F2
5DAC:  MOVFF  01,2FC
.................... 
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE)
5DB0:  MOVLB  2
5DB2:  MOVF   xFC,W
5DB4:  SUBLW  02
5DB6:  BTFSS  FD8.2
5DB8:  BRA    5EC6
....................          {
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]);
5DBA:  MOVF   xF2,W
5DBC:  MULLW  04
5DBE:  MOVF   FF3,W
5DC0:  CLRF   03
5DC2:  ADDLW  72
5DC4:  MOVWF  FE9
5DC6:  MOVLW  00
5DC8:  ADDWFC 03,W
5DCA:  MOVWF  FEA
5DCC:  MOVFF  FEF,302
5DD0:  MOVFF  FEC,303
5DD4:  MOVFF  FEC,304
5DD8:  MOVFF  FEC,305
5DDC:  MOVLB  0
5DDE:  BRA    58B4
5DE0:  MOVFF  01,2FD
....................            #if HTTP_USE_DOUBLE_ESCAPE
....................             lastHTTPPutConstPos[which] += 2;
....................            #else
....................             lastHTTPPutConstPos[which] += 1;
5DE4:  MOVLB  2
5DE6:  MOVF   xF2,W
5DE8:  MULLW  04
5DEA:  MOVF   FF3,W
5DEC:  CLRF   03
5DEE:  ADDLW  72
5DF0:  MOVWF  FE9
5DF2:  MOVLW  00
5DF4:  ADDWFC 03,W
5DF6:  MOVWF  FEA
5DF8:  MOVLW  01
5DFA:  ADDWF  FEF,W
5DFC:  MOVWF  00
5DFE:  MOVLW  00
5E00:  ADDWFC FEC,W
5E02:  MOVWF  01
5E04:  MOVLW  00
5E06:  ADDWFC FEC,W
5E08:  MOVWF  02
5E0A:  MOVLW  00
5E0C:  ADDWFC FEC,W
5E0E:  MOVF   FED,F
5E10:  MOVF   FED,F
5E12:  MOVF   FED,F
5E14:  MOVFF  00,FEF
5E18:  MOVFF  01,FEC
5E1C:  MOVFF  02,FEC
5E20:  MOVWF  FEC
....................            #endif
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1);
5E22:  MOVFF  2F8,301
5E26:  MOVFF  2F7,300
5E2A:  MOVFF  2F6,2FF
5E2E:  MOVFF  2F5,2FE
5E32:  MOVFF  2FD,302
5E36:  MOVLW  01
5E38:  MOVLB  3
5E3A:  MOVWF  x04
5E3C:  MOVLW  3C
5E3E:  MOVWF  x03
5E40:  MOVLW  27
5E42:  MOVWF  x05
5E44:  MOVLB  0
5E46:  BRA    5A90
....................             lastHTTPPutVarPos[which] = &str[0];
5E48:  CLRF   03
5E4A:  MOVLB  2
5E4C:  MOVFF  2F2,02
5E50:  BCF    FD8.0
5E52:  RLCF   02,F
5E54:  RLCF   03,F
5E56:  MOVF   02,W
5E58:  ADDLW  76
5E5A:  MOVWF  FE9
5E5C:  MOVLW  00
5E5E:  ADDWFC 03,W
5E60:  MOVWF  FEA
5E62:  MOVLW  01
5E64:  MOVWF  FEC
5E66:  MOVF   FED,F
5E68:  MOVLW  3C
5E6A:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]);
5E6C:  CLRF   03
5E6E:  MOVFF  2F2,02
5E72:  BCF    FD8.0
5E74:  RLCF   02,F
5E76:  RLCF   03,F
5E78:  MOVF   02,W
5E7A:  ADDLW  76
5E7C:  MOVWF  01
5E7E:  MOVLW  00
5E80:  ADDWFC 03,F
5E82:  MOVFF  01,2FE
5E86:  MOVFF  03,2FF
5E8A:  MOVFF  03,301
5E8E:  MOVFF  01,300
5E92:  MOVLB  0
5E94:  CALL   55A2
5E98:  MOVFF  01,2FC
....................             if (ec == TCP_PUT_CONST_EC_FINISH)
5E9C:  MOVLB  2
5E9E:  MOVF   xFC,F
5EA0:  BNZ   5EC2
....................                lastHTTPPutVarPos[which] = 0;
5EA2:  CLRF   03
5EA4:  MOVFF  2F2,02
5EA8:  BCF    FD8.0
5EAA:  RLCF   02,F
5EAC:  RLCF   03,F
5EAE:  MOVF   02,W
5EB0:  ADDLW  76
5EB2:  MOVWF  FE9
5EB4:  MOVLW  00
5EB6:  ADDWFC 03,W
5EB8:  MOVWF  FEA
5EBA:  CLRF   FEC
5EBC:  MOVF   FED,F
5EBE:  CLRF   FEF
5EC0:  BRA    5EC4
....................             else
....................                break;
5EC2:  BRA    5ED6
....................          }
5EC4:  BRA    5ED4
....................          else
....................          {
....................             if (ec == TCP_PUT_CONST_EC_FINISH)
5EC6:  MOVF   xFC,F
5EC8:  BNZ   5ED2
....................                status = HTTP_PUT_FILE_CHUNK_END;
5ECA:  MOVLW  02
5ECC:  MOVLB  0
5ECE:  MOVWF  x78
5ED0:  MOVLB  2
....................             break;
5ED2:  BRA    5ED6
....................          }
....................       } while (TRUE);
5ED4:  BRA    5D88
5ED6:  MOVLB  0
....................    }
.................... 
....................    if (status == HTTP_PUT_FILE_CHUNK_END)
5ED8:  MOVF   x78,W
5EDA:  SUBLW  02
5EDC:  BNZ   5EE2
....................    {
....................      #if HTTP_USE_CHUNKS
....................       if (tcp_http_tx_left() > 8)
....................       {
....................          TCPPutFileChunkStart(0);
....................          TCPPutFileChunkStop();
....................          status = HTTP_PUT_FILE_DONE;
....................       }
....................      #else
....................       status = HTTP_PUT_FILE_DONE;
5EDE:  MOVLW  03
5EE0:  MOVWF  x78
....................      #endif
....................    }
.................... 
.................... 
....................    TCPFlush(socket);
5EE2:  MOVFF  2FB,323
5EE6:  CALL   5088
.................... 
....................    return(status == HTTP_PUT_FILE_DONE);
5EEA:  MOVF   x78,W
5EEC:  SUBLW  03
5EEE:  BZ    5EF4
5EF0:  MOVLW  00
5EF2:  BRA    5EF6
5EF4:  MOVLW  01
5EF6:  MOVWF  01
5EF8:  RETURN 0
.................... }
.................... 
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack
.................... void HTTP_Init(void) {
....................    int8 i;
....................    debug_http("\r\nHTTP OPENING");
....................    if (HTTP_PORT != 0)
....................    {
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++)
*
1006:  MOVLB  2
1008:  CLRF   xE0
100A:  MOVF   xE0,F
100C:  BNZ   106A
....................       {
....................          http_socket[i]=TCPListen(HTTP_PORT);
100E:  CLRF   03
1010:  MOVF   xE0,W
1012:  ADDLW  6E
1014:  MOVWF  01
1016:  MOVLW  00
1018:  ADDWFC 03,F
101A:  MOVFF  01,2E1
101E:  MOVFF  03,2E2
1022:  CLRF   xE4
1024:  MOVLW  50
1026:  MOVWF  xE3
1028:  MOVLB  0
102A:  BRA    0F1A
102C:  MOVFF  2E2,FEA
1030:  MOVFF  2E1,FE9
1034:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]);
....................          if (http_socket[i]!=INVALID_SOCKET)
1038:  CLRF   03
103A:  MOVLB  2
103C:  MOVF   xE0,W
103E:  ADDLW  6E
1040:  MOVWF  FE9
1042:  MOVLW  00
1044:  ADDWFC 03,W
1046:  MOVWF  FEA
1048:  MOVF   FEF,W
104A:  SUBLW  FE
104C:  BZ    1066
....................          {
....................             http_state[i]=HTTP_LISTEN_WAIT;
104E:  BCF    FD8.0
1050:  RLCF   xE0,W
1052:  CLRF   03
1054:  ADDLW  6F
1056:  MOVWF  FE9
1058:  MOVLW  00
105A:  ADDWFC 03,W
105C:  MOVWF  FEA
105E:  MOVLW  01
1060:  MOVWF  FEC
1062:  MOVF   FED,F
1064:  MOVWF  FEF
....................          }
1066:  INCF   xE0,F
1068:  BRA    100A
....................       }
....................    }
....................    else
....................    {
....................       debug_http("\r\nHTTP DISABLED");
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++)
....................       {
....................             http_state[i]=HTTP_DISABLED;
....................       }
....................    }
106A:  MOVLB  0
106C:  GOTO   1082 (RETURN)
.................... }
.................... 
.................... void HTTP_Task(void) {
....................    static char tokens_header[]=" ";
....................    static char tokens_get[]="?";
....................    static char http_get_str[]="GET";
....................    static char http_post_str[]="POST";
....................    static char http_len_str[]="Content-Length:";
....................    //static char http_keepalive_str[]="keep-alive";
....................    //static char http_connection_str[]="Connection";
.................... 
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE];
.................... 
....................    static int8 i[HTTP_NUM_SOCKETS];
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0};
....................    static int32 http_page_req[HTTP_NUM_SOCKETS];
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0};
....................    static int16 http_timer[HTTP_NUM_SOCKETS];
....................  #if HTTP_USE_CONTENT_TYPE
....................    static char contentType[HTTP_NUM_SOCKETS][12];
....................  #endif
.................... 
....................    int1 doneSend, postContinue;
.................... 
....................    char c, *pKey, *pValue;
....................    int8 hs, currSocket;
.................... 
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++)
*
600A:  MOVLB  2
600C:  CLRF   xEC
600E:  MOVF   xEC,F
6010:  BTFSS  FD8.2
6012:  GOTO   6C5E
....................    {
....................       if (http_state[hs]==HTTP_DISABLED)
6016:  BCF    FD8.0
6018:  RLCF   xEC,W
601A:  CLRF   03
601C:  ADDLW  6F
601E:  MOVWF  FE9
6020:  MOVLW  00
6022:  ADDWFC 03,W
6024:  MOVWF  FEA
6026:  MOVFF  FEC,2EF
602A:  MOVF   FED,F
602C:  MOVFF  FEF,2EE
6030:  INCFSZ xEE,W
6032:  BRA    603C
6034:  MOVF   xEF,F
6036:  BNZ   603C
....................          return;
6038:  GOTO   6C5E
.................... 
....................       currSocket=http_socket[hs];
603C:  CLRF   03
603E:  MOVF   xEC,W
6040:  ADDLW  6E
6042:  MOVWF  FE9
6044:  MOVLW  00
6046:  ADDWFC 03,W
6048:  MOVWF  FEA
604A:  MOVFF  FEF,2ED
.................... 
....................       if (!TCPIsConnected(currSocket))
604E:  MOVFF  2ED,2EE
6052:  MOVLB  0
6054:  CALL   3E12
6058:  MOVF   01,F
605A:  BNZ   6078
....................          http_state[hs]=HTTP_LISTEN_WAIT;
605C:  BCF    FD8.0
605E:  MOVLB  2
6060:  RLCF   xEC,W
6062:  CLRF   03
6064:  ADDLW  6F
6066:  MOVWF  FE9
6068:  MOVLW  00
606A:  ADDWFC 03,W
606C:  MOVWF  FEA
606E:  MOVLW  01
6070:  MOVWF  FEC
6072:  MOVF   FED,F
6074:  MOVWF  FEF
6076:  MOVLB  0
.................... 
....................       switch(http_state[hs])
6078:  BCF    FD8.0
607A:  MOVLB  2
607C:  RLCF   xEC,W
607E:  CLRF   03
6080:  ADDLW  6F
6082:  MOVWF  FE9
6084:  MOVLW  00
6086:  ADDWFC 03,W
6088:  MOVWF  FEA
608A:  MOVF   FEF,W
608C:  MOVWF  00
608E:  MOVF   FEE,F
6090:  MOVF   FED,W
6092:  MOVWF  03
6094:  MOVLW  01
6096:  SUBWF  03,W
6098:  BNZ   60A4
609A:  MOVLW  01
609C:  SUBWF  00,W
609E:  MOVLB  0
60A0:  BZ    6152
60A2:  MOVLB  2
60A4:  MOVLW  01
60A6:  SUBWF  03,W
60A8:  BNZ   60B4
60AA:  MOVLW  02
60AC:  SUBWF  00,W
60AE:  MOVLB  0
60B0:  BZ    6162
60B2:  MOVLB  2
60B4:  MOVLW  01
60B6:  SUBWF  03,W
60B8:  BNZ   60C6
60BA:  MOVLW  03
60BC:  SUBWF  00,W
60BE:  MOVLB  0
60C0:  BTFSC  FD8.2
60C2:  BRA    6208
60C4:  MOVLB  2
60C6:  MOVLW  01
60C8:  SUBWF  03,W
60CA:  BNZ   60D8
60CC:  MOVLW  04
60CE:  SUBWF  00,W
60D0:  MOVLB  0
60D2:  BTFSC  FD8.2
60D4:  BRA    6680
60D6:  MOVLB  2
60D8:  MOVLW  01
60DA:  SUBWF  03,W
60DC:  BNZ   60EA
60DE:  MOVLW  05
60E0:  SUBWF  00,W
60E2:  MOVLB  0
60E4:  BTFSC  FD8.2
60E6:  BRA    66DE
60E8:  MOVLB  2
60EA:  MOVLW  01
60EC:  SUBWF  03,W
60EE:  BNZ   60FE
60F0:  MOVLW  06
60F2:  SUBWF  00,W
60F4:  MOVLB  0
60F6:  BTFSC  FD8.2
60F8:  GOTO   698C
60FC:  MOVLB  2
60FE:  MOVLW  01
6100:  SUBWF  03,W
6102:  BNZ   6112
6104:  MOVLW  07
6106:  SUBWF  00,W
6108:  MOVLB  0
610A:  BTFSC  FD8.2
610C:  GOTO   69C4
6110:  MOVLB  2
6112:  MOVLW  01
6114:  SUBWF  03,W
6116:  BNZ   6126
6118:  MOVLW  08
611A:  SUBWF  00,W
611C:  MOVLB  0
611E:  BTFSC  FD8.2
6120:  GOTO   6B00
6124:  MOVLB  2
6126:  MOVLW  01
6128:  SUBWF  03,W
612A:  BNZ   613A
612C:  MOVLW  09
612E:  SUBWF  00,W
6130:  MOVLB  0
6132:  BTFSC  FD8.2
6134:  GOTO   6B4A
6138:  MOVLB  2
613A:  MOVLW  01
613C:  SUBWF  03,W
613E:  BNZ   614E
6140:  MOVLW  0A
6142:  SUBWF  00,W
6144:  MOVLB  0
6146:  BTFSC  FD8.2
6148:  GOTO   6C52
614C:  MOVLB  2
614E:  GOTO   6C54
....................       {
....................          case HTTP_LISTEN_WAIT:
....................             if (!TCPIsConnected(currSocket))
6152:  MOVFF  2ED,2EE
6156:  CALL   3E12
615A:  MOVF   01,F
615C:  BNZ   6162
....................                break;
615E:  GOTO   6C56
....................             debug_http("HTTP %U CONNECTED\r\n", hs);
.................... 
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header
....................          case HTTP_CONNECTED:
....................             debug_http("HTTP %U LISTENING\r\n", hs);
....................             buffer[hs][0]=0;
6162:  MOVLB  2
6164:  MOVF   xEC,W
6166:  MULLW  FE
6168:  MOVF   FF3,W
616A:  CLRF   xEF
616C:  MOVWF  xEE
616E:  MOVLW  79
6170:  ADDWF  xEE,W
6172:  MOVWF  FE9
6174:  MOVLW  01
6176:  ADDWFC xEF,W
6178:  MOVWF  FEA
617A:  CLRF   FEF
....................             i[hs]=0;
617C:  CLRF   03
617E:  MOVF   xEC,W
6180:  ADDLW  83
6182:  MOVWF  FE9
6184:  MOVLW  00
6186:  ADDWFC 03,W
6188:  MOVWF  FEA
618A:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS;
618C:  BCF    FD8.0
618E:  RLCF   xEC,W
6190:  CLRF   03
6192:  ADDLW  6F
6194:  MOVWF  FE9
6196:  MOVLW  00
6198:  ADDWFC 03,W
619A:  MOVWF  FEA
619C:  MOVLW  01
619E:  MOVWF  FEC
61A0:  MOVF   FED,F
61A2:  MOVLW  03
61A4:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
61A6:  BCF    FD8.0
61A8:  RLCF   xEC,W
61AA:  CLRF   03
61AC:  ADDLW  7B
61AE:  MOVWF  01
61B0:  MOVLW  02
61B2:  ADDWFC 03,F
61B4:  MOVFF  01,2EE
61B8:  MOVFF  03,2EF
61BC:  MOVLB  0
61BE:  CALL   24E0
61C2:  MOVFF  2EF,FEA
61C6:  MOVFF  2EE,FE9
61CA:  MOVFF  02,FEC
61CE:  MOVF   FED,F
61D0:  MOVFF  01,FEF
....................             http_page_req[hs]=0;
61D4:  MOVLB  2
61D6:  MOVF   xEC,W
61D8:  MULLW  04
61DA:  MOVF   FF3,W
61DC:  CLRF   03
61DE:  ADDLW  77
61E0:  MOVWF  FE9
61E2:  MOVLW  02
61E4:  ADDWFC 03,W
61E6:  MOVWF  FEA
61E8:  CLRF   FEF
61EA:  CLRF   FEC
61EC:  CLRF   FEC
61EE:  CLRF   FEC
....................             http_post_len[hs]=0;
61F0:  BCF    FD8.0
61F2:  RLCF   xEC,W
61F4:  CLRF   03
61F6:  ADDLW  85
61F8:  MOVWF  FE9
61FA:  MOVLW  00
61FC:  ADDWFC 03,W
61FE:  MOVWF  FEA
6200:  CLRF   FEC
6202:  MOVF   FED,F
6204:  CLRF   FEF
6206:  MOVLB  0
....................             //http_got_headers[hs]=FALSE;
....................             //http_isKeepAlive[hs]=FALSE;
.................... 
....................          case HTTP_GET_HEADERS:
....................             postContinue=FALSE;
6208:  MOVLB  2
620A:  BCF    xE6.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c))
620C:  MOVFF  2ED,2EE
6210:  MOVLB  0
6212:  CALL   3E3C
6216:  MOVF   01,F
6218:  BTFSC  FD8.2
621A:  BRA    6584
621C:  MOVFF  2ED,2EE
6220:  MOVLW  02
6222:  MOVLB  2
6224:  MOVWF  xF0
6226:  MOVLW  E7
6228:  MOVWF  xEF
622A:  MOVLB  0
622C:  CALL   3E68
6230:  MOVF   01,F
6232:  BTFSC  FD8.2
6234:  BRA    6584
....................             {
....................                //http_got_headers[hs]=TRUE;
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) )
6236:  MOVLB  2
6238:  MOVF   xE7,W
623A:  SUBLW  1F
623C:  BC    6288
623E:  CLRF   03
6240:  MOVF   xEC,W
6242:  ADDLW  83
6244:  MOVWF  FE9
6246:  MOVLW  00
6248:  ADDWFC 03,W
624A:  MOVWF  FEA
624C:  MOVF   FEF,W
624E:  SUBLW  FB
6250:  BNC   6288
....................                {
....................                   buffer[hs][i[hs]++]=c;
6252:  MOVF   xEC,W
6254:  MULLW  FE
6256:  MOVF   FF3,W
6258:  CLRF   xEF
625A:  MOVWF  xEE
625C:  CLRF   03
625E:  MOVF   xEC,W
6260:  ADDLW  83
6262:  MOVWF  FE9
6264:  MOVLW  00
6266:  ADDWFC 03,W
6268:  MOVWF  FEA
626A:  MOVF   FEF,W
626C:  INCF   FEF,F
626E:  CLRF   03
6270:  ADDWF  xEE,W
6272:  MOVWF  01
6274:  MOVF   xEF,W
6276:  ADDWFC 03,F
6278:  MOVF   01,W
627A:  ADDLW  79
627C:  MOVWF  FE9
627E:  MOVLW  01
6280:  ADDWFC 03,W
6282:  MOVWF  FEA
6284:  MOVFF  2E7,FEF
....................                }
....................                if (c=='\n')
6288:  MOVF   xE7,W
628A:  SUBLW  0A
628C:  BTFSS  FD8.2
628E:  BRA    6580
....................                {
....................                   buffer[hs][i[hs]]=0;
6290:  MOVF   xEC,W
6292:  MULLW  FE
6294:  MOVF   FF3,W
6296:  CLRF   xEF
6298:  MOVWF  xEE
629A:  CLRF   03
629C:  MOVF   xEC,W
629E:  ADDLW  83
62A0:  MOVWF  FE9
62A2:  MOVLW  00
62A4:  ADDWFC 03,W
62A6:  MOVWF  FEA
62A8:  CLRF   03
62AA:  MOVF   FEF,W
62AC:  ADDWF  xEE,W
62AE:  MOVWF  01
62B0:  MOVF   xEF,W
62B2:  ADDWFC 03,F
62B4:  MOVF   01,W
62B6:  ADDLW  79
62B8:  MOVWF  FE9
62BA:  MOVLW  01
62BC:  ADDWFC 03,W
62BE:  MOVWF  FEA
62C0:  CLRF   FEF
....................                   if (
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) &&
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 )
62C2:  MOVF   xEC,W
62C4:  MULLW  FE
62C6:  MOVF   FF3,W
62C8:  CLRF   xEF
62CA:  MOVWF  xEE
62CC:  MOVLW  79
62CE:  ADDWF  xEE,W
62D0:  MOVWF  01
62D2:  MOVLW  01
62D4:  ADDWFC xEF,W
62D6:  MOVWF  03
62D8:  MOVFF  01,2F0
62DC:  MOVWF  xF1
62DE:  MOVWF  xF3
62E0:  MOVFF  01,2F2
62E4:  CLRF   xF5
62E6:  MOVLW  7B
62E8:  MOVWF  xF4
62EA:  MOVLB  0
62EC:  CALL   4084
62F0:  MOVFF  02,2E9
62F4:  MOVFF  01,2E8
62F8:  MOVLB  2
62FA:  MOVF   xE8,F
62FC:  BNZ   6304
62FE:  MOVF   xE9,F
6300:  BTFSC  FD8.2
6302:  BRA    6500
6304:  CLRF   xF3
6306:  CLRF   xF2
6308:  CLRF   xF5
630A:  MOVLW  7B
630C:  MOVWF  xF4
630E:  MOVLB  0
6310:  CALL   4084
6314:  MOVFF  02,2EB
6318:  MOVFF  01,2EA
631C:  MOVLB  2
631E:  MOVF   xEA,F
6320:  BNZ   6328
6322:  MOVF   xEB,F
6324:  BTFSC  FD8.2
6326:  BRA    6500
....................                      )
....................                   {
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue);
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) )
6328:  MOVFF  2E9,2EF
632C:  MOVFF  2E8,2EE
6330:  CLRF   xF1
6332:  MOVLW  7F
6334:  MOVWF  xF0
6336:  MOVLB  0
6338:  CALL   4138
633C:  MOVLB  2
633E:  CLRF   xEF
6340:  MOVFF  01,2EE
6344:  BTFSC  01.7
6346:  DECF   xEF,F
6348:  MOVF   xEE,F
634A:  BNZ   6350
634C:  MOVF   xEF,F
634E:  BZ    637E
6350:  MOVFF  2E9,2EF
6354:  MOVFF  2E8,2EE
6358:  MOVLW  01
635A:  MOVWF  xF1
635C:  MOVLW  64
635E:  MOVWF  xF0
6360:  MOVLB  0
6362:  CALL   4138
6366:  MOVLB  2
6368:  CLRF   xEF
636A:  MOVFF  01,2EE
636E:  BTFSC  01.7
6370:  DECF   xEF,F
6372:  MOVF   xEE,F
6374:  BTFSS  FD8.2
6376:  BRA    648A
6378:  MOVF   xEF,F
637A:  BTFSS  FD8.2
637C:  BRA    648A
....................                      {
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ?
637E:  MOVFF  2EB,2F3
6382:  MOVFF  2EA,2F2
6386:  CLRF   xF5
6388:  MOVLW  7D
638A:  MOVWF  xF4
638C:  MOVLB  0
638E:  CALL   4084
6392:  MOVFF  02,2EB
6396:  MOVFF  01,2EA
....................                         http_escape_chars(pValue);
639A:  MOVFF  2EB,302
639E:  MOVFF  2EA,301
63A2:  CALL   46BA
....................                        #if HTTP_USE_CONTENT_TYPE
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]);
....................                        #else
....................                         http_page_req[hs] = http_get_page(pValue);
63A6:  MOVLB  2
63A8:  MOVF   xEC,W
63AA:  MULLW  04
63AC:  MOVF   FF3,W
63AE:  CLRF   03
63B0:  ADDLW  77
63B2:  MOVWF  01
63B4:  MOVLW  02
63B6:  ADDWFC 03,F
63B8:  MOVFF  01,2EE
63BC:  MOVFF  03,2EF
63C0:  MOVFF  2EB,2F1
63C4:  MOVFF  2EA,2F0
63C8:  MOVLB  0
63CA:  GOTO   488E
63CE:  MOVFF  2EF,FEA
63D2:  MOVFF  2EE,FE9
63D6:  MOVFF  00,FEF
63DA:  MOVFF  01,FEC
63DE:  MOVFF  02,FEC
63E2:  MOVFF  03,FEC
....................                        #endif
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]);
....................                         pValue=strtok(0, tokens_get);
63E6:  MOVLB  2
63E8:  CLRF   xF3
63EA:  CLRF   xF2
63EC:  CLRF   xF5
63EE:  MOVLW  7D
63F0:  MOVWF  xF4
63F2:  MOVLB  0
63F4:  CALL   4084
63F8:  MOVFF  02,2EB
63FC:  MOVFF  01,2EA
....................                         if (pValue)
6400:  MOVLB  2
6402:  MOVF   xEA,W
6404:  IORWF  xEB,W
6406:  BZ    643A
....................                            http_parse_cgi_string(http_page_req[hs], pValue);
6408:  MOVF   xEC,W
640A:  MULLW  04
640C:  MOVF   FF3,W
640E:  CLRF   03
6410:  ADDLW  77
6412:  MOVWF  FE9
6414:  MOVLW  02
6416:  ADDWFC 03,W
6418:  MOVWF  FEA
641A:  MOVFF  FEF,2F6
641E:  MOVFF  FEC,2F7
6422:  MOVFF  FEC,2F8
6426:  MOVFF  FEC,2F9
642A:  MOVFF  2EB,2FB
642E:  MOVFF  2EA,2FA
6432:  MOVLB  0
6434:  CALL   4CAE
6438:  MOVLB  2
.................... 
....................                         if (strcmp(pKey, http_get_str)==0)
643A:  MOVFF  2E9,2EF
643E:  MOVFF  2E8,2EE
6442:  CLRF   xF1
6444:  MOVLW  7F
6446:  MOVWF  xF0
6448:  MOVLB  0
644A:  CALL   4138
644E:  MOVLB  2
6450:  CLRF   xEF
6452:  MOVFF  01,2EE
6456:  BTFSC  01.7
6458:  DECF   xEF,F
645A:  MOVF   xEE,F
645C:  BNZ   6476
645E:  MOVF   xEF,F
6460:  BNZ   6476
....................                            http_cmd[hs]=HTTP_REQ_GET;
6462:  CLRF   03
6464:  MOVF   xEC,W
6466:  ADDLW  84
6468:  MOVWF  FE9
646A:  MOVLW  00
646C:  ADDWFC 03,W
646E:  MOVWF  FEA
6470:  MOVLW  01
6472:  MOVWF  FEF
6474:  BRA    6488
....................                         else
....................                            http_cmd[hs]=HTTP_REQ_POST;
6476:  CLRF   03
6478:  MOVF   xEC,W
647A:  ADDLW  84
647C:  MOVWF  FE9
647E:  MOVLW  00
6480:  ADDWFC 03,W
6482:  MOVWF  FEA
6484:  MOVLW  02
6486:  MOVWF  FEF
....................                      }
6488:  BRA    64FE
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST
648A:  CLRF   03
648C:  MOVF   xEC,W
648E:  ADDLW  84
6490:  MOVWF  FE9
6492:  MOVLW  00
6494:  ADDWFC 03,W
6496:  MOVWF  FEA
6498:  MOVF   FEF,F
649A:  BZ    64FE
....................                      {
....................                         //if you want to parse HTTP headers, do it here.
....................                         //pKey and pVal hold the individual headers.
.................... 
....................                         //this driver only parses the Content-Length header.
....................                         if (strcmp(pKey, http_len_str)==0)
649C:  MOVFF  2E9,2EF
64A0:  MOVFF  2E8,2EE
64A4:  MOVLW  01
64A6:  MOVWF  xF1
64A8:  MOVLW  69
64AA:  MOVWF  xF0
64AC:  MOVLB  0
64AE:  CALL   4138
64B2:  MOVLB  2
64B4:  CLRF   xEF
64B6:  MOVFF  01,2EE
64BA:  BTFSC  01.7
64BC:  DECF   xEF,F
64BE:  MOVF   xEE,F
64C0:  BNZ   64FE
64C2:  MOVF   xEF,F
64C4:  BNZ   64FE
....................                         {
....................                            http_post_len[hs]=atol(pValue);
64C6:  BCF    FD8.0
64C8:  RLCF   xEC,W
64CA:  CLRF   03
64CC:  ADDLW  85
64CE:  MOVWF  01
64D0:  MOVLW  00
64D2:  ADDWFC 03,F
64D4:  MOVFF  01,2EE
64D8:  MOVFF  03,2EF
64DC:  MOVFF  2EB,2F1
64E0:  MOVFF  2EA,2F0
64E4:  MOVLB  0
64E6:  GOTO   4DBA
64EA:  MOVFF  2EF,FEA
64EE:  MOVFF  2EE,FE9
64F2:  MOVFF  02,FEC
64F6:  MOVF   FED,F
64F8:  MOVFF  01,FEF
64FC:  MOVLB  2
....................                         }
....................                      }
....................                   }
64FE:  BRA    6570
....................                   else if (i[hs] == 0)
6500:  CLRF   03
6502:  MOVF   xEC,W
6504:  ADDLW  83
6506:  MOVWF  FE9
6508:  MOVLW  00
650A:  ADDWFC 03,W
650C:  MOVWF  FEA
650E:  MOVF   FEF,F
6510:  BNZ   6570
....................                   {
....................                      //got a double \r\n
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs);
....................                      if (http_cmd[hs] == HTTP_REQ_POST)
6512:  CLRF   03
6514:  MOVF   xEC,W
6516:  ADDLW  84
6518:  MOVWF  FE9
651A:  MOVLW  00
651C:  ADDWFC 03,W
651E:  MOVWF  FEA
6520:  MOVF   FEF,W
6522:  SUBLW  02
6524:  BNZ   6544
....................                      {
....................                         http_state[hs]=HTTP_GET_POST;
6526:  BCF    FD8.0
6528:  RLCF   xEC,W
652A:  CLRF   03
652C:  ADDLW  6F
652E:  MOVWF  FE9
6530:  MOVLW  00
6532:  ADDWFC 03,W
6534:  MOVWF  FEA
6536:  MOVLW  01
6538:  MOVWF  FEC
653A:  MOVF   FED,F
653C:  MOVLW  04
653E:  MOVWF  FEF
....................                         postContinue=TRUE;
6540:  BSF    xE6.1
....................                      }
6542:  BRA    656A
....................                      else
....................                      {
....................                         http_state[hs]=HTTP_SEND_RESPONSE;
6544:  BCF    FD8.0
6546:  RLCF   xEC,W
6548:  CLRF   03
654A:  ADDLW  6F
654C:  MOVWF  FE9
654E:  MOVLW  00
6550:  ADDWFC 03,W
6552:  MOVWF  FEA
6554:  MOVLW  01
6556:  MOVWF  FEC
6558:  MOVF   FED,F
655A:  MOVLW  06
655C:  MOVWF  FEF
....................                         TCPDiscard(currSocket);
655E:  MOVFF  2ED,2F1
6562:  MOVLB  0
6564:  CALL   4F96
6568:  MOVLB  2
....................                      }
....................                      break;   //break out of read from ethernet loop
656A:  MOVLB  0
656C:  BRA    6584
656E:  MOVLB  2
....................                   }
....................                   i[hs]=0;
6570:  CLRF   03
6572:  MOVF   xEC,W
6574:  ADDLW  83
6576:  MOVWF  FE9
6578:  MOVLW  00
657A:  ADDWFC 03,W
657C:  MOVWF  FEA
657E:  CLRF   FEF
....................                }
6580:  BRA    620C
6582:  MOVLB  0
....................             }
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20)
6584:  CALL   24E0
6588:  MOVFF  02,2EF
658C:  MOVFF  01,2EE
6590:  BCF    FD8.0
6592:  MOVLB  2
6594:  RLCF   xEC,W
6596:  CLRF   03
6598:  ADDLW  7B
659A:  MOVWF  FE9
659C:  MOVLW  02
659E:  ADDWFC 03,W
65A0:  MOVWF  FEA
65A2:  MOVFF  FEC,03
65A6:  MOVF   FED,F
65A8:  MOVFF  FEF,01
65AC:  MOVF   02,W
65AE:  SUBWF  03,W
65B0:  BNC   65BA
65B2:  BNZ   65BE
65B4:  MOVF   01,W
65B6:  SUBWF  xEE,W
65B8:  BNC   65BE
65BA:  MOVLW  00
65BC:  BRA    65C0
65BE:  MOVLW  01
65C0:  CLRF   03
65C2:  IORWF  03,W
65C4:  BZ    6608
65C6:  BCF    FD8.0
65C8:  RLCF   xEC,W
65CA:  CLRF   03
65CC:  ADDLW  7B
65CE:  MOVWF  FE9
65D0:  MOVLW  02
65D2:  ADDWFC 03,W
65D4:  MOVWF  FEA
65D6:  MOVFF  FEC,03
65DA:  MOVF   FED,F
65DC:  MOVF   FEF,W
65DE:  SUBLW  FF
65E0:  MOVWF  xEE
65E2:  MOVLW  FF
65E4:  SUBFWB 03,W
65E6:  MOVWF  xEF
65E8:  MOVLB  0
65EA:  CALL   24E0
65EE:  MOVF   01,W
65F0:  MOVLB  2
65F2:  ADDWF  xEE,F
65F4:  MOVF   02,W
65F6:  ADDWFC xEF,F
65F8:  MOVLW  01
65FA:  ADDWF  xEE,W
65FC:  MOVWF  01
65FE:  MOVLW  00
6600:  ADDWFC xEF,W
6602:  MOVWF  03
6604:  MOVF   01,W
6606:  BRA    663C
6608:  MOVLB  0
660A:  CALL   24E0
660E:  MOVFF  02,2EF
6612:  MOVFF  01,2EE
6616:  BCF    FD8.0
6618:  MOVLB  2
661A:  RLCF   xEC,W
661C:  CLRF   03
661E:  ADDLW  7B
6620:  MOVWF  FE9
6622:  MOVLW  02
6624:  ADDWFC 03,W
6626:  MOVWF  FEA
6628:  MOVFF  FEC,03
662C:  MOVF   FED,F
662E:  MOVF   FEF,W
6630:  SUBWF  01,W
6632:  MOVWF  00
6634:  MOVF   03,W
6636:  SUBWFB 02,W
6638:  MOVWF  03
663A:  MOVF   00,W
663C:  SUBLW  C8
663E:  BC    6674
....................             {
....................                //if (http_got_headers[hs])
....................                //{
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs);
....................                   http_page_req[hs]=0xFFFFFFFF;
6640:  MOVF   xEC,W
6642:  MULLW  04
6644:  MOVF   FF3,W
6646:  CLRF   03
6648:  ADDLW  77
664A:  MOVWF  FE9
664C:  MOVLW  02
664E:  ADDWFC 03,W
6650:  MOVWF  FEA
6652:  SETF   FEF
6654:  SETF   FEC
6656:  SETF   FEC
6658:  SETF   FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE;
665A:  BCF    FD8.0
665C:  RLCF   xEC,W
665E:  CLRF   03
6660:  ADDLW  6F
6662:  MOVWF  FE9
6664:  MOVLW  00
6666:  ADDWFC 03,W
6668:  MOVWF  FEA
666A:  MOVLW  01
666C:  MOVWF  FEC
666E:  MOVF   FED,F
6670:  MOVLW  06
6672:  MOVWF  FEF
....................                //}
....................                //else
....................                //{
....................                //   http_state[hs]=HTTP_CLOSE;
....................                //}
....................             }
....................             if (!postContinue)
6674:  BTFSC  xE6.1
6676:  BRA    667E
....................                break;
6678:  MOVLB  0
667A:  BRA    6C56
667C:  MOVLB  2
667E:  MOVLB  0
.................... 
....................          case HTTP_GET_POST:
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]);
....................             http_state[hs]=HTTP_GET_POST_CONTINUE;
6680:  BCF    FD8.0
6682:  MOVLB  2
6684:  RLCF   xEC,W
6686:  CLRF   03
6688:  ADDLW  6F
668A:  MOVWF  FE9
668C:  MOVLW  00
668E:  ADDWFC 03,W
6690:  MOVWF  FEA
6692:  MOVLW  01
6694:  MOVWF  FEC
6696:  MOVF   FED,F
6698:  MOVLW  05
669A:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
669C:  BCF    FD8.0
669E:  RLCF   xEC,W
66A0:  CLRF   03
66A2:  ADDLW  7B
66A4:  MOVWF  01
66A6:  MOVLW  02
66A8:  ADDWFC 03,F
66AA:  MOVFF  01,2EE
66AE:  MOVFF  03,2EF
66B2:  MOVLB  0
66B4:  CALL   24E0
66B8:  MOVFF  2EF,FEA
66BC:  MOVFF  2EE,FE9
66C0:  MOVFF  02,FEC
66C4:  MOVF   FED,F
66C6:  MOVFF  01,FEF
....................             i[hs]=0;
66CA:  CLRF   03
66CC:  MOVLB  2
66CE:  MOVF   xEC,W
66D0:  ADDLW  83
66D2:  MOVWF  FE9
66D4:  MOVLW  00
66D6:  ADDWFC 03,W
66D8:  MOVWF  FEA
66DA:  CLRF   FEF
66DC:  MOVLB  0
.................... 
....................          case HTTP_GET_POST_CONTINUE:
....................             while (
....................                      TCPIsGetReady(currSocket) &&
....................                      TCPGet(currSocket, &c) &&
....................                      (http_post_len[hs] != 0)
....................                   )
66DE:  MOVFF  2ED,2EE
66E2:  CALL   3E3C
66E6:  MOVF   01,F
66E8:  BTFSC  FD8.2
66EA:  BRA    6898
66EC:  MOVFF  2ED,2EE
66F0:  MOVLW  02
66F2:  MOVLB  2
66F4:  MOVWF  xF0
66F6:  MOVLW  E7
66F8:  MOVWF  xEF
66FA:  MOVLB  0
66FC:  CALL   3E68
6700:  MOVF   01,F
6702:  BTFSC  FD8.2
6704:  BRA    6898
6706:  BCF    FD8.0
6708:  MOVLB  2
670A:  RLCF   xEC,W
670C:  CLRF   03
670E:  ADDLW  85
6710:  MOVWF  FE9
6712:  MOVLW  00
6714:  ADDWFC 03,W
6716:  MOVWF  FEA
6718:  MOVFF  FEC,2EF
671C:  MOVF   FED,F
671E:  MOVFF  FEF,2EE
6722:  MOVF   xEE,F
6724:  BNZ   6730
6726:  MOVF   xEF,F
6728:  BTFSS  FD8.2
672A:  BRA    6730
672C:  MOVLB  0
672E:  BRA    6898
....................             {
....................                http_post_len[hs] -= 1;
6730:  BCF    FD8.0
6732:  RLCF   xEC,W
6734:  CLRF   03
6736:  ADDLW  85
6738:  MOVWF  FE9
673A:  MOVLW  00
673C:  ADDWFC 03,W
673E:  MOVWF  FEA
6740:  MOVLW  01
6742:  SUBWF  FEF,W
6744:  MOVWF  00
6746:  MOVLW  00
6748:  SUBWFB FEC,W
674A:  MOVWF  03
674C:  MOVF   00,W
674E:  MOVF   FED,F
6750:  MOVWF  FEF
6752:  MOVFF  03,FEC
.................... 
....................                if (c!='&')
6756:  MOVF   xE7,W
6758:  SUBLW  26
675A:  BZ    6792
....................                {
....................                   buffer[hs][i[hs]++]=c;
675C:  MOVF   xEC,W
675E:  MULLW  FE
6760:  MOVF   FF3,W
6762:  CLRF   xEF
6764:  MOVWF  xEE
6766:  CLRF   03
6768:  MOVF   xEC,W
676A:  ADDLW  83
676C:  MOVWF  FE9
676E:  MOVLW  00
6770:  ADDWFC 03,W
6772:  MOVWF  FEA
6774:  MOVF   FEF,W
6776:  INCF   FEF,F
6778:  CLRF   03
677A:  ADDWF  xEE,W
677C:  MOVWF  01
677E:  MOVF   xEF,W
6780:  ADDWFC 03,F
6782:  MOVF   01,W
6784:  ADDLW  79
6786:  MOVWF  FE9
6788:  MOVLW  01
678A:  ADDWFC 03,W
678C:  MOVWF  FEA
678E:  MOVFF  2E7,FEF
....................                }
.................... 
....................                if ( (c=='&') || (http_post_len[hs] == 0) )
6792:  MOVF   xE7,W
6794:  SUBLW  26
6796:  BZ    67BA
6798:  BCF    FD8.0
679A:  RLCF   xEC,W
679C:  CLRF   03
679E:  ADDLW  85
67A0:  MOVWF  FE9
67A2:  MOVLW  00
67A4:  ADDWFC 03,W
67A6:  MOVWF  FEA
67A8:  MOVFF  FEC,2EF
67AC:  MOVF   FED,F
67AE:  MOVFF  FEF,2EE
67B2:  MOVF   xEE,F
67B4:  BNZ   6894
67B6:  MOVF   xEF,F
67B8:  BNZ   6894
....................                {
....................                   buffer[hs][i[hs]]=0;
67BA:  MOVF   xEC,W
67BC:  MULLW  FE
67BE:  MOVF   FF3,W
67C0:  CLRF   xEF
67C2:  MOVWF  xEE
67C4:  CLRF   03
67C6:  MOVF   xEC,W
67C8:  ADDLW  83
67CA:  MOVWF  FE9
67CC:  MOVLW  00
67CE:  ADDWFC 03,W
67D0:  MOVWF  FEA
67D2:  CLRF   03
67D4:  MOVF   FEF,W
67D6:  ADDWF  xEE,W
67D8:  MOVWF  01
67DA:  MOVF   xEF,W
67DC:  ADDWFC 03,F
67DE:  MOVF   01,W
67E0:  ADDLW  79
67E2:  MOVWF  FE9
67E4:  MOVLW  01
67E6:  ADDWFC 03,W
67E8:  MOVWF  FEA
67EA:  CLRF   FEF
.................... 
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]);
.................... 
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]);
67EC:  MOVF   xEC,W
67EE:  MULLW  04
67F0:  MOVF   FF3,W
67F2:  CLRF   03
67F4:  ADDLW  77
67F6:  MOVWF  FE9
67F8:  MOVLW  02
67FA:  ADDWFC 03,W
67FC:  MOVWF  FEA
67FE:  MOVFF  FEF,2F6
6802:  MOVFF  FEC,2F7
6806:  MOVFF  FEC,2F8
680A:  MOVFF  FEC,2F9
680E:  MOVF   xEC,W
6810:  MULLW  FE
6812:  MOVF   FF3,W
6814:  CLRF   xF3
6816:  MOVWF  xF2
6818:  MOVLW  79
681A:  ADDWF  xF2,W
681C:  MOVWF  01
681E:  MOVLW  01
6820:  ADDWFC xF3,W
6822:  MOVWF  03
6824:  MOVFF  01,2F4
6828:  MOVWF  xF5
682A:  MOVWF  xFB
682C:  MOVFF  01,2FA
6830:  MOVLB  0
6832:  CALL   4CAE
....................                   if (http_post_len[hs] == 0)
6836:  BCF    FD8.0
6838:  MOVLB  2
683A:  RLCF   xEC,W
683C:  CLRF   03
683E:  ADDLW  85
6840:  MOVWF  FE9
6842:  MOVLW  00
6844:  ADDWFC 03,W
6846:  MOVWF  FEA
6848:  MOVFF  FEC,2EF
684C:  MOVF   FED,F
684E:  MOVFF  FEF,2EE
6852:  MOVF   xEE,F
6854:  BNZ   6884
6856:  MOVF   xEF,F
6858:  BNZ   6884
....................                   {
....................                      http_state[hs]=HTTP_SEND_RESPONSE;
685A:  BCF    FD8.0
685C:  RLCF   xEC,W
685E:  CLRF   03
6860:  ADDLW  6F
6862:  MOVWF  FE9
6864:  MOVLW  00
6866:  ADDWFC 03,W
6868:  MOVWF  FEA
686A:  MOVLW  01
686C:  MOVWF  FEC
686E:  MOVF   FED,F
6870:  MOVLW  06
6872:  MOVWF  FEF
....................                      TCPDiscard(currSocket);
6874:  MOVFF  2ED,2F1
6878:  MOVLB  0
687A:  CALL   4F96
....................                      break;
687E:  BRA    6898
....................                   }
6880:  BRA    6896
6882:  MOVLB  2
....................                   else
....................                      i[hs]=0;
6884:  CLRF   03
6886:  MOVF   xEC,W
6888:  ADDLW  83
688A:  MOVWF  FE9
688C:  MOVLW  00
688E:  ADDWFC 03,W
6890:  MOVWF  FEA
6892:  CLRF   FEF
6894:  MOVLB  0
....................                }
6896:  BRA    66DE
....................             }
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20)
6898:  CALL   24E0
689C:  MOVFF  02,2EF
68A0:  MOVFF  01,2EE
68A4:  BCF    FD8.0
68A6:  MOVLB  2
68A8:  RLCF   xEC,W
68AA:  CLRF   03
68AC:  ADDLW  7B
68AE:  MOVWF  FE9
68B0:  MOVLW  02
68B2:  ADDWFC 03,W
68B4:  MOVWF  FEA
68B6:  MOVFF  FEC,03
68BA:  MOVF   FED,F
68BC:  MOVFF  FEF,01
68C0:  MOVF   02,W
68C2:  SUBWF  03,W
68C4:  BNC   68CE
68C6:  BNZ   68D2
68C8:  MOVF   01,W
68CA:  SUBWF  xEE,W
68CC:  BNC   68D2
68CE:  MOVLW  00
68D0:  BRA    68D4
68D2:  MOVLW  01
68D4:  CLRF   03
68D6:  IORWF  03,W
68D8:  BZ    691C
68DA:  BCF    FD8.0
68DC:  RLCF   xEC,W
68DE:  CLRF   03
68E0:  ADDLW  7B
68E2:  MOVWF  FE9
68E4:  MOVLW  02
68E6:  ADDWFC 03,W
68E8:  MOVWF  FEA
68EA:  MOVFF  FEC,03
68EE:  MOVF   FED,F
68F0:  MOVF   FEF,W
68F2:  SUBLW  FF
68F4:  MOVWF  xEE
68F6:  MOVLW  FF
68F8:  SUBFWB 03,W
68FA:  MOVWF  xEF
68FC:  MOVLB  0
68FE:  CALL   24E0
6902:  MOVF   01,W
6904:  MOVLB  2
6906:  ADDWF  xEE,F
6908:  MOVF   02,W
690A:  ADDWFC xEF,F
690C:  MOVLW  01
690E:  ADDWF  xEE,W
6910:  MOVWF  01
6912:  MOVLW  00
6914:  ADDWFC xEF,W
6916:  MOVWF  03
6918:  MOVF   01,W
691A:  BRA    6950
691C:  MOVLB  0
691E:  CALL   24E0
6922:  MOVFF  02,2EF
6926:  MOVFF  01,2EE
692A:  BCF    FD8.0
692C:  MOVLB  2
692E:  RLCF   xEC,W
6930:  CLRF   03
6932:  ADDLW  7B
6934:  MOVWF  FE9
6936:  MOVLW  02
6938:  ADDWFC 03,W
693A:  MOVWF  FEA
693C:  MOVFF  FEC,03
6940:  MOVF   FED,F
6942:  MOVF   FEF,W
6944:  SUBWF  01,W
6946:  MOVWF  00
6948:  MOVF   03,W
694A:  SUBWFB 02,W
694C:  MOVWF  03
694E:  MOVF   00,W
6950:  SUBLW  C8
6952:  BC    6988
....................             {
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs);
....................                http_page_req[hs]=0xFFFFFFFF;
6954:  MOVF   xEC,W
6956:  MULLW  04
6958:  MOVF   FF3,W
695A:  CLRF   03
695C:  ADDLW  77
695E:  MOVWF  FE9
6960:  MOVLW  02
6962:  ADDWFC 03,W
6964:  MOVWF  FEA
6966:  SETF   FEF
6968:  SETF   FEC
696A:  SETF   FEC
696C:  SETF   FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE;
696E:  BCF    FD8.0
6970:  RLCF   xEC,W
6972:  CLRF   03
6974:  ADDLW  6F
6976:  MOVWF  FE9
6978:  MOVLW  00
697A:  ADDWFC 03,W
697C:  MOVWF  FEA
697E:  MOVLW  01
6980:  MOVWF  FEC
6982:  MOVF   FED,F
6984:  MOVLW  06
6986:  MOVWF  FEF
....................             }
....................             break;
6988:  MOVLB  0
698A:  BRA    6C56
.................... 
....................          case HTTP_SEND_RESPONSE:
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs);
....................             lastHTTPPutConstPos[hs]=0;
698C:  MOVLB  2
698E:  MOVF   xEC,W
6990:  MULLW  04
6992:  MOVF   FF3,W
6994:  CLRF   03
6996:  ADDLW  72
6998:  MOVWF  FE9
699A:  MOVLW  00
699C:  ADDWFC 03,W
699E:  MOVWF  FEA
69A0:  CLRF   FEF
69A2:  CLRF   FEC
69A4:  CLRF   FEC
69A6:  CLRF   FEC
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE;
69A8:  BCF    FD8.0
69AA:  RLCF   xEC,W
69AC:  CLRF   03
69AE:  ADDLW  6F
69B0:  MOVWF  FE9
69B2:  MOVLW  00
69B4:  ADDWFC 03,W
69B6:  MOVWF  FEA
69B8:  MOVLW  01
69BA:  MOVWF  FEC
69BC:  MOVF   FED,F
69BE:  MOVLW  07
69C0:  MOVWF  FEF
69C2:  MOVLB  0
.................... 
....................          case HTTP_SEND_RESPONSE_CONTINUE:
....................             TCPDiscard(currSocket);
69C4:  MOVFF  2ED,2F1
69C8:  CALL   4F96
....................             if (TCPIsPutReady(currSocket))
69CC:  MOVFF  2ED,311
69D0:  CALL   4FE4
69D4:  MOVF   01,F
69D6:  BTFSC  FD8.2
69D8:  BRA    6AFE
....................             {
....................                debug_http("\r\nPUTTING HTTP SEG\r\n");
....................                if (http_page_req[hs]==0xFFFFFFFF)
69DA:  MOVLB  2
69DC:  MOVF   xEC,W
69DE:  MULLW  04
69E0:  MOVF   FF3,W
69E2:  CLRF   03
69E4:  ADDLW  77
69E6:  MOVWF  FE9
69E8:  MOVLW  02
69EA:  ADDWFC 03,W
69EC:  MOVWF  FEA
69EE:  MOVFF  FEF,2EE
69F2:  MOVFF  FEC,2EF
69F6:  MOVFF  FEC,2F0
69FA:  MOVFF  FEC,2F1
69FE:  INCFSZ xEE,W
6A00:  BRA    6A46
6A02:  INCFSZ xEF,W
6A04:  BRA    6A46
6A06:  INCFSZ xF0,W
6A08:  BRA    6A46
6A0A:  INCFSZ xF1,W
6A0C:  BRA    6A46
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0);
6A0E:  MOVLW  01
6A10:  MOVWF  03
6A12:  MOVLW  26
6A14:  MOVWF  xEE
6A16:  MOVFF  03,2EF
6A1A:  MOVFF  2EC,2F2
6A1E:  MOVLW  01
6A20:  MOVWF  xF4
6A22:  MOVLW  F4
6A24:  MOVWF  xF3
6A26:  CLRF   xF8
6A28:  CLRF   xF7
6A2A:  MOVFF  03,2F6
6A2E:  MOVFF  2EE,2F5
6A32:  CLRF   xFA
6A34:  CLRF   xF9
6A36:  MOVLB  0
6A38:  CALL   5B86
6A3C:  MOVLB  2
6A3E:  BCF    xE6.0
6A40:  BTFSC  01.0
6A42:  BSF    xE6.0
6A44:  BRA    6ADE
....................                else if (http_page_req[hs])
....................                 #if HTTP_USE_CONTENT_TYPE
6A46:  MOVF   xEC,W
6A48:  MULLW  04
6A4A:  MOVF   FF3,W
6A4C:  CLRF   03
6A4E:  ADDLW  77
6A50:  MOVWF  FE9
6A52:  MOVLW  02
6A54:  ADDWFC 03,W
6A56:  MOVWF  FEA
6A58:  MOVF   FEF,F
6A5A:  BNZ   6A68
6A5C:  MOVF   FEC,F
6A5E:  BNZ   6A68
6A60:  MOVF   FEC,F
6A62:  BNZ   6A68
6A64:  MOVF   FEC,F
6A66:  BZ    6AA8
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]);
....................                 #else
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0);
6A68:  MOVF   xEC,W
6A6A:  MULLW  04
6A6C:  MOVF   FF3,W
6A6E:  CLRF   03
6A70:  ADDLW  77
6A72:  MOVWF  FE9
6A74:  MOVLW  02
6A76:  ADDWFC 03,W
6A78:  MOVWF  FEA
6A7A:  MOVFF  FEF,2F5
6A7E:  MOVFF  FEC,2F6
6A82:  MOVFF  FEC,2F7
6A86:  MOVFF  FEC,2F8
6A8A:  MOVFF  2EC,2F2
6A8E:  CLRF   xF4
6A90:  MOVLW  C8
6A92:  MOVWF  xF3
6A94:  CLRF   xFA
6A96:  CLRF   xF9
6A98:  MOVLB  0
6A9A:  CALL   5B86
6A9E:  MOVLB  2
6AA0:  BCF    xE6.0
6AA2:  BTFSC  01.0
6AA4:  BSF    xE6.0
....................                 #endif
6AA6:  BRA    6ADE
....................                else
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0);
6AA8:  MOVLW  00
6AAA:  MOVWF  03
6AAC:  MOVLW  E2
6AAE:  MOVWF  xEE
6AB0:  MOVFF  03,2EF
6AB4:  MOVFF  2EC,2F2
6AB8:  MOVLW  01
6ABA:  MOVWF  xF4
6ABC:  MOVLW  94
6ABE:  MOVWF  xF3
6AC0:  CLRF   xF8
6AC2:  CLRF   xF7
6AC4:  MOVFF  03,2F6
6AC8:  MOVFF  2EE,2F5
6ACC:  CLRF   xFA
6ACE:  CLRF   xF9
6AD0:  MOVLB  0
6AD2:  CALL   5B86
6AD6:  MOVLB  2
6AD8:  BCF    xE6.0
6ADA:  BTFSC  01.0
6ADC:  BSF    xE6.0
.................... 
....................                if (doneSend)
6ADE:  BTFSS  xE6.0
6AE0:  BRA    6AFC
....................                {
....................                   //if (http_isKeepAlive[hs])
....................                   //   http_state[hs]=HTTP_CONNECTED;
....................                   //else
....................                   //   http_state[hs]=HTTP_CLOSE;
....................                   http_state[hs] = HTTP_CLOSE;
6AE2:  BCF    FD8.0
6AE4:  RLCF   xEC,W
6AE6:  CLRF   03
6AE8:  ADDLW  6F
6AEA:  MOVWF  FE9
6AEC:  MOVLW  00
6AEE:  ADDWFC 03,W
6AF0:  MOVWF  FEA
6AF2:  MOVLW  01
6AF4:  MOVWF  FEC
6AF6:  MOVF   FED,F
6AF8:  MOVLW  08
6AFA:  MOVWF  FEF
6AFC:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs);
....................                }
....................             }
....................             /*else
....................             {
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n",
....................                      TCB[currSocket].RemoteWindow,
....................                      TCB[currSocket].TxBuffer,
....................                      TCB[currSocket].Flags.bIsPutReady
....................                   );
....................                delay_ms(100);
....................             }*/
....................             break;
6AFE:  BRA    6C56
.................... 
....................          case HTTP_CLOSE:
....................             //since we set connection: close in the header, the client
....................             //should automatically close.  but after so many seconds we
....................             //shall kill the connection
....................             http_state[hs]=HTTP_CLOSE_WAITING;
6B00:  BCF    FD8.0
6B02:  MOVLB  2
6B04:  RLCF   xEC,W
6B06:  CLRF   03
6B08:  ADDLW  6F
6B0A:  MOVWF  FE9
6B0C:  MOVLW  00
6B0E:  ADDWFC 03,W
6B10:  MOVWF  FEA
6B12:  MOVLW  01
6B14:  MOVWF  FEC
6B16:  MOVF   FED,F
6B18:  MOVLW  09
6B1A:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
6B1C:  BCF    FD8.0
6B1E:  RLCF   xEC,W
6B20:  CLRF   03
6B22:  ADDLW  7B
6B24:  MOVWF  01
6B26:  MOVLW  02
6B28:  ADDWFC 03,F
6B2A:  MOVFF  01,2EE
6B2E:  MOVFF  03,2EF
6B32:  MOVLB  0
6B34:  CALL   24E0
6B38:  MOVFF  2EF,FEA
6B3C:  MOVFF  2EE,FE9
6B40:  MOVFF  02,FEC
6B44:  MOVF   FED,F
6B46:  MOVFF  01,FEF
.................... 
....................          case HTTP_CLOSE_WAITING:
....................             TCPDiscard(currSocket);
6B4A:  MOVFF  2ED,2F1
6B4E:  CALL   4F96
....................             if (  TCPIsPutReady(currSocket) ||
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5))
6B52:  MOVFF  2ED,311
6B56:  CALL   4FE4
6B5A:  MOVF   01,F
6B5C:  BNZ   6C2A
6B5E:  CALL   24E0
6B62:  MOVFF  02,2EF
6B66:  MOVFF  01,2EE
6B6A:  BCF    FD8.0
6B6C:  MOVLB  2
6B6E:  RLCF   xEC,W
6B70:  CLRF   03
6B72:  ADDLW  7B
6B74:  MOVWF  FE9
6B76:  MOVLW  02
6B78:  ADDWFC 03,W
6B7A:  MOVWF  FEA
6B7C:  MOVFF  FEC,03
6B80:  MOVF   FED,F
6B82:  MOVFF  FEF,01
6B86:  MOVF   02,W
6B88:  SUBWF  03,W
6B8A:  BNC   6B94
6B8C:  BNZ   6B98
6B8E:  MOVF   01,W
6B90:  SUBWF  xEE,W
6B92:  BNC   6B98
6B94:  MOVLW  00
6B96:  BRA    6B9A
6B98:  MOVLW  01
6B9A:  CLRF   03
6B9C:  IORWF  03,W
6B9E:  BZ    6BE2
6BA0:  BCF    FD8.0
6BA2:  RLCF   xEC,W
6BA4:  CLRF   03
6BA6:  ADDLW  7B
6BA8:  MOVWF  FE9
6BAA:  MOVLW  02
6BAC:  ADDWFC 03,W
6BAE:  MOVWF  FEA
6BB0:  MOVFF  FEC,03
6BB4:  MOVF   FED,F
6BB6:  MOVF   FEF,W
6BB8:  SUBLW  FF
6BBA:  MOVWF  xEE
6BBC:  MOVLW  FF
6BBE:  SUBFWB 03,W
6BC0:  MOVWF  xEF
6BC2:  MOVLB  0
6BC4:  CALL   24E0
6BC8:  MOVF   01,W
6BCA:  MOVLB  2
6BCC:  ADDWF  xEE,F
6BCE:  MOVF   02,W
6BD0:  ADDWFC xEF,F
6BD2:  MOVLW  01
6BD4:  ADDWF  xEE,W
6BD6:  MOVWF  01
6BD8:  MOVLW  00
6BDA:  ADDWFC xEF,W
6BDC:  MOVWF  03
6BDE:  MOVF   01,W
6BE0:  BRA    6C12
6BE2:  MOVLB  0
6BE4:  CALL   24E0
6BE8:  MOVFF  02,2EF
6BEC:  BCF    FD8.0
6BEE:  MOVLB  2
6BF0:  RLCF   xEC,W
6BF2:  CLRF   03
6BF4:  ADDLW  7B
6BF6:  MOVWF  FE9
6BF8:  MOVLW  02
6BFA:  ADDWFC 03,W
6BFC:  MOVWF  FEA
6BFE:  MOVFF  FEC,03
6C02:  MOVF   FED,F
6C04:  MOVF   FEF,W
6C06:  SUBWF  01,W
6C08:  MOVWF  00
6C0A:  MOVF   03,W
6C0C:  SUBWFB 02,W
6C0E:  MOVWF  03
6C10:  MOVF   00,W
6C12:  MOVWF  xEE
6C14:  MOVFF  03,2EF
6C18:  MOVF   xEF,F
6C1A:  BTFSC  FD8.2
6C1C:  BRA    6C22
6C1E:  MOVLB  0
6C20:  BRA    6C2A
6C22:  MOVF   xEE,W
6C24:  SUBLW  32
6C26:  BC    6C4E
6C28:  MOVLB  0
....................                )
....................             {
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs);
....................                TCPDisconnect(currSocket);
6C2A:  MOVFF  2ED,2EE
6C2E:  GOTO   5EFA
....................                http_state[hs]=HTTP_CLOSED;
6C32:  BCF    FD8.0
6C34:  MOVLB  2
6C36:  RLCF   xEC,W
6C38:  CLRF   03
6C3A:  ADDLW  6F
6C3C:  MOVWF  FE9
6C3E:  MOVLW  00
6C40:  ADDWFC 03,W
6C42:  MOVWF  FEA
6C44:  MOVLW  01
6C46:  MOVWF  FEC
6C48:  MOVF   FED,F
6C4A:  MOVLW  0A
6C4C:  MOVWF  FEF
....................             }
....................             break;
6C4E:  MOVLB  0
6C50:  BRA    6C56
6C52:  MOVLB  2
.................... 
....................          case HTTP_CLOSED: //do nothing until socket actually closes
....................          default:
....................             break;
6C54:  MOVLB  0
....................       }
6C56:  MOVLB  2
6C58:  INCF   xEC,F
6C5A:  GOTO   600E
....................    }
6C5E:  MOVLB  0
6C60:  GOTO   6E18 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP2
....................    #include "tcpip/http2.c"
.................... #endif
.................... 
.................... #if STACK_USE_MPFS
....................    #include "tcpip/mpfs.c"
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    #include "tcpip/smtp.c"
.................... #endif
.................... 
.................... #if STACK_USE_DNS
....................    #include "tcpip/dns.c"
.................... #endif
.................... 
.................... #if STACK_USE_ANNOUNCE
....................    #include "tcpip/announce.h"
....................    #include "tcpip/announce.c"
.................... #endif
.................... 
.................... #if STACK_USE_SNMP
....................    #include "tcpip/snmp.c"
.................... #endif
.................... 
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h
.................... 
.................... /*
....................  * Stack FSM states.
....................  */
.................... typedef enum _SM_STACK
.................... {
....................     SM_STACK_IDLE=0,
....................     SM_STACK_MAC,
....................     SM_STACK_IP,
....................     SM_STACK_ICMP,
....................     SM_STACK_ICMP_REPLY,
....................     SM_STACK_ARP,
....................     SM_STACK_TCP,
....................     SM_STACK_UDP
.................... } SM_STACK;
.................... 
.................... static SM_STACK smStack;
.................... 
.................... NODE_INFO remoteNode;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componets are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines are used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void)
.................... {
....................     smStack                     = SM_STACK_IDLE;
*
1070:  MOVLB  2
1072:  CLRF   x7D
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     /*
....................      * If DHCP or IP Gleaning is enabled,
....................      * startup in Config Mode.
....................      */
....................     AppConfig.Flags.bInConfigMode = TRUE;
.................... #endif
.................... 
....................    TickInit();
1074:  MOVLB  0
1076:  GOTO   07BA
.................... 
.................... #if STACK_USE_MAC
....................     MACInit();
107A:  BRA    0AC8
.................... #endif
.................... 
.................... #if STACK_USE_ARP
....................     ARPInit();
107C:  BRA    0C96
.................... #endif
.................... 
.................... #if STACK_USE_UDP
....................     UDPInit();
.................... #endif
.................... 
.................... #if STACK_USE_TCP
....................     TCPInit();
107E:  BRA    0DDA
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    DHCPReset();
.................... #endif
.................... 
.................... #if STACK_USE_PPP
....................    ppp_init();
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    TelnetInit();
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    SMTPInit();
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    HTTP_Init();
1080:  BRA    1006
.................... #endif
1082:  GOTO   6F72 (RETURN)
.................... }
.................... 
.................... /*
.................... #if STACK_USE_MCPENC
.................... #if MAC_TX_BUFFER_COUNT > 1
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val)
.................... #else
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val)
.................... #endif
.................... #else
....................  #define DebugDisplayVals()
.................... #endif
.................... */
.................... 
.................... #define DebugDisplayVals()
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically to
....................  *                  ensure timely responses.
....................  *
....................  ********************************************************************/
.................... void StackTask(void)
*
6C64:  MOVLB  2
6C66:  BCF    xE5.0
.................... {
....................     static WORD dataCount;
.................... 
.................... #if STACK_USE_ICMP
....................     static BYTE data[MAX_ICMP_DATA_LEN];
....................     static WORD ICMPId;
....................     static WORD ICMPSeq;
.................... #endif
....................     IP_ADDR tempLocalIP;
.................... 
.................... 
....................     union
....................     {
....................         BYTE MACFrameType;
....................         BYTE IPFrameType;
.................... #if STACK_USE_ICMP
....................         ICMP_CODE ICMPCode;
.................... #endif
....................     } type;
.................... 
.................... 
....................     BOOL lbContinue=FALSE;
.................... 
....................     do
....................     {
....................         lbContinue = FALSE;
6C68:  BCF    xE5.0
....................         switch(smStack)
6C6A:  MOVF   x7D,W
6C6C:  ADDLW  F9
6C6E:  BTFSC  FD8.0
6C70:  BRA    6E0A
6C72:  ADDLW  07
6C74:  MOVLB  0
6C76:  GOTO   6E1C
....................         {
....................         case SM_STACK_IDLE:
....................         case SM_STACK_MAC:
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) )
6C7A:  MOVLW  02
6C7C:  MOVLB  2
6C7E:  MOVWF  xE7
6C80:  MOVLW  7E
6C82:  MOVWF  xE6
6C84:  MOVLW  02
6C86:  MOVWF  xE9
6C88:  MOVLW  E4
6C8A:  MOVWF  xE8
6C8C:  MOVLB  0
6C8E:  GOTO   1242
6C92:  MOVF   01,F
6C94:  BNZ   6C9C
....................             {
....................                 #if STACK_USE_DHCP
....................                     // Normally, an application would not include  DHCP module
....................                     // if it is not enabled. But in case some one wants to disable
....................                     // DHCP module at run-time, remember to not clear our IP
....................                     // address if link is removed.
....................                     if ( !DHCPIsDisabled() )
....................                     {
....................                         if ( !MACIsLinked() )
....................                         {
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul;
....................                             AppConfig.Flags.bInConfigMode = TRUE;
....................                             DHCPReset();
....................                         }
....................                     }
....................                 #endif
....................                 break;
6C96:  MOVLB  2
6C98:  BRA    6E0A
6C9A:  MOVLB  0
....................             }
.................... 
.................... //            debug_stack("\r\nMAC GET ");
.................... 
....................             lbContinue = TRUE;
6C9C:  MOVLB  2
6C9E:  BSF    xE5.0
....................             if ( type.MACFrameType == MAC_IP ) {
6CA0:  MOVF   xE4,F
6CA2:  BNZ   6CAA
....................                 smStack = SM_STACK_IP;
6CA4:  MOVLW  02
6CA6:  MOVWF  x7D
.................... //                debug_stack("IP ");
....................             }
6CA8:  BRA    6CBE
....................             else if ( type.MACFrameType == MAC_ARP ) {
6CAA:  MOVF   xE4,W
6CAC:  SUBLW  06
6CAE:  BNZ   6CB6
....................                 smStack = SM_STACK_ARP;
6CB0:  MOVLW  05
6CB2:  MOVWF  x7D
.................... //                debug_stack("ARP ");
....................             }
6CB4:  BRA    6CBE
....................             else {
....................                 MACDiscardRx();
6CB6:  MOVLB  0
6CB8:  CALL   1160
6CBC:  MOVLB  2
.................... //                debug_stack("DISCARD");
....................             }
....................             break;
6CBE:  BRA    6E0A
.................... 
....................         case SM_STACK_ARP:
.................... #if STACK_USE_ARP
....................             if ( ARPProcess() ) {
6CC0:  GOTO   1ABC
6CC4:  MOVF   01,F
6CC6:  BZ    6CCE
....................                 smStack = SM_STACK_IDLE;
6CC8:  MOVLB  2
6CCA:  CLRF   x7D
6CCC:  MOVLB  0
....................             }
.................... #else
....................             smStack = SM_STACK_IDLE;
.................... #endif
....................             break;
6CCE:  MOVLB  2
6CD0:  BRA    6E0A
.................... 
....................         case SM_STACK_IP:
....................             if ( IPGetHeader(&tempLocalIP,
....................                              &remoteNode,
....................                              &type.IPFrameType,
....................                              &dataCount) )
6CD2:  MOVLW  02
6CD4:  MOVLB  2
6CD6:  MOVWF  xE7
6CD8:  MOVLW  E0
6CDA:  MOVWF  xE6
6CDC:  MOVLW  02
6CDE:  MOVWF  xE9
6CE0:  MOVLW  7E
6CE2:  MOVWF  xE8
6CE4:  MOVLW  02
6CE6:  MOVWF  xEB
6CE8:  MOVLW  E4
6CEA:  MOVWF  xEA
6CEC:  MOVLW  02
6CEE:  MOVWF  xED
6CF0:  MOVLW  88
6CF2:  MOVWF  xEC
6CF4:  MOVLB  0
6CF6:  GOTO   1D96
6CFA:  MOVF   01,F
6CFC:  BZ    6D28
....................             {
....................                 lbContinue = TRUE;
6CFE:  MOVLB  2
6D00:  BSF    xE5.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP )
6D02:  DECFSZ xE4,W
6D04:  BRA    6D0C
....................                 {
....................                     smStack = SM_STACK_ICMP;
6D06:  MOVLW  03
6D08:  MOVWF  x7D
.................... //                    debug_stack("ICMP ");
.................... #if STACK_USE_IP_GLEANING
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled())
....................                     {
....................                         /*
....................                          * Accoriding to "IP Gleaning" procedure,
....................                          * when we receive an ICMP packet with a valid
....................                          * IP address while we are still in configuration
....................                          * mode, accept that address as ours and conclude
....................                          * configuration mode.
....................                          */
....................                         if( tempLocalIP.Val != 0xffffffff )
....................                         {
....................                             AppConfig.Flags.bInConfigMode = FALSE;
....................                             AppConfig.MyIPAddr = tempLocalIP;
....................                             myDHCPBindCount--;
....................                         }
....................                     }
.................... #endif
....................                 }
.................... 
.................... #if STACK_USE_TCP
6D0A:  BRA    6D24
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) {
6D0C:  MOVF   xE4,W
6D0E:  SUBLW  06
6D10:  BNZ   6D18
....................                     smStack = SM_STACK_TCP;
6D12:  MOVLW  06
6D14:  MOVWF  x7D
....................                     debug_stack("TCP ");
....................                 }
.................... #endif
.................... 
.................... #if STACK_USE_UDP
6D16:  BRA    6D24
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) {
....................                     smStack = SM_STACK_UDP;
.................... //                    debug_stack("UDP ");
....................                 }
.................... #endif
.................... 
....................                 else
....................                 {
....................                     lbContinue = FALSE;
6D18:  BCF    xE5.0
....................                     MACDiscardRx();
6D1A:  MOVLB  0
6D1C:  CALL   1160
.................... 
....................                     smStack = SM_STACK_IDLE;
6D20:  MOVLB  2
6D22:  CLRF   x7D
.................... //                    debug_stack("UNKOWN-IP1 ");
....................                 }
....................             }
6D24:  BRA    6D30
6D26:  MOVLB  0
....................             else
....................             {
....................                 MACDiscardRx();
6D28:  CALL   1160
....................                 smStack = SM_STACK_IDLE;
6D2C:  MOVLB  2
6D2E:  CLRF   x7D
.................... //                debug_stack("UNKOWN-IP2 ");
....................             }
....................             break;
6D30:  BRA    6E0A
.................... 
.................... #if STACK_USE_UDP
....................         case SM_STACK_UDP:
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) )
....................             {
.................... //                debug_stack("\r\nUDP PROCESSED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
....................             }
....................             break;
.................... #endif
.................... 
.................... #if STACK_USE_TCP
....................         case SM_STACK_TCP:
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) )
6D32:  MOVLW  02
6D34:  MOVLB  2
6D36:  MOVWF  xE7
6D38:  MOVLW  7E
6D3A:  MOVWF  xE6
6D3C:  MOVLW  02
6D3E:  MOVWF  xE9
6D40:  MOVLW  E0
6D42:  MOVWF  xE8
6D44:  MOVFF  289,2EB
6D48:  MOVFF  288,2EA
6D4C:  MOVLB  0
6D4E:  GOTO   3544
6D52:  MOVF   01,F
6D54:  BZ    6D5C
....................             {
....................                 debug_stack("\r\nTCP PROCESSED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
6D56:  MOVLB  2
6D58:  CLRF   x7D
6D5A:  MOVLB  0
....................             }
....................             break;
6D5C:  MOVLB  2
6D5E:  BRA    6E0A
.................... #endif
.................... 
....................         case SM_STACK_ICMP:
....................             smStack = SM_STACK_IDLE;
6D60:  MOVLB  2
6D62:  CLRF   x7D
.................... 
.................... #if STACK_USE_ICMP
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) )
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) )
6D64:  MOVF   x89,F
6D66:  BNZ   6DB6
6D68:  MOVF   x88,W
6D6A:  SUBLW  48
6D6C:  BNC   6DB6
....................             {
....................                 if ( ICMPGet(&type.ICMPCode,
....................                              data,
....................                              (BYTE*)&dataCount,
....................                              &ICMPId,
....................                              &ICMPSeq) )
6D6E:  MOVLW  02
6D70:  MOVWF  xE7
6D72:  MOVLW  88
6D74:  MOVWF  xE6
6D76:  MOVLW  02
6D78:  MOVWF  xE9
6D7A:  MOVLW  E4
6D7C:  MOVWF  xE8
6D7E:  MOVLW  02
6D80:  MOVWF  xEB
6D82:  MOVLW  8A
6D84:  MOVWF  xEA
6D86:  MOVFF  2E7,2ED
6D8A:  MOVFF  2E6,2EC
6D8E:  MOVLW  02
6D90:  MOVWF  xEF
6D92:  MOVLW  CA
6D94:  MOVWF  xEE
6D96:  MOVLW  02
6D98:  MOVWF  xF1
6D9A:  MOVLW  CC
6D9C:  MOVWF  xF0
6D9E:  MOVLB  0
6DA0:  GOTO   37AE
6DA4:  MOVF   01,F
6DA6:  BZ    6DB8
....................                 {
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST )
6DA8:  MOVLB  2
6DAA:  MOVF   xE4,W
6DAC:  SUBLW  08
6DAE:  BNZ   6DB6
....................                     {
.................... //                        debug_stack("\r\nICMP PROCESSED");
....................                         lbContinue = TRUE;
6DB0:  BSF    xE5.0
....................                         smStack = SM_STACK_ICMP_REPLY;
6DB2:  MOVLW  04
6DB4:  MOVWF  x7D
6DB6:  MOVLB  0
....................                     }
....................                 }
....................             }
....................             DebugDisplayVals();
.................... #endif
....................             MACDiscardRx();
6DB8:  CALL   1160
....................             break;
6DBC:  MOVLB  2
6DBE:  BRA    6E0A
.................... 
.................... #if STACK_USE_ICMP
....................         case SM_STACK_ICMP_REPLY:
....................             if ( ICMPIsTxReady() )
6DC0:  MOVLW  01
6DC2:  MOVLB  3
6DC4:  MOVWF  x6F
6DC6:  MOVLB  0
6DC8:  CALL   25EE
6DCC:  MOVF   01,F
6DCE:  BZ    6E04
....................             {
....................                 ICMPPut(&remoteNode,
....................                         ICMP_ECHO_REPLY,
....................                         data,
....................                         (BYTE)dataCount,
....................                         ICMPId,
....................                         ICMPSeq);
6DD0:  MOVLW  02
6DD2:  MOVLB  2
6DD4:  MOVWF  xE7
6DD6:  MOVLW  7E
6DD8:  MOVWF  xE6
6DDA:  CLRF   xE8
6DDC:  MOVLW  02
6DDE:  MOVWF  xEA
6DE0:  MOVLW  8A
6DE2:  MOVWF  xE9
6DE4:  MOVFF  288,2EB
6DE8:  MOVFF  2CB,2ED
6DEC:  MOVFF  2CA,2EC
6DF0:  MOVFF  2CD,2EF
6DF4:  MOVFF  2CC,2EE
6DF8:  MOVLB  0
6DFA:  GOTO   387E
.................... 
.................... //                debug_stack("\r\nICMP REPLIED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
6DFE:  MOVLB  2
6E00:  CLRF   x7D
6E02:  MOVLB  0
....................             }
....................             break;
6E04:  MOVLB  2
6E06:  BRA    6E0A
6E08:  MOVLB  2
.................... #endif
.................... 
....................         }
.................... 
....................     } while( lbContinue );
6E0A:  BTFSC  xE5.0
6E0C:  BRA    6C68
.................... 
.................... #if STACK_USE_SMTP
....................    SMTPTask();
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_TCP
....................     // Perform timed TCP FSM.
....................     TCPTick();
6E0E:  MOVLB  0
6E10:  GOTO   3998
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    TelnetTask();
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    HTTP_Task();
6E14:  GOTO   600A
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
6E18:  GOTO   7014 (RETURN)
....................     /*
....................      * DHCP must be called all the time even after IP configuration is
....................      * discovered.
....................      * DHCP has to account lease expiration time and renew the configuration
....................      * time.
....................      */
....................     DHCPTask();
.................... 
....................     if ( DHCPIsBound() )
....................         AppConfig.Flags.bInConfigMode = FALSE;
.................... 
.................... #endif
.................... 
.................... 
.................... }
.................... 
.................... /******************************************************************************/
.................... 
.................... /*********************  PAGINA WEB A MOSTRAR **********************************/
.................... /* Página principal INDEX (/) */
.................... const char  HTML_INDEX_PAGE[]="
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000>
.................... 
.................... <center><H1>BeepControl </H1></center>
.................... <BR><center><H2>Dashboard</H2></CENTER>
.................... 
.................... 
.................... <FORM METHOD=GET>
.................... <P>LCD: <INPUT TYPE=\"text\" NAME=\"lcd\" size=20 maxlength=16>
.................... <input type=\"submit\" value=\"Enviar texto\">
.................... </FORM>
.................... 
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM1\" value=\"A\">
.................... <input type=\"submit\" name=\"CM1\" value=\"C\">
.................... <input type=\"submit\" name=\"CM1\" value=\"Z\">
.................... </FORM>
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM2\" value=\"A\">
.................... <input type=\"submit\" name=\"CM2\" value=\"C\">
.................... <input type=\"submit\" name=\"CM2\" value=\"Z\">
.................... </FORM>
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM3\" value=\"A\">
.................... <input type=\"submit\" name=\"CM3\" value=\"C\">
.................... <input type=\"submit\" name=\"CM3\" value=\"Z\">
.................... </FORM>
.................... </BODY></HTML>
.................... ";
.................... 
.................... /* Elección de MAC. No puede haber 2 dispositivos con misma MAC en una misma red
....................    Microchip Vendor ID  MAC: 00.04.A3.xx.xx.xx.  */
.................... void MACAddrInit(void) {
....................    MY_MAC_BYTE1=0;
*
0776:  CLRF   21
....................    MY_MAC_BYTE2=0x04;
0778:  MOVLW  04
077A:  MOVWF  22
....................    MY_MAC_BYTE3=0xA3;
077C:  MOVLW  A3
077E:  MOVWF  23
....................    MY_MAC_BYTE4=0x06;
0780:  MOVLW  06
0782:  MOVWF  24
....................    MY_MAC_BYTE5=0x07;
0784:  MOVLW  07
0786:  MOVWF  25
....................    MY_MAC_BYTE6=0x08;
0788:  MOVLW  08
078A:  MOVWF  26
078C:  GOTO   6F6A (RETURN)
.................... }
.................... 
.................... void IPAddrInit(void) {
....................    //Elección de la dirección IP. 
....................    MY_IP_BYTE1=192;
0790:  MOVLW  C0
0792:  MOVWF  1D
....................    MY_IP_BYTE2=168;
0794:  MOVLW  A8
0796:  MOVWF  1E
....................    MY_IP_BYTE3=1;
0798:  MOVLW  01
079A:  MOVWF  1F
....................    MY_IP_BYTE4=15;
079C:  MOVLW  0F
079E:  MOVWF  20
.................... 
....................    //Elección de la dirección de puerta de enlace. 
....................    MY_GATE_BYTE1=192;
07A0:  MOVLW  C0
07A2:  MOVWF  2B
....................    MY_GATE_BYTE2=168;
07A4:  MOVLW  A8
07A6:  MOVWF  2C
....................    MY_GATE_BYTE3=1;
07A8:  MOVLW  01
07AA:  MOVWF  2D
....................    MY_GATE_BYTE4=1;
07AC:  MOVWF  2E
.................... 
....................    //Elección de la máscara de red.Si no se indica nada se tomará 255.255.255.0
....................    MY_MASK_BYTE1=255;
07AE:  SETF   27
....................    MY_MASK_BYTE2=255;
07B0:  SETF   28
....................    MY_MASK_BYTE3=255;
07B2:  SETF   29
....................    MY_MASK_BYTE4=0;
07B4:  CLRF   2A
07B6:  GOTO   6F6E (RETURN)
.................... }
.................... 
.................... void moveServo(int16 puerto,int16 tiempo){
.................... unsigned int i;
....................    for(i=0;i<60;i++){ 
*
49BE:  MOVLB  3
49C0:  CLRF   x16
49C2:  MOVF   x16,W
49C4:  SUBLW  3B
49C6:  BNC   4A54
....................       output_toggle(puerto);
49C8:  MOVFF  312,317
49CC:  MOVLW  0F
49CE:  MOVWF  x19
49D0:  MOVLW  80
49D2:  MOVWF  x18
49D4:  MOVLB  0
49D6:  BRA    4966
49D8:  MOVLW  00
49DA:  BTFSS  01.0
49DC:  MOVLW  01
49DE:  MOVFF  312,317
49E2:  MOVLB  3
49E4:  MOVWF  x18
49E6:  MOVLW  0F
49E8:  MOVWF  x1A
49EA:  MOVLW  89
49EC:  MOVWF  x19
49EE:  MOVLB  0
49F0:  RCALL  4924
49F2:  MOVFF  312,317
49F6:  MOVLB  3
49F8:  CLRF   x18
49FA:  MOVLW  0F
49FC:  MOVWF  x1A
49FE:  MOVLW  92
4A00:  MOVWF  x19
4A02:  MOVLB  0
4A04:  RCALL  4924
....................       delay_us(tiempo);
4A06:  MOVFF  315,317
4A0A:  MOVLB  3
4A0C:  INCF   x17,F
4A0E:  DECF   x17,F
4A10:  BTFSC  FD8.2
4A12:  BRA    4A1E
4A14:  SETF   x18
4A16:  MOVLB  0
4A18:  RCALL  499E
4A1A:  MOVLB  3
4A1C:  BRA    4A0E
4A1E:  MOVFF  314,318
4A22:  MOVLB  0
4A24:  RCALL  499E
....................       output_low(puerto);
4A26:  MOVFF  312,317
4A2A:  MOVLB  3
4A2C:  CLRF   x18
4A2E:  MOVLW  0F
4A30:  MOVWF  x1A
4A32:  MOVLW  89
4A34:  MOVWF  x19
4A36:  MOVLB  0
4A38:  RCALL  4924
4A3A:  MOVFF  312,317
4A3E:  MOVLB  3
4A40:  CLRF   x18
4A42:  MOVLW  0F
4A44:  MOVWF  x1A
4A46:  MOVLW  92
4A48:  MOVWF  x19
4A4A:  MOVLB  0
4A4C:  RCALL  4924
4A4E:  MOVLB  3
4A50:  INCF   x16,F
4A52:  BRA    49C2
....................     }}
4A54:  MOVLB  0
4A56:  RETURN 0
.................... 
.................... 
.................... void servoAccion(int servo, int accion)   //180 Degree
4A58:  MOVLW  7C
4A5A:  MOVLB  3
4A5C:  MOVWF  x0D
4A5E:  MOVLW  10
4A60:  MOVWF  x0C
4A62:  MOVLW  01
4A64:  MOVWF  x0F
4A66:  MOVLW  64
4A68:  MOVWF  x0E
4A6A:  MOVLW  08
4A6C:  MOVWF  x11
4A6E:  MOVLW  66
4A70:  MOVWF  x10
.................... {
.................... int16 puerto = PIN_C0;
.................... int16 tiempoCerrar = 356;
.................... int16 tiempoAbrir = 2150;
.................... 
.................... switch(servo){
4A72:  MOVF   x0A,W
4A74:  XORLW  01
4A76:  MOVLB  0
4A78:  BZ    4A84
4A7A:  XORLW  03
4A7C:  BZ    4A92
4A7E:  XORLW  01
4A80:  BZ    4AA0
4A82:  BRA    4AAC
....................    case 1:
....................       puerto = PIN_C0; break;
4A84:  MOVLW  7C
4A86:  MOVLB  3
4A88:  MOVWF  x0D
4A8A:  MOVLW  10
4A8C:  MOVWF  x0C
4A8E:  MOVLB  0
4A90:  BRA    4AAC
....................    case 2:
....................       puerto = PIN_C1; break;
4A92:  MOVLW  7C
4A94:  MOVLB  3
4A96:  MOVWF  x0D
4A98:  MOVLW  11
4A9A:  MOVWF  x0C
4A9C:  MOVLB  0
4A9E:  BRA    4AAC
....................    case 3:
....................       puerto = PIN_C2; break;
4AA0:  MOVLW  7C
4AA2:  MOVLB  3
4AA4:  MOVWF  x0D
4AA6:  MOVLW  12
4AA8:  MOVWF  x0C
4AAA:  MOVLB  0
.................... }
.................... 
.................... output_low(puerto); //Me aseguro que este apagado
4AAC:  MOVFF  30C,317
4AB0:  MOVLB  3
4AB2:  CLRF   x18
4AB4:  MOVLW  0F
4AB6:  MOVWF  x1A
4AB8:  MOVLW  89
4ABA:  MOVWF  x19
4ABC:  MOVLB  0
4ABE:  RCALL  4924
4AC0:  MOVFF  30C,317
4AC4:  MOVLB  3
4AC6:  CLRF   x18
4AC8:  MOVLW  0F
4ACA:  MOVWF  x1A
4ACC:  MOVLW  92
4ACE:  MOVWF  x19
4AD0:  MOVLB  0
4AD2:  RCALL  4924
.................... 
.................... switch(accion){
4AD4:  MOVLB  3
4AD6:  MOVF   x0B,W
4AD8:  XORLW  00
4ADA:  MOVLB  0
4ADC:  BZ    4AE8
4ADE:  XORLW  01
4AE0:  BZ    4AFC
4AE2:  XORLW  03
4AE4:  BZ    4B10
4AE6:  BRA    4B5E
....................    case 0: //Cerrar
....................       moveServo(puerto,tiempoCerrar);
4AE8:  MOVFF  30D,313
4AEC:  MOVFF  30C,312
4AF0:  MOVFF  30F,315
4AF4:  MOVFF  30E,314
4AF8:  RCALL  49BE
....................       break;
4AFA:  BRA    4B5E
....................    case 1: //Abrir 180 grados
....................       moveServo(puerto,tiempoAbrir);
4AFC:  MOVFF  30D,313
4B00:  MOVFF  30C,312
4B04:  MOVFF  311,315
4B08:  MOVFF  310,314
4B0C:  RCALL  49BE
....................       break;
4B0E:  BRA    4B5E
....................    case 2: //Abre y cierra
....................       moveServo(puerto,tiempoCerrar); //Me aseguro que se cierre
4B10:  MOVFF  30D,313
4B14:  MOVFF  30C,312
4B18:  MOVFF  30F,315
4B1C:  MOVFF  30E,314
4B20:  RCALL  49BE
....................       moveServo(puerto,tiempoAbrir); //Lo abro
4B22:  MOVFF  30D,313
4B26:  MOVFF  30C,312
4B2A:  MOVFF  311,315
4B2E:  MOVFF  310,314
4B32:  RCALL  49BE
....................       delay_ms(1000); //Espero un segundo en maquina virtual, en no virtual es 3000 ms
4B34:  MOVLW  04
4B36:  MOVLB  3
4B38:  MOVWF  x12
4B3A:  MOVLW  FA
4B3C:  MOVWF  x13
4B3E:  MOVLB  0
4B40:  CALL   04DE
4B44:  MOVLB  3
4B46:  DECFSZ x12,F
4B48:  BRA    4B3A
....................       moveServo(puerto,tiempoCerrar); //Lo cierro
4B4A:  MOVFF  30D,313
4B4E:  MOVFF  30C,312
4B52:  MOVFF  30F,315
4B56:  MOVFF  30E,314
4B5A:  MOVLB  0
4B5C:  RCALL  49BE
....................       break;
....................       }
4B5E:  RETURN 0
.................... }
.................... 
.................... 
.................... /***************************  FUNCIÓN GET PAGE   ******************************/
.................... /* Esta función devuelve la posición de memoria donde se encuentra la página web 
.................... a mostrar. En este caso se trata de una web con 2 páginas. Una principal index(/) 
.................... y una secundaria(/lecturas)                                                   */
.................... 
.................... int32 http_get_page(char *file_str) {
*
488E:  MOVLB  2
4890:  CLRF   xF5
4892:  CLRF   xF4
4894:  CLRF   xF3
4896:  CLRF   xF2
....................    int32 file_loc=0;
....................    static char index[]="/";
....................  
....................    
....................    //printf(lcd_putc,"\fRequest %s ",file_str);      //Muestra en lcd solicitud
.................... 
....................    /* Busca la posición de memoria donde se encuentra la página solicitada */
....................    if (stricmp(file_str,index)==0)                 //Si es la principal...
4898:  MOVFF  2F1,30B
489C:  MOVFF  2F0,30A
48A0:  MOVLW  02
48A2:  MOVLB  3
48A4:  MOVWF  x0D
48A6:  MOVLW  CE
48A8:  MOVWF  x0C
48AA:  MOVLB  0
48AC:  RCALL  479A
48AE:  MOVLB  2
48B0:  CLRF   xF7
48B2:  MOVFF  01,2F6
48B6:  BTFSC  01.7
48B8:  DECF   xF7,F
48BA:  MOVF   xF6,F
48BC:  BNZ   48D2
48BE:  MOVF   xF7,F
48C0:  BNZ   48D2
....................       file_loc=label_address(HTML_INDEX_PAGE);     //...toma su posición en la memoria
48C2:  MOVLW  01
48C4:  MOVWF  03
48C6:  MOVLW  B8
48C8:  MOVWF  xF2
48CA:  MOVFF  03,2F3
48CE:  CLRF   xF4
48D0:  CLRF   xF5
.................... 
....................    return(file_loc);
48D2:  MOVFF  2F2,00
48D6:  MOVFF  2F3,01
48DA:  MOVFF  2F4,02
48DE:  MOVFF  2F5,03
48E2:  MOVLB  0
48E4:  GOTO   63CE (RETURN)
.................... }
.................... 
.................... /**************************  FUNCIÓN FORMAT CHAR  *****************************/
.................... /* Con  la función http_format_char  interconectamos las variables virtuales de 
.................... la página web con las variables del programa del PIC. Se encarga de enviar los 
.................... cambios producidos en la aplicación del PIC y reflejarlos en la aplicación web. 
.................... Muestra,por tanto, las lectura obtenidas por el PIC y las representa en la 
.................... aplicación de la página web      
.................... 
.................... %0 es la variable virtual para representar el valor de la lectura del canal 
.................... analógico
.................... %1 es la variable virtual para representar el valor de la lectura del bit 0 del 
.................... puerto E.
.................... */
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret) {
*
5A90:  MOVLB  3
5A92:  CLRF   x1A
....................    char new_str[20];
....................    int8 len=0;
....................    int8 AD0;
....................    int8 RE0;
.................... 
....................    *str=0;
5A94:  MOVFF  304,FEA
5A98:  MOVFF  303,FE9
5A9C:  CLRF   FEF
.................... 
....................    switch(id) {
5A9E:  MOVF   x02,W
5AA0:  XORLW  30
5AA2:  MOVLB  0
5AA4:  BZ    5AAC
5AA6:  XORLW  01
5AA8:  BZ    5B0C
5AAA:  BRA    5B42
....................       case '0':
....................          set_adc_channel(0);
5AAC:  MOVLW  00
5AAE:  MOVWF  01
5AB0:  MOVF   FC2,W
5AB2:  ANDLW  C3
5AB4:  IORWF  01,W
5AB6:  MOVWF  FC2
....................          delay_us(100);
5AB8:  MOVLW  A6
5ABA:  MOVWF  00
5ABC:  DECFSZ 00,F
5ABE:  BRA    5ABC
5AC0:  NOP   
....................          AD0=read_adc();
5AC2:  BSF    FC2.1
5AC4:  BTFSC  FC2.1
5AC6:  BRA    5AC4
5AC8:  MOVFF  FC4,31B
....................          sprintf(new_str,"0x%X",AD0);
5ACC:  MOVLW  03
5ACE:  MOVWF  x7A
5AD0:  MOVLW  06
5AD2:  MOVWF  x79
5AD4:  MOVLW  30
5AD6:  MOVLB  3
5AD8:  MOVWF  x23
5ADA:  MOVLB  0
5ADC:  RCALL  58E0
5ADE:  MOVLW  78
5AE0:  MOVLB  3
5AE2:  MOVWF  x23
5AE4:  MOVLB  0
5AE6:  RCALL  58E0
5AE8:  MOVFF  31B,31D
5AEC:  MOVLW  37
5AEE:  MOVLB  3
5AF0:  MOVWF  x1E
5AF2:  MOVLB  0
5AF4:  BRA    58FE
....................          len=strlen(new_str);
5AF6:  MOVLW  03
5AF8:  MOVLB  3
5AFA:  MOVWF  x1E
5AFC:  MOVLW  06
5AFE:  MOVWF  x1D
5B00:  MOVLB  0
5B02:  CALL   404C
5B06:  MOVFF  01,31A
....................       break;
5B0A:  BRA    5B48
....................       case '1':
....................          RE0=bit_test(porte,0);
5B0C:  MOVLB  3
5B0E:  CLRF   x1C
5B10:  BTFSC  F84.0
5B12:  INCF   x1C,F
....................          sprintf(new_str,"%d",RE0);
5B14:  MOVLW  03
5B16:  MOVLB  0
5B18:  MOVWF  x7A
5B1A:  MOVLW  06
5B1C:  MOVWF  x79
5B1E:  MOVFF  31C,31D
5B22:  MOVLW  18
5B24:  MOVLB  3
5B26:  MOVWF  x1E
5B28:  MOVLB  0
5B2A:  BRA    5946
....................          len=strlen(new_str);
5B2C:  MOVLW  03
5B2E:  MOVLB  3
5B30:  MOVWF  x1E
5B32:  MOVLW  06
5B34:  MOVWF  x1D
5B36:  MOVLB  0
5B38:  CALL   404C
5B3C:  MOVFF  01,31A
....................       break;  
5B40:  BRA    5B48
....................       default:
....................       len=0;
5B42:  MOVLB  3
5B44:  CLRF   x1A
5B46:  MOVLB  0
....................    }
.................... 
....................    if (len)strncpy(str, new_str, max_ret);
5B48:  MOVLB  3
5B4A:  MOVF   x1A,F
5B4C:  BZ    5B6E
5B4E:  MOVFF  304,31E
5B52:  MOVFF  303,31D
5B56:  MOVLW  03
5B58:  MOVWF  x20
5B5A:  MOVLW  06
5B5C:  MOVWF  x1F
5B5E:  CLRF   x22
5B60:  MOVFF  305,321
5B64:  MOVLB  0
5B66:  BRA    5A08
5B68:  MOVLB  0
5B6A:  BRA    5B7A
5B6C:  MOVLB  3
....................    else  *str=0;
5B6E:  MOVFF  304,FEA
5B72:  MOVFF  303,FE9
5B76:  CLRF   FEF
5B78:  MOVLB  0
....................    
....................    return(len);
5B7A:  MOVLB  3
5B7C:  MOVF   x1A,W
5B7E:  MOVWF  01
5B80:  MOVLB  0
5B82:  GOTO   5E48 (RETURN)
.................... }
.................... 
.................... /***************************  FUNCIÓN EXEC CGI   ******************************/
.................... /* Con la función http_exec_cgi interconectamos las variables virtuales de la 
.................... página web con las variables del programa del PIC. Se encarga de recibir 
.................... los cambios producidos en la aplicación web y reflejarlos en el hardware del PIC. 
.................... Ejecuta, por tanto, la acción elegida según el valor de la variable virtual recibida 
.................... de la página web
.................... 
.................... key es la variable virtual que viene de la pagina web
.................... val es el valor de una variable virtual de la página web
.................... file es la dirección de la página web devuelta por http__page ()
.................... 
.................... */
.................... 
.................... void http_exec_cgi(int32 file, char *key, char *val) {
*
4B88:  MOVLB  3
4B8A:  CLRF   x09
....................    static char boton1_key[]="CM1";
....................    static char boton2_key[]="CM2";
....................    static char boton3_key[]="CM3";
....................    static char lcd_key[]="lcd";
....................    int accionServo = 0;
....................    
....................    //Para ver en la pantalla los valores recibidos
....................   /*
....................    printf(lcd_putc,"\nKEY=%S", key);
....................    printf(lcd_putc,"\nVAL=%S", val);
....................   */
....................    
....................    switch (val){
4B8C:  MOVLW  B4
4B8E:  MOVWF  FF6
4B90:  MOVLW  04
4B92:  MOVWF  FF7
4B94:  MOVFF  308,FEA
4B98:  MOVFF  307,FE9
4B9C:  BRA    48E8
4B9E:  MOVF   01,W
4BA0:  BZ    4BAC
4BA2:  XORLW  01
4BA4:  BZ    4BB4
4BA6:  XORLW  03
4BA8:  BZ    4BBE
4BAA:  BRA    4BC6
....................    case "C": accionServo = 0; break;
4BAC:  MOVLB  3
4BAE:  CLRF   x09
4BB0:  MOVLB  0
4BB2:  BRA    4BC6
....................    case "A": accionServo = 1; break;
4BB4:  MOVLW  01
4BB6:  MOVLB  3
4BB8:  MOVWF  x09
4BBA:  MOVLB  0
4BBC:  BRA    4BC6
....................    case "Z": accionServo = 2; break;
4BBE:  MOVLW  02
4BC0:  MOVLB  3
4BC2:  MOVWF  x09
4BC4:  MOVLB  0
....................    }
.................... 
.................... 
....................    /* Se ejecutará al recibir un request a CM1 */
....................    if (stricmp(key,boton1_key)==0) {
4BC6:  MOVFF  306,30B
4BCA:  MOVFF  305,30A
4BCE:  MOVLW  02
4BD0:  MOVLB  3
4BD2:  MOVWF  x0D
4BD4:  MOVLW  D0
4BD6:  MOVWF  x0C
4BD8:  MOVLB  0
4BDA:  RCALL  479A
4BDC:  MOVLB  3
4BDE:  CLRF   x0B
4BE0:  MOVFF  01,30A
4BE4:  BTFSC  01.7
4BE6:  DECF   x0B,F
4BE8:  MOVF   x0A,F
4BEA:  BNZ   4BFE
4BEC:  MOVF   x0B,F
4BEE:  BNZ   4BFE
....................       servoAccion(1,accionServo);
4BF0:  MOVLW  01
4BF2:  MOVWF  x0A
4BF4:  MOVFF  309,30B
4BF8:  MOVLB  0
4BFA:  RCALL  4A58
4BFC:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a CM2 */
....................    if (stricmp(key,boton2_key)==0) {
4BFE:  MOVFF  306,30B
4C02:  MOVFF  305,30A
4C06:  MOVLW  02
4C08:  MOVWF  x0D
4C0A:  MOVLW  D4
4C0C:  MOVWF  x0C
4C0E:  MOVLB  0
4C10:  RCALL  479A
4C12:  MOVLB  3
4C14:  CLRF   x0B
4C16:  MOVFF  01,30A
4C1A:  BTFSC  01.7
4C1C:  DECF   x0B,F
4C1E:  MOVF   x0A,F
4C20:  BNZ   4C34
4C22:  MOVF   x0B,F
4C24:  BNZ   4C34
....................       servoAccion(2,accionServo);
4C26:  MOVLW  02
4C28:  MOVWF  x0A
4C2A:  MOVFF  309,30B
4C2E:  MOVLB  0
4C30:  RCALL  4A58
4C32:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a CM3 */
....................    if (stricmp(key,boton3_key)==0) {
4C34:  MOVFF  306,30B
4C38:  MOVFF  305,30A
4C3C:  MOVLW  02
4C3E:  MOVWF  x0D
4C40:  MOVLW  D8
4C42:  MOVWF  x0C
4C44:  MOVLB  0
4C46:  RCALL  479A
4C48:  MOVLB  3
4C4A:  CLRF   x0B
4C4C:  MOVFF  01,30A
4C50:  BTFSC  01.7
4C52:  DECF   x0B,F
4C54:  MOVF   x0A,F
4C56:  BNZ   4C6A
4C58:  MOVF   x0B,F
4C5A:  BNZ   4C6A
....................       servoAccion(3,accionServo);
4C5C:  MOVLW  03
4C5E:  MOVWF  x0A
4C60:  MOVFF  309,30B
4C64:  MOVLB  0
4C66:  RCALL  4A58
4C68:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a lcd */
....................    if (stricmp(key,lcd_key)==0) {
4C6A:  MOVFF  306,30B
4C6E:  MOVFF  305,30A
4C72:  MOVLW  02
4C74:  MOVWF  x0D
4C76:  MOVLW  DC
4C78:  MOVWF  x0C
4C7A:  MOVLB  0
4C7C:  RCALL  479A
4C7E:  MOVLB  3
4C80:  CLRF   x0B
4C82:  MOVFF  01,30A
4C86:  BTFSC  01.7
4C88:  DECF   x0B,F
4C8A:  MOVF   x0A,F
4C8C:  BNZ   4CA8
4C8E:  MOVF   x0B,F
4C90:  BNZ   4CA8
....................       printf(lcd_putc,"\f%s",val);  //Muestra en el lcd el texto recibido
4C92:  MOVLW  0C
4C94:  MOVWF  x0C
4C96:  MOVLB  0
4C98:  CALL   06E2
4C9C:  MOVFF  308,FEA
4CA0:  MOVFF  307,FE9
4CA4:  BRA    4B60
4CA6:  MOVLB  3
....................    }
4CA8:  MOVLB  0
4CAA:  GOTO   4D18 (RETURN)
.................... }
.................... 
.................... /************************** FUNCIÓN PRINCIPAL *********************************/
.................... void main(void) {
*
6E44:  CLRF   FF8
6E46:  BCF    FD0.7
6E48:  BSF    0B.7
6E4A:  CLRF   54
6E4C:  CLRF   53
6E4E:  CLRF   55
6E50:  CLRF   56
6E52:  CLRF   x7A
6E54:  CLRF   x79
6E56:  MOVF   FC1,W
6E58:  ANDLW  C0
6E5A:  IORLW  0F
6E5C:  MOVWF  FC1
6E5E:  MOVLW  07
6E60:  MOVWF  FB4
6E62:  BCF    5B.1
6E64:  BRA    6EC6
6E66:  DATA 02,00
6E68:  DATA 05,00
6E6A:  DATA 00,04
6E6C:  DATA 40,5D
6E6E:  DATA 00,01
6E70:  DATA 80,04
6E72:  DATA 0A,40
6E74:  DATA 64,00
6E76:  DATA 03,80
6E78:  DATA FE,00
6E7A:  DATA 01,01
6E7C:  DATA 00,78
6E7E:  DATA 00,07
6E80:  DATA 00,7B
6E82:  DATA 20,00
6E84:  DATA 3F,00
6E86:  DATA 47,45
6E88:  DATA 54,05
6E8A:  DATA C0,00
6E8C:  DATA 28,41
6E8E:  DATA 3C,00
6E90:  DATA 14,80
6E92:  DATA 50,4F
6E94:  DATA 53,54
6E96:  DATA 00,43
6E98:  DATA 6F,6E
6E9A:  DATA 74,65
6E9C:  DATA 6E,74
6E9E:  DATA 2D,4C
6EA0:  DATA 65,6E
6EA2:  DATA 67,74
6EA4:  DATA 68,3A
6EA6:  DATA FF,C0
6EA8:  DATA 00,07
6EAA:  DATA C0,00
6EAC:  DATA 46,42
6EAE:  DATA 88,00
6EB0:  DATA 12,80
6EB2:  DATA 2F,00
6EB4:  DATA 43,4D
6EB6:  DATA 31,00
6EB8:  DATA 43,4D
6EBA:  DATA 32,00
6EBC:  DATA 43,4D
6EBE:  DATA 33,00
6EC0:  DATA 6C,63
6EC2:  DATA 64,00
6EC4:  DATA 00,00
6EC6:  MOVLW  00
6EC8:  MOVWF  FF8
6ECA:  MOVLW  6E
6ECC:  MOVWF  FF7
6ECE:  MOVLW  66
6ED0:  MOVWF  FF6
6ED2:  TBLRD*+
6ED4:  MOVF   FF5,W
6ED6:  MOVWF  00
6ED8:  XORLW  00
6EDA:  BZ    6F02
6EDC:  TBLRD*+
6EDE:  MOVF   FF5,W
6EE0:  MOVWF  01
6EE2:  BTFSC  FE8.7
6EE4:  BRA    6EF0
6EE6:  ANDLW  3F
6EE8:  MOVWF  FEA
6EEA:  TBLRD*+
6EEC:  MOVFF  FF5,FE9
6EF0:  BTFSC  01.6
6EF2:  TBLRD*+
6EF4:  BTFSS  01.6
6EF6:  TBLRD*+
6EF8:  MOVFF  FF5,FEE
6EFC:  DCFSNZ 00,F
6EFE:  BRA    6ED2
6F00:  BRA    6EF4
6F02:  CLRF   FF8
.................... 
....................    /* Habilitación y configuración del canal analógico 0 */
....................    setup_adc(ADC_CLOCK_INTERNAL);
6F04:  MOVF   FC0,W
6F06:  ANDLW  C0
6F08:  IORLW  07
6F0A:  MOVWF  FC0
6F0C:  BCF    FC0.7
6F0E:  BSF    FC2.0
....................    setup_adc_ports(AN0);
6F10:  MOVF   FC1,W
6F12:  ANDLW  C0
6F14:  IORLW  0E
6F16:  MOVWF  FC1
....................    set_adc_channel(0);
6F18:  MOVLW  00
6F1A:  MOVWF  01
6F1C:  MOVF   FC2,W
6F1E:  ANDLW  C3
6F20:  IORWF  01,W
6F22:  MOVWF  FC2
....................    delay_ms(1);
6F24:  MOVLW  01
6F26:  MOVLB  3
6F28:  MOVWF  x13
6F2A:  MOVLB  0
6F2C:  CALL   04DE
....................    
....................    /*Reset de las salidas */
....................    output_low(PIN_C0);
6F30:  BCF    F94.0
6F32:  BCF    F8B.0
....................    output_low(PIN_C1);
6F34:  BCF    F94.1
6F36:  BCF    F8B.1
....................    output_low(PIN_C2);
6F38:  BCF    F94.2
6F3A:  BCF    F8B.2
....................     
....................    /* Inicialización del lcd */
....................    lcd_init();
6F3C:  GOTO   05FA
....................    printf(lcd_putc,"\fBeepControl");   //Mensaje de inicio en lcd 
6F40:  MOVLW  BC
6F42:  MOVWF  FF6
6F44:  MOVLW  04
6F46:  MOVWF  FF7
6F48:  GOTO   0754
....................    delay_ms(1000);
6F4C:  MOVLW  04
6F4E:  MOVLB  2
6F50:  MOVWF  xE0
6F52:  MOVLW  FA
6F54:  MOVLB  3
6F56:  MOVWF  x13
6F58:  MOVLB  0
6F5A:  CALL   04DE
6F5E:  MOVLB  2
6F60:  DECFSZ xE0,F
6F62:  BRA    6F52
....................   
....................    /* Inicialización del Stack */
....................    MACAddrInit(); //Se asigna la dirección MAC elegida 
6F64:  MOVLB  0
6F66:  GOTO   0776
....................    IPAddrInit();  //Se asigna IP, mascara de red y puerta de enlace elegidos
6F6A:  GOTO   0790
....................    StackInit();   //Inicializa el stack
6F6E:  GOTO   1070
....................    
....................    /* Muestra la IP elegida en lcd */
....................    printf(lcd_putc,"\nIP: %u.%u.%u.%u:%u", MY_IP_BYTE1, MY_IP_BYTE2, MY_IP_BYTE3, MY_IP_BYTE4,HTTP_SOCKET);
6F72:  MOVLW  CA
6F74:  MOVWF  FF6
6F76:  MOVLW  04
6F78:  MOVWF  FF7
6F7A:  MOVLW  05
6F7C:  MOVLB  2
6F7E:  MOVWF  xE0
6F80:  MOVLB  0
6F82:  GOTO   1086
6F86:  MOVFF  1D,2E0
6F8A:  MOVLW  1B
6F8C:  MOVLB  2
6F8E:  MOVWF  xE1
6F90:  MOVLB  0
6F92:  CALL   10DE
6F96:  MOVLW  2E
6F98:  MOVLB  3
6F9A:  MOVWF  x0C
6F9C:  MOVLB  0
6F9E:  CALL   06E2
6FA2:  MOVFF  1E,2E0
6FA6:  MOVLW  1B
6FA8:  MOVLB  2
6FAA:  MOVWF  xE1
6FAC:  MOVLB  0
6FAE:  CALL   10DE
6FB2:  MOVLW  2E
6FB4:  MOVLB  3
6FB6:  MOVWF  x0C
6FB8:  MOVLB  0
6FBA:  CALL   06E2
6FBE:  MOVFF  1F,2E0
6FC2:  MOVLW  1B
6FC4:  MOVLB  2
6FC6:  MOVWF  xE1
6FC8:  MOVLB  0
6FCA:  CALL   10DE
6FCE:  MOVLW  2E
6FD0:  MOVLB  3
6FD2:  MOVWF  x0C
6FD4:  MOVLB  0
6FD6:  CALL   06E2
6FDA:  MOVFF  20,2E0
6FDE:  MOVLW  1B
6FE0:  MOVLB  2
6FE2:  MOVWF  xE1
6FE4:  MOVLB  0
6FE6:  CALL   10DE
6FEA:  MOVLW  3A
6FEC:  MOVLB  3
6FEE:  MOVWF  x0C
6FF0:  MOVLB  0
6FF2:  CALL   06E2
6FF6:  MOVLW  50
6FF8:  MOVLB  2
6FFA:  MOVWF  xE0
6FFC:  MOVLW  1B
6FFE:  MOVWF  xE1
7000:  MOVLB  0
7002:  CALL   10DE
....................    delay_ms(10);
7006:  MOVLW  0A
7008:  MOVLB  3
700A:  MOVWF  x13
700C:  MOVLB  0
700E:  CALL   04DE
....................    while(TRUE) {
....................    StackTask();
7012:  BRA    6C64
7014:  BRA    7012
....................    /* KeyPad */
....................    /* End KeyPad */
.................... }
....................    }
7016:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E26   PUT BROWNOUT VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: A00F   NOWRT NOWRTC WRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
