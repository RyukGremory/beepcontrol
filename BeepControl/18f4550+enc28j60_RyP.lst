CCS PCH C Compiler, Version 5.094d, 1               10-Apr-20 19:22
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\pdelacruz\Downloads\AutomatizacionRobotica\BeepControl\18f4550+enc28j60_RyP.lst

               ROM used:   28698 bytes (88%)
                           Largest free fragment is 4068
               RAM used:   737 (36%) at main() level
                           922 (45%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

0000:  GOTO   6E48
*
0008:  MOVWF  08
000A:  MOVFF  FD8,09
000E:  MOVFF  FE0,0A
0012:  MOVLB  0
0014:  MOVFF  FE9,10
0018:  MOVFF  FEA,0B
001C:  MOVFF  FE1,0C
0020:  MOVFF  FE2,0D
0024:  MOVFF  FD9,0E
0028:  MOVFF  FDA,0F
002C:  MOVFF  FF3,16
0030:  MOVFF  FF4,17
0034:  MOVFF  FFA,18
0038:  MOVFF  FF5,19
003C:  MOVFF  FF6,1A
0040:  MOVFF  FF7,1B
0044:  MOVFF  00,12
0048:  MOVFF  01,13
004C:  MOVFF  02,14
0050:  MOVFF  03,15
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00C2
0060:  MOVFF  12,00
0064:  MOVFF  13,01
0068:  MOVFF  14,02
006C:  MOVFF  15,03
0070:  MOVFF  10,FE9
0074:  MOVFF  0B,FEA
0078:  BSF    0B.7
007A:  MOVFF  0C,FE1
007E:  MOVFF  0D,FE2
0082:  MOVFF  0E,FD9
0086:  MOVFF  0F,FDA
008A:  MOVFF  16,FF3
008E:  MOVFF  17,FF4
0092:  MOVFF  18,FFA
0096:  MOVFF  19,FF5
009A:  MOVFF  1A,FF6
009E:  MOVFF  1B,FF7
00A2:  MOVF   08,W
00A4:  MOVFF  0A,FE0
00A8:  MOVFF  09,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 28,0C
00C0:  DATA 01,06
*
00E2:  DATA 3C,48
00E4:  DATA 54,4D
00E6:  DATA 4C,3E
00E8:  DATA 3C,42
00EA:  DATA 4F,44
00EC:  DATA 59,3E
00EE:  DATA 3C,48
00F0:  DATA 31,3E
00F2:  DATA 34,30
00F4:  DATA 34,20
00F6:  DATA 45,72
00F8:  DATA 72,6F
00FA:  DATA 72,3C
00FC:  DATA 2F,48
00FE:  DATA 31,3E
0100:  DATA 3C,48
0102:  DATA 52,3E
0104:  DATA 3C,50
0106:  DATA 3E,46
0108:  DATA 69,6C
010A:  DATA 65,20
010C:  DATA 4E,6F
010E:  DATA 74,20
0110:  DATA 66,6F
0112:  DATA 75,6E
0114:  DATA 64,2E
0116:  DATA 3C,2F
0118:  DATA 42,4F
011A:  DATA 44,59
011C:  DATA 3E,3C
011E:  DATA 2F,48
0120:  DATA 54,4D
0122:  DATA 4C,3E
0124:  DATA 00,00
0126:  DATA 3C,48
0128:  DATA 54,4D
012A:  DATA 4C,3E
012C:  DATA 3C,42
012E:  DATA 4F,44
0130:  DATA 59,3E
0132:  DATA 3C,48
0134:  DATA 31,3E
0136:  DATA 35,30
0138:  DATA 30,20
013A:  DATA 45,72
013C:  DATA 72,6F
013E:  DATA 72,3C
0140:  DATA 2F,48
0142:  DATA 31,3E
0144:  DATA 3C,48
0146:  DATA 52,3E
0148:  DATA 3C,50
014A:  DATA 3E,49
014C:  DATA 6E,74
014E:  DATA 65,72
0150:  DATA 6E,61
0152:  DATA 6C,20
0154:  DATA 53,65
0156:  DATA 72,76
0158:  DATA 65,72
015A:  DATA 20,45
015C:  DATA 72,72
015E:  DATA 6F,72
0160:  DATA 3C,2F
0162:  DATA 42,4F
0164:  DATA 44,59
0166:  DATA 3E,3C
0168:  DATA 2F,48
016A:  DATA 54,4D
016C:  DATA 4C,3E
016E:  DATA 00,00
0170:  DATA 48,54
0172:  DATA 54,50
0174:  DATA 2F,31
0176:  DATA 2E,30
0178:  DATA 20,25
017A:  DATA 4C,55
017C:  DATA 20,00
017E:  DATA 4E,6F
0180:  DATA 74,20
0182:  DATA 66,6F
0184:  DATA 75,6E
0186:  DATA 64,00
0188:  DATA 53,65
018A:  DATA 72,76
018C:  DATA 65,72
018E:  DATA 20,45
0190:  DATA 72,72
0192:  DATA 6F,72
0194:  DATA 00,00
0196:  DATA 0D,0A
0198:  DATA 43,6F
019A:  DATA 6E,74
019C:  DATA 65,6E
019E:  DATA 74,2D
01A0:  DATA 54,79
01A2:  DATA 70,65
01A4:  DATA 3A,20
01A6:  DATA 00,00
01A8:  DATA 74,65
01AA:  DATA 78,74
01AC:  DATA 2F,68
01AE:  DATA 74,6D
01B0:  DATA 6C,00
01B2:  DATA 0D,0A
01B4:  DATA 0D,0A
01B6:  DATA 00,00
01B8:  DATA 20,0A
01BA:  DATA 3C,48
01BC:  DATA 54,4D
01BE:  DATA 4C,3E
01C0:  DATA 3C,42
01C2:  DATA 4F,44
01C4:  DATA 59,20
01C6:  DATA 42,47
01C8:  DATA 43,4F
01CA:  DATA 4C,4F
01CC:  DATA 52,3D
01CE:  DATA 23,46
01D0:  DATA 46,46
01D2:  DATA 46,46
01D4:  DATA 46,20
01D6:  DATA 54,45
01D8:  DATA 58,54
01DA:  DATA 3D,23
01DC:  DATA 30,30
01DE:  DATA 30,30
01E0:  DATA 30,30
01E2:  DATA 3E,20
01E4:  DATA 0A,20
01E6:  DATA 0A,3C
01E8:  DATA 63,65
01EA:  DATA 6E,74
01EC:  DATA 65,72
01EE:  DATA 3E,3C
01F0:  DATA 48,31
01F2:  DATA 3E,42
01F4:  DATA 65,65
01F6:  DATA 70,43
01F8:  DATA 6F,6E
01FA:  DATA 74,72
01FC:  DATA 6F,6C
01FE:  DATA 20,3C
0200:  DATA 2F,48
0202:  DATA 31,3E
0204:  DATA 3C,2F
0206:  DATA 63,65
0208:  DATA 6E,74
020A:  DATA 65,72
020C:  DATA 3E,20
020E:  DATA 0A,3C
0210:  DATA 42,52
0212:  DATA 3E,3C
0214:  DATA 63,65
0216:  DATA 6E,74
0218:  DATA 65,72
021A:  DATA 3E,3C
021C:  DATA 48,32
021E:  DATA 3E,44
0220:  DATA 61,73
0222:  DATA 68,62
0224:  DATA 6F,61
0226:  DATA 72,64
0228:  DATA 3C,2F
022A:  DATA 48,32
022C:  DATA 3E,3C
022E:  DATA 2F,43
0230:  DATA 45,4E
0232:  DATA 54,45
0234:  DATA 52,3E
0236:  DATA 20,0A
0238:  DATA 20,0A
023A:  DATA 20,0A
023C:  DATA 3C,46
023E:  DATA 4F,52
0240:  DATA 4D,20
0242:  DATA 4D,45
0244:  DATA 54,48
0246:  DATA 4F,44
0248:  DATA 3D,47
024A:  DATA 45,54
024C:  DATA 3E,20
024E:  DATA 0A,3C
0250:  DATA 50,3E
0252:  DATA 4C,43
0254:  DATA 44,3A
0256:  DATA 20,3C
0258:  DATA 49,4E
025A:  DATA 50,55
025C:  DATA 54,20
025E:  DATA 54,59
0260:  DATA 50,45
0262:  DATA 3D,22
0264:  DATA 74,65
0266:  DATA 78,74
0268:  DATA 22,20
026A:  DATA 4E,41
026C:  DATA 4D,45
026E:  DATA 3D,22
0270:  DATA 6C,63
0272:  DATA 64,22
0274:  DATA 20,73
0276:  DATA 69,7A
0278:  DATA 65,3D
027A:  DATA 32,30
027C:  DATA 20,6D
027E:  DATA 61,78
0280:  DATA 6C,65
0282:  DATA 6E,67
0284:  DATA 74,68
0286:  DATA 3D,31
0288:  DATA 36,3E
028A:  DATA 20,0A
028C:  DATA 3C,69
028E:  DATA 6E,70
0290:  DATA 75,74
0292:  DATA 20,74
0294:  DATA 79,70
0296:  DATA 65,3D
0298:  DATA 22,73
029A:  DATA 75,62
029C:  DATA 6D,69
029E:  DATA 74,22
02A0:  DATA 20,76
02A2:  DATA 61,6C
02A4:  DATA 75,65
02A6:  DATA 3D,22
02A8:  DATA 45,6E
02AA:  DATA 76,69
02AC:  DATA 61,72
02AE:  DATA 20,74
02B0:  DATA 65,78
02B2:  DATA 74,6F
02B4:  DATA 22,3E
02B6:  DATA 20,0A
02B8:  DATA 3C,2F
02BA:  DATA 46,4F
02BC:  DATA 52,4D
02BE:  DATA 3E,20
02C0:  DATA 0A,20
02C2:  DATA 0A,3C
02C4:  DATA 46,4F
02C6:  DATA 52,4D
02C8:  DATA 20,4D
02CA:  DATA 45,54
02CC:  DATA 48,4F
02CE:  DATA 44,3D
02D0:  DATA 47,45
02D2:  DATA 54,3E
02D4:  DATA 20,0A
02D6:  DATA 3C,69
02D8:  DATA 6E,70
02DA:  DATA 75,74
02DC:  DATA 20,74
02DE:  DATA 79,70
02E0:  DATA 65,3D
02E2:  DATA 22,73
02E4:  DATA 75,62
02E6:  DATA 6D,69
02E8:  DATA 74,22
02EA:  DATA 20,6E
02EC:  DATA 61,6D
02EE:  DATA 65,3D
02F0:  DATA 22,43
02F2:  DATA 4D,31
02F4:  DATA 22,20
02F6:  DATA 76,61
02F8:  DATA 6C,75
02FA:  DATA 65,3D
02FC:  DATA 22,41
02FE:  DATA 22,3E
0300:  DATA 20,0A
0302:  DATA 3C,69
0304:  DATA 6E,70
0306:  DATA 75,74
0308:  DATA 20,74
030A:  DATA 79,70
030C:  DATA 65,3D
030E:  DATA 22,73
0310:  DATA 75,62
0312:  DATA 6D,69
0314:  DATA 74,22
0316:  DATA 20,6E
0318:  DATA 61,6D
031A:  DATA 65,3D
031C:  DATA 22,43
031E:  DATA 4D,31
0320:  DATA 22,20
0322:  DATA 76,61
0324:  DATA 6C,75
0326:  DATA 65,3D
0328:  DATA 22,43
032A:  DATA 22,3E
032C:  DATA 20,0A
032E:  DATA 3C,69
0330:  DATA 6E,70
0332:  DATA 75,74
0334:  DATA 20,74
0336:  DATA 79,70
0338:  DATA 65,3D
033A:  DATA 22,73
033C:  DATA 75,62
033E:  DATA 6D,69
0340:  DATA 74,22
0342:  DATA 20,6E
0344:  DATA 61,6D
0346:  DATA 65,3D
0348:  DATA 22,43
034A:  DATA 4D,31
034C:  DATA 22,20
034E:  DATA 76,61
0350:  DATA 6C,75
0352:  DATA 65,3D
0354:  DATA 22,41
0356:  DATA 43,22
0358:  DATA 3E,20
035A:  DATA 0A,3C
035C:  DATA 2F,46
035E:  DATA 4F,52
0360:  DATA 4D,3E
0362:  DATA 20,0A
0364:  DATA 3C,46
0366:  DATA 4F,52
0368:  DATA 4D,20
036A:  DATA 4D,45
036C:  DATA 54,48
036E:  DATA 4F,44
0370:  DATA 3D,47
0372:  DATA 45,54
0374:  DATA 3E,20
0376:  DATA 0A,3C
0378:  DATA 69,6E
037A:  DATA 70,75
037C:  DATA 74,20
037E:  DATA 74,79
0380:  DATA 70,65
0382:  DATA 3D,22
0384:  DATA 73,75
0386:  DATA 62,6D
0388:  DATA 69,74
038A:  DATA 22,20
038C:  DATA 6E,61
038E:  DATA 6D,65
0390:  DATA 3D,22
0392:  DATA 43,4D
0394:  DATA 32,22
0396:  DATA 20,76
0398:  DATA 61,6C
039A:  DATA 75,65
039C:  DATA 3D,22
039E:  DATA 41,22
03A0:  DATA 3E,20
03A2:  DATA 0A,3C
03A4:  DATA 69,6E
03A6:  DATA 70,75
03A8:  DATA 74,20
03AA:  DATA 74,79
03AC:  DATA 70,65
03AE:  DATA 3D,22
03B0:  DATA 73,75
03B2:  DATA 62,6D
03B4:  DATA 69,74
03B6:  DATA 22,20
03B8:  DATA 6E,61
03BA:  DATA 6D,65
03BC:  DATA 3D,22
03BE:  DATA 43,4D
03C0:  DATA 32,22
03C2:  DATA 20,76
03C4:  DATA 61,6C
03C6:  DATA 75,65
03C8:  DATA 3D,22
03CA:  DATA 43,22
03CC:  DATA 3E,20
03CE:  DATA 0A,3C
03D0:  DATA 69,6E
03D2:  DATA 70,75
03D4:  DATA 74,20
03D6:  DATA 74,79
03D8:  DATA 70,65
03DA:  DATA 3D,22
03DC:  DATA 73,75
03DE:  DATA 62,6D
03E0:  DATA 69,74
03E2:  DATA 22,20
03E4:  DATA 6E,61
03E6:  DATA 6D,65
03E8:  DATA 3D,22
03EA:  DATA 43,4D
03EC:  DATA 32,22
03EE:  DATA 20,76
03F0:  DATA 61,6C
03F2:  DATA 75,65
03F4:  DATA 3D,22
03F6:  DATA 41,43
03F8:  DATA 22,3E
03FA:  DATA 20,0A
03FC:  DATA 3C,2F
03FE:  DATA 46,4F
0400:  DATA 52,4D
0402:  DATA 3E,20
0404:  DATA 0A,3C
0406:  DATA 46,4F
0408:  DATA 52,4D
040A:  DATA 20,4D
040C:  DATA 45,54
040E:  DATA 48,4F
0410:  DATA 44,3D
0412:  DATA 47,45
0414:  DATA 54,3E
0416:  DATA 20,0A
0418:  DATA 3C,69
041A:  DATA 6E,70
041C:  DATA 75,74
041E:  DATA 20,74
0420:  DATA 79,70
0422:  DATA 65,3D
0424:  DATA 22,73
0426:  DATA 75,62
0428:  DATA 6D,69
042A:  DATA 74,22
042C:  DATA 20,6E
042E:  DATA 61,6D
0430:  DATA 65,3D
0432:  DATA 22,43
0434:  DATA 4D,33
0436:  DATA 22,20
0438:  DATA 76,61
043A:  DATA 6C,75
043C:  DATA 65,3D
043E:  DATA 22,41
0440:  DATA 22,3E
0442:  DATA 20,0A
0444:  DATA 3C,69
0446:  DATA 6E,70
0448:  DATA 75,74
044A:  DATA 20,74
044C:  DATA 79,70
044E:  DATA 65,3D
0450:  DATA 22,73
0452:  DATA 75,62
0454:  DATA 6D,69
0456:  DATA 74,22
0458:  DATA 20,6E
045A:  DATA 61,6D
045C:  DATA 65,3D
045E:  DATA 22,43
0460:  DATA 4D,33
0462:  DATA 22,20
0464:  DATA 76,61
0466:  DATA 6C,75
0468:  DATA 65,3D
046A:  DATA 22,43
046C:  DATA 22,3E
046E:  DATA 20,0A
0470:  DATA 3C,69
0472:  DATA 6E,70
0474:  DATA 75,74
0476:  DATA 20,74
0478:  DATA 79,70
047A:  DATA 65,3D
047C:  DATA 22,73
047E:  DATA 75,62
0480:  DATA 6D,69
0482:  DATA 74,22
0484:  DATA 20,6E
0486:  DATA 61,6D
0488:  DATA 65,3D
048A:  DATA 22,43
048C:  DATA 4D,33
048E:  DATA 22,20
0490:  DATA 76,61
0492:  DATA 6C,75
0494:  DATA 65,3D
0496:  DATA 22,41
0498:  DATA 43,22
049A:  DATA 3E,20
049C:  DATA 0A,3C
049E:  DATA 2F,46
04A0:  DATA 4F,52
04A2:  DATA 4D,3E
04A4:  DATA 20,0A
04A6:  DATA 3C,2F
04A8:  DATA 42,4F
04AA:  DATA 44,59
04AC:  DATA 3E,3C
04AE:  DATA 2F,48
04B0:  DATA 54,4D
04B2:  DATA 4C,3E
04B4:  DATA 20,0A
04B6:  DATA 00,00
04B8:  DATA 43,00
04BA:  DATA 41,00
04BC:  DATA 41,43
04BE:  DATA 00,00
04C0:  DATA 0C,42
04C2:  DATA 65,65
04C4:  DATA 70,43
04C6:  DATA 6F,6E
04C8:  DATA 74,72
04CA:  DATA 6F,6C
04CC:  DATA 00,00
04CE:  DATA 0A,49
04D0:  DATA 50,3A
04D2:  DATA 20,25
04D4:  DATA 75,2E
04D6:  DATA 25,75
04D8:  DATA 2E,25
04DA:  DATA 75,2E
04DC:  DATA 25,75
04DE:  DATA 3A,25
04E0:  DATA 75,00
*
06C4:  ADDWF  FE8,W
06C6:  CLRF   FF7
06C8:  RLCF   FF7,F
06CA:  ADDLW  DF
06CC:  MOVWF  FF6
06CE:  MOVLW  06
06D0:  ADDWFC FF7,F
06D2:  TBLRD*-
06D4:  MOVF   FF5,W
06D6:  MOVWF  FFA
06D8:  TBLRD*
06DA:  MOVF   FF5,W
06DC:  MOVWF  FF9
06DE:  DATA 80,06
06E0:  DATA 8C,06
06E2:  DATA 98,06
06E4:  DATA A4,06
*
0758:  TBLRD*+
075A:  MOVF   FF5,F
075C:  BZ    0776
075E:  MOVFF  FF6,2E0
0762:  MOVFF  FF7,2E1
0766:  MOVFF  FF5,30C
076A:  RCALL  06E6
076C:  MOVFF  2E0,FF6
0770:  MOVFF  2E1,FF7
0774:  BRA    0758
0776:  GOTO   6F50 (RETURN)
*
0CC8:  MOVLB  3
0CCA:  CLRF   x48
0CCC:  CLRF   x49
0CCE:  MOVLW  01
0CD0:  MOVWF  x4A
0CD2:  CLRF   FDA
0CD4:  CLRF   FD9
0CD6:  MOVLW  03
0CD8:  MOVWF  x4D
0CDA:  MOVLW  40
0CDC:  MOVWF  x4C
0CDE:  MOVLW  03
0CE0:  MOVWF  FEA
0CE2:  MOVLW  44
0CE4:  MOVWF  FE9
0CE6:  MOVFF  34D,FE2
0CEA:  MOVFF  34C,FE1
0CEE:  MOVFF  34A,34B
0CF2:  BCF    FD8.0
0CF4:  MOVF   FE5,W
0CF6:  MULWF  FEE
0CF8:  MOVF   FF3,W
0CFA:  ADDWFC x48,F
0CFC:  MOVF   FF4,W
0CFE:  ADDWFC x49,F
0D00:  DECFSZ x4B,F
0D02:  BRA    0CF2
0D04:  MOVFF  348,FDE
0D08:  MOVFF  349,348
0D0C:  CLRF   x49
0D0E:  BTFSC  FD8.0
0D10:  INCF   x49,F
0D12:  INCF   x4C,F
0D14:  BTFSC  FD8.2
0D16:  INCF   x4D,F
0D18:  INCF   x4A,F
0D1A:  MOVF   x4A,W
0D1C:  SUBLW  05
0D1E:  BNZ   0CDE
0D20:  MOVLB  0
0D22:  RETURN 0
0D24:  CLRF   01
0D26:  CLRF   02
0D28:  CLRF   00
0D2A:  CLRF   03
0D2C:  MOVLB  2
0D2E:  MOVF   xE9,W
0D30:  BNZ   0D36
0D32:  MOVF   xE8,W
0D34:  BZ    0D66
0D36:  MOVLW  10
0D38:  MOVWF  xEA
0D3A:  BCF    FD8.0
0D3C:  RLCF   xE6,F
0D3E:  RLCF   xE7,F
0D40:  RLCF   00,F
0D42:  RLCF   03,F
0D44:  MOVF   xE9,W
0D46:  SUBWF  03,W
0D48:  BNZ   0D4E
0D4A:  MOVF   xE8,W
0D4C:  SUBWF  00,W
0D4E:  BNC   0D5E
0D50:  MOVF   xE8,W
0D52:  SUBWF  00,F
0D54:  BTFSS  FD8.0
0D56:  DECF   03,F
0D58:  MOVF   xE9,W
0D5A:  SUBWF  03,F
0D5C:  BSF    FD8.0
0D5E:  RLCF   01,F
0D60:  RLCF   02,F
0D62:  DECFSZ xEA,F
0D64:  BRA    0D3A
0D66:  MOVLB  0
0D68:  GOTO   0DD2 (RETURN)
*
108A:  TBLRD*+
108C:  MOVFF  FF6,2E1
1090:  MOVFF  FF7,2E2
1094:  MOVFF  FF5,30C
1098:  CALL   06E6
109C:  MOVFF  2E1,FF6
10A0:  MOVFF  2E2,FF7
10A4:  MOVLB  2
10A6:  DECFSZ xE0,F
10A8:  BRA    10AC
10AA:  BRA    10B0
10AC:  MOVLB  0
10AE:  BRA    108A
10B0:  MOVLB  0
10B2:  GOTO   6F8A (RETURN)
10B6:  MOVLB  3
10B8:  MOVF   x24,W
10BA:  CLRF   01
10BC:  SUBWF  x23,W
10BE:  BC    10C6
10C0:  MOVFF  323,00
10C4:  BRA    10DE
10C6:  CLRF   00
10C8:  MOVLW  08
10CA:  MOVWF  x25
10CC:  RLCF   x23,F
10CE:  RLCF   00,F
10D0:  MOVF   x24,W
10D2:  SUBWF  00,W
10D4:  BTFSC  FD8.0
10D6:  MOVWF  00
10D8:  RLCF   01,F
10DA:  DECFSZ x25,F
10DC:  BRA    10CC
10DE:  MOVLB  0
10E0:  RETURN 0
10E2:  MOVF   01,W
10E4:  MOVFF  2E0,323
10E8:  MOVLW  64
10EA:  MOVLB  3
10EC:  MOVWF  x24
10EE:  MOVLB  0
10F0:  RCALL  10B6
10F2:  MOVFF  00,2E0
10F6:  MOVF   01,W
10F8:  MOVLW  30
10FA:  BNZ   110C
10FC:  MOVLB  2
10FE:  BTFSS  xE1.1
1100:  BRA    1120
1102:  BTFSC  xE1.3
1104:  BRA    1120
1106:  BTFSC  xE1.4
1108:  MOVLW  20
110A:  BRA    1114
110C:  MOVLB  2
110E:  BCF    xE1.3
1110:  BCF    xE1.4
1112:  BSF    xE1.0
1114:  ADDWF  01,F
1116:  MOVFF  01,30C
111A:  MOVLB  0
111C:  CALL   06E6
1120:  MOVFF  2E0,323
1124:  MOVLW  0A
1126:  MOVLB  3
1128:  MOVWF  x24
112A:  MOVLB  0
112C:  RCALL  10B6
112E:  MOVFF  00,2E0
1132:  MOVF   01,W
1134:  MOVLW  30
1136:  BNZ   1148
1138:  MOVLB  2
113A:  BTFSC  xE1.3
113C:  BRA    1154
113E:  BTFSS  xE1.0
1140:  BRA    1154
1142:  BTFSC  xE1.4
1144:  MOVLW  20
1146:  MOVLB  0
1148:  ADDWF  01,F
114A:  MOVFF  01,30C
114E:  CALL   06E6
1152:  MOVLB  2
1154:  MOVLW  30
1156:  ADDWF  xE0,F
1158:  MOVFF  2E0,30C
115C:  MOVLB  0
115E:  CALL   06E6
1162:  RETURN 0
*
3DEA:  ADDWF  FE8,W
3DEC:  CLRF   FF7
3DEE:  RLCF   FF7,F
3DF0:  ADDLW  05
3DF2:  MOVWF  FF6
3DF4:  MOVLW  3E
3DF6:  ADDWFC FF7,F
3DF8:  TBLRD*-
3DFA:  MOVF   FF5,W
3DFC:  MOVWF  FFA
3DFE:  TBLRD*
3E00:  MOVF   FF5,W
3E02:  MOVWF  FF9
3E04:  DATA 86,3B
3E06:  DATA 8E,3B
3E08:  DATA D6,3B
3E0A:  DATA 78,3C
3E0C:  DATA A4,3C
3E0E:  DATA A4,3C
3E10:  DATA B4,3C
3E12:  DATA C4,3C
3E14:  DATA D8,3C
*
48EC:  MOVFF  FEA,FE2
48F0:  MOVFF  FE9,FE1
48F4:  CLRF   01
48F6:  BSF    00.0
48F8:  TBLRD*+
48FA:  MOVF   FF5,W
48FC:  BTFSS  00.0
48FE:  BRA    490A
4900:  SUBWF  FEE,W
4902:  BNZ   490A
4904:  MOVF   FF5,F
4906:  BNZ   48F8
4908:  BRA    4924
490A:  BCF    00.0
490C:  MOVF   FF5,F
490E:  BNZ   48F8
4910:  INCF   01,F
4912:  BSF    00.0
4914:  MOVFF  FE2,FEA
4918:  MOVFF  FE1,FE9
491C:  TBLRD*
491E:  MOVF   FF5,F
4920:  BNZ   48F8
4922:  SETF   01
4924:  GOTO   4BA2 (RETURN)
4928:  MOVLB  3
492A:  MOVF   x17,W
492C:  ANDLW  07
492E:  MOVWF  00
4930:  RRCF   x17,W
4932:  MOVWF  01
4934:  RRCF   01,F
4936:  RRCF   01,F
4938:  MOVLW  1F
493A:  ANDWF  01,F
493C:  MOVF   01,W
493E:  ADDWF  x19,W
4940:  MOVWF  FE9
4942:  MOVLW  00
4944:  ADDWFC x1A,W
4946:  MOVWF  FEA
4948:  CLRF   01
494A:  INCF   01,F
494C:  INCF   00,F
494E:  BRA    4952
4950:  RLCF   01,F
4952:  DECFSZ 00,F
4954:  BRA    4950
4956:  MOVF   x18,F
4958:  BZ    4960
495A:  MOVF   01,W
495C:  IORWF  FEF,F
495E:  BRA    4966
4960:  COMF   01,F
4962:  MOVF   01,W
4964:  ANDWF  FEF,F
4966:  MOVLB  0
4968:  RETURN 0
496A:  MOVLB  3
496C:  MOVF   x17,W
496E:  ANDLW  07
4970:  MOVWF  00
4972:  RRCF   x17,W
4974:  MOVWF  01
4976:  RRCF   01,F
4978:  RRCF   01,F
497A:  MOVLW  1F
497C:  ANDWF  01,F
497E:  MOVF   01,W
4980:  ADDWF  x18,W
4982:  MOVWF  FE9
4984:  MOVLW  00
4986:  ADDWFC x19,W
4988:  MOVWF  FEA
498A:  MOVFF  FEF,01
498E:  INCF   00,F
4990:  BRA    4994
4992:  RRCF   01,F
4994:  DECFSZ 00,F
4996:  BRA    4992
4998:  MOVLW  01
499A:  ANDWF  01,F
499C:  MOVLB  0
499E:  GOTO   49DC (RETURN)
*
4B64:  MOVF   FEF,F
4B66:  BZ    4B88
4B68:  MOVFF  FEA,30B
4B6C:  MOVFF  FE9,30A
4B70:  MOVFF  FEF,30C
4B74:  CALL   06E6
4B78:  MOVFF  30B,FEA
4B7C:  MOVFF  30A,FE9
4B80:  INCF   FE9,F
4B82:  BTFSC  FD8.2
4B84:  INCF   FEA,F
4B86:  BRA    4B64
4B88:  GOTO   4CAA (RETURN)
*
4D68:  MOVLB  2
4D6A:  MOVF   xF9,W
4D6C:  XORWF  xFB,W
4D6E:  ANDLW  80
4D70:  MOVWF  xFD
4D72:  BTFSS  xF9.7
4D74:  BRA    4D80
4D76:  COMF   xF8,F
4D78:  COMF   xF9,F
4D7A:  INCF   xF8,F
4D7C:  BTFSC  FD8.2
4D7E:  INCF   xF9,F
4D80:  BTFSS  xFB.7
4D82:  BRA    4D8E
4D84:  COMF   xFA,F
4D86:  COMF   xFB,F
4D88:  INCF   xFA,F
4D8A:  BTFSC  FD8.2
4D8C:  INCF   xFB,F
4D8E:  MOVF   xF8,W
4D90:  MULWF  xFA
4D92:  MOVFF  FF3,01
4D96:  MOVFF  FF4,00
4D9A:  MULWF  xFB
4D9C:  MOVF   FF3,W
4D9E:  ADDWF  00,F
4DA0:  MOVF   xF9,W
4DA2:  MULWF  xFA
4DA4:  MOVF   FF3,W
4DA6:  ADDWFC 00,W
4DA8:  MOVWF  02
4DAA:  BTFSS  xFD.7
4DAC:  BRA    4DB8
4DAE:  COMF   01,F
4DB0:  COMF   02,F
4DB2:  INCF   01,F
4DB4:  BTFSC  FD8.2
4DB6:  INCF   02,F
4DB8:  MOVLB  0
4DBA:  GOTO   4E98 (RETURN)
*
536A:  TBLRD*+
536C:  MOVFF  FF6,2FF
5370:  MOVFF  FF7,300
5374:  MOVFF  FF5,31C
5378:  RCALL  535C
537A:  MOVFF  2FF,FF6
537E:  MOVFF  300,FF7
5382:  MOVLB  2
5384:  DECFSZ xFE,F
5386:  BRA    538A
5388:  BRA    538E
538A:  MOVLB  0
538C:  BRA    536A
538E:  MOVLB  0
5390:  GOTO   5C4A (RETURN)
5394:  MOVFF  FEA,306
5398:  MOVFF  FE9,305
539C:  MOVLB  2
539E:  SWAPF  xFF,W
53A0:  IORLW  F0
53A2:  MOVLB  3
53A4:  MOVWF  x01
53A6:  ADDWF  x01,F
53A8:  ADDLW  E2
53AA:  MOVWF  x02
53AC:  ADDLW  32
53AE:  MOVWF  x04
53B0:  MOVLB  2
53B2:  MOVF   xFF,W
53B4:  ANDLW  0F
53B6:  MOVLB  3
53B8:  ADDWF  x02,F
53BA:  ADDWF  x02,F
53BC:  ADDWF  x04,F
53BE:  ADDLW  E9
53C0:  MOVWF  x03
53C2:  ADDWF  x03,F
53C4:  ADDWF  x03,F
53C6:  MOVLB  2
53C8:  SWAPF  xFE,W
53CA:  ANDLW  0F
53CC:  MOVLB  3
53CE:  ADDWF  x03,F
53D0:  ADDWF  x04,F
53D2:  RLCF   x03,F
53D4:  RLCF   x04,F
53D6:  COMF   x04,F
53D8:  RLCF   x04,F
53DA:  MOVLB  2
53DC:  MOVF   xFE,W
53DE:  ANDLW  0F
53E0:  MOVLB  3
53E2:  ADDWF  x04,F
53E4:  RLCF   x01,F
53E6:  MOVLW  07
53E8:  MOVWF  x00
53EA:  MOVLW  0A
53EC:  DECF   x03,F
53EE:  ADDWF  x04,F
53F0:  BNC   53EC
53F2:  DECF   x02,F
53F4:  ADDWF  x03,F
53F6:  BNC   53F2
53F8:  DECF   x01,F
53FA:  ADDWF  x02,F
53FC:  BNC   53F8
53FE:  DECF   x00,F
5400:  ADDWF  x01,F
5402:  BNC   53FE
5404:  MOVLW  03
5406:  MOVWF  FEA
5408:  CLRF   FE9
540A:  MOVLW  07
540C:  ANDWF  x05,W
540E:  BCF    x05.6
5410:  ADDWF  FE9,F
5412:  MOVLW  00
5414:  ADDWFC FEA,F
5416:  MOVF   FE9,W
5418:  SUBLW  04
541A:  BNZ   5424
541C:  MOVF   FEA,W
541E:  SUBLW  03
5420:  BNZ   5424
5422:  BSF    x05.6
5424:  MOVF   FEF,W
5426:  MOVWF  00
5428:  BNZ   543A
542A:  BTFSC  x05.6
542C:  BRA    543A
542E:  BTFSC  x05.4
5430:  BRA    545C
5432:  BTFSC  x05.3
5434:  BRA    543A
5436:  MOVLW  20
5438:  BRA    5440
543A:  BSF    x05.3
543C:  BCF    x05.4
543E:  MOVLW  30
5440:  ADDWF  00,F
5442:  MOVFF  FEA,2FF
5446:  MOVFF  FE9,2FE
544A:  MOVFF  00,31C
544E:  MOVLB  0
5450:  RCALL  535C
5452:  MOVFF  2FF,FEA
5456:  MOVFF  2FE,FE9
545A:  MOVLB  3
545C:  MOVF   FEE,W
545E:  BTFSS  x05.6
5460:  BRA    5416
5462:  MOVLB  0
5464:  GOTO   5C5A (RETURN)
5468:  TBLRD*+
546A:  MOVF   FF5,F
546C:  BZ    5486
546E:  MOVFF  FF6,2FE
5472:  MOVFF  FF7,2FF
5476:  MOVFF  FF5,31C
547A:  RCALL  535C
547C:  MOVFF  2FE,FF6
5480:  MOVFF  2FF,FF7
5484:  BRA    5468
5486:  RETURN 0
5488:  MOVF   FEF,F
548A:  BZ    54AA
548C:  MOVFF  FEA,2FF
5490:  MOVFF  FE9,2FE
5494:  MOVFF  FEF,31C
5498:  RCALL  535C
549A:  MOVFF  2FF,FEA
549E:  MOVFF  2FE,FE9
54A2:  INCF   FE9,F
54A4:  BTFSC  FD8.2
54A6:  INCF   FEA,F
54A8:  BRA    5488
54AA:  GOTO   5D10 (RETURN)
*
565E:  MOVFF  321,01
5662:  MOVFF  320,00
5666:  TSTFSZ 00
5668:  INCF   01,F
566A:  TBLRD*+
566C:  MOVFF  FF5,FEE
5670:  DECFSZ 00,F
5672:  BRA    566A
5674:  DECFSZ 01,F
5676:  BRA    566A
5678:  CLRF   FF8
567A:  RETURN 0
*
58E4:  MOVFF  7A,FEA
58E8:  MOVFF  79,FE9
58EC:  MOVFF  323,FEF
58F0:  INCF   FE9,F
58F2:  BTFSC  FD8.2
58F4:  INCF   FEA,F
58F6:  CLRF   FEF
58F8:  MOVLB  0
58FA:  INCF   x79,F
58FC:  BTFSC  FD8.2
58FE:  INCF   x7A,F
5900:  RETURN 0
5902:  MOVLB  3
5904:  BTFSC  x1E.7
5906:  BRA    592A
5908:  MOVLW  0F
590A:  MOVWF  00
590C:  SWAPF  x1D,W
590E:  ANDWF  00,F
5910:  MOVLW  0A
5912:  SUBWF  00,W
5914:  BC    591C
5916:  MOVLW  30
5918:  ADDWF  00,F
591A:  BRA    5920
591C:  MOVF   x1E,W
591E:  ADDWF  00,F
5920:  MOVFF  00,323
5924:  MOVLB  0
5926:  RCALL  58E4
5928:  MOVLB  3
592A:  MOVLW  0F
592C:  ANDWF  x1D,F
592E:  MOVLW  0A
5930:  SUBWF  x1D,W
5932:  BC    5938
5934:  MOVLW  30
5936:  BRA    593C
5938:  BCF    x1E.7
593A:  MOVF   x1E,W
593C:  ADDWF  x1D,F
593E:  MOVFF  31D,323
5942:  MOVLB  0
5944:  RCALL  58E4
5946:  GOTO   5AFA (RETURN)
594A:  MOVLW  20
594C:  MOVLB  3
594E:  BTFSS  x1E.4
5950:  MOVLW  30
5952:  MOVWF  x1F
5954:  MOVFF  31D,00
5958:  BTFSS  00.7
595A:  BRA    596C
595C:  COMF   00,F
595E:  INCF   00,F
5960:  MOVFF  00,31D
5964:  MOVLW  2D
5966:  MOVWF  x1F
5968:  BSF    x1E.7
596A:  BSF    x1E.0
596C:  MOVF   01,W
596E:  MOVFF  31D,323
5972:  MOVLW  64
5974:  MOVWF  x24
5976:  MOVLB  0
5978:  CALL   10B6
597C:  MOVFF  00,31D
5980:  MOVLW  30
5982:  ADDWF  01,W
5984:  MOVLB  3
5986:  MOVWF  x20
5988:  MOVFF  31D,323
598C:  MOVLW  0A
598E:  MOVWF  x24
5990:  MOVLB  0
5992:  CALL   10B6
5996:  MOVLW  30
5998:  ADDWF  00,W
599A:  MOVLB  3
599C:  MOVWF  x22
599E:  MOVLW  30
59A0:  ADDWF  01,W
59A2:  MOVWF  x21
59A4:  MOVFF  31F,00
59A8:  MOVLW  30
59AA:  SUBWF  x20,W
59AC:  BZ    59B6
59AE:  BSF    x1E.1
59B0:  BTFSC  x1E.7
59B2:  BSF    x1E.2
59B4:  BRA    59DA
59B6:  MOVFF  31F,320
59BA:  MOVLW  20
59BC:  MOVWF  x1F
59BE:  MOVLW  30
59C0:  SUBWF  x21,W
59C2:  BZ    59CC
59C4:  BSF    x1E.0
59C6:  BTFSC  x1E.7
59C8:  BSF    x1E.1
59CA:  BRA    59DA
59CC:  BTFSS  FD8.2
59CE:  BSF    x1E.0
59D0:  BNZ   59DA
59D2:  MOVFF  320,321
59D6:  MOVLW  20
59D8:  MOVWF  x20
59DA:  BTFSC  x1E.2
59DC:  BRA    59E8
59DE:  BTFSC  x1E.1
59E0:  BRA    59F0
59E2:  BTFSC  x1E.0
59E4:  BRA    59F8
59E6:  BRA    5A00
59E8:  MOVFF  31F,323
59EC:  MOVLB  0
59EE:  RCALL  58E4
59F0:  MOVFF  320,323
59F4:  MOVLB  0
59F6:  RCALL  58E4
59F8:  MOVFF  321,323
59FC:  MOVLB  0
59FE:  RCALL  58E4
5A00:  MOVFF  322,323
5A04:  MOVLB  0
5A06:  RCALL  58E4
5A08:  GOTO   5B30 (RETURN)
*
6E20:  ADDWF  FE8,W
6E22:  CLRF   FF7
6E24:  RLCF   FF7,F
6E26:  ADDLW  3B
6E28:  MOVWF  FF6
6E2A:  MOVLW  6E
6E2C:  ADDWFC FF7,F
6E2E:  TBLRD*-
6E30:  MOVF   FF5,W
6E32:  MOVWF  FFA
6E34:  TBLRD*
6E36:  MOVF   FF5,W
6E38:  MOVWF  FF9
6E3A:  DATA 7E,6C
6E3C:  DATA 7E,6C
6E3E:  DATA D6,6C
6E40:  DATA 64,6D
6E42:  DATA C4,6D
6E44:  DATA C4,6C
6E46:  DATA 36,6D
.................... 
.................... #list
.................... 
.................... #device ADC=8
.................... #use delay(clock=20000000)
*
04E2:  MOVLW  03
04E4:  MOVWF  FEA
04E6:  MOVLW  13
04E8:  MOVWF  FE9
04EA:  MOVF   FEF,W
04EC:  BZ    0508
04EE:  MOVLW  06
04F0:  MOVWF  01
04F2:  CLRF   00
04F4:  DECFSZ 00,F
04F6:  BRA    04F4
04F8:  DECFSZ 01,F
04FA:  BRA    04F2
04FC:  MOVLW  7B
04FE:  MOVWF  00
0500:  DECFSZ 00,F
0502:  BRA    0500
0504:  DECFSZ FEF,F
0506:  BRA    04EE
0508:  RETURN 0
*
49A2:  MOVLW  03
49A4:  MOVLB  3
49A6:  SUBWF  x18,F
49A8:  BNC   49BE
49AA:  MOVLW  03
49AC:  MOVWF  FEA
49AE:  MOVLW  18
49B0:  MOVWF  FE9
49B2:  MOVF   FEF,W
49B4:  BZ    49BE
49B6:  BRA    49BA
49B8:  BRA    49BA
49BA:  DECFSZ FEF,F
49BC:  BRA    49B8
49BE:  MOVLB  0
49C0:  RETURN 0
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,VREGEN,NOPBADEN,WRTB
.................... 
.................... #byte porte = 0xF84
.................... #byte trisc=0x87
.................... #byte portc = 0x07
.................... 
.................... 
.................... 
.................... 
.................... /** Configuración para el uso del stack tcip **/
.................... #define STACK_USE_ICMP        1  //Módulo de respuesta ICMP (ping)
.................... #define STACK_USE_ARP         1  //Para solucionar direccionamiento MAC de las IP
.................... #define STACK_USE_TCP         1  //Para enviar paquetes TCP 
.................... #define STACK_USE_HTTP        1  //Uso de las funciones http del stack.
.................... #define STACK_USE_CCS_PICENS  1  //CCS PICENS (Embedded Ethernet) 18F4620 + ENC28J60
.................... #define STACK_USE_MCPENC      1  //Uso del enc28j60 por el stack (stacktsk.c)
.................... #define STACK_USE_MAC         1  //Uso de la tarjeta de red
.................... 
.................... #define HTTP_SOCKET 80         //Nº de puerto asociado al socket.
.................... 
.................... #define ENC_MAC_USE_SPI 1           //Uso del SPI por hardware
.................... 
.................... #define PIN_ENC_MAC_SO  PIN_B0      //Entrada serie de datos
.................... #define PIN_ENC_MAC_CS  PIN_B2      //Chip select
.................... #define PIN_ENC_MAC_RST PIN_B3      //Reset
.................... #define PIN_ENC_MAC_INT PIN_B4      //Interrupción
.................... 
.................... /******************************************************************************/
.................... 
.................... #define use_portd_lcd TRUE       //Uso del puerto d para control del lcd
.................... #include <LCD420PIC18F_RyP.c>    //Carga librería del lcd de 4x20 para familia 18F
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //                                                                            //
.................... //           LIBRERIA PARA CONTROL DE LCD 4X20 con PIC 18F4550                //
.................... //                                                                            //
.................... //                                                                            //
.................... //      Se debe llamar a este archivo mediante #include <LCD420PIC18_RyP.c>   //
.................... //                                                                            //
.................... //      Es necesariodefinir el puerto a utilizar para el teclado mediante:    //
.................... //      #define use_portb_lcd TRUE   //para el puerto B                       //
.................... //      #define use_portd_lcd TRUE   //para el puerto D                       //
.................... //                                                                            //
.................... //      FUNCIONES:                                                            //
.................... //      void lcd_init(void);         //Inicializa el lcd.                     //
.................... //                                                                            //
.................... //                                                                            //
.................... //                            RobotyPic 2013                                  //
.................... //                    http://robotypic.blogspot.com/                          //
.................... //                                                                            //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //Elección del puerto y pines
.................... 
.................... #ifdef use_portd_lcd
.................... 
.................... #define LCD_DB4  PIN_D4
.................... #define LCD_DB5  PIN_D5
.................... #define LCD_DB6  PIN_D6
.................... #define LCD_DB7  PIN_D7
.................... #define LCD_E    PIN_D0
.................... #define LCD_RS   PIN_D1
.................... #define LCD_RW   PIN_D2
.................... 
.................... #else
.................... 
.................... #define LCD_DB4  PIN_B4
.................... #define LCD_DB5  PIN_B5
.................... #define LCD_DB6  PIN_B6
.................... #define LCD_DB7  PIN_B7
.................... #define LCD_E    PIN_B0
.................... #define LCD_RS   PIN_B1
.................... #define LCD_RW   PIN_B2
.................... 
.................... #endif
.................... 
.................... // If you only want a 6-pin interface to your LCD, then
.................... // connect the R/W pin on the LCD to ground, and comment
.................... // out the following line.
.................... 
.................... #define USE_LCD_RW  1    
.................... 
.................... 
.................... #define lcd_type 2
.................... #define lcd_line_two 0x40
.................... 
.................... BYTE lcdline;
.................... 
.................... int8 const LCD_INIT_STRING[4] =
.................... {
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots
....................  0xc,                    // Display on
....................  1,                      // Clear display
....................  6                      // Increment cursor
....................  };
.................... 
.................... 
.................... //-------------------------------------
.................... void lcd_send_nibble(int8 nibble)
.................... {
....................  output_bit(LCD_DB4, !!(nibble & 1));
*
050A:  MOVLB  3
050C:  BTFSC  x13.0
050E:  BRA    0514
0510:  BCF    F8C.4
0512:  BRA    0516
0514:  BSF    F8C.4
0516:  BCF    F95.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
0518:  BTFSC  x13.1
051A:  BRA    0520
051C:  BCF    F8C.5
051E:  BRA    0522
0520:  BSF    F8C.5
0522:  BCF    F95.5
....................  output_bit(LCD_DB6, !!(nibble & 4));  
0524:  BTFSC  x13.2
0526:  BRA    052C
0528:  BCF    F8C.6
052A:  BRA    052E
052C:  BSF    F8C.6
052E:  BCF    F95.6
....................  output_bit(LCD_DB7, !!(nibble & 8));  
0530:  BTFSC  x13.3
0532:  BRA    0538
0534:  BCF    F8C.7
0536:  BRA    053A
0538:  BSF    F8C.7
053A:  BCF    F95.7
.................... 
....................  delay_cycles(1);
053C:  NOP   
....................  output_high(LCD_E);
053E:  BCF    F95.0
0540:  BSF    F8C.0
....................  delay_us(2);
0542:  MOVLW  03
0544:  MOVWF  00
0546:  DECFSZ 00,F
0548:  BRA    0546
....................  output_low(LCD_E);
054A:  BCF    F95.0
054C:  BCF    F8C.0
054E:  MOVLB  0
0550:  RETURN 0
.................... }
.................... 
.................... #ifdef USE_LCD_RW
.................... int8 lcd_read_nibble(void)
.................... {
.................... int8 retval;
.................... #bit retval_0 = retval.0
.................... #bit retval_1 = retval.1
.................... #bit retval_2 = retval.2
.................... #bit retval_3 = retval.3
.................... 
.................... retval = 0;
0552:  MOVLB  3
0554:  CLRF   x14
....................   
.................... output_high(LCD_E);
0556:  BCF    F95.0
0558:  BSF    F8C.0
.................... delay_cycles(1);
055A:  NOP   
.................... 
.................... retval_0 = input(LCD_DB4);
055C:  BSF    F95.4
055E:  BCF    x14.0
0560:  BTFSC  F83.4
0562:  BSF    x14.0
.................... retval_1 = input(LCD_DB5);
0564:  BSF    F95.5
0566:  BCF    x14.1
0568:  BTFSC  F83.5
056A:  BSF    x14.1
.................... retval_2 = input(LCD_DB6);
056C:  BSF    F95.6
056E:  BCF    x14.2
0570:  BTFSC  F83.6
0572:  BSF    x14.2
.................... retval_3 = input(LCD_DB7);
0574:  BSF    F95.7
0576:  BCF    x14.3
0578:  BTFSC  F83.7
057A:  BSF    x14.3
....................  
.................... output_low(LCD_E);
057C:  BCF    F95.0
057E:  BCF    F8C.0
....................   
.................... return(retval);  
0580:  MOVFF  314,01
0584:  MOVLB  0
0586:  RETURN 0
.................... }  
.................... #endif
.................... 
.................... #ifdef USE_LCD_RW
.................... int8 lcd_read_byte(void)
.................... {
.................... int8 low;
.................... int8 high;
.................... 
.................... output_high(LCD_RW);
0588:  BCF    F95.2
058A:  BSF    F8C.2
.................... delay_cycles(1);
058C:  NOP   
.................... 
.................... high = lcd_read_nibble();
058E:  RCALL  0552
0590:  MOVFF  01,313
.................... 
.................... low = lcd_read_nibble();
0594:  RCALL  0552
0596:  MOVFF  01,312
.................... 
.................... return( (high<<4) | low);
059A:  MOVLB  3
059C:  SWAPF  x13,W
059E:  MOVWF  00
05A0:  MOVLW  F0
05A2:  ANDWF  00,F
05A4:  MOVF   00,W
05A6:  IORWF  x12,W
05A8:  MOVWF  01
05AA:  MOVLB  0
05AC:  GOTO   05B6 (RETURN)
.................... }
.................... #endif
.................... 
.................... void lcd_send_byte(int8 address, int8 n)
.................... {
.................... output_low(LCD_RS);
05B0:  BCF    F95.1
05B2:  BCF    F8C.1
.................... 
.................... #ifdef USE_LCD_RW
.................... while(bit_test(lcd_read_byte(),7)) ;
05B4:  BRA    0588
05B6:  MOVFF  01,312
05BA:  MOVLB  3
05BC:  BTFSS  01.7
05BE:  BRA    05C4
05C0:  MOVLB  0
05C2:  BRA    05B4
.................... #else
.................... delay_us(60); 
.................... #endif
.................... 
.................... if(address)
05C4:  MOVF   x10,F
05C6:  BZ    05CE
....................   output_high(LCD_RS);
05C8:  BCF    F95.1
05CA:  BSF    F8C.1
05CC:  BRA    05D2
.................... else
....................   output_low(LCD_RS);
05CE:  BCF    F95.1
05D0:  BCF    F8C.1
....................     
....................  delay_cycles(1);
05D2:  NOP   
.................... 
.................... #ifdef USE_LCD_RW
.................... output_low(LCD_RW);
05D4:  BCF    F95.2
05D6:  BCF    F8C.2
.................... delay_cycles(1);
05D8:  NOP   
.................... #endif
.................... 
.................... output_low(LCD_E);
05DA:  BCF    F95.0
05DC:  BCF    F8C.0
.................... 
.................... lcd_send_nibble(n >> 4);
05DE:  SWAPF  x11,W
05E0:  MOVWF  x12
05E2:  MOVLW  0F
05E4:  ANDWF  x12,F
05E6:  MOVFF  312,313
05EA:  MOVLB  0
05EC:  RCALL  050A
.................... lcd_send_nibble(n & 0xf);
05EE:  MOVLB  3
05F0:  MOVF   x11,W
05F2:  ANDLW  0F
05F4:  MOVWF  x12
05F6:  MOVWF  x13
05F8:  MOVLB  0
05FA:  RCALL  050A
05FC:  RETURN 0
.................... }
.................... 
.................... void lcd_init(void)
.................... {
.................... int8 i;
.................... 
.................... output_low(LCD_RS);
05FE:  BCF    F95.1
0600:  BCF    F8C.1
.................... 
.................... #ifdef USE_LCD_RW
.................... output_low(LCD_RW);
0602:  BCF    F95.2
0604:  BCF    F8C.2
.................... #endif
.................... 
.................... output_low(LCD_E);
0606:  BCF    F95.0
0608:  BCF    F8C.0
.................... 
.................... delay_ms(15);
060A:  MOVLW  0F
060C:  MOVLB  3
060E:  MOVWF  x13
0610:  MOVLB  0
0612:  RCALL  04E2
.................... 
.................... for(i=0 ;i < 3; i++)
0614:  MOVLB  2
0616:  CLRF   xE0
0618:  MOVF   xE0,W
061A:  SUBLW  02
061C:  BNC   0638
....................   {
....................     lcd_send_nibble(0x03);
061E:  MOVLW  03
0620:  MOVLB  3
0622:  MOVWF  x13
0624:  MOVLB  0
0626:  RCALL  050A
....................     delay_ms(5);
0628:  MOVLW  05
062A:  MOVLB  3
062C:  MOVWF  x13
062E:  MOVLB  0
0630:  RCALL  04E2
0632:  MOVLB  2
0634:  INCF   xE0,F
0636:  BRA    0618
....................   }
.................... 
.................... lcd_send_nibble(0x02);
0638:  MOVLW  02
063A:  MOVLB  3
063C:  MOVWF  x13
063E:  MOVLB  0
0640:  RCALL  050A
.................... 
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)
0642:  MOVLB  2
0644:  CLRF   xE0
0646:  MOVF   xE0,W
0648:  SUBLW  03
064A:  BNC   0668
....................   {
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);
064C:  CLRF   03
064E:  MOVF   xE0,W
0650:  MOVLB  0
0652:  RCALL  00AE
0654:  MOVLB  2
0656:  MOVWF  xE1
0658:  MOVLB  3
065A:  CLRF   x10
065C:  MOVWF  x11
065E:  MOVLB  0
0660:  RCALL  05B0
....................   
....................     #ifndef USE_LCD_RW
0662:  MOVLB  2
0664:  INCF   xE0,F
0666:  BRA    0646
....................     delay_ms(5);
....................     #endif
....................   }
0668:  MOVLB  0
066A:  GOTO   6F44 (RETURN)
.................... 
.................... }
.................... 
.................... void lcd_gotoxy( BYTE x, BYTE y)
.................... {
....................   BYTE address;
....................  
.................... 
....................   switch(y)
066E:  MOVLW  01
0670:  MOVLB  3
0672:  SUBWF  x0E,W
0674:  ADDLW  FC
0676:  BC    06B2
0678:  ADDLW  04
067A:  MOVLB  0
067C:  GOTO   06C4
....................   {
....................     case 1 : address=0x80;
0680:  MOVLW  80
0682:  MOVLB  3
0684:  MOVWF  x0F
....................     lcdline=1;
0686:  MOVLW  01
0688:  MOVWF  04
....................     break;
068A:  BRA    06B2
....................     case 2 : address=0xc0;
068C:  MOVLW  C0
068E:  MOVLB  3
0690:  MOVWF  x0F
....................     lcdline=2;
0692:  MOVLW  02
0694:  MOVWF  04
....................     break;
0696:  BRA    06B2
....................     case 3 : address=0x94;
0698:  MOVLW  94
069A:  MOVLB  3
069C:  MOVWF  x0F
....................     lcdline=3;
069E:  MOVLW  03
06A0:  MOVWF  04
....................     break;
06A2:  BRA    06B2
....................     case 4 : address=0xd4;
06A4:  MOVLW  D4
06A6:  MOVLB  3
06A8:  MOVWF  x0F
....................     lcdline=4;
06AA:  MOVLW  04
06AC:  MOVWF  04
....................     break;
06AE:  BRA    06B2
06B0:  MOVLB  3
....................   }
.................... 
....................   address+=x-1;
06B2:  MOVLW  01
06B4:  SUBWF  x0D,W
06B6:  ADDWF  x0F,F
....................   lcd_send_byte(0,address);
06B8:  CLRF   x10
06BA:  MOVFF  30F,311
06BE:  MOVLB  0
06C0:  RCALL  05B0
06C2:  RETURN 0
.................... }
.................... 
.................... 
.................... void lcd_putc(char c)
.................... {
....................  switch(c)
*
06E6:  MOVLB  3
06E8:  MOVF   x0C,W
06EA:  XORLW  0C
06EC:  MOVLB  0
06EE:  BZ    06FA
06F0:  XORLW  06
06F2:  BZ    0716
06F4:  XORLW  02
06F6:  BZ    073A
06F8:  BRA    0748
....................   {
....................     case '\f':
....................       lcd_send_byte(0,1);
06FA:  MOVLB  3
06FC:  CLRF   x10
06FE:  MOVLW  01
0700:  MOVWF  x11
0702:  MOVLB  0
0704:  RCALL  05B0
....................       lcdline=1;
0706:  MOVLW  01
0708:  MOVWF  04
....................       delay_ms(2);
070A:  MOVLW  02
070C:  MOVLB  3
070E:  MOVWF  x13
0710:  MOVLB  0
0712:  RCALL  04E2
....................       break;
0714:  BRA    0756
....................   
....................     case '\n':
....................       lcd_gotoxy(1,++lcdline);
0716:  INCF   04,F
0718:  MOVLW  01
071A:  MOVLB  3
071C:  MOVWF  x0D
071E:  MOVFF  04,30E
0722:  MOVLB  0
0724:  RCALL  066E
....................       if (lcdline>4) lcd_gotoxy(1,1);
0726:  MOVF   04,W
0728:  SUBLW  04
072A:  BC    0738
072C:  MOVLW  01
072E:  MOVLB  3
0730:  MOVWF  x0D
0732:  MOVWF  x0E
0734:  MOVLB  0
0736:  RCALL  066E
....................       break;
0738:  BRA    0756
....................   
....................     case '\b':
....................       lcd_send_byte(0,0x10);
073A:  MOVLB  3
073C:  CLRF   x10
073E:  MOVLW  10
0740:  MOVWF  x11
0742:  MOVLB  0
0744:  RCALL  05B0
....................       break;
0746:  BRA    0756
....................   
....................     default:
....................       lcd_send_byte(1,c);
0748:  MOVLW  01
074A:  MOVLB  3
074C:  MOVWF  x10
074E:  MOVFF  30C,311
0752:  MOVLB  0
0754:  RCALL  05B0
....................       break;
....................   }
0756:  RETURN 0
.................... }
.................... 
.................... #ifdef USE_LCD_RW
.................... char lcd_getc(int8 x, int8 y)
.................... {
.................... char value;
.................... 
.................... lcd_gotoxy(x,y);
.................... 
.................... // Wait until busy flag is low.
.................... while(bit_test(lcd_read_byte(),7)); 
.................... 
.................... output_high(LCD_RS);
.................... value = lcd_read_byte();
.................... output_low(lcd_RS);
.................... 
.................... return(value);
.................... }
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.c"      //Carga el stack TCP/IP de Microchip 
.................... /*********************************************************************
....................  *
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.c
....................  * Dependencies:    StackTsk.H
....................  *                  ARPTsk.h
....................  *                  MAC.h
....................  *                  IP.h
....................  *                  ICMP.h
....................  *                  Tcp.h
....................  *                  http.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess()
....................  *                                  to include localIP as third param.
....................  *                                  This was done to allow these functions
....................  *                                  to calculate checksum correctly.
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not
....................  *                                  clear statically IP address if link is
....................  *                                  removed and DHCP module is disabled
....................  *                                  at runtime.
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler.
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #case
.................... 
.................... #define STACK_INCLUDE
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... /*********************************************************************
....................  *
....................  *                  PIC18 SFR Definitions
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        pic18.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or later
....................  *
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  ********************************************************************/
.................... #ifndef COMPILER_H
.................... #define COMPILER_H
.................... 
.................... #if !defined(__PCH__)
.................... #error "This version only works with CCS PCH or PCWH"
.................... #endif
.................... 
.................... // ** I/O PORT REGISTERS
.................... 
.................... #byte PORTA    =  0xF80
.................... #byte PORTB    =  0xF81
.................... #byte PORTC    =  0xF82
.................... #byte PORTD    =  0xF83
.................... #byte PORTE    =  0xF84
.................... #byte PORTF    =  0xF85
.................... 
.................... #bit PORTA_RA5 =  0xF80.5
.................... #bit PORTA_RA4 =  0xF80.4
.................... #bit PORTA_RA3 =  0xF80.3
.................... #bit PORTA_RA2 =  0xF80.2
.................... #bit PORTA_RA1 =  0xF80.1
.................... #bit PORTA_RA0 =  0xF80.0
.................... 
.................... #bit PORTB_RB7 =  0xF81.7
.................... #bit PORTB_RB6 =  0xF81.6
.................... #bit PORTB_RB5 =  0xF81.5
.................... #bit PORTB_RB4 =  0xF81.4
.................... #bit PORTB_RB3 =  0xF81.3
.................... #bit PORTB_RB2 =  0xF81.2
.................... #bit PORTB_RB1 =  0xF81.1
.................... #bit PORTB_RB0 =  0xF81.0
.................... 
.................... #bit PORTC_RC7 =  0xF82.7
.................... #bit PORTC_RC6 =  0xF82.6
.................... #bit PORTC_RC5 =  0xF82.5
.................... #bit PORTC_RC4 =  0xF82.4
.................... #bit PORTC_RC3 =  0xF82.3
.................... #bit PORTC_RC2 =  0xF82.2
.................... #bit PORTC_RC1 =  0xF82.1
.................... #bit PORTC_RC0 =  0xF82.0
.................... 
.................... #bit PORTD_RD7 =  0xF83.7
.................... #bit PORTD_RD6 =  0xF83.6
.................... #bit PORTD_RD5 =  0xF83.5
.................... #bit PORTD_RD4 =  0xF83.4
.................... #bit PORTD_RD3 =  0xF83.3
.................... #bit PORTD_RD2 =  0xF83.2
.................... #bit PORTD_RD1 =  0xF83.1
.................... #bit PORTD_RD0 =  0xF83.0
.................... 
.................... #bit PORTE_RE7 =  0xF84.7
.................... #bit PORTE_RE6 =  0xF84.6
.................... #bit PORTE_RE5 =  0xF84.5
.................... #bit PORTE_RE4 =  0xF84.4
.................... #bit PORTE_RE3 =  0xF84.3
.................... #bit PORTE_RE2 =  0xF84.2
.................... #bit PORTE_RE1 =  0xF84.1
.................... #bit PORTE_RE0 =  0xF84.0
.................... 
.................... #bit PORTF_RF7 =  0xF85.7
.................... #bit PORTF_RF6 =  0xF85.6
.................... #bit PORTF_RF5 =  0xF85.5
.................... #bit PORTF_RF4 =  0xF85.4
.................... #bit PORTF_RF3 =  0xF85.3
.................... #bit PORTF_RF2 =  0xF85.2
.................... #bit PORTF_RF1 =  0xF85.1
.................... #bit PORTF_RF0 =  0xF85.0
.................... 
.................... 
.................... // *** TRIS REGISTERS
.................... 
.................... #byte TRISA    =  0xF92
.................... #byte TRISB    =  0xF93
.................... #byte TRISC    =  0xF94
.................... #byte TRISD    =  0xF95
.................... #byte TRISE    =  0xF96
.................... #byte TRISF    =  0xF97
.................... 
.................... #bit TRISA_RA7 =  0xF92.7
.................... #bit TRISA_RA6 =  0xF92.6
.................... #bit TRISA_RA5 =  0xF92.5
.................... #bit TRISA_RA4 =  0xF92.4
.................... #bit TRISA_RA3 =  0xF92.3
.................... #bit TRISA_RA2 =  0xF92.2
.................... #bit TRISA_RA1 =  0xF92.1
.................... #bit TRISA_RA0 =  0xF92.0
.................... 
.................... #bit TRISB_RB7 =  0xF93.7
.................... #bit TRISB_RB6 =  0xF93.6
.................... #bit TRISB_RB5 =  0xF93.5
.................... #bit TRISB_RB4 =  0xF93.4
.................... #bit TRISB_RB3 =  0xF93.3
.................... #bit TRISB_RB2 =  0xF93.2
.................... #bit TRISB_RB1 =  0xF93.1
.................... #bit TRISB_RB0 =  0xF93.0
.................... 
.................... #bit TRISC_RC7 =  0xF94.7
.................... #bit TRISC_RC6 =  0xF94.6
.................... #bit TRISC_RC5 =  0xF94.5
.................... #bit TRISC_RC4 =  0xF94.4
.................... #bit TRISC_RC3 =  0xF94.3
.................... #bit TRISC_RC2 =  0xF94.2
.................... #bit TRISC_RC1 =  0xF94.1
.................... #bit TRISC_RC0 =  0xF94.0
.................... 
.................... #bit TRISD_RD7 =  0xF95.7
.................... #bit TRISD_RD6 =  0xF95.6
.................... #bit TRISD_RD5 =  0xF95.5
.................... #bit TRISD_RD4 =  0xF95.4
.................... #bit TRISD_RD3 =  0xF95.3
.................... #bit TRISD_RD2 =  0xF95.2
.................... #bit TRISD_RD1 =  0xF95.1
.................... #bit TRISD_RD0 =  0xF95.0
.................... 
.................... #bit TRISE_RE7 =  0xF96.7
.................... #bit TRISE_RE6 =  0xF96.6
.................... #bit TRISE_RE5 =  0xF96.5
.................... #bit TRISE_RE4 =  0xF96.4
.................... #bit TRISE_RE3 =  0xF96.3
.................... #bit TRISE_RE2 =  0xF96.2
.................... #bit TRISE_RE1 =  0xF96.1
.................... #bit TRISE_RE0 =  0xF96.0
.................... 
.................... #bit TRISF_RF7 =  0xF97.7
.................... #bit TRISF_RF6 =  0xF97.6
.................... #bit TRISF_RF5 =  0xF97.5
.................... #bit TRISF_RF4 =  0xF97.4
.................... #bit TRISF_RF3 =  0xF97.3
.................... #bit TRISF_RF2 =  0xF97.2
.................... #bit TRISF_RF1 =  0xF97.1
.................... #bit TRISF_RF0 =  0xF97.0
.................... 
.................... 
.................... // *** LAT REGISTERS
.................... #byte LATA    =  0xF89
.................... #byte LATB    =  0xF8A
.................... #byte LATC    =  0xF8B
.................... #byte LATD    =  0xF8C
.................... #byte LATE    =  0xF8D
.................... #byte LATF    =  0xF8E
.................... 
.................... #bit LATA_RA7 =  0xF89.7
.................... #bit LATA_RA6 =  0xF89.6
.................... #bit LATA_RA5 =  0xF89.5
.................... #bit LATA_RA4 =  0xF89.4
.................... #bit LATA_RA3 =  0xF89.3
.................... #bit LATA_RA2 =  0xF89.2
.................... #bit LATA_RA1 =  0xF89.1
.................... #bit LATA_RA0 =  0xF89.0
.................... 
.................... #bit LATB_RB7 =  0xF8A.7
.................... #bit LATB_RB6 =  0xF8A.6
.................... #bit LATB_RB5 =  0xF8A.5
.................... #bit LATB_RB4 =  0xF8A.4
.................... #bit LATB_RB3 =  0xF8A.3
.................... #bit LATB_RB2 =  0xF8A.2
.................... #bit LATB_RB1 =  0xF8A.1
.................... #bit LATB_RB0 =  0xF8A.0
.................... 
.................... #bit LATC_RC7 =  0xF8B.7
.................... #bit LATC_RC6 =  0xF8B.6
.................... #bit LATC_RC5 =  0xF8B.5
.................... #bit LATC_RC4 =  0xF8B.4
.................... #bit LATC_RC3 =  0xF8B.3
.................... #bit LATC_RC2 =  0xF8B.2
.................... #bit LATC_RC1 =  0xF8B.1
.................... #bit LATC_RC0 =  0xF8B.0
.................... 
.................... #bit LATD_RD7 =  0xF8C.7
.................... #bit LATD_RD6 =  0xF8C.6
.................... #bit LATD_RD5 =  0xF8C.5
.................... #bit LATD_RD4 =  0xF8C.4
.................... #bit LATD_RD3 =  0xF8C.3
.................... #bit LATD_RD2 =  0xF8C.2
.................... #bit LATD_RD1 =  0xF8C.1
.................... #bit LATD_RD0 =  0xF8C.0
.................... 
.................... #bit LATE_RE7 =  0xF8D.7
.................... #bit LATE_RE6 =  0xF8D.6
.................... #bit LATE_RE5 =  0xF8D.5
.................... #bit LATE_RE4 =  0xF8D.4
.................... #bit LATE_RE3 =  0xF8D.3
.................... #bit LATE_RE2 =  0xF8D.2
.................... #bit LATE_RE1 =  0xF8D.1
.................... #bit LATE_RE0 =  0xF8D.0
.................... 
.................... #bit LATF_RF7 =  0xF8E.7
.................... #bit LATF_RF6 =  0xF8E.6
.................... #bit LATF_RF5 =  0xF8E.5
.................... #bit LATF_RF4 =  0xF8E.4
.................... #bit LATF_RF3 =  0xF8E.3
.................... #bit LATF_RF2 =  0xF8E.2
.................... #bit LATF_RF1 =  0xF8E.1
.................... #bit LATF_RF0 =  0xF8E.0
.................... 
.................... 
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP
.................... 
.................... #bit  PIE1_TXIE       =  0xF9D.4
.................... #bit  PIE1_RCIE       =  0xF9D.5
.................... #bit  PIR1_TXIF       =  0xF9E.4
.................... #bit  PIR1_RCIF       =  0xF9E.5
.................... #byte TXSTA           =  0xFAC
.................... #byte RCSTA           =  0xFAB
.................... #bit  RCSTA_CREN      =  0xFAB.4
.................... #byte RCREG           =  0xFAE
.................... #byte SPBRG           =  0xFAF
.................... #byte TXREG           =  0xFAD
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                         HARDWARE.H                                ////
.................... ////                                                                   ////
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. ////
.................... ////                                                                   ////
.................... //// These values will probably change with each application.          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// RELEASE HISTORY:                                                  ////
.................... ////                                                                   ////
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT ////
.................... ////                  moved to here.                                   ////
.................... ////                                                                   ////
.................... ////    Jan 09, 2004: Initial Public Release                           ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION
.................... #define ___TCPIP_STACK_CONFIGURATION
.................... 
.................... 
.................... #ifndef STACK_USE_CCS_PICNET
.................... #define STACK_USE_CCS_PICNET  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_CCS_PICENS
.................... #define STACK_USE_CCS_PICENS  FALSE
.................... #endif
.................... 
.................... 
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT.
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED.
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE
.................... 
.................... 
.................... ///DEFAULT HARDCODED IP ADDRESSES.
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM.
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP).
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address.
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        1
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        10
.................... 
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network.
....................    #define MY_DEFAULT_MASK_BYTE4           0x00
.................... 
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks.
....................    #define MY_DEFAULT_GATE_BYTE3           1
....................    #define MY_DEFAULT_GATE_BYTE4           1
.................... 
.................... ///DEFAULT HARDCODED MAC ADDRESS.
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER.
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS.
.................... #define MY_DEFAULT_MAC_BYTE1            0x00
.................... #define MY_DEFAULT_MAC_BYTE2            0x02
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3
.................... #define MY_DEFAULT_MAC_BYTE4            0x04
.................... #define MY_DEFAULT_MAC_BYTE5            0x05
.................... #define MY_DEFAULT_MAC_BYTE6            0x06
.................... 
.................... ///Maximum sockets to be defined.
.................... /// Note that each socket consumes 36 bytes of RAM.
.................... /// If you remove this, a default value will be loaded in stacktsk.h
....................    #ifndef MAX_SOCKETS
....................    #define MAX_SOCKETS                     5
....................    #endif
.................... 
.................... ///Avaialble UDP Socket
.................... /// DCHP takes 1 socket.
.................... /// If you remove this, a default value will be loaded in stacktsk.h
....................    #ifndef MAX_UDP_SOCKETS
....................    #define MAX_UDP_SOCKETS                 2
....................    #endif
.................... 
.................... ///BUFFER SIZE DEFINITIONS
.................... ///
.................... /// For SLIP, there can only be one transmit and one receive buffer.
.................... /// Both buffer must fit in one bank.  If bigger buffer is required,
.................... /// you must manually locate tx and rx buffer in different bank
.................... /// or modify your linker script file to support arrays bigger than
.................... /// 256 bytes.
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE
.................... ///
.................... /// For PPP, there can only be one transmit and one receive buffer.
.................... /// You can receive messages larger than the receive buffer if your
.................... /// routines are fast enough.  You cannot transmit messages larger
.................... /// than the TX buffer.  The larger the buffer you can make, the better.
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE
.................... ///
.................... /// For Ethernet, the Ethernet controler has many buffers that are
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX.
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers.
....................    #if STACK_USE_MAC
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line
....................    #elif STACK_USE_PPP
....................        #define MAC_TX_BUFFER_SIZE          1024
....................        #define MAC_TX_BUFFER_COUNT         1
....................    #elif STACK_USE_SLIP
....................        #define MAC_TX_BUFFER_SIZE          250
....................        #define MAC_TX_BUFFER_COUNT         1
....................    #endif
.................... 
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing
.................... 
.................... #endif
.................... 
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
45E0:  MOVFF  30F,315
45E4:  MOVFF  30E,314
....................    sc2=s2;
45E8:  MOVFF  311,317
45EC:  MOVFF  310,316
....................    if(sc2<sc1 && sc1 <sc2 +n)
45F0:  MOVLB  3
45F2:  MOVF   x17,W
45F4:  SUBWF  x15,W
45F6:  BNC   4670
45F8:  BNZ   4600
45FA:  MOVF   x14,W
45FC:  SUBWF  x16,W
45FE:  BC    4670
4600:  MOVF   x12,W
4602:  ADDWF  x16,W
4604:  MOVWF  01
4606:  MOVF   x13,W
4608:  ADDWFC x17,W
460A:  MOVWF  03
460C:  MOVF   x15,W
460E:  SUBWF  03,W
4610:  BNC   4670
4612:  BNZ   461A
4614:  MOVF   01,W
4616:  SUBWF  x14,W
4618:  BC    4670
....................       for(sc1+=n,sc2+=n;0<n;--n)
461A:  MOVF   x12,W
461C:  ADDWF  x14,F
461E:  MOVF   x13,W
4620:  ADDWFC x15,F
4622:  MOVF   x12,W
4624:  ADDWF  x16,F
4626:  MOVF   x13,W
4628:  ADDWFC x17,F
462A:  MOVF   x13,F
462C:  BNZ   4634
462E:  MOVF   x12,W
4630:  SUBLW  00
4632:  BC    466E
....................          *--sc1=*--sc2;
4634:  MOVF   x14,W
4636:  BTFSC  FD8.2
4638:  DECF   x15,F
463A:  DECF   x14,F
463C:  MOVFF  315,319
4640:  MOVFF  314,318
4644:  MOVF   x16,W
4646:  BTFSC  FD8.2
4648:  DECF   x17,F
464A:  DECF   x16,F
464C:  MOVFF  317,FEA
4650:  MOVFF  316,FE9
4654:  MOVFF  FEF,31A
4658:  MOVFF  315,FEA
465C:  MOVFF  314,FE9
4660:  MOVFF  31A,FEF
4664:  MOVF   x12,W
4666:  BTFSC  FD8.2
4668:  DECF   x13,F
466A:  DECF   x12,F
466C:  BRA    462A
466E:  BRA    46B0
....................    else
....................       for(;0<n;--n)
4670:  MOVF   x13,F
4672:  BNZ   467A
4674:  MOVF   x12,W
4676:  SUBLW  00
4678:  BC    46B0
....................          *sc1++=*sc2++;
467A:  MOVFF  315,319
467E:  MOVF   x14,W
4680:  INCF   x14,F
4682:  BTFSC  FD8.2
4684:  INCF   x15,F
4686:  MOVWF  x18
4688:  MOVFF  317,FEA
468C:  MOVF   x16,W
468E:  INCF   x16,F
4690:  BTFSC  FD8.2
4692:  INCF   x17,F
4694:  MOVWF  FE9
4696:  MOVFF  FEF,31A
469A:  MOVFF  319,FEA
469E:  MOVFF  318,FE9
46A2:  MOVFF  31A,FEF
46A6:  MOVF   x12,W
46A8:  BTFSC  FD8.2
46AA:  DECF   x13,F
46AC:  DECF   x12,F
46AE:  BRA    4670
....................   return s1;
46B0:  MOVFF  30E,01
46B4:  MOVFF  30F,02
46B8:  MOVLB  0
46BA:  GOTO   4784 (RETURN)
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
*
5A0C:  MOVFF  31E,324
5A10:  MOVFF  31D,323
5A14:  MOVLB  3
5A16:  MOVF   x21,F
5A18:  BNZ   5A1E
5A1A:  MOVF   x22,F
5A1C:  BZ    5A64
5A1E:  MOVFF  320,FEA
5A22:  MOVFF  31F,FE9
5A26:  MOVF   FEF,F
5A28:  BZ    5A64
....................      *s++ = *s2++;
5A2A:  MOVFF  324,03
5A2E:  MOVF   x23,W
5A30:  INCF   x23,F
5A32:  BTFSC  FD8.2
5A34:  INCF   x24,F
5A36:  MOVWF  x25
5A38:  MOVFF  03,326
5A3C:  MOVFF  320,FEA
5A40:  MOVF   x1F,W
5A42:  INCF   x1F,F
5A44:  BTFSC  FD8.2
5A46:  INCF   x20,F
5A48:  MOVWF  FE9
5A4A:  MOVFF  FEF,327
5A4E:  MOVFF  03,FEA
5A52:  MOVFF  325,FE9
5A56:  MOVFF  327,FEF
5A5A:  MOVF   x21,W
5A5C:  BTFSC  FD8.2
5A5E:  DECF   x22,F
5A60:  DECF   x21,F
5A62:  BRA    5A16
....................   for (; n > 0; n--)
5A64:  MOVF   x21,F
5A66:  BNZ   5A6C
5A68:  MOVF   x22,F
5A6A:  BZ    5A86
....................      *s++ = '\0';
5A6C:  MOVFF  324,FEA
5A70:  MOVF   x23,W
5A72:  INCF   x23,F
5A74:  BTFSC  FD8.2
5A76:  INCF   x24,F
5A78:  MOVWF  FE9
5A7A:  CLRF   FEF
5A7C:  MOVF   x21,W
5A7E:  BTFSC  FD8.2
5A80:  DECF   x22,F
5A82:  DECF   x21,F
5A84:  BRA    5A64
.................... 
....................   return(s1);
5A86:  MOVFF  31D,01
5A8A:  MOVFF  31E,02
5A8E:  MOVLB  0
5A90:  GOTO   5B7E (RETURN)
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
413C:  MOVFF  2EF,FEA
4140:  MOVLB  2
4142:  MOVFF  2EE,FE9
4146:  MOVFF  FEF,2F2
414A:  MOVFF  2F1,FEA
414E:  MOVFF  2F0,FE9
4152:  MOVF   FEF,W
4154:  SUBWF  xF2,W
4156:  BNZ   4186
....................       if (*s1 == '\0')
4158:  MOVFF  2EF,03
415C:  MOVFF  2EE,FE9
4160:  MOVFF  03,FEA
4164:  MOVF   FEF,F
4166:  BNZ   416E
....................          return(0);
4168:  MOVLW  00
416A:  MOVWF  01
416C:  BRA    41B0
416E:  MOVFF  2EF,03
4172:  MOVF   xEE,W
4174:  INCF   xEE,F
4176:  BTFSC  FD8.2
4178:  INCF   xEF,F
417A:  INCF   xF0,F
417C:  BTFSC  FD8.2
417E:  INCF   xF1,F
4180:  MOVLB  0
4182:  BRA    413C
4184:  MOVLB  2
....................    return((*s1 < *s2) ? -1: 1);
4186:  MOVFF  2EF,03
418A:  MOVFF  2EE,FE9
418E:  MOVFF  03,FEA
4192:  MOVFF  FEF,2F2
4196:  MOVFF  2F1,03
419A:  MOVFF  2F0,FE9
419E:  MOVFF  03,FEA
41A2:  MOVF   FEF,W
41A4:  SUBWF  xF2,W
41A6:  BC    41AC
41A8:  MOVLW  FF
41AA:  BRA    41AE
41AC:  MOVLW  01
41AE:  MOVWF  01
41B0:  MOVLB  0
41B2:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
41B4:  MOVFF  33F,342
....................    for(su=s;0<n;++su,--n)
41B8:  MOVFF  33E,344
41BC:  MOVFF  33D,343
41C0:  MOVLB  3
41C2:  MOVF   x41,F
41C4:  BNZ   41CC
41C6:  MOVF   x40,W
41C8:  SUBLW  00
41CA:  BC    41F4
....................       if(*su==uc)
41CC:  MOVFF  344,FEA
41D0:  MOVFF  343,FE9
41D4:  MOVF   x42,W
41D6:  SUBWF  FEF,W
41D8:  BNZ   41E4
....................       return su;
41DA:  MOVFF  343,01
41DE:  MOVFF  344,02
41E2:  BRA    41FA
41E4:  INCF   x43,F
41E6:  BTFSC  FD8.2
41E8:  INCF   x44,F
41EA:  MOVF   x40,W
41EC:  BTFSC  FD8.2
41EE:  DECF   x41,F
41F0:  DECF   x40,F
41F2:  BRA    41C2
....................    return NULL;
41F4:  MOVLW  00
41F6:  MOVWF  01
41F8:  MOVWF  02
41FA:  MOVLB  0
41FC:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
3FD2:  MOVFF  2FB,2FF
3FD6:  MOVFF  2FA,2FE
3FDA:  MOVFF  2FF,FEA
3FDE:  MOVLB  2
3FE0:  MOVFF  2FE,FE9
3FE4:  MOVF   FEF,F
3FE6:  BZ    4044
....................       for (sc2 = s2; *sc2 != 0; sc2++)
3FE8:  MOVFF  2FD,301
3FEC:  MOVFF  2FC,300
3FF0:  MOVFF  301,FEA
3FF4:  MOVLB  3
3FF6:  MOVFF  300,FE9
3FFA:  MOVF   FEF,F
3FFC:  BZ    4036
....................          if (*sc1 == *sc2)
3FFE:  MOVFF  2FF,03
4002:  MOVFF  2FE,FE9
4006:  MOVFF  03,FEA
400A:  MOVFF  FEF,302
400E:  MOVFF  301,FEA
4012:  MOVLB  3
4014:  MOVFF  300,FE9
4018:  MOVF   FEF,W
401A:  SUBWF  x02,W
401C:  BNZ   402C
....................             return(sc1);
401E:  MOVLB  2
4020:  MOVFF  2FE,01
4024:  MOVFF  2FF,02
4028:  BRA    404A
402A:  MOVLB  3
402C:  INCF   x00,F
402E:  BTFSC  FD8.2
4030:  INCF   x01,F
4032:  MOVLB  2
4034:  BRA    3FF0
4036:  MOVLB  2
4038:  INCF   xFE,F
403A:  BTFSC  FD8.2
403C:  INCF   xFF,F
403E:  MOVLB  0
4040:  BRA    3FDA
4042:  MOVLB  2
....................    return(0);
4044:  MOVLW  00
4046:  MOVWF  01
4048:  MOVWF  02
404A:  MOVLB  0
404C:  GOTO   40EA (RETURN)
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
*
3F3E:  MOVFF  2FB,2FF
3F42:  MOVFF  2FA,2FE
3F46:  MOVFF  2FF,FEA
3F4A:  MOVLB  2
3F4C:  MOVFF  2FE,FE9
3F50:  MOVF   FEF,F
3F52:  BZ    3FBA
....................       for (sc2 = s2; ; sc2++)
3F54:  MOVFF  2FD,301
3F58:  MOVFF  2FC,300
....................     if (*sc2 == '\0')
3F5C:  MOVFF  301,FEA
3F60:  MOVLB  3
3F62:  MOVFF  300,FE9
3F66:  MOVF   FEF,F
3F68:  BNZ   3F82
....................        return(sc1 - s1);
3F6A:  MOVLB  2
3F6C:  MOVF   xFA,W
3F6E:  SUBWF  xFE,W
3F70:  MOVWF  00
3F72:  MOVF   xFB,W
3F74:  SUBWFB xFF,W
3F76:  MOVWF  03
3F78:  MOVFF  00,01
3F7C:  MOVWF  02
3F7E:  BRA    3FCC
3F80:  BRA    3FA0
....................          else if (*sc1 == *sc2)
3F82:  MOVFF  2FF,FEA
3F86:  MOVFF  2FE,FE9
3F8A:  MOVFF  FEF,302
3F8E:  MOVFF  301,FEA
3F92:  MOVLB  3
3F94:  MOVFF  300,FE9
3F98:  MOVF   FEF,W
3F9A:  SUBWF  x02,W
3F9C:  BNZ   3FA0
....................             break;
3F9E:  BRA    3FAC
3FA0:  MOVLB  3
3FA2:  INCF   x00,F
3FA4:  BTFSC  FD8.2
3FA6:  INCF   x01,F
3FA8:  MOVLB  2
3FAA:  BRA    3F5C
3FAC:  MOVLB  2
3FAE:  INCF   xFE,F
3FB0:  BTFSC  FD8.2
3FB2:  INCF   xFF,F
3FB4:  MOVLB  0
3FB6:  BRA    3F46
3FB8:  MOVLB  2
....................    return(sc1 - s1);
3FBA:  MOVF   xFA,W
3FBC:  SUBWF  xFE,W
3FBE:  MOVWF  00
3FC0:  MOVF   xFB,W
3FC2:  SUBWFB xFF,W
3FC4:  MOVWF  03
3FC6:  MOVFF  00,01
3FCA:  MOVWF  02
3FCC:  MOVLB  0
3FCE:  GOTO   40B8 (RETURN)
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
4050:  MOVFF  31E,320
4054:  MOVFF  31D,31F
4058:  MOVFF  320,FEA
405C:  MOVLB  3
405E:  MOVFF  31F,FE9
4062:  MOVF   FEF,F
4064:  BZ    4072
4066:  INCF   x1F,F
4068:  BTFSC  FD8.2
406A:  INCF   x20,F
406C:  MOVLB  0
406E:  BRA    4058
4070:  MOVLB  3
....................    return(sc - s);
4072:  MOVF   x1D,W
4074:  SUBWF  x1F,W
4076:  MOVWF  00
4078:  MOVF   x1E,W
407A:  SUBWFB x20,W
407C:  MOVWF  03
407E:  MOVFF  00,01
4082:  MOVWF  02
4084:  MOVLB  0
4086:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
4088:  MOVLB  2
408A:  MOVF   xF2,W
408C:  IORWF  xF3,W
408E:  BZ    4098
4090:  MOVFF  2F3,03
4094:  MOVF   xF2,W
4096:  BRA    409E
4098:  MOVFF  06,03
409C:  MOVF   05,W
409E:  MOVWF  xF6
40A0:  MOVFF  03,2F7
....................    beg += strspn(beg, s2);
40A4:  MOVFF  2F7,2FB
40A8:  MOVFF  2F6,2FA
40AC:  MOVFF  2F5,2FD
40B0:  MOVFF  2F4,2FC
40B4:  MOVLB  0
40B6:  BRA    3F3E
40B8:  MOVF   01,W
40BA:  MOVLB  2
40BC:  ADDWF  xF6,F
40BE:  MOVF   02,W
40C0:  ADDWFC xF7,F
....................    if (*beg == '\0')
40C2:  MOVFF  2F7,FEA
40C6:  MOVFF  2F6,FE9
40CA:  MOVF   FEF,F
40CC:  BNZ   40D6
....................       return(0);
40CE:  MOVLW  00
40D0:  MOVWF  01
40D2:  MOVWF  02
40D4:  BRA    4138
....................       
....................    end = strpbrk(beg, s2);
40D6:  MOVFF  2F7,2FB
40DA:  MOVFF  2F6,2FA
40DE:  MOVFF  2F5,2FD
40E2:  MOVFF  2F4,2FC
40E6:  MOVLB  0
40E8:  BRA    3FD2
40EA:  MOVFF  02,2F9
40EE:  MOVFF  01,2F8
....................    if (end != '\0')
40F2:  MOVLB  2
40F4:  MOVF   xF8,F
40F6:  BNZ   40FC
40F8:  MOVF   xF9,F
40FA:  BZ    4116
....................    {
....................       *end = '\0';
40FC:  MOVFF  2F9,FEA
4100:  MOVFF  2F8,FE9
4104:  CLRF   FEF
....................       end++;
4106:  INCF   xF8,F
4108:  BTFSC  FD8.2
410A:  INCF   xF9,F
....................       save = end;
410C:  MOVFF  2F9,06
4110:  MOVFF  2F8,05
....................    }
4114:  BRA    4130
....................    else
....................       save = beg + strlen(beg);
4116:  MOVFF  2F7,31E
411A:  MOVFF  2F6,31D
411E:  MOVLB  0
4120:  RCALL  4050
4122:  MOVF   01,W
4124:  MOVLB  2
4126:  ADDWF  xF6,W
4128:  MOVWF  05
412A:  MOVF   02,W
412C:  ADDWFC xF7,W
412E:  MOVWF  06
....................    
....................    return(beg);
4130:  MOVFF  2F6,01
4134:  MOVFF  2F7,02
4138:  MOVLB  0
413A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
*
479E:  MOVFF  30B,FEA
47A2:  MOVLB  3
47A4:  MOVFF  30A,FE9
47A8:  MOVFF  FEF,30E
47AC:  MOVFF  30D,FEA
47B0:  MOVFF  30C,FE9
47B4:  MOVF   FEF,W
47B6:  SUBWF  x0E,W
47B8:  BZ    483A
47BA:  MOVFF  30B,FEA
47BE:  MOVFF  30A,FE9
47C2:  MOVFF  FEF,30E
47C6:  MOVF   x0E,W
47C8:  SUBLW  40
47CA:  BC    47D2
47CC:  MOVF   x0E,W
47CE:  SUBLW  5A
47D0:  BC    47DE
47D2:  MOVF   x0E,W
47D4:  SUBLW  60
47D6:  BC    4864
47D8:  MOVF   x0E,W
47DA:  SUBLW  7A
47DC:  BNC   4864
47DE:  MOVFF  30D,FEA
47E2:  MOVFF  30C,FE9
47E6:  MOVFF  FEF,30E
47EA:  MOVF   x0E,W
47EC:  SUBLW  40
47EE:  BC    47F6
47F0:  MOVF   x0E,W
47F2:  SUBLW  5A
47F4:  BC    4802
47F6:  MOVF   x0E,W
47F8:  SUBLW  60
47FA:  BC    4864
47FC:  MOVF   x0E,W
47FE:  SUBLW  7A
4800:  BNC   4864
4802:  MOVFF  30B,FEA
4806:  MOVFF  30A,FE9
480A:  MOVFF  FEF,30E
480E:  MOVFF  30D,FEA
4812:  MOVFF  30C,FE9
4816:  MOVLW  20
4818:  ADDWF  FEF,W
481A:  SUBWF  x0E,W
481C:  BZ    483A
481E:  MOVFF  30D,FEA
4822:  MOVFF  30C,FE9
4826:  MOVFF  FEF,30E
482A:  MOVFF  30B,FEA
482E:  MOVFF  30A,FE9
4832:  MOVLW  20
4834:  ADDWF  FEF,W
4836:  SUBWF  x0E,W
4838:  BNZ   4864
....................     s1++, s2++)
....................     if (*s1 == '\0')
483A:  MOVFF  30B,FEA
483E:  MOVFF  30A,FE9
4842:  MOVF   FEF,F
4844:  BNZ   484C
....................        return(0);
4846:  MOVLW  00
4848:  MOVWF  01
484A:  BRA    488E
484C:  MOVFF  30B,03
4850:  MOVF   x0A,W
4852:  INCF   x0A,F
4854:  BTFSC  FD8.2
4856:  INCF   x0B,F
4858:  INCF   x0C,F
485A:  BTFSC  FD8.2
485C:  INCF   x0D,F
485E:  MOVLB  0
4860:  BRA    479E
4862:  MOVLB  3
....................  return((*s1 < *s2) ? -1: 1);
4864:  MOVFF  30B,03
4868:  MOVFF  30A,FE9
486C:  MOVFF  03,FEA
4870:  MOVFF  FEF,30E
4874:  MOVFF  30D,03
4878:  MOVFF  30C,FE9
487C:  MOVFF  03,FEA
4880:  MOVF   FEF,W
4882:  SUBWF  x0E,W
4884:  BC    488A
4886:  MOVLW  FF
4888:  BRA    488C
488A:  MOVLW  01
488C:  MOVWF  01
488E:  MOVLB  0
4890:  RETURN 0
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
4DBE:  MOVLB  2
4DC0:  CLRF   xF6
....................    sign = 0;
4DC2:  CLRF   xF4
....................    base = 10;
4DC4:  MOVLW  0A
4DC6:  MOVWF  xF5
....................    result = 0;
4DC8:  CLRF   xF3
4DCA:  CLRF   xF2
.................... 
....................    if (!s)
4DCC:  MOVF   xF0,W
4DCE:  IORWF  xF1,W
4DD0:  BNZ   4DDA
....................       return 0;
4DD2:  MOVLW  00
4DD4:  MOVWF  01
4DD6:  MOVWF  02
4DD8:  BRA    4F94
....................    c = s[index++];
4DDA:  MOVF   xF6,W
4DDC:  INCF   xF6,F
4DDE:  ADDWF  xF0,W
4DE0:  MOVWF  FE9
4DE2:  MOVLW  00
4DE4:  ADDWFC xF1,W
4DE6:  MOVWF  FEA
4DE8:  MOVFF  FEF,2F7
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
4DEC:  MOVF   xF7,W
4DEE:  SUBLW  2D
4DF0:  BNZ   4E0A
....................    {
....................       sign = 1;         // Set the sign to negative
4DF2:  MOVLW  01
4DF4:  MOVWF  xF4
....................       c = s[index++];
4DF6:  MOVF   xF6,W
4DF8:  INCF   xF6,F
4DFA:  ADDWF  xF0,W
4DFC:  MOVWF  FE9
4DFE:  MOVLW  00
4E00:  ADDWFC xF1,W
4E02:  MOVWF  FEA
4E04:  MOVFF  FEF,2F7
....................    }
4E08:  BRA    4E22
....................    else if (c == '+')
4E0A:  MOVF   xF7,W
4E0C:  SUBLW  2B
4E0E:  BNZ   4E22
....................    {
....................       c = s[index++];
4E10:  MOVF   xF6,W
4E12:  INCF   xF6,F
4E14:  ADDWF  xF0,W
4E16:  MOVWF  FE9
4E18:  MOVLW  00
4E1A:  ADDWFC xF1,W
4E1C:  MOVWF  FEA
4E1E:  MOVFF  FEF,2F7
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
4E22:  MOVF   xF7,W
4E24:  SUBLW  2F
4E26:  BTFSC  FD8.0
4E28:  BRA    4F78
4E2A:  MOVF   xF7,W
4E2C:  SUBLW  39
4E2E:  BTFSS  FD8.0
4E30:  BRA    4F78
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
4E32:  MOVF   xF7,W
4E34:  SUBLW  30
4E36:  BNZ   4E74
4E38:  MOVF   xF6,W
4E3A:  ADDWF  xF0,W
4E3C:  MOVWF  FE9
4E3E:  MOVLW  00
4E40:  ADDWFC xF1,W
4E42:  MOVWF  FEA
4E44:  MOVF   FEF,W
4E46:  SUBLW  78
4E48:  BZ    4E5C
4E4A:  MOVF   xF6,W
4E4C:  ADDWF  xF0,W
4E4E:  MOVWF  FE9
4E50:  MOVLW  00
4E52:  ADDWFC xF1,W
4E54:  MOVWF  FEA
4E56:  MOVF   FEF,W
4E58:  SUBLW  58
4E5A:  BNZ   4E74
....................       {
....................          base = 16;
4E5C:  MOVLW  10
4E5E:  MOVWF  xF5
....................          index++;
4E60:  INCF   xF6,F
....................          c = s[index++];
4E62:  MOVF   xF6,W
4E64:  INCF   xF6,F
4E66:  ADDWF  xF0,W
4E68:  MOVWF  FE9
4E6A:  MOVLW  00
4E6C:  ADDWFC xF1,W
4E6E:  MOVWF  FEA
4E70:  MOVFF  FEF,2F7
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
4E74:  MOVF   xF5,W
4E76:  SUBLW  0A
4E78:  BNZ   4EBE
....................       {
....................          while (c >= '0' && c <= '9')
4E7A:  MOVF   xF7,W
4E7C:  SUBLW  2F
4E7E:  BC    4EBC
4E80:  MOVF   xF7,W
4E82:  SUBLW  39
4E84:  BNC   4EBC
....................          {
....................             result = 10*result + (c - '0');
4E86:  CLRF   xF9
4E88:  MOVLW  0A
4E8A:  MOVWF  xF8
4E8C:  MOVFF  2F3,2FB
4E90:  MOVFF  2F2,2FA
4E94:  MOVLB  0
4E96:  BRA    4D68
4E98:  MOVLW  30
4E9A:  MOVLB  2
4E9C:  SUBWF  xF7,W
4E9E:  ADDWF  01,W
4EA0:  MOVWF  xF2
4EA2:  MOVLW  00
4EA4:  ADDWFC 02,W
4EA6:  MOVWF  xF3
....................             c = s[index++];
4EA8:  MOVF   xF6,W
4EAA:  INCF   xF6,F
4EAC:  ADDWF  xF0,W
4EAE:  MOVWF  FE9
4EB0:  MOVLW  00
4EB2:  ADDWFC xF1,W
4EB4:  MOVWF  FEA
4EB6:  MOVFF  FEF,2F7
4EBA:  BRA    4E7A
....................          }
....................       }
4EBC:  BRA    4F78
....................       else if (base == 16)    // The number is a hexa number
4EBE:  MOVF   xF5,W
4EC0:  SUBLW  10
4EC2:  BNZ   4F78
....................       {
....................          c = toupper(c);
4EC4:  MOVF   xF7,W
4EC6:  SUBLW  60
4EC8:  BC    4ED6
4ECA:  MOVF   xF7,W
4ECC:  SUBLW  7A
4ECE:  BNC   4ED6
4ED0:  MOVF   xF7,W
4ED2:  ANDLW  DF
4ED4:  BRA    4ED8
4ED6:  MOVF   xF7,W
4ED8:  MOVWF  xF7
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
4EDA:  MOVF   xF7,W
4EDC:  SUBLW  2F
4EDE:  BC    4EE6
4EE0:  MOVF   xF7,W
4EE2:  SUBLW  39
4EE4:  BC    4EF2
4EE6:  MOVF   xF7,W
4EE8:  SUBLW  40
4EEA:  BC    4F78
4EEC:  MOVF   xF7,W
4EEE:  SUBLW  46
4EF0:  BNC   4F78
....................          {
....................             if (c >= '0' && c <= '9')
4EF2:  MOVF   xF7,W
4EF4:  SUBLW  2F
4EF6:  BC    4F26
4EF8:  MOVF   xF7,W
4EFA:  SUBLW  39
4EFC:  BNC   4F26
....................                result = (result << 4) + (c - '0');
4EFE:  RLCF   xF2,W
4F00:  MOVWF  xF8
4F02:  RLCF   xF3,W
4F04:  MOVWF  xF9
4F06:  RLCF   xF8,F
4F08:  RLCF   xF9,F
4F0A:  RLCF   xF8,F
4F0C:  RLCF   xF9,F
4F0E:  RLCF   xF8,F
4F10:  RLCF   xF9,F
4F12:  MOVLW  F0
4F14:  ANDWF  xF8,F
4F16:  MOVLW  30
4F18:  SUBWF  xF7,W
4F1A:  ADDWF  xF8,W
4F1C:  MOVWF  xF2
4F1E:  MOVLW  00
4F20:  ADDWFC xF9,W
4F22:  MOVWF  xF3
4F24:  BRA    4F4E
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
4F26:  RLCF   xF2,W
4F28:  MOVWF  xF8
4F2A:  RLCF   xF3,W
4F2C:  MOVWF  xF9
4F2E:  RLCF   xF8,F
4F30:  RLCF   xF9,F
4F32:  RLCF   xF8,F
4F34:  RLCF   xF9,F
4F36:  RLCF   xF8,F
4F38:  RLCF   xF9,F
4F3A:  MOVLW  F0
4F3C:  ANDWF  xF8,F
4F3E:  MOVLW  41
4F40:  SUBWF  xF7,W
4F42:  ADDLW  0A
4F44:  ADDWF  xF8,W
4F46:  MOVWF  xF2
4F48:  MOVLW  00
4F4A:  ADDWFC xF9,W
4F4C:  MOVWF  xF3
.................... 
....................             c = s[index++];c = toupper(c);
4F4E:  MOVF   xF6,W
4F50:  INCF   xF6,F
4F52:  ADDWF  xF0,W
4F54:  MOVWF  FE9
4F56:  MOVLW  00
4F58:  ADDWFC xF1,W
4F5A:  MOVWF  FEA
4F5C:  MOVFF  FEF,2F7
4F60:  MOVF   xF7,W
4F62:  SUBLW  60
4F64:  BC    4F72
4F66:  MOVF   xF7,W
4F68:  SUBLW  7A
4F6A:  BNC   4F72
4F6C:  MOVF   xF7,W
4F6E:  ANDLW  DF
4F70:  BRA    4F74
4F72:  MOVF   xF7,W
4F74:  MOVWF  xF7
4F76:  BRA    4EDA
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
4F78:  MOVF   xF5,W
4F7A:  SUBLW  0A
4F7C:  BNZ   4F8C
4F7E:  DECFSZ xF4,W
4F80:  BRA    4F8C
....................       result = -result;
4F82:  COMF   xF2,F
4F84:  COMF   xF3,F
4F86:  INCF   xF2,F
4F88:  BTFSC  FD8.2
4F8A:  INCF   xF3,F
.................... 
....................    return(result);
4F8C:  MOVFF  2F2,01
4F90:  MOVFF  2F3,02
4F94:  MOVLB  0
4F96:  GOTO   64EE (RETURN)
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
41FE:  MOVLB  3
4200:  CLRF   x16
4202:  CLRF   x15
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
4204:  MOVLW  30
4206:  MOVWF  x18
4208:  MOVLW  31
420A:  MOVWF  x19
420C:  MOVLW  32
420E:  MOVWF  x1A
4210:  MOVLW  33
4212:  MOVWF  x1B
4214:  MOVLW  34
4216:  MOVWF  x1C
4218:  MOVLW  35
421A:  MOVWF  x1D
421C:  MOVLW  36
421E:  MOVWF  x1E
4220:  MOVLW  37
4222:  MOVWF  x1F
4224:  MOVLW  38
4226:  MOVWF  x20
4228:  MOVLW  39
422A:  MOVWF  x21
422C:  MOVLW  61
422E:  MOVWF  x22
4230:  MOVLW  62
4232:  MOVWF  x23
4234:  MOVLW  63
4236:  MOVWF  x24
4238:  MOVLW  64
423A:  MOVWF  x25
423C:  MOVLW  65
423E:  MOVWF  x26
4240:  MOVLW  66
4242:  MOVWF  x27
4244:  MOVLW  67
4246:  MOVWF  x28
4248:  MOVLW  68
424A:  MOVWF  x29
424C:  MOVLW  69
424E:  MOVWF  x2A
4250:  MOVLW  6A
4252:  MOVWF  x2B
4254:  MOVLW  6B
4256:  MOVWF  x2C
4258:  MOVLW  6C
425A:  MOVWF  x2D
425C:  MOVLW  6D
425E:  MOVWF  x2E
4260:  MOVLW  6E
4262:  MOVWF  x2F
4264:  MOVLW  6F
4266:  MOVWF  x30
4268:  MOVLW  70
426A:  MOVWF  x31
426C:  MOVLW  71
426E:  MOVWF  x32
4270:  MOVLW  73
4272:  MOVWF  x33
4274:  MOVLW  74
4276:  MOVWF  x34
4278:  MOVLW  75
427A:  MOVWF  x35
427C:  MOVLW  76
427E:  MOVWF  x36
4280:  MOVLW  77
4282:  MOVWF  x37
4284:  MOVLW  78
4286:  MOVWF  x38
4288:  MOVLW  79
428A:  MOVWF  x39
428C:  MOVLW  7A
428E:  MOVWF  x3A
4290:  CLRF   x3B
....................    for(sc=s;isspace(*sc);++sc);
4292:  MOVFF  30B,310
4296:  MOVFF  30A,30F
429A:  MOVFF  310,FEA
429E:  MOVFF  30F,FE9
42A2:  MOVF   FEF,W
42A4:  SUBLW  20
42A6:  BNZ   42B0
42A8:  INCF   x0F,F
42AA:  BTFSC  FD8.2
42AC:  INCF   x10,F
42AE:  BRA    429A
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
42B0:  MOVFF  310,03
42B4:  MOVFF  30F,FE9
42B8:  MOVFF  03,FEA
42BC:  MOVF   FEF,W
42BE:  SUBLW  2D
42C0:  BZ    42D0
42C2:  MOVFF  310,FEA
42C6:  MOVFF  30F,FE9
42CA:  MOVF   FEF,W
42CC:  SUBLW  2B
42CE:  BNZ   42E2
42D0:  MOVFF  310,FEA
42D4:  MOVF   x0F,W
42D6:  INCF   x0F,F
42D8:  BTFSC  FD8.2
42DA:  INCF   x10,F
42DC:  MOVWF  FE9
42DE:  MOVF   FEF,W
42E0:  BRA    42E4
42E2:  MOVLW  2B
42E4:  MOVWF  x17
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
42E6:  MOVF   x17,W
42E8:  SUBLW  2D
42EA:  BZ    4328
42EC:  CLRF   03
42EE:  MOVF   x0E,W
42F0:  MOVWF  00
42F2:  BTFSC  FE8.7
42F4:  DECF   03,F
42F6:  MOVWF  01
42F8:  BTFSC  03.7
42FA:  BRA    4328
42FC:  CLRF   03
42FE:  MOVF   x0E,W
4300:  MOVWF  00
4302:  BTFSC  FE8.7
4304:  DECF   03,F
4306:  SUBLW  01
4308:  BNZ   430E
430A:  MOVF   03,F
430C:  BZ    4328
430E:  CLRF   03
4310:  MOVF   x0E,W
4312:  MOVWF  00
4314:  BTFSC  FE8.7
4316:  DECF   03,F
4318:  MOVWF  01
431A:  BTFSC  03.7
431C:  BRA    432C
431E:  MOVF   03,F
4320:  BNZ   4328
4322:  MOVF   01,W
4324:  SUBLW  24
4326:  BC    432C
....................    goto StrtoulGO;
4328:  BRA    4598
432A:  BRA    4448
.................... 
....................    else if (base)
432C:  MOVF   x0E,F
432E:  BZ    43E0
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
4330:  CLRF   03
4332:  MOVF   x0E,W
4334:  MOVWF  00
4336:  BTFSC  FE8.7
4338:  DECF   03,F
433A:  SUBLW  10
433C:  BNZ   437C
433E:  MOVF   03,F
4340:  BNZ   437C
4342:  MOVFF  310,FEA
4346:  MOVFF  30F,FE9
434A:  MOVF   FEF,W
434C:  SUBLW  30
434E:  BNZ   437C
4350:  MOVLW  01
4352:  ADDWF  x0F,W
4354:  MOVWF  FE9
4356:  MOVLW  00
4358:  ADDWFC x10,W
435A:  MOVWF  FEA
435C:  MOVF   FEF,W
435E:  SUBLW  78
4360:  BZ    4374
4362:  MOVLW  01
4364:  ADDWF  x0F,W
4366:  MOVWF  FE9
4368:  MOVLW  00
436A:  ADDWFC x10,W
436C:  MOVWF  FEA
436E:  MOVF   FEF,W
4370:  SUBLW  58
4372:  BNZ   437C
....................          sc+=2;
4374:  MOVLW  02
4376:  ADDWF  x0F,F
4378:  MOVLW  00
437A:  ADDWFC x10,F
....................       if(base==8 && *sc =='0')
437C:  CLRF   03
437E:  MOVF   x0E,W
4380:  MOVWF  00
4382:  BTFSC  FE8.7
4384:  DECF   03,F
4386:  SUBLW  08
4388:  BNZ   43A4
438A:  MOVF   03,F
438C:  BNZ   43A4
438E:  MOVFF  310,FEA
4392:  MOVFF  30F,FE9
4396:  MOVF   FEF,W
4398:  SUBLW  30
439A:  BNZ   43A4
....................          sc+=1;
439C:  MOVLW  01
439E:  ADDWF  x0F,F
43A0:  MOVLW  00
43A2:  ADDWFC x10,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
43A4:  CLRF   03
43A6:  MOVF   x0E,W
43A8:  MOVWF  00
43AA:  BTFSC  FE8.7
43AC:  DECF   03,F
43AE:  SUBLW  02
43B0:  BNZ   43DE
43B2:  MOVF   03,F
43B4:  BNZ   43DE
43B6:  MOVFF  310,FEA
43BA:  MOVFF  30F,FE9
43BE:  MOVF   FEF,W
43C0:  SUBLW  30
43C2:  BNZ   43DE
43C4:  MOVLW  01
43C6:  ADDWF  x0F,W
43C8:  MOVWF  FE9
43CA:  MOVLW  00
43CC:  ADDWFC x10,W
43CE:  MOVWF  FEA
43D0:  MOVF   FEF,W
43D2:  SUBLW  62
43D4:  BNZ   43DE
....................          sc+=2;
43D6:  MOVLW  02
43D8:  ADDWF  x0F,F
43DA:  MOVLW  00
43DC:  ADDWFC x10,F
.................... 
....................    }
43DE:  BRA    4448
....................    else if(*sc!='0') // base is 0, find base
43E0:  MOVFF  310,FEA
43E4:  MOVFF  30F,FE9
43E8:  MOVF   FEF,W
43EA:  SUBLW  30
43EC:  BZ    43F4
....................       base=10;
43EE:  MOVLW  0A
43F0:  MOVWF  x0E
43F2:  BRA    4448
....................    else if (sc[1]=='x' || sc[1]=='X')
43F4:  MOVLW  01
43F6:  ADDWF  x0F,W
43F8:  MOVWF  FE9
43FA:  MOVLW  00
43FC:  ADDWFC x10,W
43FE:  MOVWF  FEA
4400:  MOVF   FEF,W
4402:  SUBLW  78
4404:  BZ    4418
4406:  MOVLW  01
4408:  ADDWF  x0F,W
440A:  MOVWF  FE9
440C:  MOVLW  00
440E:  ADDWFC x10,W
4410:  MOVWF  FEA
4412:  MOVF   FEF,W
4414:  SUBLW  58
4416:  BNZ   4426
....................       base =16,sc+=2;
4418:  MOVLW  10
441A:  MOVWF  x0E
441C:  MOVLW  02
441E:  ADDWF  x0F,F
4420:  MOVLW  00
4422:  ADDWFC x10,F
4424:  BRA    4448
....................    else if(sc[1]=='b')
4426:  MOVLW  01
4428:  ADDWF  x0F,W
442A:  MOVWF  FE9
442C:  MOVLW  00
442E:  ADDWFC x10,W
4430:  MOVWF  FEA
4432:  MOVF   FEF,W
4434:  SUBLW  62
4436:  BNZ   4444
....................       base=2,sc+=2;
4438:  MOVLW  02
443A:  MOVWF  x0E
443C:  ADDWF  x0F,F
443E:  MOVLW  00
4440:  ADDWFC x10,F
4442:  BRA    4448
....................    else
....................       base=8;
4444:  MOVLW  08
4446:  MOVWF  x0E
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
4448:  MOVFF  310,312
444C:  MOVFF  30F,311
4450:  MOVFF  310,FEA
4454:  MOVFF  30F,FE9
4458:  MOVF   FEF,W
445A:  SUBLW  30
445C:  BNZ   4466
445E:  INCF   x0F,F
4460:  BTFSC  FD8.2
4462:  INCF   x10,F
4464:  BRA    4450
....................    sd=memchr(digits,tolower(*sc),base);
4466:  MOVFF  310,03
446A:  MOVFF  30F,FE9
446E:  MOVFF  03,FEA
4472:  MOVFF  FEF,33C
4476:  MOVF   x3C,W
4478:  SUBLW  40
447A:  BC    4488
447C:  MOVF   x3C,W
447E:  SUBLW  5A
4480:  BNC   4488
4482:  MOVF   x3C,W
4484:  IORLW  20
4486:  BRA    448A
4488:  MOVF   x3C,W
448A:  MOVWF  x3C
448C:  MOVLW  03
448E:  MOVWF  x3E
4490:  MOVLW  18
4492:  MOVWF  x3D
4494:  MOVFF  33C,33F
4498:  CLRF   x41
449A:  MOVFF  30E,340
449E:  BTFSC  x40.7
44A0:  DECF   x41,F
44A2:  MOVLB  0
44A4:  RCALL  41B4
44A6:  MOVFF  02,314
44AA:  MOVFF  01,313
....................    for(; sd!=0; )
44AE:  MOVLB  3
44B0:  MOVF   x13,F
44B2:  BNZ   44B8
44B4:  MOVF   x14,F
44B6:  BZ    458C
....................    {
....................       x=x*base+(int16)(sd-digits);
44B8:  CLRF   03
44BA:  MOVF   x0E,W
44BC:  BTFSC  FE8.7
44BE:  DECF   03,F
44C0:  MOVWF  00
44C2:  MOVFF  03,01
44C6:  CLRF   02
44C8:  CLRF   03
44CA:  BTFSS  01.7
44CC:  BRA    44D2
44CE:  DECF   02,F
44D0:  DECF   03,F
44D2:  MOVFF  03,33F
44D6:  MOVFF  02,33E
44DA:  MOVFF  01,33D
44DE:  MOVFF  00,33C
44E2:  CLRF   x43
44E4:  CLRF   x42
44E6:  MOVFF  316,341
44EA:  MOVFF  315,340
44EE:  MOVFF  03,347
44F2:  MOVFF  02,346
44F6:  MOVFF  01,345
44FA:  MOVFF  00,344
44FE:  MOVLB  0
4500:  CALL   0CC8
4504:  MOVFF  03,33F
4508:  MOVFF  02,33E
450C:  MOVFF  01,33D
4510:  MOVFF  00,33C
4514:  MOVLW  18
4516:  MOVLB  3
4518:  SUBWF  x13,W
451A:  MOVWF  00
451C:  MOVLW  03
451E:  SUBWFB x14,W
4520:  MOVWF  03
4522:  MOVF   00,W
4524:  ADDWF  x3C,W
4526:  MOVWF  00
4528:  MOVF   03,W
452A:  ADDWFC 01,W
452C:  MOVWF  01
452E:  MOVLW  00
4530:  ADDWFC 02,W
4532:  MOVLW  00
4534:  ADDWFC x3F,W
4536:  MOVFF  01,316
453A:  MOVFF  00,315
....................       ++sc;
453E:  INCF   x0F,F
4540:  BTFSC  FD8.2
4542:  INCF   x10,F
....................       sd=memchr(digits,tolower(*sc),base);
4544:  MOVFF  310,FEA
4548:  MOVFF  30F,FE9
454C:  MOVFF  FEF,33C
4550:  MOVF   x3C,W
4552:  SUBLW  40
4554:  BC    4562
4556:  MOVF   x3C,W
4558:  SUBLW  5A
455A:  BNC   4562
455C:  MOVF   x3C,W
455E:  IORLW  20
4560:  BRA    4564
4562:  MOVF   x3C,W
4564:  MOVWF  x3C
4566:  MOVLW  03
4568:  MOVWF  x3E
456A:  MOVLW  18
456C:  MOVWF  x3D
456E:  MOVFF  33C,33F
4572:  CLRF   x41
4574:  MOVFF  30E,340
4578:  BTFSC  x40.7
457A:  DECF   x41,F
457C:  MOVLB  0
457E:  RCALL  41B4
4580:  MOVFF  02,314
4584:  MOVFF  01,313
4588:  BRA    44AE
458A:  MOVLB  3
....................    }
....................    if(s1==sc)
458C:  MOVF   x0F,W
458E:  SUBWF  x11,W
4590:  BNZ   45BA
4592:  MOVF   x10,W
4594:  SUBWF  x12,W
4596:  BNZ   45BA
....................    {
....................    StrtoulGO:
....................       if (endptr)
4598:  MOVLB  3
459A:  MOVF   x0C,W
459C:  IORWF  x0D,W
459E:  BZ    45B2
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
45A0:  MOVFF  30D,FEA
45A4:  MOVFF  30C,FE9
45A8:  MOVFF  30B,FEC
45AC:  MOVF   FED,F
45AE:  MOVFF  30A,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
45B2:  MOVLW  00
45B4:  MOVWF  01
45B6:  MOVWF  02
45B8:  BRA    45DA
....................    }
....................    if (endptr)
45BA:  MOVF   x0C,W
45BC:  IORWF  x0D,W
45BE:  BZ    45D2
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
45C0:  MOVFF  30D,FEA
45C4:  MOVFF  30C,FE9
45C8:  MOVFF  310,FEC
45CC:  MOVF   FED,F
45CE:  MOVFF  30F,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
45D2:  MOVFF  315,01
45D6:  MOVFF  316,02
45DA:  MOVLB  0
45DC:  GOTO   4726 (RETURN)
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
*
0D6C:  MOVFF  51,343
0D70:  MOVFF  50,342
0D74:  MOVFF  4F,341
0D78:  MOVFF  4E,340
0D7C:  MOVLW  41
0D7E:  MOVLB  3
0D80:  MOVWF  x47
0D82:  MOVLW  C6
0D84:  MOVWF  x46
0D86:  MOVLW  4E
0D88:  MOVWF  x45
0D8A:  MOVLW  6D
0D8C:  MOVWF  x44
0D8E:  MOVLB  0
0D90:  RCALL  0CC8
0D92:  MOVLW  39
0D94:  MOVLB  2
0D96:  ADDWF  00,W
0D98:  MOVWF  4E
0D9A:  MOVLW  30
0D9C:  ADDWFC 01,W
0D9E:  MOVWF  4F
0DA0:  MOVLW  00
0DA2:  ADDWFC 02,W
0DA4:  MOVWF  50
0DA6:  MOVLW  00
0DA8:  ADDWFC 03,W
0DAA:  MOVWF  51
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
0DAC:  MOVFF  50,00
0DB0:  MOVFF  51,01
0DB4:  CLRF   02
0DB6:  CLRF   03
0DB8:  MOVFF  51,2E5
0DBC:  MOVFF  50,2E4
0DC0:  MOVFF  51,2E7
0DC4:  MOVFF  50,2E6
0DC8:  MOVLW  7F
0DCA:  MOVWF  xE9
0DCC:  SETF   xE8
0DCE:  MOVLB  0
0DD0:  BRA    0D24
0DD2:  MOVFF  00,01
0DD6:  MOVFF  03,02
0DDA:  GOTO   0EEA (RETURN)
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
*
0CB4:  MOVFF  2E6,51
0CB8:  MOVFF  2E5,50
0CBC:  MOVFF  2E4,4F
0CC0:  MOVFF  2E3,4E
0CC4:  GOTO   0EE8 (RETURN)
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.c"
.................... /*********************************************************************
....................  *
....................  *                  Helper Functions for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.C
....................  * Dependencies:    compiler.h
....................  *                  helpers.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid
....................  *                               multi-byte shift operation.
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and
....................  *                        btohexa_low()
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... /*********************************************************************
....................  *
....................  *            ENC28J60 registers/bits
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.h
....................  * Description: 	Include file for ENC28J60 control registers
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder		06/01/04	Original
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a 
....................  *									couple of PHY register structs.
....................  * Howard Schlunder		09/29/04	Matched with data sheet
....................  * Howard Schlunder		01/04/06	Matched with new data sheet
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN
....................  * Howard Schlunder		07/21/06	Several bits removed to match now 
....................  *									reserved bits in rev. B data sheet 
....................  *									(DS39662B)
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef ENC28J60_H
.................... #define ENC28J60_H
.................... 
.................... typedef union {
.................... 	BYTE v[7];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 CollisionCount:4;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 Done:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 PacketDefer:1;
.................... 		int8 ExcessiveDefer:1;
.................... 		int8 MaximumCollisions:1;
.................... 		int8 LateCollision:1;
.................... 		int8 Giant:1;
.................... 		int8 Underrun:1;
.................... 		int16 	 BytesTransmittedOnWire;
.................... 		int8 ControlFrame:1;
.................... 		int8 PAUSEControlFrame:1;
.................... 		int8 BackpressureApplied:1;
.................... 		int8 VLANTaggedFrame:1;
.................... 		int8 Zeros:4;
.................... 	} bits;
.................... } TXSTATUS;
.................... 
.................... typedef union {
.................... 	char v[4];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 PreviouslyIgnored:1;
.................... 		int8 RXDCPreviouslySeen:1;
.................... 		int8 CarrierPreviouslySeen:1;
.................... 		int8 CodeViolation:1;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 ReceiveOk:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 DribbleNibble:1;
.................... 		int8 ControlFrame:1;
.................... 		int8 PauseControlFrame:1;
.................... 		int8 UnsupportedOpcode:1;
.................... 		int8 VLANType:1;
.................... 		int8 Zero:1;
.................... 	} bits;
.................... } RXSTATUS;
.................... 
.................... /******************************************************************************
.................... * Register locations
.................... ******************************************************************************/
.................... // Bank 0 registers --------
.................... #define ERDPTL		0x00
.................... #define ERDPTH		0x01
.................... #define EWRPTL		0x02
.................... #define EWRPTH		0x03
.................... #define ETXSTL		0x04
.................... #define ETXSTH		0x05
.................... #define ETXNDL		0x06
.................... #define ETXNDH		0x07
.................... #define ERXSTL		0x08
.................... #define ERXSTH		0x09
.................... #define ERXNDL		0x0A
.................... #define ERXNDH		0x0B
.................... #define ERXRDPTL	0x0C
.................... #define ERXRDPTH	0x0D
.................... #define ERXWRPTL	0x0E
.................... #define ERXWRPTH	0x0F
.................... #define EDMASTL		0x10
.................... #define EDMASTH		0x11
.................... #define EDMANDL		0x12
.................... #define EDMANDH		0x13
.................... #define EDMADSTL	0x14
.................... #define EDMADSTH	0x15
.................... #define EDMACSL		0x16
.................... #define EDMACSH		0x17
.................... //#define			0x18
.................... //#define			0x19
.................... //#define r			0x1A
.................... #define EIE			0x1B
.................... #define EIR			0x1C
.................... #define ESTAT		0x1D
.................... #define ECON2		0x1E
.................... #define ECON1		0x1F
.................... 
.................... // Bank 1 registers -----
.................... #define EHT0		0x100
.................... #define EHT1		0x101
.................... #define EHT2		0x102
.................... #define EHT3		0x103
.................... #define EHT4		0x104
.................... #define EHT5		0x105
.................... #define EHT6		0x106
.................... #define EHT7		0x107
.................... #define EPMM0		0x108
.................... #define EPMM1		0x109
.................... #define EPMM2		0x10A
.................... #define EPMM3		0x10B
.................... #define EPMM4		0x10C
.................... #define EPMM5		0x10D
.................... #define EPMM6		0x10E
.................... #define EPMM7		0x10F
.................... #define EPMCSL		0x110
.................... #define EPMCSH		0x111
.................... //#define			0x112
.................... //#define			0x113
.................... #define EPMOL		0x114
.................... #define EPMOH		0x115
.................... //#define r			0x116
.................... //#define r			0x117
.................... #define ERXFCON		0x118
.................... #define EPKTCNT		0x119
.................... //#define r			0x11A
.................... //#define EIE		0x11B
.................... //#define EIR		0x11C
.................... //#define ESTAT		0x11D
.................... //#define ECON2		0x11E
.................... //#define ECON1		0x11F
.................... 
.................... // Bank 2 registers -----
.................... #define MACON1		0x200
.................... #define MACON2    0x201
.................... //#define r			0x201
.................... #define MACON3		0x202
.................... #define MACON4		0x203
.................... #define MABBIPG		0x204
.................... //#define			0x205
.................... #define MAIPGL		0x206
.................... #define MAIPGH		0x207
.................... #define MACLCON1	0x208
.................... #define MACLCON2	0x209
.................... #define MAMXFLL		0x20A
.................... #define MAMXFLH		0x20B
.................... //#define r			0x20C
.................... //#define r			0x20D
.................... //#define r			0x20E
.................... //#define			0x20F
.................... //#define r			0x210
.................... //#define r			0x211
.................... #define MICMD		0x212
.................... //#define r			0x213
.................... #define MIREGADR	0x214
.................... //#define r			0x215
.................... #define MIWRL		0x216
.................... #define MIWRH		0x217
.................... #define MIRDL		0x218
.................... #define MIRDH		0x219
.................... //#define r			0x21A
.................... //#define EIE		0x21B
.................... //#define EIR		0x21C
.................... //#define ESTAT		0x21D
.................... //#define ECON2		0x21E
.................... //#define ECON1		0x21F
.................... 
.................... // Bank 3 registers -----
.................... #define MAADR5		0x300
.................... #define MAADR6		0x301
.................... #define MAADR3		0x302
.................... #define MAADR4		0x303
.................... #define MAADR1		0x304
.................... #define MAADR2		0x305
.................... #define EBSTSD		0x306
.................... #define EBSTCON		0x307
.................... #define EBSTCSL		0x308
.................... #define EBSTCSH		0x309
.................... #define MISTAT		0x30A
.................... //#define			0x30B
.................... //#define			0x30C
.................... //#define			0x30D
.................... //#define			0x30E
.................... //#define			0x30F
.................... //#define			0x310
.................... //#define			0x311
.................... #define EREVID		0x312
.................... //#define			0x313
.................... //#define			0x314
.................... #define ECOCON		0x315
.................... //#define 			0x316
.................... #define EFLOCON		0x317
.................... #define EPAUSL		0x318
.................... #define EPAUSH		0x319
.................... //#define r			0x31A
.................... //#define EIE		0x31B
.................... //#define EIR		0x31C
.................... //#define ESTAT		0x31D
.................... //#define ECON2		0x31E
.................... //#define ECON1		0x31F
.................... 
.................... 
.................... 
.................... // Structures
.................... typedef union _REG
.................... {
.................... 	char Val;
.................... 
.................... 	// EIE bits ----------
.................... 	struct {
.................... 		unsigned char RXERIE:1;
.................... 		unsigned char TXERIE:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIE:1;
.................... 		unsigned char LINKIE:1;
.................... 		unsigned char DMAIE:1;
.................... 		unsigned char PKTIE:1;
.................... 		unsigned char INTIE:1;
.................... 	} EIEbits;
.................... 
.................... 	// EIR bits ----------
.................... 	struct {
.................... 		unsigned char RXERIF:1;
.................... 		unsigned char TXERIF:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIF:1;
.................... 		unsigned char LINKIF:1;
.................... 		unsigned char DMAIF:1;
.................... 		unsigned char PKTIF:1;
.................... 		unsigned char blank1:1;
.................... 	} EIRbits;
.................... 
.................... 	// ESTAT bits ---------
.................... 	struct {
.................... 		unsigned char CLKRDY:1;
.................... 		unsigned char TXABRT:1;
.................... 		unsigned char RXBUSY:1;
.................... 		unsigned char blank1:1;
.................... 		unsigned char LATECOL:1;
.................... 		unsigned char blank2:2;
.................... 		unsigned char INTR:1;
.................... 	} ESTATbits;
.................... 
.................... 	// ECON2 bits --------
.................... 	struct {
.................... 		unsigned char blank3:3;
.................... 		unsigned char VRPS:1;
.................... 		unsigned char VRTP:1;
.................... 		unsigned char PWRSV:1;
.................... 		unsigned char PKTDEC:1;
.................... 		unsigned char AUTOINC:1;
.................... 	} ECON2bits;
.................... 
.................... 	// ECON1 bits --------
.................... 	struct {
.................... 		unsigned char BSEL0:1;
.................... 		unsigned char BSEL1:1;
.................... 		unsigned char RXEN:1;
.................... 		unsigned char TXRTS:1;
.................... 		unsigned char CSUMEN:1;
.................... 		unsigned char DMAST:1;
.................... 		unsigned char RXRST:1;
.................... 		unsigned char TXRST:1;
.................... 	} ECON1bits;
.................... 
.................... 	// ERXFCON bits ------
.................... 	struct {
.................... 		unsigned char BCEN:1;
.................... 		unsigned char MCEN:1;
.................... 		unsigned char HTEN:1;
.................... 		unsigned char MPEN:1;
.................... 		unsigned char PMEN:1;
.................... 		unsigned char CRCEN:1;
.................... 		unsigned char ANDOR:1;
.................... 		unsigned char UCEN:1;
.................... 	} ERXFCONbits;
.................... 
.................... 	// MACON1 bits --------
.................... 	struct {
.................... 		unsigned char MARXEN:1;
.................... 		unsigned char PASSALL:1;
.................... 		unsigned char RXPAUS:1;
.................... 		unsigned char TXPAUS:1;
.................... 		unsigned char :4;
.................... 	} MACON1bits;
.................... 
.................... 
.................... 	// MACON3 bits --------
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG0:1;
.................... 		unsigned char PADCFG1:1;
.................... 		unsigned char PADCFG2:1;
.................... 	} MACON3bits;
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG:3;
.................... 	} MACON3bits2;
.................... 
.................... 	// MACON4 bits --------
.................... 	struct {
.................... 		unsigned char :4;
.................... 		unsigned char NOBKOFF:1;
.................... 		unsigned char BPEN:1;
.................... 		unsigned char DEFER:1;
.................... 		unsigned char blank1:1;
.................... 	} MACON4bits;
.................... 
.................... 	// MICMD bits ---------
.................... 	struct {
.................... 		unsigned char MIIRD:1;
.................... 		unsigned char MIISCAN:1;
.................... 		unsigned char blank6:6;
.................... 	} MICMDbits;
.................... 
.................... 	// EBSTCON bits -----
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL0:1;
.................... 		unsigned char TMSEL1:1;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV0:1;
.................... 		unsigned char PSV1:1;
.................... 		unsigned char PSV2:1;
.................... 	} EBSTCONbits;
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL:2;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV:3;
.................... 	} EBSTCONbits2;
.................... 
.................... 	// MISTAT bits --------
.................... 	struct {
.................... 		unsigned char BUSY:1;
.................... 		unsigned char SCAN:1;
.................... 		unsigned char NVALID:1;
.................... 		unsigned char blank5:5;
.................... 	} MISTATbits;
.................... 
.................... 	// ECOCON bits -------
.................... 	struct {
.................... 		unsigned char COCON0:1;
.................... 		unsigned char COCON1:1;
.................... 		unsigned char COCON2:1;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits;
.................... 	struct {
.................... 		unsigned char COCON:3;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits2;
.................... 
.................... 	// EFLOCON bits -----
.................... 	struct {
.................... 		unsigned char FCEN0:1;
.................... 		unsigned char FCEN1:1;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits;
.................... 	struct {
.................... 		unsigned char FCEN:2;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits2;
.................... } REG;
.................... 
.................... 
.................... /******************************************************************************
.................... * PH Register Locations
.................... ******************************************************************************/
.................... #define PHCON1	0x00
.................... #define PHSTAT1	0x01
.................... #define PHID1	0x02
.................... #define PHID2	0x03
.................... #define PHCON2	0x10
.................... #define PHSTAT2	0x11
.................... #define PHIE	0x12
.................... #define PHIR	0x13
.................... #define PHLCON	0x14
.................... 
.................... 
.................... typedef union {
.................... 	int16 Val;
.................... 	WORD_VAL VAL;
.................... 
.................... 	// PHCON1 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 PDPXMD:1;
.................... 		int8 blank2:2;
.................... 		int8 PPWRSV:1;
.................... 		int8 blank22:2;
.................... 		int8 PLOOPBK:1;
.................... 		int8 PRST:1;
.................... 	} PHCON1bits;
.................... 
.................... 	// PHSTAT1 bits --------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 JBSTAT:1;
.................... 		int8 LLSTAT:1;
.................... 		int8 blank5:5;
.................... 		int8 blank3:3;
.................... 		int8 PHDPX:1;
.................... 		int8 PFDPX:1;
.................... 		int8 blank33:3;
.................... 	} PHSTAT1bits;
.................... 
.................... 	// PHID2 bits ----------
.................... 	struct {
.................... 		int8 PREV0:1;
.................... 		int8 PREV1:1;
.................... 		int8 PREV2:1;
.................... 		int8 PREV3:1;
.................... 		int8 PPN0:1;
.................... 		int8 PPN1:1;
.................... 		int8 PPN2:1;
.................... 		int8 PPN3:1;
.................... 		int8 PPN4:1;
.................... 		int8 PPN5:1;
.................... 		int8 PID19:1;
.................... 		int8 PID20:1;
.................... 		int8 PID21:1;
.................... 		int8 PID22:1;
.................... 		int8 PID23:1;
.................... 		int8 PID24:1;
.................... 	} PHID2bits;
.................... 	struct {
.................... 		int8 PREV:4;
.................... 		int8 PPNL:4;
.................... 		int8 PPNH:2;
.................... 		int8 PID:6;
.................... 	} PHID2bits2;
.................... 
.................... 	// PHCON2 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 HDLDIS:1;
.................... 		int8 blank1:1;
.................... 		int8 JABBER:1;
.................... 		int8 blank2:2;
.................... 		int8 TXDIS:1;
.................... 		int8 FRCLNK:1;
.................... 		int8 blank11:1;
.................... 	} PHCON2bits;
.................... 
.................... 	// PHSTAT2 bits --------
.................... 	struct {
.................... 		int8 blank5:5;
.................... 		int8 PLRITY:1;
.................... 		int8 blank2:2;
.................... 		int8 blank11:1;
.................... 		int8 DPXSTAT:1;
.................... 		int8 LSTAT:1;
.................... 		int8 COLSTAT:1;
.................... 		int8 RXSTAT:1;
.................... 		int8 TXSTAT:1;
.................... 		int8 blank22:2;
.................... 	} PHSTAT2bits;
.................... 
.................... 	// PHIE bits -----------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 PGEIE:1;
.................... 		int8 blank2:2;
.................... 		int8 PLNKIE:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIEbits;
.................... 
.................... 	// PHIR bits -----------
.................... 	struct {
.................... 		int8 blank2:2;
.................... 		int8 PGIF:1;
.................... 		int8 blank1:1;
.................... 		int8 PLNKIF:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIRbits;
.................... 
.................... 	// PHLCON bits -------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ0:1;
.................... 		int8 LFRQ1:1;
.................... 		int8 LBCFG0:1;
.................... 		int8 LBCFG1:1;
.................... 		int8 LBCFG2:1;
.................... 		int8 LBCFG3:1;
.................... 		int8 LACFG0:1;
.................... 		int8 LACFG1:1;
.................... 		int8 LACFG2:1;
.................... 		int8 LACFG3:1;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits;
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ:2;
.................... 		int8 LBCFG:4;
.................... 		int8 LACFG:4;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits2;
.................... } PHYREG;
.................... 
.................... 
.................... /******************************************************************************
.................... * Individual Register Bits
.................... ******************************************************************************/
.................... // ETH/MAC/MII bits
.................... 
.................... // EIE bits ----------
.................... #define	EIE_INTIE		(1<<7)
.................... #define	EIE_PKTIE		(1<<6)
.................... #define	EIE_DMAIE		(1<<5)
.................... #define	EIE_LINKIE		(1<<4)
.................... #define	EIE_TXIE		(1<<3)
.................... #define	EIE_TXERIE		(1<<1)
.................... #define	EIE_RXERIE		(1)
.................... 
.................... // EIR bits ----------
.................... #define	EIR_PKTIF		(1<<6)
.................... #define	EIR_DMAIF		(1<<5)
.................... #define	EIR_LINKIF		(1<<4)
.................... #define	EIR_TXIF		(1<<3)
.................... #define	EIR_TXERIF		(1<<1)
.................... #define	EIR_RXERIF		(1)
.................... 
.................... // ESTAT bits ---------
.................... #define	ESTAT_INT		(1<<7)
.................... #define ESTAT_BUFFER	(1<<6)
.................... #define	ESTAT_LATECOL	(1<<4)
.................... #define	ESTAT_RXBUSY	(1<<2)
.................... #define	ESTAT_TXABRT	(1<<1)
.................... #define	ESTAT_CLKRDY	(1)
.................... 
.................... // ECON2 bits --------
.................... #define	ECON2_AUTOINC	(1<<7)
.................... #define	ECON2_PKTDEC	(1<<6)
.................... #define	ECON2_PWRSV		(1<<5)
.................... #define	ECON2_VRPS		(1<<3)
.................... 
.................... // ECON1 bits --------
.................... #define	ECON1_TXRST		(1<<7)
.................... #define	ECON1_RXRST		(1<<6)
.................... #define	ECON1_DMAST		(1<<5)
.................... #define	ECON1_CSUMEN	(1<<4)
.................... #define	ECON1_TXRTS		(1<<3)
.................... #define	ECON1_RXEN		(1<<2)
.................... #define	ECON1_BSEL1		(1<<1)
.................... #define	ECON1_BSEL0		(1)
.................... 
.................... // ERXFCON bits ------
.................... #define	ERXFCON_UCEN	(1<<7)
.................... #define	ERXFCON_ANDOR	(1<<6)
.................... #define	ERXFCON_CRCEN	(1<<5)
.................... #define	ERXFCON_PMEN	(1<<4)
.................... #define	ERXFCON_MPEN	(1<<3)
.................... #define	ERXFCON_HTEN	(1<<2)
.................... #define	ERXFCON_MCEN	(1<<1)
.................... #define	ERXFCON_BCEN	(1)
.................... 
.................... // MACON1 bits --------
.................... #define	MACON1_TXPAUS	(1<<3)
.................... #define	MACON1_RXPAUS	(1<<2)
.................... #define	MACON1_PASSALL	(1<<1)
.................... #define	MACON1_MARXEN	(1)
.................... 
.................... // MACON3 bits --------
.................... #define	MACON3_PADCFG2	(1<<7)
.................... #define	MACON3_PADCFG1	(1<<6)
.................... #define	MACON3_PADCFG0	(1<<5)
.................... #define	MACON3_TXCRCEN	(1<<4)
.................... #define	MACON3_PHDRLEN	(1<<3)
.................... #define	MACON3_HFRMEN	(1<<2)
.................... #define	MACON3_FRMLNEN	(1<<1)
.................... #define	MACON3_FULDPX	(1)
.................... 
.................... // MACON4 bits --------
.................... #define	MACON4_DEFER	(1<<6)
.................... #define	MACON4_BPEN		(1<<5)
.................... #define	MACON4_NOBKOFF	(1<<4)
.................... 
.................... 
.................... // MICMD bits ---------
.................... #define	MICMD_MIISCAN	(1<<1)
.................... #define	MICMD_MIIRD		(1)
.................... 
.................... // EBSTCON bits -----
.................... #define	EBSTCON_PSV2	(1<<7)
.................... #define	EBSTCON_PSV1	(1<<6)
.................... #define	EBSTCON_PSV0	(1<<5)
.................... #define	EBSTCON_PSEL	(1<<4)
.................... #define	EBSTCON_TMSEL1	(1<<3)
.................... #define	EBSTCON_TMSEL0	(1<<2)
.................... #define	EBSTCON_TME		(1<<1)
.................... #define	EBSTCON_BISTST	(1)
.................... 
.................... // MISTAT bits --------
.................... #define	MISTAT_NVALID	(1<<2)
.................... #define	MISTAT_SCAN		(1<<1)
.................... #define	MISTAT_BUSY		(1)
.................... 
.................... // ECOCON bits -------
.................... #define	ECOCON_COCON2	(1<<2)
.................... #define	ECOCON_COCON1	(1<<1)
.................... #define	ECOCON_COCON0	(1)
.................... 
.................... // EFLOCON bits -----
.................... #define	EFLOCON_FULDPXS	(1<<2)
.................... #define	EFLOCON_FCEN1	(1<<1)
.................... #define	EFLOCON_FCEN0	(1)
.................... 
.................... 
.................... 
.................... // PHY bits
.................... 
.................... // PHCON1 bits ----------
.................... #define	PHCON1_PRST		(1ul<<15)
.................... #define	PHCON1_PLOOPBK	(1ul<<14)
.................... #define	PHCON1_PPWRSV	(1ul<<11)
.................... #define	PHCON1_PDPXMD	(1ul<<8)
.................... 
.................... // PHSTAT1 bits --------
.................... #define	PHSTAT1_PFDPX	(1ul<<12)
.................... #define	PHSTAT1_PHDPX	(1ul<<11)
.................... #define	PHSTAT1_LLSTAT	(1ul<<2)
.................... #define	PHSTAT1_JBSTAT	(1ul<<1)
.................... 
.................... // PHID2 bits --------
.................... #define	PHID2_PID24		(1ul<<15)
.................... #define	PHID2_PID23		(1ul<<14)
.................... #define	PHID2_PID22		(1ul<<13)
.................... #define	PHID2_PID21		(1ul<<12)
.................... #define	PHID2_PID20		(1ul<<11)
.................... #define	PHID2_PID19		(1ul<<10)
.................... #define	PHID2_PPN5		(1ul<<9)
.................... #define	PHID2_PPN4		(1ul<<8)
.................... #define	PHID2_PPN3		(1ul<<7)
.................... #define	PHID2_PPN2		(1ul<<6)
.................... #define	PHID2_PPN1		(1ul<<5)
.................... #define	PHID2_PPN0		(1ul<<4)
.................... #define	PHID2_PREV3		(1ul<<3)
.................... #define	PHID2_PREV2		(1ul<<2)
.................... #define	PHID2_PREV1		(1ul<<1)
.................... #define	PHID2_PREV0		(1ul)
.................... 
.................... // PHCON2 bits ----------
.................... #define	PHCON2_FRCLNK	(1ul<<14)
.................... #define	PHCON2_TXDIS	(1ul<<13)
.................... #define	PHCON2_JABBER	(1ul<<10)
.................... #define	PHCON2_HDLDIS	(1ul<<8)
.................... 
.................... // PHSTAT2 bits --------
.................... #define	PHSTAT2_TXSTAT	(1ul<<13)
.................... #define	PHSTAT2_RXSTAT	(1ul<<12)
.................... #define	PHSTAT2_COLSTAT	(1ul<<11)
.................... #define	PHSTAT2_LSTAT	(1ul<<10)
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9)
.................... #define	PHSTAT2_PLRITY	(1ul<<5)
.................... 
.................... // PHIE bits -----------
.................... #define	PHIE_PLNKIE		(1ul<<4)
.................... #define	PHIE_PGEIE		(1ul<<1)
.................... 
.................... // PHIR bits -----------
.................... #define	PHIR_PLNKIF		(1ul<<4)
.................... #define	PHIR_PGIF		(1ul<<2)
.................... 
.................... // PHLCON bits -------
.................... #define	PHLCON_LACFG3	(1ul<<11)
.................... #define	PHLCON_LACFG2	(1ul<<10)
.................... #define	PHLCON_LACFG1	(1ul<<9)
.................... #define	PHLCON_LACFG0	(1ul<<8)
.................... #define	PHLCON_LBCFG3	(1ul<<7)
.................... #define	PHLCON_LBCFG2	(1ul<<6)
.................... #define	PHLCON_LBCFG1	(1ul<<5)
.................... #define	PHLCON_LBCFG0	(1ul<<4)
.................... #define	PHLCON_LFRQ1	(1ul<<3)
.................... #define	PHLCON_LFRQ0	(1ul<<2)
.................... #define	PHLCON_STRCH	(1ul<<1)
.................... 
.................... #endif
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars)
.................... *
.................... * PreCondition:    None
.................... *
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or
.................... *                  'a'-'f'
.................... *
.................... * Output:          The resulting packed byte: 0x00-0xFF
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:         None
.................... ********************************************************************/
.................... BYTE hexatob(WORD_VAL AsciiChars)
.................... {
....................    // Convert lowercase to uppercase
....................    if(AsciiChars.v[1] > 'F')
....................       AsciiChars.v[1] -= 'a'-'A';
....................    if(AsciiChars.v[0] > 'F')
....................       AsciiChars.v[0] -= 'a'-'A';
.................... 
....................    // Convert 0-9, A-F to 0x0-0xF
....................    if(AsciiChars.v[1] > '9')
....................       AsciiChars.v[1] -= 'A' - 10;
....................    else
....................       AsciiChars.v[1] -= '0';
.................... 
....................    if(AsciiChars.v[0] > '9')
....................       AsciiChars.v[0] -= 'A' - 10;
....................    else
....................       AsciiChars.v[0] -= '0';
.................... 
....................    // Concatenate
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        BYTE btohexa_high(BYTE b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           One byte ranged 0x00-0xFF
....................  *
....................  * Output:          An ascii byte (always uppercase) between '0'-'9'
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of
....................  *               the input byte.
....................  *               ex: b = 0xAE, btohexa_high() returns 'A'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:         None
....................  ********************************************************************/
.................... BYTE btohexa_high(BYTE b)
.................... {
....................    b >>= 4;
....................    return (b>0x9) ? b+'A'-10:b+'0';
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        BYTE btohexa_low(BYTE b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           One byte ranged 0x00-0xFF
....................  *
....................  * Output:          An ascii byte (always uppercase) between '0'-'9'
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of
....................  *               the input byte.
....................  *               ex: b = 0xAE, btohexa_low() returns 'E'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:         None
....................  ********************************************************************/
.................... BYTE btohexa_low(BYTE b)
.................... {
....................    b &= 0x0F;
....................    return (b>9) ? b+'A'-10:b+'0';
.................... }
.................... 
.................... WORD swaps(WORD_VAL v)
.................... {
....................     WORD_VAL new;
.................... 
....................     new.v[0]=v.v[1];
*
1230:  MOVFF  38F,390
....................     new.v[1]=v.v[0];
1234:  MOVFF  38E,391
.................... 
....................     return(new.Val);
1238:  MOVLB  3
123A:  MOVFF  390,01
123E:  MOVFF  391,02
1242:  MOVLB  0
1244:  RETURN 0
.................... }
.................... 
.................... DWORD swapl(DWORD_VAL v)
.................... {
....................     DWORD_VAL new;
.................... 
....................     new.v[0]=v.v[3];
*
210C:  MOVFF  37A,37B
....................     new.v[1]=v.v[2];
2110:  MOVFF  379,37C
....................     new.v[2]=v.v[1];
2114:  MOVFF  378,37D
....................     new.v[3]=v.v[0];
2118:  MOVFF  377,37E
.................... 
....................     return(new.Val);
211C:  MOVFF  37B,00
2120:  MOVFF  37C,01
2124:  MOVFF  37D,02
2128:  MOVFF  37E,03
212C:  RETURN 0
.................... }
.................... 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count)
.................... {
....................    WORD i;
....................    WORD *val;
.................... 
....................    union
....................    {
....................       DWORD Val;
....................       struct
....................       {
....................          WORD_VAL LSB;
....................          WORD_VAL MSB;
....................       } words;
....................    } tempSum, sum;
.................... 
....................    sum.Val = 0;
*
1E80:  MOVLB  3
1E82:  CLRF   x80
1E84:  CLRF   x7F
1E86:  CLRF   x7E
1E88:  CLRF   x7D
.................... 
....................    i = count >> 1;
1E8A:  BCF    FD8.0
1E8C:  RRCF   x74,W
1E8E:  MOVWF  x76
1E90:  RRCF   x73,W
1E92:  MOVWF  x75
....................    val = (WORD *)buffer;
1E94:  MOVFF  372,378
1E98:  MOVFF  371,377
.................... 
....................    while( i-- )
1E9C:  MOVFF  376,03
1EA0:  MOVF   x75,W
1EA2:  BTFSC  FD8.2
1EA4:  DECF   x76,F
1EA6:  DECF   x75,F
1EA8:  IORWF  03,W
1EAA:  BZ    1ED2
....................       sum.Val += *val++;
1EAC:  MOVFF  378,FEA
1EB0:  MOVFF  377,FE9
1EB4:  MOVLW  02
1EB6:  ADDWF  x77,F
1EB8:  BTFSC  FD8.0
1EBA:  INCF   x78,F
1EBC:  MOVFF  FEC,03
1EC0:  MOVF   FED,F
1EC2:  MOVF   FEF,W
1EC4:  ADDWF  x7D,F
1EC6:  MOVF   03,W
1EC8:  ADDWFC x7E,F
1ECA:  MOVLW  00
1ECC:  ADDWFC x7F,F
1ECE:  ADDWFC x80,F
1ED0:  BRA    1E9C
.................... 
....................    if ( count & 1 )
1ED2:  MOVF   x73,W
1ED4:  ANDLW  01
1ED6:  MOVWF  00
1ED8:  CLRF   03
1EDA:  MOVF   00,W
1EDC:  IORWF  03,W
1EDE:  BZ    1EF4
....................       sum.Val += *(BYTE *)val;
1EE0:  MOVFF  378,FEA
1EE4:  MOVFF  377,FE9
1EE8:  MOVF   FEF,W
1EEA:  ADDWF  x7D,F
1EEC:  MOVLW  00
1EEE:  ADDWFC x7E,F
1EF0:  ADDWFC x7F,F
1EF2:  ADDWFC x80,F
.................... 
....................    tempSum.Val = sum.Val;
1EF4:  MOVFF  380,37C
1EF8:  MOVFF  37F,37B
1EFC:  MOVFF  37E,37A
1F00:  MOVFF  37D,379
.................... 
....................    while( (i = tempSum.words.MSB.Val) != 0u )
1F04:  MOVFF  37C,376
1F08:  MOVFF  37B,375
1F0C:  MOVF   x75,F
1F0E:  BNZ   1F14
1F10:  MOVF   x76,F
1F12:  BZ    1F5A
....................    {
....................       sum.words.MSB.Val = 0;
1F14:  CLRF   x80
1F16:  CLRF   x7F
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i;
1F18:  CLRF   x84
1F1A:  CLRF   x83
1F1C:  MOVFF  37E,382
1F20:  MOVFF  37D,381
1F24:  MOVFF  375,00
1F28:  MOVFF  376,01
1F2C:  CLRF   02
1F2E:  CLRF   03
1F30:  MOVF   00,W
1F32:  ADDWF  x7D,W
1F34:  MOVWF  x7D
1F36:  MOVF   01,W
1F38:  ADDWFC x7E,W
1F3A:  MOVWF  x7E
1F3C:  MOVF   02,W
1F3E:  ADDWFC x83,W
1F40:  MOVWF  x7F
1F42:  MOVF   03,W
1F44:  ADDWFC x84,W
1F46:  MOVWF  x80
....................       tempSum.Val = sum.Val;
1F48:  MOVFF  380,37C
1F4C:  MOVFF  37F,37B
1F50:  MOVFF  37E,37A
1F54:  MOVFF  37D,379
1F58:  BRA    1F04
....................    }
.................... 
....................    return (~sum.words.LSB.Val);
1F5A:  MOVFF  37E,03
1F5E:  COMF   03,F
1F60:  MOVF   x7D,W
1F62:  XORLW  FF
1F64:  MOVWF  01
1F66:  MOVFF  03,02
1F6A:  MOVLB  0
1F6C:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        WORD CalcIPBufferChecksum(WORD len)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  MAC buffer pointer set to starting of buffer
....................  *
....................  * Input:           len     - Total number of bytes to calculate
....................  *                          checksum for.
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs checksum calculation in
....................  *                  MAC buffer itself.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #if !defined(MCHP_MAC)
.................... WORD CalcIPBufferChecksum(WORD len)
.................... {
....................     BOOL lbMSB;
....................     WORD_VAL checkSum;
....................     BYTE Checkbyte;
.................... 
....................     lbMSB = TRUE;
....................     checkSum.Val = 0;
.................... 
....................     while( len-- )
....................     {
....................         Checkbyte = MACGet();
.................... 
....................         if ( !lbMSB )
....................         {
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte)
....................             {
....................                 if ( ++checkSum.v[1] == 0 )
....................                     checkSum.v[0]++;
....................             }
....................         }
....................         else
....................         {
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte)
....................             {
....................                 if ( ++checkSum.v[0] == 0 )
....................                     checkSum.v[1]++;
....................             }
....................         }
.................... 
....................         lbMSB = !lbMSB;
....................     }
.................... 
....................     checkSum.v[1] = ~checkSum.v[1];
....................     checkSum.v[0] = ~checkSum.v[0];
....................     return checkSum.Val;
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void delay_s(int8 s) {
....................    while(s) {
....................       restart_wdt();
....................       delay_ms(1000);
....................       s--;
....................    }
.................... }
.................... 
.................... #include "tcpip/tick.c"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.c
....................  * Dependencies:    stackTSK.h
....................  *                  Tick.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt
....................  ********************************************************************/
.................... 
.................... #define TICK_INCLUDE
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... TICKTYPE TickCount = 0;  //increment every 100ms
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void)
.................... {
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16);
*
07BE:  MOVLW  83
07C0:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER);
07C2:  MOVLW  85
07C4:  MOVWF  FD7
07C6:  MOVLW  ED
07C8:  MOVWF  FD6
.................... 
....................     enable_interrupts(INT_TIMER0);
07CA:  BSF    FF2.5
....................     enable_interrupts(GLOBAL);
07CC:  MOVLW  C0
07CE:  IORWF  FF2,F
07D0:  GOTO   107E (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void)
.................... {
....................     int16 ret;
....................     disable_interrupts(INT_TIMER0);
*
24E4:  BCF    FF2.5
....................     ret=TickCount;
24E6:  MOVFF  54,333
24EA:  MOVFF  53,332
....................     enable_interrupts(INT_TIMER0);
24EE:  BSF    FF2.5
....................     return ret;
24F0:  MOVLB  3
24F2:  MOVFF  332,01
24F6:  MOVFF  333,02
24FA:  MOVLB  0
24FC:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... int8 second_counter=0;  //increment this every 1s
.................... int8 second_counter_intermediate=0;
.................... 
.................... #if STACK_USE_PPP
....................  int8 ppp_second_counter=0;
....................  int8 ppp_second_counter_intermediate=0;
.................... #endif
.................... 
.................... #int_timer0
.................... void Tick_Isr(void)
.................... {
....................         TickCount++;    //increment this every 100ms
*
00C2:  INCF   53,F
00C4:  BTFSC  FD8.2
00C6:  INCF   54,F
.................... 
....................         second_counter_intermediate++;
00C8:  INCF   56,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) {
00CA:  MOVF   56,W
00CC:  SUBLW  09
00CE:  BC    00D4
....................             second_counter++; //increment this ever 1s
00D0:  INCF   55,F
....................             second_counter_intermediate=0;
00D2:  CLRF   56
....................         }
.................... 
.................... 
....................        #if STACK_USE_PPP
....................         ppp_second_counter_intermediate++;
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) {
....................             ppp_second_counter_intermediate=0;
....................             ppp_second_counter++;
....................         }
....................        #endif
.................... 
.................... 
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms
00D4:  MOVLW  85
00D6:  MOVWF  FD7
00D8:  MOVLW  ED
00DA:  MOVWF  FD6
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //#define debug_stack  debug_printf
.................... #define debug_stack
.................... 
.................... #if STACK_USE_MAC
....................    #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
....................    #if STACK_USE_MCPENC
....................     #include "tcpip/enc28j60.c"
.................... /*********************************************************************
....................  *
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.c
....................  * Dependencies:    ENC28J60.h
....................  *                    MAC.h
....................  *                    string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                    Delay.h
....................  * Processor:       PIC18
....................  * Complier:        MCC18 v3.00 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date         Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder      6/28/04   Original
....................  * Howard Schlunder      10/8/04   Cleanup
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds
....................  * Howard Schlunder      1/09/06   Added comments and minor mods
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP
....................  * Darren Rook          7/11/06  CCS Port
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
.................... ********************************************************************/
.................... #define THIS_IS_MAC_LAYER
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/StackTsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/Helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/MAC.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ENC28J60.h"
.................... /*********************************************************************
....................  *
....................  *            ENC28J60 registers/bits
....................  *
....................  *********************************************************************
....................  * FileName:        ENC28J60.h
....................  * Description: 	Include file for ENC28J60 control registers
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Howard Schlunder		06/01/04	Original
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a 
....................  *									couple of PHY register structs.
....................  * Howard Schlunder		09/29/04	Matched with data sheet
....................  * Howard Schlunder		01/04/06	Matched with new data sheet
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN
....................  * Howard Schlunder		07/21/06	Several bits removed to match now 
....................  *									reserved bits in rev. B data sheet 
....................  *									(DS39662B)
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef ENC28J60_H
.................... #define ENC28J60_H
.................... 
.................... typedef union {
.................... 	BYTE v[7];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 CollisionCount:4;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 Done:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 PacketDefer:1;
.................... 		int8 ExcessiveDefer:1;
.................... 		int8 MaximumCollisions:1;
.................... 		int8 LateCollision:1;
.................... 		int8 Giant:1;
.................... 		int8 Underrun:1;
.................... 		int16 	 BytesTransmittedOnWire;
.................... 		int8 ControlFrame:1;
.................... 		int8 PAUSEControlFrame:1;
.................... 		int8 BackpressureApplied:1;
.................... 		int8 VLANTaggedFrame:1;
.................... 		int8 Zeros:4;
.................... 	} bits;
.................... } TXSTATUS;
.................... 
.................... typedef union {
.................... 	char v[4];
.................... 	struct {
.................... 		int16	 ByteCount;
.................... 		int8 PreviouslyIgnored:1;
.................... 		int8 RXDCPreviouslySeen:1;
.................... 		int8 CarrierPreviouslySeen:1;
.................... 		int8 CodeViolation:1;
.................... 		int8 CRCError:1;
.................... 		int8 LengthCheckError:1;
.................... 		int8 LengthOutOfRange:1;
.................... 		int8 ReceiveOk:1;
.................... 		int8 Multicast:1;
.................... 		int8 Broadcast:1;
.................... 		int8 DribbleNibble:1;
.................... 		int8 ControlFrame:1;
.................... 		int8 PauseControlFrame:1;
.................... 		int8 UnsupportedOpcode:1;
.................... 		int8 VLANType:1;
.................... 		int8 Zero:1;
.................... 	} bits;
.................... } RXSTATUS;
.................... 
.................... /******************************************************************************
.................... * Register locations
.................... ******************************************************************************/
.................... // Bank 0 registers --------
.................... #define ERDPTL		0x00
.................... #define ERDPTH		0x01
.................... #define EWRPTL		0x02
.................... #define EWRPTH		0x03
.................... #define ETXSTL		0x04
.................... #define ETXSTH		0x05
.................... #define ETXNDL		0x06
.................... #define ETXNDH		0x07
.................... #define ERXSTL		0x08
.................... #define ERXSTH		0x09
.................... #define ERXNDL		0x0A
.................... #define ERXNDH		0x0B
.................... #define ERXRDPTL	0x0C
.................... #define ERXRDPTH	0x0D
.................... #define ERXWRPTL	0x0E
.................... #define ERXWRPTH	0x0F
.................... #define EDMASTL		0x10
.................... #define EDMASTH		0x11
.................... #define EDMANDL		0x12
.................... #define EDMANDH		0x13
.................... #define EDMADSTL	0x14
.................... #define EDMADSTH	0x15
.................... #define EDMACSL		0x16
.................... #define EDMACSH		0x17
.................... //#define			0x18
.................... //#define			0x19
.................... //#define r			0x1A
.................... #define EIE			0x1B
.................... #define EIR			0x1C
.................... #define ESTAT		0x1D
.................... #define ECON2		0x1E
.................... #define ECON1		0x1F
.................... 
.................... // Bank 1 registers -----
.................... #define EHT0		0x100
.................... #define EHT1		0x101
.................... #define EHT2		0x102
.................... #define EHT3		0x103
.................... #define EHT4		0x104
.................... #define EHT5		0x105
.................... #define EHT6		0x106
.................... #define EHT7		0x107
.................... #define EPMM0		0x108
.................... #define EPMM1		0x109
.................... #define EPMM2		0x10A
.................... #define EPMM3		0x10B
.................... #define EPMM4		0x10C
.................... #define EPMM5		0x10D
.................... #define EPMM6		0x10E
.................... #define EPMM7		0x10F
.................... #define EPMCSL		0x110
.................... #define EPMCSH		0x111
.................... //#define			0x112
.................... //#define			0x113
.................... #define EPMOL		0x114
.................... #define EPMOH		0x115
.................... //#define r			0x116
.................... //#define r			0x117
.................... #define ERXFCON		0x118
.................... #define EPKTCNT		0x119
.................... //#define r			0x11A
.................... //#define EIE		0x11B
.................... //#define EIR		0x11C
.................... //#define ESTAT		0x11D
.................... //#define ECON2		0x11E
.................... //#define ECON1		0x11F
.................... 
.................... // Bank 2 registers -----
.................... #define MACON1		0x200
.................... #define MACON2    0x201
.................... //#define r			0x201
.................... #define MACON3		0x202
.................... #define MACON4		0x203
.................... #define MABBIPG		0x204
.................... //#define			0x205
.................... #define MAIPGL		0x206
.................... #define MAIPGH		0x207
.................... #define MACLCON1	0x208
.................... #define MACLCON2	0x209
.................... #define MAMXFLL		0x20A
.................... #define MAMXFLH		0x20B
.................... //#define r			0x20C
.................... //#define r			0x20D
.................... //#define r			0x20E
.................... //#define			0x20F
.................... //#define r			0x210
.................... //#define r			0x211
.................... #define MICMD		0x212
.................... //#define r			0x213
.................... #define MIREGADR	0x214
.................... //#define r			0x215
.................... #define MIWRL		0x216
.................... #define MIWRH		0x217
.................... #define MIRDL		0x218
.................... #define MIRDH		0x219
.................... //#define r			0x21A
.................... //#define EIE		0x21B
.................... //#define EIR		0x21C
.................... //#define ESTAT		0x21D
.................... //#define ECON2		0x21E
.................... //#define ECON1		0x21F
.................... 
.................... // Bank 3 registers -----
.................... #define MAADR5		0x300
.................... #define MAADR6		0x301
.................... #define MAADR3		0x302
.................... #define MAADR4		0x303
.................... #define MAADR1		0x304
.................... #define MAADR2		0x305
.................... #define EBSTSD		0x306
.................... #define EBSTCON		0x307
.................... #define EBSTCSL		0x308
.................... #define EBSTCSH		0x309
.................... #define MISTAT		0x30A
.................... //#define			0x30B
.................... //#define			0x30C
.................... //#define			0x30D
.................... //#define			0x30E
.................... //#define			0x30F
.................... //#define			0x310
.................... //#define			0x311
.................... #define EREVID		0x312
.................... //#define			0x313
.................... //#define			0x314
.................... #define ECOCON		0x315
.................... //#define 			0x316
.................... #define EFLOCON		0x317
.................... #define EPAUSL		0x318
.................... #define EPAUSH		0x319
.................... //#define r			0x31A
.................... //#define EIE		0x31B
.................... //#define EIR		0x31C
.................... //#define ESTAT		0x31D
.................... //#define ECON2		0x31E
.................... //#define ECON1		0x31F
.................... 
.................... 
.................... 
.................... // Structures
.................... typedef union _REG
.................... {
.................... 	char Val;
.................... 
.................... 	// EIE bits ----------
.................... 	struct {
.................... 		unsigned char RXERIE:1;
.................... 		unsigned char TXERIE:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIE:1;
.................... 		unsigned char LINKIE:1;
.................... 		unsigned char DMAIE:1;
.................... 		unsigned char PKTIE:1;
.................... 		unsigned char INTIE:1;
.................... 	} EIEbits;
.................... 
.................... 	// EIR bits ----------
.................... 	struct {
.................... 		unsigned char RXERIF:1;
.................... 		unsigned char TXERIF:1;
.................... 		unsigned char :1;
.................... 		unsigned char TXIF:1;
.................... 		unsigned char LINKIF:1;
.................... 		unsigned char DMAIF:1;
.................... 		unsigned char PKTIF:1;
.................... 		unsigned char blank1:1;
.................... 	} EIRbits;
.................... 
.................... 	// ESTAT bits ---------
.................... 	struct {
.................... 		unsigned char CLKRDY:1;
.................... 		unsigned char TXABRT:1;
.................... 		unsigned char RXBUSY:1;
.................... 		unsigned char blank1:1;
.................... 		unsigned char LATECOL:1;
.................... 		unsigned char blank2:2;
.................... 		unsigned char INTR:1;
.................... 	} ESTATbits;
.................... 
.................... 	// ECON2 bits --------
.................... 	struct {
.................... 		unsigned char blank3:3;
.................... 		unsigned char VRPS:1;
.................... 		unsigned char VRTP:1;
.................... 		unsigned char PWRSV:1;
.................... 		unsigned char PKTDEC:1;
.................... 		unsigned char AUTOINC:1;
.................... 	} ECON2bits;
.................... 
.................... 	// ECON1 bits --------
.................... 	struct {
.................... 		unsigned char BSEL0:1;
.................... 		unsigned char BSEL1:1;
.................... 		unsigned char RXEN:1;
.................... 		unsigned char TXRTS:1;
.................... 		unsigned char CSUMEN:1;
.................... 		unsigned char DMAST:1;
.................... 		unsigned char RXRST:1;
.................... 		unsigned char TXRST:1;
.................... 	} ECON1bits;
.................... 
.................... 	// ERXFCON bits ------
.................... 	struct {
.................... 		unsigned char BCEN:1;
.................... 		unsigned char MCEN:1;
.................... 		unsigned char HTEN:1;
.................... 		unsigned char MPEN:1;
.................... 		unsigned char PMEN:1;
.................... 		unsigned char CRCEN:1;
.................... 		unsigned char ANDOR:1;
.................... 		unsigned char UCEN:1;
.................... 	} ERXFCONbits;
.................... 
.................... 	// MACON1 bits --------
.................... 	struct {
.................... 		unsigned char MARXEN:1;
.................... 		unsigned char PASSALL:1;
.................... 		unsigned char RXPAUS:1;
.................... 		unsigned char TXPAUS:1;
.................... 		unsigned char :4;
.................... 	} MACON1bits;
.................... 
.................... 
.................... 	// MACON3 bits --------
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG0:1;
.................... 		unsigned char PADCFG1:1;
.................... 		unsigned char PADCFG2:1;
.................... 	} MACON3bits;
.................... 	struct {
.................... 		unsigned char FULDPX:1;
.................... 		unsigned char FRMLNEN:1;
.................... 		unsigned char HFRMEN:1;
.................... 		unsigned char PHDRLEN:1;
.................... 		unsigned char TXCRCEN:1;
.................... 		unsigned char PADCFG:3;
.................... 	} MACON3bits2;
.................... 
.................... 	// MACON4 bits --------
.................... 	struct {
.................... 		unsigned char :4;
.................... 		unsigned char NOBKOFF:1;
.................... 		unsigned char BPEN:1;
.................... 		unsigned char DEFER:1;
.................... 		unsigned char blank1:1;
.................... 	} MACON4bits;
.................... 
.................... 	// MICMD bits ---------
.................... 	struct {
.................... 		unsigned char MIIRD:1;
.................... 		unsigned char MIISCAN:1;
.................... 		unsigned char blank6:6;
.................... 	} MICMDbits;
.................... 
.................... 	// EBSTCON bits -----
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL0:1;
.................... 		unsigned char TMSEL1:1;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV0:1;
.................... 		unsigned char PSV1:1;
.................... 		unsigned char PSV2:1;
.................... 	} EBSTCONbits;
.................... 	struct {
.................... 		unsigned char BISTST:1;
.................... 		unsigned char TME:1;
.................... 		unsigned char TMSEL:2;
.................... 		unsigned char PSEL:1;
.................... 		unsigned char PSV:3;
.................... 	} EBSTCONbits2;
.................... 
.................... 	// MISTAT bits --------
.................... 	struct {
.................... 		unsigned char BUSY:1;
.................... 		unsigned char SCAN:1;
.................... 		unsigned char NVALID:1;
.................... 		unsigned char blank5:5;
.................... 	} MISTATbits;
.................... 
.................... 	// ECOCON bits -------
.................... 	struct {
.................... 		unsigned char COCON0:1;
.................... 		unsigned char COCON1:1;
.................... 		unsigned char COCON2:1;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits;
.................... 	struct {
.................... 		unsigned char COCON:3;
.................... 		unsigned char blank5:5;
.................... 	} ECOCONbits2;
.................... 
.................... 	// EFLOCON bits -----
.................... 	struct {
.................... 		unsigned char FCEN0:1;
.................... 		unsigned char FCEN1:1;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits;
.................... 	struct {
.................... 		unsigned char FCEN:2;
.................... 		unsigned char FULDPXS:1;
.................... 		unsigned char blank5:5;
.................... 	} EFLOCONbits2;
.................... } REG;
.................... 
.................... 
.................... /******************************************************************************
.................... * PH Register Locations
.................... ******************************************************************************/
.................... #define PHCON1	0x00
.................... #define PHSTAT1	0x01
.................... #define PHID1	0x02
.................... #define PHID2	0x03
.................... #define PHCON2	0x10
.................... #define PHSTAT2	0x11
.................... #define PHIE	0x12
.................... #define PHIR	0x13
.................... #define PHLCON	0x14
.................... 
.................... 
.................... typedef union {
.................... 	int16 Val;
.................... 	WORD_VAL VAL;
.................... 
.................... 	// PHCON1 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 PDPXMD:1;
.................... 		int8 blank2:2;
.................... 		int8 PPWRSV:1;
.................... 		int8 blank22:2;
.................... 		int8 PLOOPBK:1;
.................... 		int8 PRST:1;
.................... 	} PHCON1bits;
.................... 
.................... 	// PHSTAT1 bits --------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 JBSTAT:1;
.................... 		int8 LLSTAT:1;
.................... 		int8 blank5:5;
.................... 		int8 blank3:3;
.................... 		int8 PHDPX:1;
.................... 		int8 PFDPX:1;
.................... 		int8 blank33:3;
.................... 	} PHSTAT1bits;
.................... 
.................... 	// PHID2 bits ----------
.................... 	struct {
.................... 		int8 PREV0:1;
.................... 		int8 PREV1:1;
.................... 		int8 PREV2:1;
.................... 		int8 PREV3:1;
.................... 		int8 PPN0:1;
.................... 		int8 PPN1:1;
.................... 		int8 PPN2:1;
.................... 		int8 PPN3:1;
.................... 		int8 PPN4:1;
.................... 		int8 PPN5:1;
.................... 		int8 PID19:1;
.................... 		int8 PID20:1;
.................... 		int8 PID21:1;
.................... 		int8 PID22:1;
.................... 		int8 PID23:1;
.................... 		int8 PID24:1;
.................... 	} PHID2bits;
.................... 	struct {
.................... 		int8 PREV:4;
.................... 		int8 PPNL:4;
.................... 		int8 PPNH:2;
.................... 		int8 PID:6;
.................... 	} PHID2bits2;
.................... 
.................... 	// PHCON2 bits ----------
.................... 	struct {
.................... 		int8 blank8:8;
.................... 		int8 HDLDIS:1;
.................... 		int8 blank1:1;
.................... 		int8 JABBER:1;
.................... 		int8 blank2:2;
.................... 		int8 TXDIS:1;
.................... 		int8 FRCLNK:1;
.................... 		int8 blank11:1;
.................... 	} PHCON2bits;
.................... 
.................... 	// PHSTAT2 bits --------
.................... 	struct {
.................... 		int8 blank5:5;
.................... 		int8 PLRITY:1;
.................... 		int8 blank2:2;
.................... 		int8 blank11:1;
.................... 		int8 DPXSTAT:1;
.................... 		int8 LSTAT:1;
.................... 		int8 COLSTAT:1;
.................... 		int8 RXSTAT:1;
.................... 		int8 TXSTAT:1;
.................... 		int8 blank22:2;
.................... 	} PHSTAT2bits;
.................... 
.................... 	// PHIE bits -----------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 PGEIE:1;
.................... 		int8 blank2:2;
.................... 		int8 PLNKIE:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIEbits;
.................... 
.................... 	// PHIR bits -----------
.................... 	struct {
.................... 		int8 blank2:2;
.................... 		int8 PGIF:1;
.................... 		int8 blank1:1;
.................... 		int8 PLNKIF:1;
.................... 		int8 blank3:3;
.................... 		int8 blank8:8;
.................... 	} PHIRbits;
.................... 
.................... 	// PHLCON bits -------
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ0:1;
.................... 		int8 LFRQ1:1;
.................... 		int8 LBCFG0:1;
.................... 		int8 LBCFG1:1;
.................... 		int8 LBCFG2:1;
.................... 		int8 LBCFG3:1;
.................... 		int8 LACFG0:1;
.................... 		int8 LACFG1:1;
.................... 		int8 LACFG2:1;
.................... 		int8 LACFG3:1;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits;
.................... 	struct {
.................... 		int8 blank1:1;
.................... 		int8 STRCH:1;
.................... 		int8 LFRQ:2;
.................... 		int8 LBCFG:4;
.................... 		int8 LACFG:4;
.................... 		int8 blank4:4;
.................... 	} PHLCONbits2;
.................... } PHYREG;
.................... 
.................... 
.................... /******************************************************************************
.................... * Individual Register Bits
.................... ******************************************************************************/
.................... // ETH/MAC/MII bits
.................... 
.................... // EIE bits ----------
.................... #define	EIE_INTIE		(1<<7)
.................... #define	EIE_PKTIE		(1<<6)
.................... #define	EIE_DMAIE		(1<<5)
.................... #define	EIE_LINKIE		(1<<4)
.................... #define	EIE_TXIE		(1<<3)
.................... #define	EIE_TXERIE		(1<<1)
.................... #define	EIE_RXERIE		(1)
.................... 
.................... // EIR bits ----------
.................... #define	EIR_PKTIF		(1<<6)
.................... #define	EIR_DMAIF		(1<<5)
.................... #define	EIR_LINKIF		(1<<4)
.................... #define	EIR_TXIF		(1<<3)
.................... #define	EIR_TXERIF		(1<<1)
.................... #define	EIR_RXERIF		(1)
.................... 
.................... // ESTAT bits ---------
.................... #define	ESTAT_INT		(1<<7)
.................... #define ESTAT_BUFFER	(1<<6)
.................... #define	ESTAT_LATECOL	(1<<4)
.................... #define	ESTAT_RXBUSY	(1<<2)
.................... #define	ESTAT_TXABRT	(1<<1)
.................... #define	ESTAT_CLKRDY	(1)
.................... 
.................... // ECON2 bits --------
.................... #define	ECON2_AUTOINC	(1<<7)
.................... #define	ECON2_PKTDEC	(1<<6)
.................... #define	ECON2_PWRSV		(1<<5)
.................... #define	ECON2_VRPS		(1<<3)
.................... 
.................... // ECON1 bits --------
.................... #define	ECON1_TXRST		(1<<7)
.................... #define	ECON1_RXRST		(1<<6)
.................... #define	ECON1_DMAST		(1<<5)
.................... #define	ECON1_CSUMEN	(1<<4)
.................... #define	ECON1_TXRTS		(1<<3)
.................... #define	ECON1_RXEN		(1<<2)
.................... #define	ECON1_BSEL1		(1<<1)
.................... #define	ECON1_BSEL0		(1)
.................... 
.................... // ERXFCON bits ------
.................... #define	ERXFCON_UCEN	(1<<7)
.................... #define	ERXFCON_ANDOR	(1<<6)
.................... #define	ERXFCON_CRCEN	(1<<5)
.................... #define	ERXFCON_PMEN	(1<<4)
.................... #define	ERXFCON_MPEN	(1<<3)
.................... #define	ERXFCON_HTEN	(1<<2)
.................... #define	ERXFCON_MCEN	(1<<1)
.................... #define	ERXFCON_BCEN	(1)
.................... 
.................... // MACON1 bits --------
.................... #define	MACON1_TXPAUS	(1<<3)
.................... #define	MACON1_RXPAUS	(1<<2)
.................... #define	MACON1_PASSALL	(1<<1)
.................... #define	MACON1_MARXEN	(1)
.................... 
.................... // MACON3 bits --------
.................... #define	MACON3_PADCFG2	(1<<7)
.................... #define	MACON3_PADCFG1	(1<<6)
.................... #define	MACON3_PADCFG0	(1<<5)
.................... #define	MACON3_TXCRCEN	(1<<4)
.................... #define	MACON3_PHDRLEN	(1<<3)
.................... #define	MACON3_HFRMEN	(1<<2)
.................... #define	MACON3_FRMLNEN	(1<<1)
.................... #define	MACON3_FULDPX	(1)
.................... 
.................... // MACON4 bits --------
.................... #define	MACON4_DEFER	(1<<6)
.................... #define	MACON4_BPEN		(1<<5)
.................... #define	MACON4_NOBKOFF	(1<<4)
.................... 
.................... 
.................... // MICMD bits ---------
.................... #define	MICMD_MIISCAN	(1<<1)
.................... #define	MICMD_MIIRD		(1)
.................... 
.................... // EBSTCON bits -----
.................... #define	EBSTCON_PSV2	(1<<7)
.................... #define	EBSTCON_PSV1	(1<<6)
.................... #define	EBSTCON_PSV0	(1<<5)
.................... #define	EBSTCON_PSEL	(1<<4)
.................... #define	EBSTCON_TMSEL1	(1<<3)
.................... #define	EBSTCON_TMSEL0	(1<<2)
.................... #define	EBSTCON_TME		(1<<1)
.................... #define	EBSTCON_BISTST	(1)
.................... 
.................... // MISTAT bits --------
.................... #define	MISTAT_NVALID	(1<<2)
.................... #define	MISTAT_SCAN		(1<<1)
.................... #define	MISTAT_BUSY		(1)
.................... 
.................... // ECOCON bits -------
.................... #define	ECOCON_COCON2	(1<<2)
.................... #define	ECOCON_COCON1	(1<<1)
.................... #define	ECOCON_COCON0	(1)
.................... 
.................... // EFLOCON bits -----
.................... #define	EFLOCON_FULDPXS	(1<<2)
.................... #define	EFLOCON_FCEN1	(1<<1)
.................... #define	EFLOCON_FCEN0	(1)
.................... 
.................... 
.................... 
.................... // PHY bits
.................... 
.................... // PHCON1 bits ----------
.................... #define	PHCON1_PRST		(1ul<<15)
.................... #define	PHCON1_PLOOPBK	(1ul<<14)
.................... #define	PHCON1_PPWRSV	(1ul<<11)
.................... #define	PHCON1_PDPXMD	(1ul<<8)
.................... 
.................... // PHSTAT1 bits --------
.................... #define	PHSTAT1_PFDPX	(1ul<<12)
.................... #define	PHSTAT1_PHDPX	(1ul<<11)
.................... #define	PHSTAT1_LLSTAT	(1ul<<2)
.................... #define	PHSTAT1_JBSTAT	(1ul<<1)
.................... 
.................... // PHID2 bits --------
.................... #define	PHID2_PID24		(1ul<<15)
.................... #define	PHID2_PID23		(1ul<<14)
.................... #define	PHID2_PID22		(1ul<<13)
.................... #define	PHID2_PID21		(1ul<<12)
.................... #define	PHID2_PID20		(1ul<<11)
.................... #define	PHID2_PID19		(1ul<<10)
.................... #define	PHID2_PPN5		(1ul<<9)
.................... #define	PHID2_PPN4		(1ul<<8)
.................... #define	PHID2_PPN3		(1ul<<7)
.................... #define	PHID2_PPN2		(1ul<<6)
.................... #define	PHID2_PPN1		(1ul<<5)
.................... #define	PHID2_PPN0		(1ul<<4)
.................... #define	PHID2_PREV3		(1ul<<3)
.................... #define	PHID2_PREV2		(1ul<<2)
.................... #define	PHID2_PREV1		(1ul<<1)
.................... #define	PHID2_PREV0		(1ul)
.................... 
.................... // PHCON2 bits ----------
.................... #define	PHCON2_FRCLNK	(1ul<<14)
.................... #define	PHCON2_TXDIS	(1ul<<13)
.................... #define	PHCON2_JABBER	(1ul<<10)
.................... #define	PHCON2_HDLDIS	(1ul<<8)
.................... 
.................... // PHSTAT2 bits --------
.................... #define	PHSTAT2_TXSTAT	(1ul<<13)
.................... #define	PHSTAT2_RXSTAT	(1ul<<12)
.................... #define	PHSTAT2_COLSTAT	(1ul<<11)
.................... #define	PHSTAT2_LSTAT	(1ul<<10)
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9)
.................... #define	PHSTAT2_PLRITY	(1ul<<5)
.................... 
.................... // PHIE bits -----------
.................... #define	PHIE_PLNKIE		(1ul<<4)
.................... #define	PHIE_PGEIE		(1ul<<1)
.................... 
.................... // PHIR bits -----------
.................... #define	PHIR_PLNKIF		(1ul<<4)
.................... #define	PHIR_PGIF		(1ul<<2)
.................... 
.................... // PHLCON bits -------
.................... #define	PHLCON_LACFG3	(1ul<<11)
.................... #define	PHLCON_LACFG2	(1ul<<10)
.................... #define	PHLCON_LACFG1	(1ul<<9)
.................... #define	PHLCON_LACFG0	(1ul<<8)
.................... #define	PHLCON_LBCFG3	(1ul<<7)
.................... #define	PHLCON_LBCFG2	(1ul<<6)
.................... #define	PHLCON_LBCFG1	(1ul<<5)
.................... #define	PHLCON_LBCFG0	(1ul<<4)
.................... #define	PHLCON_LFRQ1	(1ul<<3)
.................... #define	PHLCON_LFRQ0	(1ul<<2)
.................... #define	PHLCON_STRCH	(1ul<<1)
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if STACK_USE_SLIP
.................... #error Unexpected module is detected.
.................... #error This file must be linked when SLIP module is not in use.
.................... #endif
.................... 
.................... #define debug_mac
.................... //#define debug_mac debug_printf
.................... 
....................    #ifndef PIN_ENC_MAC_SO
....................       #define PIN_ENC_MAC_SO  PIN_D7   // PIC <<<< ENC
....................       #define PIN_ENC_MAC_SI  PIN_D6   // PIC >>>> ENC
....................       #define PIN_ENC_MAC_CLK PIN_D5
....................       #define PIN_ENC_MAC_CS  PIN_D4
....................       #define PIN_ENC_MAC_RST PIN_D3
....................       #define PIN_ENC_MAC_INT PIN_D2
....................       #define PIN_ENC_MAC_WOL PIN_D1
....................       #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz!
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC
....................       #define mac_enc_spi_tris_init()  *0xF95= (0b10000110);
....................      #endif
.................... 
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs
.................... 
.................... /** D E F I N I T I O N S ****************************************************/
.................... /* Hardware interface to NIC. */
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these
.................... // The following SPI pins are used but are not configurable
.................... //   RC3 is used for the SCK pin and is an output
.................... //   RC4 is used for the SDI pin and is an input
.................... //   RC5 is used for the SDO pin and is an output
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is
.................... //      done using the SPI.
.................... 
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is
.................... // not compatible with most switches/routers.  If a dedicated network is used
.................... // where the duplex of the remote node can be manually configured, you may
.................... // change this configuration.  Otherwise, half duplex should always be used.
.................... #define HALF_DUPLEX
.................... //#define FULL_DUPLEX
.................... //#define LEDB_DUPLEX
.................... 
.................... // Pseudo Functions
.................... #define LOW(a)                (a & 0xFF)
.................... #define HIGH(a)             ((a>>8) & 0xFF)
.................... 
.................... // NIC RAM definitions
.................... #define RAMSIZE   8192ul
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul)))
.................... #define RXSTART   (0ul)                  // Should be an even memory address
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul)
.................... 
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address)
.................... #define   WCR (0b010<<5)         // Write Control Register command
.................... #define BFS (0b100<<5)         // Bit Field Set command
.................... #define   BFC (0b101<<5)         // Bit Field Clear command
.................... #define   RCR (0b000<<5)         // Read Control Register command
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address.
....................                         //   It requires 0x1F, however.
.................... 
.................... #define ETHER_IP   (0x00u)
.................... #define ETHER_ARP   (0x06u)
.................... 
00DC:  BCF    FF2.2
00DE:  GOTO   0060
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u)
.................... 
.................... // A generic structure representing the Ethernet header starting all Ethernet
.................... // frames
.................... typedef struct _ETHER_HEADER
.................... {
....................     MAC_ADDR        DestMACAddr;
....................     MAC_ADDR        SourceMACAddr;
....................     WORD_VAL        Type;
.................... } ETHER_HEADER;
.................... 
.................... // A header appended at the start of all RX frames by the hardware
.................... typedef struct _ENC_PREAMBLE
.................... {
....................     int16         NextPacketPointer;
....................     RXSTATUS      StatusVector;
.................... 
....................     MAC_ADDR        DestMACAddr;
....................     MAC_ADDR        SourceMACAddr;
....................     WORD_VAL        Type;
.................... } ENC_PREAMBLE;
.................... 
.................... typedef struct _DATA_BUFFER
.................... {
....................    WORD_VAL StartAddress;
....................    WORD_VAL EndAddress;
....................    struct
....................    {
....................       unsigned char bFree : 1;
....................       unsigned char bTransmitted : 1;
....................    } Flags;
.................... } DATA_BUFFER;
.................... 
.................... void MACSetDuplex(DUPLEX DuplexState);
.................... 
.................... // Prototypes of functions intended for MAC layer use only.
.................... static void BankSel(WORD Register);
.................... static REG ReadETHReg(BYTE Address);
.................... static REG ReadMACReg(BYTE Address);
.................... static void WriteReg(BYTE Address, BYTE Data);
.................... static void BFCReg(BYTE Address, BYTE Data);
.................... static void BFSReg(BYTE Address, BYTE Data);
.................... static void SendSystemReset(void);
.................... //static void GetRegs(void);
.................... #ifdef MAC_POWER_ON_TEST
.................... static BOOL TestMemory(void);
.................... #endif
.................... 
.................... /* Internal and externally used MAC level variables */
.................... #if MAC_TX_BUFFER_COUNT > 1
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT];
.................... #endif
.................... 
.................... // Internal and externally used MAC level variables.
.................... #if MAC_TX_BUFFER_COUNT > 1
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT];
.................... BUFFER LastTXedBuffer;
.................... #endif
.................... 
.................... 
.................... // Internal MAC level variables and flags.
.................... WORD_VAL NextPacketLocation;
.................... WORD_VAL CurrentPacketLocation;
.................... BOOL WasDiscarded;
.................... BYTE ENCRevID;
.................... 
.................... //ENCSPIInit() added by CCS.
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI
.................... void ENCSPIInit(void)
.................... {
.................... 
....................    #ifdef mac_enc_spi_tris_init
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0;
....................    #endif
.................... 
....................  #if ENC_MAC_USE_SPI
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4);
*
07D4:  BCF    FC6.5
07D6:  BCF    F94.7
07D8:  BSF    F93.0
07DA:  BCF    F93.1
07DC:  MOVLW  20
07DE:  MOVWF  FC6
07E0:  MOVLW  40
07E2:  MOVWF  FC7
....................  #else
....................    
....................    output_low(PIN_ENC_MAC_CLK);
....................    output_float(PIN_ENC_MAC_SO);
....................  #endif
....................    //
....................    // Set up the SPI module on the PIC for communications with the ENC28J60
....................    //
....................    SPIUnselectEthernet();
07E4:  BCF    F93.2
07E6:  BSF    F8A.2
.................... 
....................    // Deassert the nRESET pin on the ENC28J60.  The internal
....................    // weak pull on the nRESET pin will get the job done anyway,
....................    // so this isn't necessary, but it may provide extra noise immunity,
....................    // should someone put their finger on the pin or otherwise cause a leakage
....................    // path to ground on this pin.
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1;
07E8:  BCF    F93.3
07EA:  BSF    F8A.3
07EC:  GOTO   0ACE (RETURN)
.................... }
.................... 
.................... //ENCSPIXfer() added by CCS.
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI
.................... char ENCSPIXfer(char c)
.................... {
....................  #if ENC_MAC_USE_SPI
....................    return(spi_read(c));
07F0:  MOVF   FC9,W
07F2:  MOVFF  399,FC9
07F6:  RRCF   FC7,W
07F8:  BNC   07F6
07FA:  MOVFF  FC9,01
....................  #else
07FE:  RETURN 0
....................    int8 i, in;
....................    for (i=0;i<8;i++) {
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0));
....................       output_high(PIN_ENC_MAC_CLK);
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO));
....................       output_low(PIN_ENC_MAC_CLK);
....................    }
....................    return(in);
....................  #endif
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        void MACInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACInit sets up the PIC's SPI module and all the
....................  *               registers in the ENC28J60 so that normal operation can
....................  *               begin.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACInit(void)
.................... {
....................    BYTE i;
.................... 
....................    ENCSPIInit();
*
0ACC:  BRA    07D4
.................... 
....................    // Wait for CLKRDY to become set.
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that
....................    // means the part is in RESET or otherwise our SPI pin is being driven
....................    // incorrectly.  Make sure it is working before proceeding.
....................    do
....................    {
....................       i = ReadETHReg(ESTAT).Val;
0ACE:  MOVLW  1D
0AD0:  MOVLB  3
0AD2:  MOVWF  x8E
0AD4:  MOVLB  0
0AD6:  RCALL  0800
0AD8:  MOVFF  01,2E0
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY));
0ADC:  MOVLB  2
0ADE:  BTFSS  xE0.3
0AE0:  BRA    0AE6
0AE2:  MOVLB  0
0AE4:  BRA    0ACE
0AE6:  MOVF   xE0,W
0AE8:  XORLW  FF
0AEA:  ANDLW  01
0AEC:  BTFSC  FD8.2
0AEE:  BRA    0AF4
0AF0:  MOVLB  0
0AF2:  BRA    0ACE
.................... 
.................... 
.................... #ifdef MAC_POWER_ON_TEST
....................    // Do the memory test and enter a while always trap if a hardware error
....................    // occured.  The LEDA and LEDB pins will be configured to blink
....................    // periodically in an abnormal manner to indicate to the user that the
....................    // error occured.
....................    if( !TestMemory() )
....................    {
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically
....................       while(1);
....................    }
.................... #endif
.................... 
....................    // RESET the entire ENC28J60, clearing all registers
....................    SendSystemReset();
0AF4:  MOVLB  0
0AF6:  BRA    082A
....................     delay_ms(1);
0AF8:  MOVLW  01
0AFA:  MOVLB  3
0AFC:  MOVWF  x13
0AFE:  MOVLB  0
0B00:  RCALL  04E2
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
....................     // On Init, all transmit buffers are free.
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ )
....................     {
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8));
....................         TxBuffers[i].Flags.bFree = TRUE;
....................     }
.................... #endif
....................     CurrentTxBuffer = 0;
0B02:  CLRF   52
.................... 
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers
....................    // and the buffer write protect pointer (receive buffer read pointer)
....................    WasDiscarded = TRUE;
0B04:  BSF    5B.0
....................    NextPacketLocation.Val = RXSTART;
0B06:  CLRF   58
0B08:  CLRF   57
....................    WriteReg(ERXSTL, LOW(RXSTART));
0B0A:  MOVLW  08
0B0C:  MOVLB  3
0B0E:  MOVWF  x94
0B10:  CLRF   x95
0B12:  MOVLB  0
0B14:  RCALL  083E
....................    WriteReg(ERXSTH, HIGH(RXSTART));
0B16:  MOVLW  09
0B18:  MOVLB  3
0B1A:  MOVWF  x94
0B1C:  CLRF   x95
0B1E:  MOVLB  0
0B20:  RCALL  083E
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first
0B22:  MOVLW  0C
0B24:  MOVLB  3
0B26:  MOVWF  x94
0B28:  MOVLW  F7
0B2A:  MOVWF  x95
0B2C:  MOVLB  0
0B2E:  RCALL  083E
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last
0B30:  MOVLW  0D
0B32:  MOVLB  3
0B34:  MOVWF  x94
0B36:  MOVLW  1B
0B38:  MOVWF  x95
0B3A:  MOVLB  0
0B3C:  RCALL  083E
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF
....................    WriteReg(ERXNDL, LOW(RXSTOP));
0B3E:  MOVLW  0A
0B40:  MOVLB  3
0B42:  MOVWF  x94
0B44:  MOVLW  F7
0B46:  MOVWF  x95
0B48:  MOVLB  0
0B4A:  RCALL  083E
....................    WriteReg(ERXNDH, HIGH(RXSTOP));
0B4C:  MOVLW  0B
0B4E:  MOVLB  3
0B50:  MOVWF  x94
0B52:  MOVLW  1B
0B54:  MOVWF  x95
0B56:  MOVLB  0
0B58:  RCALL  083E
.................... #endif
.................... #if TXSTART != 0      // The RESET default ETXST is 0
....................    WriteReg(ETXSTL, LOW(TXSTART));
0B5A:  MOVLW  04
0B5C:  MOVLB  3
0B5E:  MOVWF  x94
0B60:  MOVLW  F8
0B62:  MOVWF  x95
0B64:  MOVLB  0
0B66:  RCALL  083E
....................    WriteReg(ETXSTH, HIGH(TXSTART));
0B68:  MOVLW  05
0B6A:  MOVLB  3
0B6C:  MOVWF  x94
0B6E:  MOVLW  1B
0B70:  MOVWF  x95
0B72:  MOVLB  0
0B74:  RCALL  083E
.................... #endif
.................... 
....................    // Enter Bank 1 and configure Receive Filters
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is
....................    // acceptable)
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode
....................    //BankSel(ERXFCON);
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN);
.................... 
....................    // Enter Bank 2 and configure the MAC
....................    BankSel(MACON1);
0B76:  MOVLW  02
0B78:  MOVLB  3
0B7A:  MOVWF  x92
0B7C:  CLRF   x91
0B7E:  MOVLB  0
0B80:  RCALL  0898
.................... 
....................    // Enable the receive portion of the MAC
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN);
0B82:  MOVLB  3
0B84:  CLRF   x94
0B86:  MOVLW  0D
0B88:  MOVWF  x95
0B8A:  MOVLB  0
0B8C:  RCALL  083E
.................... 
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field.
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN);
0B8E:  MOVLW  02
0B90:  MOVLB  3
0B92:  MOVWF  x94
0B94:  MOVLW  32
0B96:  MOVWF  x95
0B98:  MOVLB  0
0B9A:  RCALL  083E
.................... 
....................     // Allow infinite deferals if the medium is continuously busy
....................     // (do not time out a transmission if the half duplex medium is
....................     // completely saturated with other people's data)
....................     WriteReg((BYTE)MACON4, MACON4_DEFER);
0B9C:  MOVLW  03
0B9E:  MOVLB  3
0BA0:  MOVWF  x94
0BA2:  MOVLW  40
0BA4:  MOVWF  x95
0BA6:  MOVLB  0
0BA8:  RCALL  083E
.................... 
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter)
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse
....................    // collisions will occur less often with a larger number.
....................     WriteReg((BYTE)MACLCON2, 63);
0BAA:  MOVLW  09
0BAC:  MOVLB  3
0BAE:  MOVWF  x94
0BB0:  MOVLW  3F
0BB2:  MOVWF  x95
0BB4:  MOVLB  0
0BB6:  RCALL  083E
.................... 
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called
....................    // later.
....................    WriteReg((BYTE)MAIPGL, 0x12);
0BB8:  MOVLW  06
0BBA:  MOVLB  3
0BBC:  MOVWF  x94
0BBE:  MOVLW  12
0BC0:  MOVWF  x95
0BC2:  MOVLB  0
0BC4:  RCALL  083E
....................    WriteReg((BYTE)MAIPGH, 0x0C);
0BC6:  MOVLW  07
0BC8:  MOVLB  3
0BCA:  MOVWF  x94
0BCC:  MOVLW  0C
0BCE:  MOVWF  x95
0BD0:  MOVLB  0
0BD2:  RCALL  083E
.................... 
....................    // Set the maximum packet size which the controller will accept
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC));
0BD4:  MOVLW  0A
0BD6:  MOVLB  3
0BD8:  MOVWF  x94
0BDA:  MOVLW  EE
0BDC:  MOVWF  x95
0BDE:  MOVLB  0
0BE0:  RCALL  083E
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC));
0BE2:  MOVLW  0B
0BE4:  MOVLB  3
0BE6:  MOVWF  x94
0BE8:  MOVLW  05
0BEA:  MOVWF  x95
0BEC:  MOVLB  0
0BEE:  RCALL  083E
.................... 
....................     // Enter Bank 3 and initialize physical MAC address registers
....................    BankSel(MAADR1);
0BF0:  MOVLW  03
0BF2:  MOVLB  3
0BF4:  MOVWF  x92
0BF6:  MOVLW  04
0BF8:  MOVWF  x91
0BFA:  MOVLB  0
0BFC:  RCALL  0898
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]);
0BFE:  MOVLW  04
0C00:  MOVLB  3
0C02:  MOVWF  x94
0C04:  MOVFF  21,395
0C08:  MOVLB  0
0C0A:  RCALL  083E
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]);
0C0C:  MOVLW  05
0C0E:  MOVLB  3
0C10:  MOVWF  x94
0C12:  MOVFF  22,395
0C16:  MOVLB  0
0C18:  RCALL  083E
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]);
0C1A:  MOVLW  02
0C1C:  MOVLB  3
0C1E:  MOVWF  x94
0C20:  MOVFF  23,395
0C24:  MOVLB  0
0C26:  RCALL  083E
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]);
0C28:  MOVLW  03
0C2A:  MOVLB  3
0C2C:  MOVWF  x94
0C2E:  MOVFF  24,395
0C32:  MOVLB  0
0C34:  RCALL  083E
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]);
0C36:  MOVLB  3
0C38:  CLRF   x94
0C3A:  MOVFF  25,395
0C3E:  MOVLB  0
0C40:  RCALL  083E
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]);
0C42:  MOVLW  01
0C44:  MOVLB  3
0C46:  MOVWF  x94
0C48:  MOVFF  26,395
0C4C:  MOVLB  0
0C4E:  RCALL  083E
.................... 
....................    // Get the Rev ID so that we can implement the correct errata workarounds
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val;
0C50:  MOVLW  12
0C52:  MOVLB  3
0C54:  MOVWF  x8E
0C56:  MOVLB  0
0C58:  RCALL  0800
0C5A:  MOVFF  01,5C
.................... 
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a
....................    // side effect.
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS);
0C5E:  MOVLW  10
0C60:  MOVLB  2
0C62:  MOVWF  xE5
0C64:  MOVLW  01
0C66:  MOVWF  xE7
0C68:  CLRF   xE6
0C6A:  MOVLB  0
0C6C:  RCALL  08FC
.................... 
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity
....................    SetLEDConfig(0x0472);
0C6E:  MOVLW  14
0C70:  MOVLB  2
0C72:  MOVWF  xE5
0C74:  MOVLW  04
0C76:  MOVWF  xE7
0C78:  MOVLW  72
0C7A:  MOVWF  xE6
0C7C:  MOVLB  0
0C7E:  RCALL  08FC
.................... 
....................    // Set the MAC and PHY into the proper duplex state
.................... #if defined(FULL_DUPLEX)
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected
.................... #elif defined(HALF_DUPLEX)
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected
0C80:  MOVLB  2
0C82:  CLRF   xE1
0C84:  MOVLB  0
0C86:  BRA    0A2A
.................... #else
....................    // Use the external LEDB polarity to determine weather full or half duplex
....................    // communication mode should be set.
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected
.................... #endif
.................... 
....................    // Enable packet reception
....................    BFSReg(ECON1, ECON1_RXEN);
0C88:  MOVLW  1F
0C8A:  MOVLB  3
0C8C:  MOVWF  x96
0C8E:  MOVLW  04
0C90:  MOVWF  x97
0C92:  MOVLB  0
0C94:  RCALL  087A
0C96:  GOTO   1080 (RETURN)
.................... }//end MACInit
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACIsLinked(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE: If the PHY reports that a link partner is present
....................  *                    and the link has been up continuously since the last
....................  *                    call to MACIsLinked()
....................  *               FALSE: If the PHY reports no link partner, or the link went
....................  *                     down momentarily since the last call to MACIsLinked()
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACIsLinked(void)
.................... {
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link
....................    // goes down and comes back up before a higher level stack program calls
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next
....................    // call to MACIsLinked() will return TRUE (unless the link goes down
....................    // again).
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT;
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit
....................  *                          FALSE: Check if a TX buffer is free
....................  *
....................  * Output:          TRUE: If no Ethernet transmission is in progress
....................  *               FALSE: If a previous transmission was started, and it has
....................  *                     not completed yet.  While FALSE, the data in the
....................  *                     transmit buffer and the TXST/TXND pointers must not
....................  *                     be changed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the ECON1.TXRTS bit
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACIsTxReady(BOOL HighPriority)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    BUFFER i;
.................... 
....................    if(HighPriority)
.................... #endif
....................    {
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS;
*
25F2:  MOVLW  1F
25F4:  MOVLB  3
25F6:  MOVWF  x8E
25F8:  MOVLB  0
25FA:  CALL   0800
25FE:  MOVFF  01,370
2602:  MOVLW  00
2604:  MOVLB  3
2606:  BTFSC  01.3
2608:  MOVLW  01
260A:  XORLW  00
260C:  BZ    2612
260E:  MOVLW  00
2610:  BRA    2614
2612:  MOVLW  01
2614:  MOVWF  01
....................    }
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
2616:  MOVLB  0
2618:  RETURN 0
.................... 
....................    // Check if the current buffer can be modified.  It cannot be modified if
....................    // the TX hardware is currently transmitting it.
....................    if(CurrentTxBuffer == LastTXedBuffer)
....................    {
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS;
....................    }
.................... 
....................    // Check if a buffer is available for a new packet
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++)
....................    {
....................       if(TxBuffers[i].Flags.bFree)
....................       {
....................          return TRUE;
....................       }
....................    }
.................... 
....................    return FALSE;
.................... #endif
.................... }
.................... 
.................... BUFFER MACGetTxBuffer(BOOL HighPriority)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    BUFFER i;
.................... 
....................    if(HighPriority)
.................... #endif
....................    {
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER;
*
1528:  MOVLW  1F
152A:  MOVLB  3
152C:  MOVWF  x8E
152E:  MOVLB  0
1530:  CALL   0800
1534:  MOVFF  01,370
1538:  MOVLW  00
153A:  MOVLB  3
153C:  BTFSC  01.3
153E:  MOVLW  01
1540:  XORLW  00
1542:  BNZ   1548
1544:  MOVLW  00
1546:  BRA    154A
1548:  MOVLW  FF
154A:  MOVWF  01
....................    }
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
154C:  MOVLB  0
154E:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for
....................    // high priority messages that don't need to be acknowledged
....................    // before being discarded (TCP control packets, all ICMP
....................    // packets, all UDP packets, etc.)
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++)
....................    {
....................       // If this buffer is free, then mark it as used and return with it
....................       if(TxBuffers[i].Flags.bFree)
....................       {
....................          TxBuffers[i].Flags.bFree = FALSE;
....................          TxBuffers[i].Flags.bTransmitted = FALSE;
....................          return i;
....................       }
....................    }
.................... 
....................    return INVALID_BUFFER;
.................... #endif
.................... }
.................... 
.................... 
.................... void MACDiscardTx(BUFFER buffer)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
*
0004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0]))
....................    {
....................        TxBuffers[buffer].Flags.bFree = TRUE;
....................        CurrentTxBuffer = buffer;
....................    }
.................... #endif
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACDiscardRx(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Marks the last received packet (obtained using
....................  *               MACGetHeader())as being processed and frees the buffer
....................  *               memory associated with it
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACDiscardRx(void)
.................... {
....................    WORD_VAL NewRXRDLocation;
.................... 
....................    // Make sure the current packet was not already discarded
....................    if( WasDiscarded )
*
1164:  BTFSS  5B.0
1166:  BRA    116A
....................       return;
1168:  BRA    11CE
....................    WasDiscarded = TRUE;
116A:  BSF    5B.0
.................... 
....................    // Decrement the next packet pointer before writing it into
....................    // the ERXRDPT registers.  This is a silicon errata workaround.
....................    // RX buffer wrapping must be taken into account if the
....................    // NextPacketLocation is precisely RXSTART.
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1;
116C:  MOVLW  01
116E:  SUBWF  57,W
1170:  MOVLB  3
1172:  MOVWF  x32
1174:  MOVLW  00
1176:  SUBWFB 58,W
1178:  MOVWF  x33
.................... #if RXSTART == 0
....................    if(NewRXRDLocation.Val > RXSTOP)
117A:  MOVF   x33,W
117C:  SUBLW  1A
117E:  BC    1192
1180:  XORLW  FF
1182:  BNZ   118A
1184:  MOVF   x32,W
1186:  SUBLW  F7
1188:  BC    1192
.................... #else
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP)
.................... #endif
....................    {
....................       NewRXRDLocation.Val = RXSTOP;
118A:  MOVLW  1B
118C:  MOVWF  x33
118E:  MOVLW  F7
1190:  MOVWF  x32
....................    }
.................... 
....................    // Decrement the RX packet counter register, EPKTCNT
....................    BFSReg(ECON2, ECON2_PKTDEC);
1192:  MOVLW  1E
1194:  MOVWF  x96
1196:  MOVLW  40
1198:  MOVWF  x97
119A:  MOVLB  0
119C:  CALL   087A
.................... 
....................    // Move the receive read pointer to unwrite-protect the memory used by the
....................    // last packet.  The writing order is important: set the low byte first,
....................    // high byte last.
....................    BankSel(ERXRDPTL);
11A0:  MOVLB  3
11A2:  CLRF   x92
11A4:  MOVLW  0C
11A6:  MOVWF  x91
11A8:  MOVLB  0
11AA:  CALL   0898
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]);
11AE:  MOVLW  0C
11B0:  MOVLB  3
11B2:  MOVWF  x94
11B4:  MOVFF  332,395
11B8:  MOVLB  0
11BA:  CALL   083E
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]);
11BE:  MOVLW  0D
11C0:  MOVLB  3
11C2:  MOVWF  x94
11C4:  MOVFF  333,395
11C8:  MOVLB  0
11CA:  CALL   083E
11CE:  RETURN 0
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACGetFreeRxSize(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          A WORD estimate of how much RX buffer space is free at
....................  *               the present time.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACGetFreeRxSize(void)
.................... {
....................    WORD_VAL ReadPT, WritePT;
.................... 
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be
....................    // received at any time, it can change between reading the low and high
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair
....................    // is read.
....................    BankSel(EPKTCNT);
*
261A:  MOVLW  01
261C:  MOVLB  3
261E:  MOVWF  x92
2620:  MOVLW  19
2622:  MOVWF  x91
2624:  MOVLB  0
2626:  CALL   0898
....................    do {
....................       // Save EPKTCNT in a temporary location
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val;
262A:  MOVLW  19
262C:  MOVLB  3
262E:  MOVWF  x8E
2630:  MOVLB  0
2632:  CALL   0800
2636:  MOVFF  01,36F
.................... 
....................       BankSel(ERXWRPTL);
263A:  MOVLB  3
263C:  CLRF   x92
263E:  MOVLW  0E
2640:  MOVWF  x91
2642:  MOVLB  0
2644:  CALL   0898
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val;
2648:  MOVLW  0E
264A:  MOVLB  3
264C:  MOVWF  x8E
264E:  MOVLB  0
2650:  CALL   0800
2654:  MOVFF  01,371
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val;
2658:  MOVLW  0F
265A:  MOVLB  3
265C:  MOVWF  x8E
265E:  MOVLB  0
2660:  CALL   0800
2664:  MOVFF  01,372
.................... 
....................       BankSel(EPKTCNT);
2668:  MOVLW  01
266A:  MOVLB  3
266C:  MOVWF  x92
266E:  MOVLW  19
2670:  MOVWF  x91
2672:  MOVLB  0
2674:  CALL   0898
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]);
2678:  MOVLW  19
267A:  MOVLB  3
267C:  MOVWF  x8E
267E:  MOVLB  0
2680:  CALL   0800
2684:  MOVFF  01,373
2688:  MOVLB  3
268A:  MOVF   x6F,W
268C:  SUBWF  01,W
268E:  BTFSC  FD8.2
2690:  BRA    2696
2692:  MOVLB  0
2694:  BRA    262A
.................... 
....................    // Determine where the write protection pointer is
....................    BankSel(ERXRDPTL);
2696:  CLRF   x92
2698:  MOVLW  0C
269A:  MOVWF  x91
269C:  MOVLB  0
269E:  CALL   0898
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val;
26A2:  MOVLW  0C
26A4:  MOVLB  3
26A6:  MOVWF  x8E
26A8:  MOVLB  0
26AA:  CALL   0800
26AE:  MOVFF  01,36F
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val;
26B2:  MOVLW  0D
26B4:  MOVLB  3
26B6:  MOVWF  x8E
26B8:  MOVLB  0
26BA:  CALL   0800
26BE:  MOVFF  01,370
.................... 
....................    // Calculate the difference between the pointers, taking care to account
....................    // for buffer wrapping conditions
....................    if ( WritePT.Val > ReadPT.Val )
26C2:  MOVLB  3
26C4:  MOVF   x70,W
26C6:  SUBWF  x72,W
26C8:  BNC   26F6
26CA:  BNZ   26D2
26CC:  MOVF   x71,W
26CE:  SUBWF  x6F,W
26D0:  BC    26F6
....................    {
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val);
26D2:  MOVF   x6F,W
26D4:  SUBWF  x71,W
26D6:  MOVWF  00
26D8:  MOVF   x70,W
26DA:  SUBWFB x72,W
26DC:  MOVWF  03
26DE:  MOVF   00,W
26E0:  XORLW  FF
26E2:  ADDLW  F8
26E4:  MOVWF  00
26E6:  MOVLW  1B
26E8:  SUBFWB 03,F
26EA:  MOVFF  00,01
26EE:  MOVFF  03,02
26F2:  BRA    272C
....................    }
26F4:  BRA    272C
....................    else if ( WritePT.Val == ReadPT.Val )
26F6:  MOVF   x6F,W
26F8:  SUBWF  x71,W
26FA:  BNZ   270E
26FC:  MOVF   x70,W
26FE:  SUBWF  x72,W
2700:  BNZ   270E
....................    {
....................       return RXSIZE - 1;
2702:  MOVLW  F7
2704:  MOVWF  01
2706:  MOVLW  1B
2708:  MOVWF  02
270A:  BRA    272C
....................    }
270C:  BRA    272C
....................    else
....................     {
....................       return ReadPT.Val - WritePT.Val - 1;
270E:  MOVF   x71,W
2710:  SUBWF  x6F,W
2712:  MOVWF  x73
2714:  MOVF   x72,W
2716:  SUBWFB x70,W
2718:  MOVWF  x74
271A:  MOVLW  01
271C:  SUBWF  x73,W
271E:  MOVWF  00
2720:  MOVLW  00
2722:  SUBWFB x74,W
2724:  MOVWF  03
2726:  MOVFF  00,01
272A:  MOVWF  02
....................    }
272C:  MOVLB  0
272E:  GOTO   29AA (RETURN)
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           *remote: Location to store the Source MAC address of the
....................  *                      received frame.
....................  *               *type: Location of a BYTE to store the constant
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing
....................  *                     the contents of the Ethernet type field.
....................  *
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The
....................  *                    remote, and type values are updated.
....................  *               FALSE: If a packet was not pending.  remote and type are
....................  *                     not changed.
....................  *
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already
....................  *               been called.
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
.................... {
....................    ENC_PREAMBLE header;
.................... 
....................    // Test if at least one packet has been received and is waiting
....................    BankSel(EPKTCNT);
*
1246:  MOVLW  01
1248:  MOVLB  3
124A:  MOVWF  x92
124C:  MOVLW  19
124E:  MOVWF  x91
1250:  MOVLB  0
1252:  CALL   0898
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0)
1256:  MOVLW  19
1258:  MOVLB  3
125A:  MOVWF  x8E
125C:  MOVLB  0
125E:  CALL   0800
1262:  MOVFF  01,2FE
1266:  MOVLB  2
1268:  MOVF   xFE,F
126A:  BNZ   1272
....................       return FALSE;
126C:  MOVLW  00
126E:  MOVWF  01
1270:  BRA    1384
.................... 
....................    // Make absolutely certain that any previous packet was discarded
....................    if(WasDiscarded == FALSE)
1272:  BTFSC  5B.0
1274:  BRA    1282
....................    {
....................       MACDiscardRx();
1276:  MOVLB  0
1278:  RCALL  1164
....................       return FALSE;
127A:  MOVLW  00
127C:  MOVWF  01
127E:  MOVLB  2
1280:  BRA    1384
....................    }
.................... 
....................    // Save the location of this packet
....................    CurrentPacketLocation.Val = NextPacketLocation.Val;
1282:  MOVFF  58,5A
1286:  MOVFF  57,59
.................... 
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet
....................    BankSel(ERDPTL);
128A:  MOVLB  3
128C:  CLRF   x92
128E:  CLRF   x91
1290:  MOVLB  0
1292:  CALL   0898
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]);
1296:  MOVLB  3
1298:  CLRF   x94
129A:  MOVFF  57,395
129E:  MOVLB  0
12A0:  CALL   083E
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]);
12A4:  MOVLW  01
12A6:  MOVLB  3
12A8:  MOVWF  x94
12AA:  MOVFF  58,395
12AE:  MOVLB  0
12B0:  CALL   083E
.................... 
....................    // Obtain the MAC header from the Ethernet buffer
....................    MACGetArray((BYTE*)&header, sizeof(header));
12B4:  MOVLW  02
12B6:  MOVLB  2
12B8:  MOVWF  xFF
12BA:  MOVLW  EA
12BC:  MOVWF  xFE
12BE:  MOVFF  2FF,37E
12C2:  MOVFF  FE8,37D
12C6:  MOVLB  3
12C8:  CLRF   x80
12CA:  MOVLW  14
12CC:  MOVWF  x7F
12CE:  MOVLB  0
12D0:  RCALL  11D0
.................... 
....................    // The EtherType field, like most items transmitted on the Ethernet medium
....................    // are in big endian.
....................     header.Type.Val = swaps(header.Type.Val);
12D2:  MOVFF  2FD,38F
12D6:  MOVFF  2FC,38E
12DA:  RCALL  1230
12DC:  MOVFF  02,2FD
12E0:  MOVFF  01,2FC
.................... 
....................    // Validate the data returned from the ENC28J60.  Random data corruption,
....................    // such as if a single SPI bit error occurs while communicating or a
....................    // momentary power glitch could cause this to occur in rare circumstances.
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 ||
....................       header.StatusVector.bits.Zero ||
....................       header.StatusVector.bits.CRCError ||
....................       header.StatusVector.bits.ByteCount > 1518 ||
....................       !header.StatusVector.bits.ReceiveOk)
12E4:  MOVLB  2
12E6:  MOVF   xEB,W
12E8:  SUBLW  1A
12EA:  BC    12F6
12EC:  XORLW  FF
12EE:  BNZ   1322
12F0:  MOVF   xEA,W
12F2:  SUBLW  F7
12F4:  BNC   1322
12F6:  MOVLW  02
12F8:  MOVWF  xFF
12FA:  MOVLW  EA
12FC:  MOVWF  FE9
12FE:  MOVFF  2FF,FEA
1302:  BTFSC  FEF.0
1304:  BRA    1322
1306:  BTFSC  xEF.7
1308:  BRA    1322
130A:  BTFSC  xEE.4
130C:  BRA    1322
130E:  MOVF   xED,W
1310:  SUBLW  04
1312:  BC    131E
1314:  XORLW  FF
1316:  BNZ   1322
1318:  MOVF   xEC,W
131A:  SUBLW  EE
131C:  BNC   1322
131E:  BTFSC  xEE.7
1320:  BRA    1324
....................    {
....................       //Reset();
....................       reset_cpu();
1322:  RESET
....................    }
.................... 
....................    // Save the location where the hardware will write the next packet to
....................    NextPacketLocation.Val = header.NextPacketPointer;
1324:  MOVFF  2EB,58
1328:  MOVFF  2EA,57
.................... 
....................    // Return the Ethernet frame's Source MAC address field to the caller
....................    // This parameter is useful for replying to requests without requiring an
....................    // ARP cycle.
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote));
132C:  MOVFF  2E6,01
1330:  MOVFF  2E7,03
1334:  MOVFF  01,2FE
1338:  MOVFF  03,2FF
133C:  MOVFF  03,FEA
1340:  MOVFF  01,FE9
1344:  MOVLW  02
1346:  MOVWF  FE2
1348:  MOVLW  F6
134A:  MOVWF  FE1
134C:  MOVLW  06
134E:  MOVWF  01
1350:  MOVFF  FE6,FEE
1354:  DECFSZ 01,F
1356:  BRA    1350
.................... 
....................    // Return a simplified version of the EtherType field to the caller
....................     *type = MAC_UNKNOWN;
1358:  MOVFF  2E9,FEA
135C:  MOVFF  2E8,FE9
1360:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) &&
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) )
1362:  MOVF   xFD,W
1364:  SUBLW  08
1366:  BNZ   137E
1368:  MOVF   xFC,F
136A:  BZ    1372
136C:  MOVF   xFC,W
136E:  SUBLW  06
1370:  BNZ   137E
....................     {
....................        *type = header.Type.v[0];
1372:  MOVFF  2E9,FEA
1376:  MOVFF  2E8,FE9
137A:  MOVFF  2FC,FEF
....................     }
.................... 
....................     // Mark this packet as discardable
....................     WasDiscarded = FALSE;
137E:  BCF    5B.0
....................    return TRUE;
1380:  MOVLW  01
1382:  MOVWF  01
1384:  MOVLB  0
1386:  GOTO   6C96 (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote,
....................  *                                    BYTE type,
....................  *                                   WORD dataLen)
....................  *
....................  * PreCondition:    MACIsTxReady() must return TRUE.
....................  *
....................  * Input:           *remote: Pointer to memory which contains the destination
....................  *                       MAC address (6 bytes)
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which
....................  *                    value to write into the Ethernet header's type field.
....................  *               dataLen: Length of the Ethernet data payload
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Because of the dataLen parameter, it is probably
....................  *               advantagous to call this function immediately before
....................  *               transmitting a packet rather than initially when the
....................  *               packet is first created.  The order in which the packet
....................  *               is constructed (header first or data first) is not
....................  *               important.
....................  *****************************************************************************/
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen)
.................... {
.................... 
....................    BankSel(EWRPTL);
*
1652:  MOVLB  3
1654:  CLRF   x92
1656:  MOVLW  02
1658:  MOVWF  x91
165A:  MOVLB  0
165C:  CALL   0898
.................... 
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    // Set the SPI write pointer to the beginning of the transmit buffer
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]);
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]);
.................... 
....................    // Calculate where to put the TXND pointer
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val;
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen;
.................... #else
....................    // Set the SPI write pointer to the beginning of the transmit buffer
....................    WriteReg(EWRPTL, LOW(TXSTART));
1660:  MOVLW  02
1662:  MOVLB  3
1664:  MOVWF  x94
1666:  MOVLW  F8
1668:  MOVWF  x95
166A:  MOVLB  0
166C:  CALL   083E
....................    WriteReg(EWRPTH, HIGH(TXSTART));
1670:  MOVLW  03
1672:  MOVLB  3
1674:  MOVWF  x94
1676:  MOVLW  1B
1678:  MOVWF  x95
167A:  MOVLB  0
167C:  CALL   083E
.................... 
....................    // Calculate where to put the TXND pointer
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART;
1680:  MOVLW  06
1682:  MOVLB  3
1684:  ADDWF  x8F,F
1686:  MOVLW  1C
1688:  ADDWFC x90,F
.................... 
....................    // Write the TXND pointer into the registers, given the dataLen given
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]);
168A:  MOVLW  03
168C:  MOVWF  x92
168E:  MOVLW  8F
1690:  MOVWF  x91
1692:  MOVWF  FE9
1694:  MOVFF  392,FEA
1698:  MOVFF  FEF,395
169C:  MOVLW  06
169E:  MOVWF  x94
16A0:  MOVLB  0
16A2:  CALL   083E
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]);
16A6:  MOVLW  03
16A8:  MOVLB  3
16AA:  MOVWF  x92
16AC:  MOVLW  8F
16AE:  MOVWF  x91
16B0:  MOVLW  01
16B2:  ADDWF  x91,W
16B4:  MOVWF  FE9
16B6:  MOVLW  00
16B8:  ADDWFC x92,W
16BA:  MOVWF  FEA
16BC:  MOVFF  FEF,395
16C0:  MOVLW  07
16C2:  MOVWF  x94
16C4:  MOVLB  0
16C6:  CALL   083E
.................... #endif
.................... 
.................... 
....................    // Set the per-packet control byte and write the Ethernet destination
....................    // address
....................    MACPut(0x00);   // Use default control configuration
16CA:  MOVLB  3
16CC:  CLRF   x92
16CE:  MOVLB  0
16D0:  RCALL  15EE
....................     MACPutArray((BYTE*)remote, sizeof(*remote));
16D2:  MOVFF  38D,394
16D6:  MOVFF  38C,393
16DA:  MOVLB  3
16DC:  CLRF   x96
16DE:  MOVLW  06
16E0:  MOVWF  x95
16E2:  MOVLB  0
16E4:  RCALL  160C
.................... 
....................    // Write our MAC address in the Ethernet source field
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr));
16E6:  MOVLB  3
16E8:  MOVLW  21
16EA:  MOVWF  x91
16EC:  CLRF   x94
16EE:  MOVWF  x93
16F0:  CLRF   x96
16F2:  MOVLW  06
16F4:  MOVWF  x95
16F6:  MOVLB  0
16F8:  RCALL  160C
.................... 
....................    // Write the appropriate Ethernet Type WORD for the protocol being used
....................     MACPut(0x08);
16FA:  MOVLW  08
16FC:  MOVLB  3
16FE:  MOVWF  x92
1700:  MOVLB  0
1702:  RCALL  15EE
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP);
1704:  MOVLB  3
1706:  MOVF   x8E,F
1708:  BNZ   170E
170A:  MOVLW  00
170C:  BRA    1710
170E:  MOVLW  06
1710:  MOVWF  x91
1712:  MOVWF  x92
1714:  MOVLB  0
1716:  RCALL  15EE
1718:  RETURN 0
.................... }
.................... 
.................... /******************************************************************************
....................  * Function:        void MACFlush(void)
....................  *
....................  * PreCondition:    A packet has been created by calling MACPut() and
....................  *               MACPutHeader().
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACFlush causes the current TX packet to be sent out on
....................  *               the Ethernet medium.  The hardware MAC will take control
....................  *               and handle CRC generation, collision retransmission and
....................  *               other details.
....................  *
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE),
....................  *               the packet can be modified and transmitted again by calling
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is
....................  *               called (in the TX data area), the data in the TX buffer
....................  *               will not be corrupted.
....................  *****************************************************************************/
.................... void MACFlush(void)
.................... {
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    // Set the packet start and end address pointers
....................    BankSel(ETXSTL);
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]);
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]);
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]);
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]);
....................    LastTXedBuffer = CurrentTxBuffer;
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE;
.................... #endif
.................... 
....................    // Reset transmit logic if a TX Error has previously occured
....................    // This is a silicon errata workaround
....................    if(ReadETHReg(EIR).EIRbits.TXERIF)
171A:  MOVLW  1C
171C:  MOVLB  3
171E:  MOVWF  x8E
1720:  MOVLB  0
1722:  CALL   0800
1726:  MOVFF  01,37B
172A:  MOVLW  00
172C:  MOVLB  3
172E:  BTFSC  01.1
1730:  MOVLW  01
1732:  XORLW  00
1734:  BZ    1756
....................    {
....................       BFSReg(ECON1, ECON1_TXRST);
1736:  MOVLW  1F
1738:  MOVWF  x96
173A:  MOVLW  80
173C:  MOVWF  x97
173E:  MOVLB  0
1740:  CALL   087A
....................       BFCReg(ECON1, ECON1_TXRST);
1744:  MOVLW  1F
1746:  MOVLB  3
1748:  MOVWF  x93
174A:  MOVLW  80
174C:  MOVWF  x94
174E:  MOVLB  0
1750:  CALL   085C
1754:  MOVLB  3
....................    }
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
1756:  MOVLW  1C
1758:  MOVWF  x93
175A:  MOVLW  0A
175C:  MOVWF  x94
175E:  MOVLB  0
1760:  CALL   085C
.................... 
....................    // Start the transmission
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet
....................    // can be modified and transmitted again by calling MACFlush() again.
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be
....................    // corrupted.
....................    BFSReg(ECON1, ECON1_TXRTS);
1764:  MOVLW  1F
1766:  MOVLB  3
1768:  MOVWF  x96
176A:  MOVLW  08
176C:  MOVWF  x97
176E:  MOVLB  0
1770:  CALL   087A
.................... 
....................    // Revision B5 silicon errata workaround
....................    if(ENCRevID == 0x05)
1774:  MOVF   5C,W
1776:  SUBLW  05
1778:  BTFSS  FD8.2
177A:  BRA    1940
....................    {
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)));
177C:  MOVLW  1C
177E:  MOVLB  3
1780:  MOVWF  x8E
1782:  MOVLB  0
1784:  CALL   0800
1788:  MOVFF  01,37B
178C:  MOVLB  3
178E:  MOVF   01,W
1790:  ANDLW  0A
1792:  BTFSS  FD8.2
1794:  BRA    179A
1796:  MOVLB  0
1798:  BRA    177C
....................       if(ReadETHReg(EIR).EIRbits.TXERIF)
179A:  MOVLW  1C
179C:  MOVWF  x8E
179E:  MOVLB  0
17A0:  CALL   0800
17A4:  MOVFF  01,37B
17A8:  MOVLW  00
17AA:  MOVLB  3
17AC:  BTFSC  01.1
17AE:  MOVLW  01
17B0:  XORLW  00
17B2:  BTFSC  FD8.2
17B4:  BRA    1942
....................       {
....................          WORD_VAL ReadPtrSave;
....................          WORD_VAL TXEnd;
....................          TXSTATUS TXStatus;
....................          BYTE i;
.................... 
....................          // Cancel the previous transmission if it has become stuck set
....................          BFCReg(ECON1, ECON1_TXRTS);
17B6:  MOVLW  1F
17B8:  MOVWF  x93
17BA:  MOVLW  08
17BC:  MOVWF  x94
17BE:  MOVLB  0
17C0:  CALL   085C
.................... 
....................          // Save the current read pointer (controlled by application)
....................          BankSel(ERDPTL);
17C4:  MOVLB  3
17C6:  CLRF   x92
17C8:  CLRF   x91
17CA:  MOVLB  0
17CC:  CALL   0898
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val;
17D0:  MOVLB  3
17D2:  CLRF   x8E
17D4:  MOVLB  0
17D6:  CALL   0800
17DA:  MOVFF  01,36F
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val;
17DE:  MOVLW  01
17E0:  MOVLB  3
17E2:  MOVWF  x8E
17E4:  MOVLB  0
17E6:  CALL   0800
17EA:  MOVFF  01,370
.................... 
....................          // Get the location of the transmit status vector
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val;
17EE:  MOVLW  06
17F0:  MOVLB  3
17F2:  MOVWF  x8E
17F4:  MOVLB  0
17F6:  CALL   0800
17FA:  MOVFF  01,371
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val;
17FE:  MOVLW  07
1800:  MOVLB  3
1802:  MOVWF  x8E
1804:  MOVLB  0
1806:  CALL   0800
180A:  MOVFF  01,372
....................          TXEnd.Val++;
180E:  MOVLB  3
1810:  INCF   x71,F
1812:  BTFSC  FD8.2
1814:  INCF   x72,F
.................... 
....................          // Read the transmit status vector
....................          WriteReg(ERDPTL, TXEnd.v[0]);
1816:  CLRF   x94
1818:  MOVFF  371,395
181C:  MOVLB  0
181E:  CALL   083E
....................          WriteReg(ERDPTH, TXEnd.v[1]);
1822:  MOVLW  01
1824:  MOVLB  3
1826:  MOVWF  x94
1828:  MOVFF  372,395
182C:  MOVLB  0
182E:  CALL   083E
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus));
1832:  MOVLW  03
1834:  MOVLB  3
1836:  MOVWF  x7C
1838:  MOVLW  73
183A:  MOVWF  x7B
183C:  MOVFF  37C,37E
1840:  MOVWF  x7D
1842:  CLRF   x80
1844:  MOVLW  07
1846:  MOVWF  x7F
1848:  MOVLB  0
184A:  RCALL  11D0
.................... 
....................          // Implement retransmission if a late collision occured (this can
....................          // happen on B5 when certain link pulses arrive at the same time
....................          // as the transmission)
....................          for(i = 0; i < 16; i++)
184C:  MOVLB  3
184E:  CLRF   x7A
1850:  MOVF   x7A,W
1852:  SUBLW  0F
1854:  BNC   1924
....................          {
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision)
1856:  MOVLW  1C
1858:  MOVWF  x8E
185A:  MOVLB  0
185C:  CALL   0800
1860:  MOVFF  01,37B
1864:  MOVLW  00
1866:  MOVLB  3
1868:  BTFSC  01.1
186A:  MOVLW  01
186C:  XORLW  00
186E:  BZ    191A
1870:  BTFSS  x76.5
1872:  BRA    191A
....................             {
....................                // Reset the TX logic
....................                BFSReg(ECON1, ECON1_TXRST);
1874:  MOVLW  1F
1876:  MOVWF  x96
1878:  MOVLW  80
187A:  MOVWF  x97
187C:  MOVLB  0
187E:  CALL   087A
....................                BFCReg(ECON1, ECON1_TXRST);
1882:  MOVLW  1F
1884:  MOVLB  3
1886:  MOVWF  x93
1888:  MOVLW  80
188A:  MOVWF  x94
188C:  MOVLB  0
188E:  CALL   085C
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
1892:  MOVLW  1C
1894:  MOVLB  3
1896:  MOVWF  x93
1898:  MOVLW  0A
189A:  MOVWF  x94
189C:  MOVLB  0
189E:  CALL   085C
.................... 
....................                // Transmit the packet again
....................                BFSReg(ECON1, ECON1_TXRTS);
18A2:  MOVLW  1F
18A4:  MOVLB  3
18A6:  MOVWF  x96
18A8:  MOVLW  08
18AA:  MOVWF  x97
18AC:  MOVLB  0
18AE:  CALL   087A
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)));
18B2:  MOVLW  1C
18B4:  MOVLB  3
18B6:  MOVWF  x8E
18B8:  MOVLB  0
18BA:  CALL   0800
18BE:  MOVFF  01,37B
18C2:  MOVLB  3
18C4:  MOVF   01,W
18C6:  ANDLW  0A
18C8:  BTFSS  FD8.2
18CA:  BRA    18D0
18CC:  MOVLB  0
18CE:  BRA    18B2
.................... 
....................                // Cancel the previous transmission if it has become stuck set
....................                BFCReg(ECON1, ECON1_TXRTS);
18D0:  MOVLW  1F
18D2:  MOVWF  x93
18D4:  MOVLW  08
18D6:  MOVWF  x94
18D8:  MOVLB  0
18DA:  CALL   085C
.................... 
....................                // Read transmit status vector
....................                WriteReg(ERDPTL, TXEnd.v[0]);
18DE:  MOVLB  3
18E0:  CLRF   x94
18E2:  MOVFF  371,395
18E6:  MOVLB  0
18E8:  CALL   083E
....................                WriteReg(ERDPTH, TXEnd.v[1]);
18EC:  MOVLW  01
18EE:  MOVLB  3
18F0:  MOVWF  x94
18F2:  MOVFF  372,395
18F6:  MOVLB  0
18F8:  CALL   083E
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus));
18FC:  MOVLW  03
18FE:  MOVLB  3
1900:  MOVWF  x7C
1902:  MOVLW  73
1904:  MOVWF  x7B
1906:  MOVFF  37C,37E
190A:  MOVWF  x7D
190C:  CLRF   x80
190E:  MOVLW  07
1910:  MOVWF  x7F
1912:  MOVLB  0
1914:  RCALL  11D0
....................             }
1916:  BRA    191E
1918:  MOVLB  3
....................             else
....................             {
....................                break;
191A:  BRA    1924
191C:  MOVLB  0
....................             }
191E:  MOVLB  3
1920:  INCF   x7A,F
1922:  BRA    1850
....................          }
.................... 
....................          // Restore the current read pointer
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]);
1924:  CLRF   x94
1926:  MOVFF  36F,395
192A:  MOVLB  0
192C:  CALL   083E
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]);
1930:  MOVLW  01
1932:  MOVLB  3
1934:  MOVWF  x94
1936:  MOVFF  370,395
193A:  MOVLB  0
193C:  CALL   083E
1940:  MOVLB  3
....................       }
....................    }
1942:  MOVLB  0
1944:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetRxBuffer(WORD offset)
....................  *
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and
....................  *               getting a TRUE result.
....................  *
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet
....................  *                     header's type field to relocate the SPI read and
....................  *                     write pointers.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SPI read and write pointers are updated.  All calls to
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(),
....................  *               and various other functions will use these new values.
....................  *
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for
....................  *               this function to work correctly.  In other words, do not
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory
....................  *               boundary.
....................  *****************************************************************************/
.................... void MACSetRxBuffer(WORD offset)
.................... {
....................    WORD_VAL ReadPT;
.................... 
....................    // Determine the address of the beginning of the entire packet
....................    // and adjust the address to the desired location
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset;
*
1C56:  MOVLW  14
1C58:  ADDWF  59,W
1C5A:  MOVLB  3
1C5C:  MOVWF  x1B
1C5E:  MOVLW  00
1C60:  ADDWFC 5A,W
1C62:  MOVWF  x1C
1C64:  MOVF   x17,W
1C66:  ADDWF  x1B,W
1C68:  MOVWF  x19
1C6A:  MOVF   x18,W
1C6C:  ADDWFC x1C,W
1C6E:  MOVWF  x1A
.................... 
....................    // Since the receive buffer is circular, adjust if a wraparound is needed
....................    if ( ReadPT.Val > RXSTOP )
1C70:  MOVF   x1A,W
1C72:  SUBLW  1A
1C74:  BC    1C88
1C76:  XORLW  FF
1C78:  BNZ   1C80
1C7A:  MOVF   x19,W
1C7C:  SUBLW  F7
1C7E:  BC    1C88
....................       ReadPT.Val -= RXSIZE;
1C80:  MOVLW  F8
1C82:  SUBWF  x19,F
1C84:  MOVLW  1B
1C86:  SUBWFB x1A,F
.................... 
....................    // Set the SPI read and write pointers to the new calculated value
....................    BankSel(ERDPTL);
1C88:  CLRF   x92
1C8A:  CLRF   x91
1C8C:  MOVLB  0
1C8E:  CALL   0898
....................    WriteReg(ERDPTL, ReadPT.v[0]);
1C92:  MOVLB  3
1C94:  CLRF   x94
1C96:  MOVFF  319,395
1C9A:  MOVLB  0
1C9C:  CALL   083E
....................    WriteReg(ERDPTH, ReadPT.v[1]);
1CA0:  MOVLW  01
1CA2:  MOVLB  3
1CA4:  MOVWF  x94
1CA6:  MOVFF  31A,395
1CAA:  MOVLB  0
1CAC:  CALL   083E
....................    WriteReg(EWRPTL, ReadPT.v[0]);
1CB0:  MOVLW  02
1CB2:  MOVLB  3
1CB4:  MOVWF  x94
1CB6:  MOVFF  319,395
1CBA:  MOVLB  0
1CBC:  CALL   083E
....................    WriteReg(EWRPTH, ReadPT.v[1]);
1CC0:  MOVLW  03
1CC2:  MOVLB  3
1CC4:  MOVWF  x94
1CC6:  MOVFF  31A,395
1CCA:  MOVLB  0
1CCC:  CALL   083E
1CD0:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this
....................  *                     parameter is not used.
....................  *               offset: WORD specifying how many bytes beyond the Ethernet
....................  *                     header's type field to relocate the SPI read and
....................  *                     write pointers.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SPI read and write pointers are updated.  All calls to
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(),
....................  *               and various other functions will use these new values.
....................  *
....................  * Note:         None
....................  *****************************************************************************/
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset)
.................... {
....................     CurrentTxBuffer = buffer;
*
1550:  MOVFF  388,52
.................... 
....................    // Calculate the proper address.  Since the TX memory area is not circular,
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of
....................    // the per packet control byte which preceeds the packet in the TX memory
....................    // area.
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER);
.................... #else
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER);
1554:  MOVLW  07
1556:  MOVLB  3
1558:  ADDWF  x89,F
155A:  MOVLW  1C
155C:  ADDWFC x8A,F
.................... #endif
.................... 
....................    // Set the SPI read and write pointers to the new calculated value
....................    BankSel(EWRPTL);
155E:  CLRF   x92
1560:  MOVLW  02
1562:  MOVWF  x91
1564:  MOVLB  0
1566:  CALL   0898
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]);
156A:  MOVLW  03
156C:  MOVLB  3
156E:  MOVWF  x8C
1570:  MOVLW  89
1572:  MOVWF  x8B
1574:  MOVWF  FE9
1576:  MOVFF  38C,FEA
157A:  MOVFF  FEF,395
157E:  CLRF   x94
1580:  MOVLB  0
1582:  CALL   083E
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]);
1586:  MOVLW  03
1588:  MOVLB  3
158A:  MOVWF  x8C
158C:  MOVLW  89
158E:  MOVWF  x8B
1590:  MOVLW  01
1592:  ADDWF  x8B,W
1594:  MOVWF  FE9
1596:  MOVLW  00
1598:  ADDWFC x8C,W
159A:  MOVWF  FEA
159C:  MOVFF  FEF,395
15A0:  MOVLW  01
15A2:  MOVWF  x94
15A4:  MOVLB  0
15A6:  CALL   083E
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]);
15AA:  MOVLW  03
15AC:  MOVLB  3
15AE:  MOVWF  x8C
15B0:  MOVLW  89
15B2:  MOVWF  x8B
15B4:  MOVWF  FE9
15B6:  MOVFF  38C,FEA
15BA:  MOVFF  FEF,395
15BE:  MOVLW  02
15C0:  MOVWF  x94
15C2:  MOVLB  0
15C4:  CALL   083E
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]);
15C8:  MOVLW  03
15CA:  MOVLB  3
15CC:  MOVWF  x8C
15CE:  MOVLW  89
15D0:  MOVWF  x8B
15D2:  MOVLW  01
15D4:  ADDWF  x8B,W
15D6:  MOVWF  FE9
15D8:  MOVLW  00
15DA:  ADDWFC x8C,W
15DC:  MOVWF  FEA
15DE:  MOVFF  FEF,395
15E2:  MOVLW  03
15E4:  MOVWF  x94
15E6:  MOVLB  0
15E8:  CALL   083E
15EC:  RETURN 0
.................... }
.................... 
.................... 
.................... #if defined(MCHP_MAC)
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate
.................... // checksums.  These two functions have been tested.
.................... /******************************************************************************
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           offset   - Number of bytes beyond the beginning of the
....................  *                     Ethernet data (first byte after the type field)
....................  *                     where the checksum should begin
....................  *               len      - Total number of bytes to include in the checksum
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself using the hardware DMA module
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACCalcRxChecksum(WORD offset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Add the offset requested by firmware plus the Ethernet header
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset;
*
1B4E:  MOVLW  14
1B50:  ADDWF  59,W
1B52:  MOVLB  3
1B54:  MOVWF  x45
1B56:  MOVLW  00
1B58:  ADDWFC 5A,W
1B5A:  MOVWF  x46
1B5C:  MOVF   x3F,W
1B5E:  ADDWF  x45,W
1B60:  MOVWF  x43
1B62:  MOVF   x40,W
1B64:  ADDWFC x46,W
1B66:  MOVWF  x44
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
1B68:  MOVF   x44,W
1B6A:  SUBLW  1A
1B6C:  BC    1B80
1B6E:  XORLW  FF
1B70:  BNZ   1B78
1B72:  MOVF   x43,W
1B74:  SUBLW  F7
1B76:  BC    1B80
....................    {
....................       temp.Val -= RXSIZE;
1B78:  MOVLW  F8
1B7A:  SUBWF  x43,F
1B7C:  MOVLW  1B
1B7E:  SUBWFB x44,F
....................    }
.................... 
....................    // Program the start address of the DMA
....................    BankSel(EDMASTL);
1B80:  CLRF   x92
1B82:  MOVLW  10
1B84:  MOVWF  x91
1B86:  MOVLB  0
1B88:  CALL   0898
....................    WriteReg(EDMASTL, temp.v[0]);
1B8C:  MOVLW  10
1B8E:  MOVLB  3
1B90:  MOVWF  x94
1B92:  MOVFF  343,395
1B96:  MOVLB  0
1B98:  CALL   083E
....................    WriteReg(EDMASTH, temp.v[1]);
1B9C:  MOVLW  11
1B9E:  MOVLB  3
1BA0:  MOVWF  x94
1BA2:  MOVFF  344,395
1BA6:  MOVLB  0
1BA8:  CALL   083E
.................... 
....................    // Calculate the end address, given the start address and len
....................    temp.Val += len-1;
1BAC:  MOVLW  01
1BAE:  MOVLB  3
1BB0:  SUBWF  x41,W
1BB2:  MOVWF  00
1BB4:  MOVLW  00
1BB6:  SUBWFB x42,W
1BB8:  MOVWF  03
1BBA:  MOVF   00,W
1BBC:  ADDWF  x43,F
1BBE:  MOVF   03,W
1BC0:  ADDWFC x44,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
1BC2:  MOVF   x44,W
1BC4:  SUBLW  1A
1BC6:  BC    1BDA
1BC8:  XORLW  FF
1BCA:  BNZ   1BD2
1BCC:  MOVF   x43,W
1BCE:  SUBLW  F7
1BD0:  BC    1BDA
....................    {
....................       temp.Val -= RXSIZE;
1BD2:  MOVLW  F8
1BD4:  SUBWF  x43,F
1BD6:  MOVLW  1B
1BD8:  SUBWFB x44,F
....................    }
.................... 
....................    // Program the end address of the DMA
....................    WriteReg(EDMANDL, temp.v[0]);
1BDA:  MOVLW  12
1BDC:  MOVWF  x94
1BDE:  MOVFF  343,395
1BE2:  MOVLB  0
1BE4:  CALL   083E
....................    WriteReg(EDMANDH, temp.v[1]);
1BE8:  MOVLW  13
1BEA:  MOVLB  3
1BEC:  MOVWF  x94
1BEE:  MOVFF  344,395
1BF2:  MOVLB  0
1BF4:  CALL   083E
.................... 
....................    // Do the checksum calculation
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
1BF8:  MOVLW  1F
1BFA:  MOVLB  3
1BFC:  MOVWF  x96
1BFE:  MOVLW  30
1C00:  MOVWF  x97
1C02:  MOVLB  0
1C04:  CALL   087A
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
1C08:  MOVLW  1F
1C0A:  MOVLB  3
1C0C:  MOVWF  x8E
1C0E:  MOVLB  0
1C10:  CALL   0800
1C14:  MOVFF  01,345
1C18:  MOVLW  00
1C1A:  MOVLB  3
1C1C:  BTFSC  01.5
1C1E:  MOVLW  01
1C20:  XORLW  00
1C22:  BTFSC  FD8.2
1C24:  BRA    1C2A
1C26:  MOVLB  0
1C28:  BRA    1C08
.................... 
....................    // Swap endianness and return
....................    temp.v[1] = ReadETHReg(EDMACSL).Val;
1C2A:  MOVLW  16
1C2C:  MOVWF  x8E
1C2E:  MOVLB  0
1C30:  CALL   0800
1C34:  MOVFF  01,344
....................    temp.v[0] = ReadETHReg(EDMACSH).Val;
1C38:  MOVLW  17
1C3A:  MOVLB  3
1C3C:  MOVWF  x8E
1C3E:  MOVLB  0
1C40:  CALL   0800
1C44:  MOVFF  01,343
....................    return temp.Val;
1C48:  MOVLB  3
1C4A:  MOVFF  343,01
1C4E:  MOVFF  344,02
1C52:  MOVLB  0
1C54:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           offset   - Number of bytes beyond the beginning of the
....................  *                     Ethernet data (first byte after the type field)
....................  *                     where the checksum should begin
....................  *               len      - Total number of bytes to include in the checksum
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself using the hardware DMA module
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACCalcTxChecksum(WORD offset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Program the start address of the DMA, after adjusting for the Ethernet
....................    // header
.................... #if MAC_TX_BUFFER_COUNT > 1
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER)
....................             + offset + 1;   // +1 needed to account for per packet control byte
.................... #else
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER)
....................             + offset + 1;   // +1 needed to account for per packet control byte
*
2732:  MOVLW  06
2734:  MOVLB  3
2736:  ADDWF  x88,W
2738:  MOVWF  x8E
273A:  MOVLW  1C
273C:  ADDWFC x89,W
273E:  MOVWF  x8F
2740:  MOVLW  01
2742:  ADDWF  x8E,W
2744:  MOVWF  x8C
2746:  MOVLW  00
2748:  ADDWFC x8F,W
274A:  MOVWF  x8D
.................... #endif
....................    BankSel(EDMASTL);
274C:  CLRF   x92
274E:  MOVLW  10
2750:  MOVWF  x91
2752:  MOVLB  0
2754:  CALL   0898
....................    WriteReg(EDMASTL, temp.v[0]);
2758:  MOVLW  10
275A:  MOVLB  3
275C:  MOVWF  x94
275E:  MOVFF  38C,395
2762:  MOVLB  0
2764:  CALL   083E
....................    WriteReg(EDMASTH, temp.v[1]);
2768:  MOVLW  11
276A:  MOVLB  3
276C:  MOVWF  x94
276E:  MOVFF  38D,395
2772:  MOVLB  0
2774:  CALL   083E
.................... 
....................    // Program the end address of the DMA.
....................    temp.Val += len-1;
2778:  MOVLW  01
277A:  MOVLB  3
277C:  SUBWF  x8A,W
277E:  MOVWF  00
2780:  MOVLW  00
2782:  SUBWFB x8B,W
2784:  MOVWF  03
2786:  MOVF   00,W
2788:  ADDWF  x8C,F
278A:  MOVF   03,W
278C:  ADDWFC x8D,F
....................    WriteReg(EDMANDL, temp.v[0]);
278E:  MOVLW  12
2790:  MOVWF  x94
2792:  MOVFF  38C,395
2796:  MOVLB  0
2798:  CALL   083E
....................    WriteReg(EDMANDH, temp.v[1]);
279C:  MOVLW  13
279E:  MOVLB  3
27A0:  MOVWF  x94
27A2:  MOVFF  38D,395
27A6:  MOVLB  0
27A8:  CALL   083E
.................... 
....................    // Do the checksum calculation
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
27AC:  MOVLW  1F
27AE:  MOVLB  3
27B0:  MOVWF  x96
27B2:  MOVLW  30
27B4:  MOVWF  x97
27B6:  MOVLB  0
27B8:  CALL   087A
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
27BC:  MOVLW  1F
27BE:  MOVLB  3
27C0:  MOVWF  x8E
27C2:  MOVLB  0
27C4:  CALL   0800
27C8:  MOVFF  01,38E
27CC:  MOVLW  00
27CE:  MOVLB  3
27D0:  BTFSC  01.5
27D2:  MOVLW  01
27D4:  XORLW  00
27D6:  BTFSC  FD8.2
27D8:  BRA    27DE
27DA:  MOVLB  0
27DC:  BRA    27BC
.................... 
....................    // Swap endianness and return
....................    temp.v[1] = ReadETHReg(EDMACSL).Val;
27DE:  MOVLW  16
27E0:  MOVWF  x8E
27E2:  MOVLB  0
27E4:  CALL   0800
27E8:  MOVFF  01,38D
....................    temp.v[0] = ReadETHReg(EDMACSH).Val;
27EC:  MOVLW  17
27EE:  MOVLB  3
27F0:  MOVWF  x8E
27F2:  MOVLB  0
27F4:  CALL   0800
27F8:  MOVFF  01,38C
....................    return temp.Val;
27FC:  MOVLB  3
27FE:  MOVFF  38C,01
2802:  MOVFF  38D,02
2806:  MOVLB  0
2808:  RETURN 0
.................... }
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD CalcIPBufferChecksum(WORD len)
....................  *
....................  * PreCondition:    Read buffer pointer set to starting of checksum data
....................  *
....................  * Input:           len: Total number of bytes to calculate the checksum over.
....................  *                   The first byte included in the checksum is the byte
....................  *                   pointed to by ERDPT, which is updated by calls to
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc.
....................  *
....................  * Output:          16-bit checksum as defined by rfc 793.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        This function performs a checksum calculation in the MAC
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module
....................  *               which can calculate the checksum faster than software, so
....................  *               this function replaces the CaclIPBufferChecksum() function
....................  *               defined in the helpers.c file.  Through the use of
....................  *               preprocessor defines, this replacement is automatic.
....................  *
....................  * Note:            This function works either in the RX buffer area or the TX
....................  *               buffer area.  No validation is done on the len parameter.
....................  *****************************************************************************/
.................... WORD CalcIPBufferChecksum(WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    // Take care of special cases which the DMA cannot be used for
....................    if(len == 0u)
*
1F9A:  MOVLB  3
1F9C:  MOVF   x6F,F
1F9E:  BNZ   1FAE
1FA0:  MOVF   x70,F
1FA2:  BNZ   1FAE
....................    {
....................       return 0xFFFF;
1FA4:  MOVLW  FF
1FA6:  MOVWF  01
1FA8:  MOVWF  02
1FAA:  BRA    20EE
....................    }
1FAC:  BRA    1FDC
....................    else if(len == 1u)
1FAE:  DECFSZ x6F,W
1FB0:  BRA    1FDC
1FB2:  MOVF   x70,F
1FB4:  BNZ   1FDC
....................    {
....................       return ~(((WORD)MACGet())<<8);
1FB6:  MOVLB  0
1FB8:  RCALL  1F6E
1FBA:  MOVLB  3
1FBC:  CLRF   x74
1FBE:  MOVFF  01,373
1FC2:  MOVFF  01,03
1FC6:  MOVLW  00
1FC8:  CLRF   00
1FCA:  DECF   00,F
1FCC:  XORWF  00,F
1FCE:  MOVLW  FF
1FD0:  XORWF  03,F
1FD2:  MOVFF  00,01
1FD6:  MOVFF  03,02
1FDA:  BRA    20EE
....................    }
.................... 
.................... 
....................    // Set the DMA starting address to the SPI read pointer value
....................    BankSel(ERDPTL);
1FDC:  CLRF   x92
1FDE:  CLRF   x91
1FE0:  MOVLB  0
1FE2:  CALL   0898
....................    temp.v[0] = ReadETHReg(ERDPTL).Val;
1FE6:  MOVLB  3
1FE8:  CLRF   x8E
1FEA:  MOVLB  0
1FEC:  CALL   0800
1FF0:  MOVFF  01,371
....................    temp.v[1] = ReadETHReg(ERDPTH).Val;
1FF4:  MOVLW  01
1FF6:  MOVLB  3
1FF8:  MOVWF  x8E
1FFA:  MOVLB  0
1FFC:  CALL   0800
2000:  MOVFF  01,372
....................    WriteReg(EDMASTL, temp.v[0]);
2004:  MOVLW  10
2006:  MOVLB  3
2008:  MOVWF  x94
200A:  MOVFF  371,395
200E:  MOVLB  0
2010:  CALL   083E
....................    WriteReg(EDMASTH, temp.v[1]);
2014:  MOVLW  11
2016:  MOVLB  3
2018:  MOVWF  x94
201A:  MOVFF  372,395
201E:  MOVLB  0
2020:  CALL   083E
.................... 
....................    // See if we are calculating a checksum within the RX buffer (where
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are
....................    // not applied)
.................... #if RXSTART == 0
....................    if(temp.Val <= RXSTOP)
2024:  MOVLB  3
2026:  MOVF   x72,W
2028:  SUBLW  1B
202A:  BNC   2062
202C:  BNZ   2034
202E:  MOVF   x71,W
2030:  SUBLW  F7
2032:  BNC   2062
.................... #else
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP)
.................... #endif
....................    {
....................       // Calculate the DMA ending address given the starting address and len
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary.
....................       temp.Val += len-1;
2034:  MOVLW  01
2036:  SUBWF  x6F,W
2038:  MOVWF  00
203A:  MOVLW  00
203C:  SUBWFB x70,W
203E:  MOVWF  03
2040:  MOVF   00,W
2042:  ADDWF  x71,F
2044:  MOVF   03,W
2046:  ADDWFC x72,F
....................       if(temp.Val > RXSTOP)
2048:  MOVF   x72,W
204A:  SUBLW  1A
204C:  BC    2060
204E:  XORLW  FF
2050:  BNZ   2058
2052:  MOVF   x71,W
2054:  SUBLW  F7
2056:  BC    2060
....................       {
....................          temp.Val -= RXSIZE;
2058:  MOVLW  F8
205A:  SUBWF  x71,F
205C:  MOVLW  1B
205E:  SUBWFB x72,F
....................       }
....................    }
2060:  BRA    2076
....................    else
....................    {
....................       temp.Val += len-1;
2062:  MOVLW  01
2064:  SUBWF  x6F,W
2066:  MOVWF  00
2068:  MOVLW  00
206A:  SUBWFB x70,W
206C:  MOVWF  03
206E:  MOVF   00,W
2070:  ADDWF  x71,F
2072:  MOVF   03,W
2074:  ADDWFC x72,F
....................    }
.................... 
....................    // Write the DMA end address
....................    WriteReg(EDMANDL, temp.v[0]);
2076:  MOVLW  12
2078:  MOVWF  x94
207A:  MOVFF  371,395
207E:  MOVLB  0
2080:  CALL   083E
....................    WriteReg(EDMANDH, temp.v[1]);
2084:  MOVLW  13
2086:  MOVLB  3
2088:  MOVWF  x94
208A:  MOVFF  372,395
208E:  MOVLB  0
2090:  CALL   083E
.................... 
....................    // Begin the DMA checksum calculation and wait until it is finished
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
2094:  MOVLW  1F
2096:  MOVLB  3
2098:  MOVWF  x96
209A:  MOVLW  30
209C:  MOVWF  x97
209E:  MOVLB  0
20A0:  CALL   087A
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
20A4:  MOVLW  1F
20A6:  MOVLB  3
20A8:  MOVWF  x8E
20AA:  MOVLB  0
20AC:  CALL   0800
20B0:  MOVFF  01,373
20B4:  MOVLW  00
20B6:  MOVLB  3
20B8:  BTFSC  01.5
20BA:  MOVLW  01
20BC:  XORLW  00
20BE:  BTFSC  FD8.2
20C0:  BRA    20C6
20C2:  MOVLB  0
20C4:  BRA    20A4
.................... 
....................    // Return the resulting good stuff
....................    temp.v[0] = ReadETHReg(EDMACSL).Val;
20C6:  MOVLW  16
20C8:  MOVWF  x8E
20CA:  MOVLB  0
20CC:  CALL   0800
20D0:  MOVFF  01,371
....................    temp.v[1] = ReadETHReg(EDMACSH).Val;
20D4:  MOVLW  17
20D6:  MOVLB  3
20D8:  MOVWF  x8E
20DA:  MOVLB  0
20DC:  CALL   0800
20E0:  MOVFF  01,372
....................    return temp.Val;
20E4:  MOVLB  3
20E6:  MOVFF  371,01
20EA:  MOVFF  372,02
20EE:  MOVLB  0
20F0:  RETURN 0
.................... }
.................... #endif   // End of MCHP_MAC specific code
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of
....................  *                        destination MAC address) to copy from.
....................  *               TxOffset: Offset in the TX buffer (0=first byte of
....................  *                       destination MAC address) to copy to.
....................  *               len:     Number of bytes to copy
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is
....................  *               set), the hardware will wait until it is finished.  Then,
....................  *               the DMA module will copy the data from the receive buffer
....................  *               to the transmit buffer.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... // Remove this line if your application needs to use this
.................... // function.  This code has NOT been tested.
.................... #if 0
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len)
.................... {
....................    WORD_VAL temp;
.................... 
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE);
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
....................       temp.Val -= RXSIZE;
.................... 
....................    BankSel(EDMASTL);
....................    WriteReg(EDMASTL, temp.v[0]);
....................    WriteReg(EDMASTH, temp.v[1]);
.................... 
....................    temp.Val += len-1;
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed
....................       temp.Val -= RXSIZE;
.................... 
....................    WriteReg(EDMANDL, temp.v[0]);
....................    WriteReg(EDMANDH, temp.v[1]);
.................... 
....................    TxOffset += TXSTART+1;
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]);
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]);
.................... 
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear
....................    // before starting the copy.
....................    BFCReg(ECON1, ECON1_CSUMEN);
....................    BFSReg(ECON1, ECON1_DMAST);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... }
.................... #endif
.................... 
.................... 
.................... #if defined(MAC_FILTER_BROADCASTS)
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation
.................... // of MAC_FILTER_BROADCASTS.
.................... /******************************************************************************
....................  * Function:        void MACSetPMFilter(BYTE *Pattern,
....................  *                              BYTE *PatternMask,
....................  *                              WORD PatternOffset)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                MACIsTxReady() must return TRUE
....................  *
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which
....................  *                          defines which bytes of the pattern are
....................  *                          important.  At least one bit must be set.
....................  *               PatternOffset: Offset from the beginning of the Ethernet
....................  *                           frame (1st byte of destination address), to
....................  *                           begin comparing with the given pattern.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Contents of the TX buffer space are overwritten
....................  *
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for:
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a
....................  *               subset of the broadcast packets which are normally
....................  *               received will be received.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACSetPMFilter(BYTE *Pattern,
....................                BYTE *PatternMask,
....................                WORD PatternOffset)
.................... {
....................    WORD_VAL i;
....................    BYTE *MaskPtr;
....................    BYTE UnmaskedPatternLen;
.................... 
....................    // Set the SPI write pointer and DMA startting address to the beginning of
....................    // the transmit buffer
....................    BankSel(EWRPTL);
....................    WriteReg(EWRPTL, LOW(TXSTART));
....................    WriteReg(EWRPTH, HIGH(TXSTART));
....................    WriteReg(EDMASTL, LOW(TXSTART));
....................    WriteReg(EDMASTH, HIGH(TXSTART));
.................... 
....................    // Fill the transmit buffer with the pattern to match against.  Only the
....................    // bytes which have a mask bit of 1 are written into the buffer and will
....................    // subsequently be used for checksum computation.
....................    MaskPtr = PatternMask;
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++)
....................    {
....................       if( *MaskPtr & i.v[1] )
....................       {
....................          MACPut(*Pattern);
....................          UnmaskedPatternLen++;
....................       }
....................       Pattern++;
.................... 
....................       i.v[1] <<= 1;
....................       if( i.v[1] == 0u )
....................       {
....................          i.v[1] = 0x01;
....................          MaskPtr++;
....................       }
....................    }
.................... 
....................    // Calculate and set the DMA end address
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1;
....................    WriteReg(EDMANDL, i.v[0]);
....................    WriteReg(EDMANDH, i.v[1]);
.................... 
....................    // Calculate the checksum on the given pattern using the DMA module
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Make certain that the PM filter isn't enabled while it is
....................    // being reconfigured.
....................    BankSel(ERXFCON);
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);
.................... 
....................    // Get the calculated DMA checksum and store it in the PM
....................    // checksum registers
....................    i.v[0] == ReadETHReg(EDMACSL).Val;
....................    i.v[1] == ReadETHReg(EDMACSH).Val;
....................    WriteReg(EPMCSL, i.v[0]);
....................    WriteReg(EPMCSH, i.v[0]);
.................... 
....................    // Set the Pattern Match offset and 8 byte mask
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]);
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]);
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++)
....................    {
....................       WriteReg(i.Val, *PatternMask++);
....................    }
.................... 
....................    // Begin using the new Pattern Match filter instead of the
....................    // broadcast filter
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN);
.................... }//end MACSetPMFilter
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACDisablePMFilter(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive
....................  *               filter (if enabled) and returns to the default filter
....................  *               configuration of: CRC AND (Unicast OR Broadcast).
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACDisablePMFilter(void)
.................... {
....................    BankSel(ERXFCON);
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN);
....................    return;
.................... }//end MACDisablePMFilter
.................... #endif // end of MAC_FILTER_BROADCASTS specific code
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BYTE MACGet()
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                ERDPT must point to the place to read from.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Byte read from the ENC28J60's RAM
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and
....................  *               increments ERDPT so MACGet() can be called again.  The
....................  *               increment will follow the receive buffer wrapping boundary.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BYTE MACGet()
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = RBM;
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = 0;            // Send a dummy byte to receive the register
....................                      //   contents.
....................    while(!PIR1_SSPIF);      // Wait until register is received.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... 
....................    return SSPBUF;
.................... */
....................    char c;
.................... 
....................    SPISelectEthernet();
*
1F6E:  BCF    F93.2
1F70:  BCF    F8A.2
....................    ENCSPIXfer(RBM);
1F72:  MOVLW  3A
1F74:  MOVLB  3
1F76:  MOVWF  x99
1F78:  MOVLB  0
1F7A:  CALL   07F0
....................    c=ENCSPIXfer(0);
1F7E:  MOVLB  3
1F80:  CLRF   x99
1F82:  MOVLB  0
1F84:  CALL   07F0
1F88:  MOVFF  01,373
....................    SPIUnselectEthernet();
1F8C:  BCF    F93.2
1F8E:  BSF    F8A.2
....................    return(c);
1F90:  MOVLB  3
1F92:  MOVFF  373,01
1F96:  MOVLB  0
1F98:  RETURN 0
.................... }//end MACGet
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                ERDPT must point to the place to read from.
....................  *
....................  * Input:           *val: Pointer to storage location
....................  *               len:  Number of bytes to read from the data buffer.
....................  *
....................  * Output:          Byte(s) of data read from the data buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Burst reads several sequential bytes from the data buffer
....................  *               and places them into local memory.  With SPI burst support,
....................  *               it performs much faster than multiple MACGet() calls.
....................  *               ERDPT is incremented after each byte, following the same
....................  *               rules as MACGet().
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... WORD MACGetArray(BYTE *val, WORD len)
*
11D0:  MOVLB  3
11D2:  CLRF   x82
11D4:  CLRF   x81
.................... {
.................... /*
....................    int16 i;
.................... 
....................    // Start the burst operation
....................    SPISelectEthernet();
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode.
....................    i = 0;
....................    val--;
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    // Read the data
....................    while(i<len)
....................    {
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte
....................       i++;
....................       val++;
....................       while(!PIR1_SSPIF);   // Wait until byte is received.
....................       PIR1_SSPIF = 0;
....................       *val = SSPBUF;
....................    };
.................... 
....................    // Terminate the burst operation
....................    SPIUnselectEthernet();
.................... 
....................    return i;
.................... */
.................... 
....................    int16 i=0;
.................... 
....................    SPISelectEthernet();
11D6:  BCF    F93.2
11D8:  BCF    F8A.2
....................    ENCSPIXfer(RBM);
11DA:  MOVLW  3A
11DC:  MOVWF  x99
11DE:  MOVLB  0
11E0:  CALL   07F0
....................    while(i<len)
11E4:  MOVLB  3
11E6:  MOVF   x82,W
11E8:  SUBWF  x80,W
11EA:  BNC   1220
11EC:  BNZ   11F4
11EE:  MOVF   x7F,W
11F0:  SUBWF  x81,W
11F2:  BC    1220
....................    {
....................       *val=ENCSPIXfer(0);
11F4:  MOVFF  37E,384
11F8:  MOVFF  37D,383
11FC:  CLRF   x99
11FE:  MOVLB  0
1200:  CALL   07F0
1204:  MOVFF  384,FEA
1208:  MOVFF  383,FE9
120C:  MOVFF  01,FEF
....................       val++;
1210:  MOVLB  3
1212:  INCF   x7D,F
1214:  BTFSC  FD8.2
1216:  INCF   x7E,F
....................       i++;
1218:  INCF   x81,F
121A:  BTFSC  FD8.2
121C:  INCF   x82,F
121E:  BRA    11E6
....................    }
....................    SPIUnselectEthernet();
1220:  BCF    F93.2
1222:  BSF    F8A.2
.................... 
....................    return(i);
1224:  MOVFF  381,01
1228:  MOVFF  382,02
122C:  MOVLB  0
122E:  RETURN 0
.................... }//end MACGetArray
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPut(BYTE val)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                EWRPT must point to the location to begin writing.
....................  *
....................  * Input:           Byte to write into the ENC28J60 buffer memory
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant
....................  *               (8 bits) and data to write (8 bits) over the SPI.
....................  *               EWRPT is incremented after the write.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACPut(BYTE val)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = WBM;         // Send the opcode and constant.
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = val;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
15EE:  BCF    F93.2
15F0:  BCF    F8A.2
....................    ENCSPIXfer(WBM);
15F2:  MOVLW  7A
15F4:  MOVLB  3
15F6:  MOVWF  x99
15F8:  MOVLB  0
15FA:  CALL   07F0
....................    ENCSPIXfer(val);
15FE:  MOVFF  392,399
1602:  CALL   07F0
....................    SPIUnselectEthernet();
1606:  BCF    F93.2
1608:  BSF    F8A.2
160A:  RETURN 0
.................... }//end MACPut
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPutArray(BYTE *val, WORD len)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                EWRPT must point to the location to begin writing.
....................  *
....................  * Input:           *val: Pointer to source of bytes to copy.
....................  *               len:  Number of bytes to write to the data buffer.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPutArray writes several sequential bytes to the
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut()
....................  *               calls.  EWRPT is incremented by len.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void MACPutArray(BYTE *val, WORD len)
.................... {
.................... /*
....................    // Select the chip and send the proper opcode
....................    SPISelectEthernet();
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    // Send the data
....................    while(len)
....................    {
....................       SSPBUF = *val;      // Start sending the byte
....................       val++;            // Increment after writing to SSPBUF to increase speed
....................       len--;            // Decrement after writing to SSPBUF to increase speed
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted
....................       PIR1_SSPIF = 0;
....................    };
.................... 
....................    // Terminate the burst operation
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
160C:  BCF    F93.2
160E:  BCF    F8A.2
....................    ENCSPIXfer(WBM);
1610:  MOVLW  7A
1612:  MOVLB  3
1614:  MOVWF  x99
1616:  MOVLB  0
1618:  CALL   07F0
....................    while(len--)
161C:  MOVLB  3
161E:  MOVFF  396,03
1622:  MOVF   x95,W
1624:  BTFSC  FD8.2
1626:  DECF   x96,F
1628:  DECF   x95,F
162A:  IORWF  03,W
162C:  BZ    164A
....................    {
....................       ENCSPIXfer(*val);
162E:  MOVFF  394,FEA
1632:  MOVFF  393,FE9
1636:  MOVFF  FEF,399
163A:  MOVLB  0
163C:  CALL   07F0
....................       val++;
1640:  MOVLB  3
1642:  INCF   x93,F
1644:  BTFSC  FD8.2
1646:  INCF   x94,F
1648:  BRA    161E
....................    }
....................    SPIUnselectEthernet();
164A:  BCF    F93.2
164C:  BSF    F8A.2
164E:  MOVLB  0
1650:  RETURN 0
.................... }//end MACPutArray
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        static void SendSystemReset(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        SendSystemReset sends the System Reset SPI command to
....................  *               the Ethernet controller.  It resets all register contents
....................  *               (except for ECOCON) and returns the device to the power
....................  *               on default state.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... static void SendSystemReset(void)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = SR;
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
082A:  BCF    F93.2
082C:  BCF    F8A.2
....................    ENCSPIXfer(SR);
082E:  MOVLB  3
0830:  SETF   x99
0832:  MOVLB  0
0834:  RCALL  07F0
....................    SPIUnselectEthernet();
0836:  BCF    F93.2
0838:  BSF    F8A.2
083A:  GOTO   0AF8 (RETURN)
.................... }//end SendSystemReset
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        REG ReadETHReg(BYTE Address)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                to read from.
....................  *
....................  * Input:           5 bit address of the ETH control register to read from.
....................  *                 The top 3 bits must be 0.
....................  *
....................  * Output:          Byte read from the Ethernet controller's ETH register.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over
....................  *               the SPI and then retrives the register contents in the
....................  *               next 8 SPI clocks.
....................  *
....................  * Note:            This routine cannot be used to access MAC/MII or PHY
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that
....................  *               purpose.
....................  *****************************************************************************/
.................... static REG ReadETHReg(BYTE Address)
.................... {
....................    char c;
.................... /*
....................    // Select the chip and send the Read Control Register opcode/address
....................    SPISelectEthernet();
....................    SSPBUF = RCR | Address;
.................... 
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted
....................    PIR1_SSPIF = 0;
....................    SSPBUF = 0;            // Send a dummy byte to receive the register
....................                      //   contents
....................    while(!PIR1_SSPIF);      // Wait until the register is received
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... 
....................    return *((REG*)&SSPBUF);
....................    */
.................... 
....................    SPISelectEthernet();
*
0800:  BCF    F93.2
0802:  BCF    F8A.2
....................    ENCSPIXfer(RCR | Address);
0804:  MOVFF  38E,390
0808:  MOVFF  38E,399
080C:  MOVLB  0
080E:  RCALL  07F0
....................    c=ENCSPIXfer(0);
0810:  MOVLB  3
0812:  CLRF   x99
0814:  MOVLB  0
0816:  RCALL  07F0
0818:  MOVFF  01,38F
....................    SPIUnselectEthernet();
081C:  BCF    F93.2
081E:  BSF    F8A.2
....................    return(c);
0820:  MOVLB  3
0822:  MOVFF  38F,01
0826:  MOVLB  0
0828:  RETURN 0
.................... }//end ReadETHReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        REG ReadMACReg(BYTE Address)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                to read from.
....................  *
....................  * Input:           5 bit address of the MAC or MII register to read from.
....................  *                 The top 3 bits must be 0.
....................  *
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well
....................  *               as a dummy byte over the SPI and then retrives the
....................  *               register contents in the last 8 SPI clocks.
....................  *
....................  * Note:            This routine cannot be used to access ETH or PHY
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that
....................  *               purpose.
....................  *****************************************************************************/
.................... static REG ReadMACReg(BYTE Address)
.................... {
....................    char c;
.................... /*
....................    SPISelectEthernet();
.................... 
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and
....................                      //   address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
.................... 
....................    SSPBUF = 0;            // Send a dummy byte
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted
....................    PIR1_SSPIF = 0;
.................... 
....................    SSPBUF = 0;            // Send another dummy byte to receive the register
....................                      //   contents.
....................    while(!PIR1_SSPIF);      // Wait until register is received.
....................    PIR1_SSPIF = 0;
.................... 
....................    SPIUnselectEthernet();
.................... 
....................    return *((REG*)&SSPBUF);
.................... */
....................    SPISelectEthernet();
*
08CA:  BCF    F93.2
08CC:  BCF    F8A.2
.................... 
....................    ENCSPIXfer(RCR | Address);
08CE:  MOVFF  2E8,2EA
08D2:  MOVFF  2E8,399
08D6:  MOVLB  0
08D8:  RCALL  07F0
....................    ENCSPIXfer(0);
08DA:  MOVLB  3
08DC:  CLRF   x99
08DE:  MOVLB  0
08E0:  RCALL  07F0
....................    c=ENCSPIXfer(0);
08E2:  MOVLB  3
08E4:  CLRF   x99
08E6:  MOVLB  0
08E8:  RCALL  07F0
08EA:  MOVFF  01,2E9
.................... 
....................    SPIUnselectEthernet();
08EE:  BCF    F93.2
08F0:  BSF    F8A.2
.................... 
....................    return(c);
08F2:  MOVLB  2
08F4:  MOVFF  2E9,01
08F8:  MOVLB  0
08FA:  RETURN 0
.................... }//end ReadMACReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        ReadPHYReg
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Address of the PHY register to read from.
....................  *
....................  * Output:          16 bits of data read from the PHY register.
....................  *
....................  * Side Effects:    Alters bank bits to point to Bank 2
....................  *
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in
....................  *               progress, it simply polls the MII BUSY bit wasting time.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... PHYREG ReadPHYReg(BYTE Register)
.................... {
....................    PHYREG Result;
.................... 
....................    // Set the right address and start the register read operation
....................    BankSel(MIREGADR);
*
098C:  MOVLW  02
098E:  MOVLB  3
0990:  MOVWF  x92
0992:  MOVLW  14
0994:  MOVWF  x91
0996:  MOVLB  0
0998:  RCALL  0898
....................    WriteReg(MIREGADR, Register);
099A:  MOVLW  14
099C:  MOVLB  3
099E:  MOVWF  x94
09A0:  MOVFF  2E5,395
09A4:  MOVLB  0
09A6:  RCALL  083E
....................    WriteReg(MICMD, MICMD_MIIRD);
09A8:  MOVLW  12
09AA:  MOVLB  3
09AC:  MOVWF  x94
09AE:  MOVLW  01
09B0:  MOVWF  x95
09B2:  MOVLB  0
09B4:  RCALL  083E
.................... 
....................    // Loop to wait until the PHY register has been read through the MII
....................    // This requires 10.24us
....................    BankSel(MISTAT);
09B6:  MOVLW  03
09B8:  MOVLB  3
09BA:  MOVWF  x92
09BC:  MOVLW  0A
09BE:  MOVWF  x91
09C0:  MOVLB  0
09C2:  RCALL  0898
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY);
09C4:  MOVLW  0A
09C6:  MOVLB  2
09C8:  MOVWF  xE8
09CA:  MOVLB  0
09CC:  RCALL  08CA
09CE:  MOVFF  01,2E8
09D2:  MOVLW  00
09D4:  MOVLB  2
09D6:  BTFSC  01.0
09D8:  MOVLW  01
09DA:  XORLW  00
09DC:  BTFSC  FD8.2
09DE:  BRA    09E4
09E0:  MOVLB  0
09E2:  BRA    09C4
.................... 
....................    // Stop reading
....................    BankSel(MIREGADR);
09E4:  MOVLW  02
09E6:  MOVLB  3
09E8:  MOVWF  x92
09EA:  MOVLW  14
09EC:  MOVWF  x91
09EE:  MOVLB  0
09F0:  RCALL  0898
....................    WriteReg(MICMD, 0x00);
09F2:  MOVLW  12
09F4:  MOVLB  3
09F6:  MOVWF  x94
09F8:  CLRF   x95
09FA:  MOVLB  0
09FC:  RCALL  083E
.................... 
....................    // Obtain results and return
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val;
09FE:  MOVLW  18
0A00:  MOVLB  2
0A02:  MOVWF  xE8
0A04:  MOVLB  0
0A06:  RCALL  08CA
0A08:  MOVFF  01,2E6
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val;
0A0C:  MOVLW  19
0A0E:  MOVLB  2
0A10:  MOVWF  xE8
0A12:  MOVLB  0
0A14:  RCALL  08CA
0A16:  MOVFF  01,2E7
....................    return Result;
0A1A:  MOVLB  2
0A1C:  MOVFF  2E6,01
0A20:  MOVFF  2E7,02
0A24:  MOVLB  0
0A26:  GOTO   0A40 (RETURN)
.................... }//end ReadPHYReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void WriteReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *               to modify.
....................  *
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify.
....................  *                 The top 3 bits must be 0.
....................  *               Byte to be written into the register.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the
....................  *               SPI and then sends the data to write in the next 8 SPI
....................  *               clocks.
....................  *
....................  * Note:            This routine is almost identical to the BFCReg() and
....................  *               BFSReg() functions.  It is seperate to maximize speed.
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg()
....................  *               can write to any ETH or MAC register.  Writing to PHY
....................  *               registers must be accomplished with WritePHYReg().
....................  *****************************************************************************/
.................... static void WriteReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = WCR | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
*
083E:  BCF    F93.2
0840:  BCF    F8A.2
....................    ENCSPIXfer(WCR | Address);
0842:  MOVLB  3
0844:  MOVF   x94,W
0846:  IORLW  40
0848:  MOVWF  x96
084A:  MOVWF  x99
084C:  MOVLB  0
084E:  RCALL  07F0
....................    ENCSPIXfer(Data);
0850:  MOVFF  395,399
0854:  RCALL  07F0
....................    SPIUnselectEthernet();
0856:  BCF    F93.2
0858:  BSF    F8A.2
085A:  RETURN 0
.................... }//end WriteReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void BFCReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *                 to modify.
....................  *
....................  * Input:           5 bit address of the register to modify.  The top 3 bits
....................  *                 must be 0.
....................  *               Byte to be used with the Bit Field Clear operation.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the
....................  *               SPI and then sends the data in the next 8 SPI clocks.
....................  *
....................  * Note:            This routine is almost identical to the WriteReg() and
....................  *               BFSReg() functions.  It is separate to maximize speed.
....................  *               BFCReg() must only be used on ETH registers.
....................  *****************************************************************************/
.................... static void BFCReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = BFC | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
085C:  BCF    F93.2
085E:  BCF    F8A.2
....................    ENCSPIXfer(BFC | Address);
0860:  MOVLB  3
0862:  MOVF   x93,W
0864:  IORLW  A0
0866:  MOVWF  x95
0868:  MOVWF  x99
086A:  MOVLB  0
086C:  RCALL  07F0
....................    ENCSPIXfer(Data);
086E:  MOVFF  394,399
0872:  RCALL  07F0
....................    SPIUnselectEthernet();
0874:  BCF    F93.2
0876:  BSF    F8A.2
0878:  RETURN 0
.................... }//end BFCReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void BFSReg(BYTE Address, BYTE Data)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *                Bank select bits must be set corresponding to the register
....................  *               to modify.
....................  *
....................  * Input:           5 bit address of the register to modify.  The top 3 bits
....................  *                 must be 0.
....................  *               Byte to be used with the Bit Field Set operation.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the
....................  *               SPI and then sends the data in the next 8 SPI clocks.
....................  *
....................  * Note:            This routine is almost identical to the WriteReg() and
....................  *               BFCReg() functions.  It is separate to maximize speed.
....................  *               BFSReg() must only be used on ETH registers.
....................  *****************************************************************************/
.................... static void BFSReg(BYTE Address, BYTE Data)
.................... {
.................... /*
....................    SPISelectEthernet();
....................    SSPBUF = BFS | Address;   // Send the opcode and address.
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted.
....................    PIR1_SSPIF = 0;
....................    SSPBUF = Data;         // Send the byte to be writen.
....................    while(!PIR1_SSPIF);      // Wait until register is written.
....................    PIR1_SSPIF = 0;
....................    SPIUnselectEthernet();
.................... */
....................    SPISelectEthernet();
087A:  BCF    F93.2
087C:  BCF    F8A.2
....................    ENCSPIXfer(BFS | Address);
087E:  MOVLB  3
0880:  MOVF   x96,W
0882:  IORLW  80
0884:  MOVWF  x98
0886:  MOVWF  x99
0888:  MOVLB  0
088A:  RCALL  07F0
....................    ENCSPIXfer(Data);
088C:  MOVFF  397,399
0890:  RCALL  07F0
....................    SPIUnselectEthernet();
0892:  BCF    F93.2
0894:  BSF    F8A.2
0896:  RETURN 0
.................... }//end BFSReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        WritePHYReg
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Address of the PHY register to write to.
....................  *               16 bits of data to write to PHY register.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Alters bank bits to point to Bank 3
....................  *
....................  * Overview:        WritePHYReg performs an MII write operation.  While in
....................  *               progress, it simply polls the MII BUSY bit wasting time.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... void WritePHYReg(BYTE Register, WORD Data)
.................... {
....................    // Write the register address
....................    BankSel(MIREGADR);
*
08FC:  MOVLW  02
08FE:  MOVLB  3
0900:  MOVWF  x92
0902:  MOVLW  14
0904:  MOVWF  x91
0906:  MOVLB  0
0908:  RCALL  0898
....................    WriteReg(MIREGADR, Register);
090A:  MOVLW  14
090C:  MOVLB  3
090E:  MOVWF  x94
0910:  MOVFF  2E5,395
0914:  MOVLB  0
0916:  RCALL  083E
.................... 
....................    // Write the data
....................    // Order is important: write low byte first, high byte last
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]);
0918:  MOVLW  02
091A:  MOVLB  2
091C:  MOVWF  xE9
091E:  MOVLW  E6
0920:  MOVWF  xE8
0922:  MOVWF  FE9
0924:  MOVFF  2E9,FEA
0928:  MOVFF  FEF,395
092C:  MOVLW  16
092E:  MOVLB  3
0930:  MOVWF  x94
0932:  MOVLB  0
0934:  RCALL  083E
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]);
0936:  MOVLW  02
0938:  MOVLB  2
093A:  MOVWF  xE9
093C:  MOVLW  E6
093E:  MOVWF  xE8
0940:  MOVLW  01
0942:  ADDWF  xE8,W
0944:  MOVWF  FE9
0946:  MOVLW  00
0948:  ADDWFC xE9,W
094A:  MOVWF  FEA
094C:  MOVFF  FEF,395
0950:  MOVLW  17
0952:  MOVLB  3
0954:  MOVWF  x94
0956:  MOVLB  0
0958:  RCALL  083E
.................... 
....................    // Wait until the PHY register has been written
....................    BankSel(MISTAT);
095A:  MOVLW  03
095C:  MOVLB  3
095E:  MOVWF  x92
0960:  MOVLW  0A
0962:  MOVWF  x91
0964:  MOVLB  0
0966:  RCALL  0898
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY);
0968:  MOVLW  0A
096A:  MOVLB  2
096C:  MOVWF  xE8
096E:  MOVLB  0
0970:  RCALL  08CA
0972:  MOVFF  01,2E8
0976:  MOVLW  00
0978:  MOVLB  2
097A:  BTFSC  01.0
097C:  MOVLW  01
097E:  XORLW  00
0980:  BTFSC  FD8.2
0982:  BRA    0988
0984:  MOVLB  0
0986:  BRA    0968
0988:  MOVLB  0
098A:  RETURN 0
.................... }//end WritePHYReg
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BankSel
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Register address with the high byte containing the 2 bank
....................  *                 select 2 bits.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        BankSel takes the high byte of a register address and
....................  *               changes the bank select bits in ETHCON1 to match.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... static void BankSel(WORD Register)
.................... {
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0);
*
0898:  MOVLW  1F
089A:  MOVLB  3
089C:  MOVWF  x93
089E:  MOVLW  03
08A0:  MOVWF  x94
08A2:  MOVLB  0
08A4:  RCALL  085C
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]);
08A6:  MOVLW  03
08A8:  MOVLB  3
08AA:  MOVWF  x94
08AC:  MOVLW  91
08AE:  MOVWF  x93
08B0:  MOVLW  01
08B2:  ADDWF  x93,W
08B4:  MOVWF  FE9
08B6:  MOVLW  00
08B8:  ADDWFC x94,W
08BA:  MOVWF  FEA
08BC:  MOVFF  FEF,397
08C0:  MOVLW  1F
08C2:  MOVWF  x96
08C4:  MOVLB  0
08C6:  RCALL  087A
08C8:  RETURN 0
.................... }//end BankSel
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        static BOOL TestMemory(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if the memory tests have passed
....................  *               FALSE if the BIST has detected a hardware fault
....................  *
....................  * Side Effects:    Alters the state of numerous control registers and all
....................  *               RAM bytes.
....................  *
....................  * Overview:        The internal BIST and DMA modules are used to fill the
....................  *               entire dual port memory and calculate a checksum of the
....................  *               data stored within.  Address and Random fill modes are
....................  *               used.
....................  *
....................  * Note:            For the Random Fill mode, the random number generator is
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer
....................  *               is running, additional confidence that the memory is
....................  *               working can be obtained by calling TestMemory multiple
....................  *               times.
....................  *****************************************************************************/
.................... #if defined(MAC_POWER_ON_TEST)
.................... static BOOL TestMemory(void)
.................... {
....................    #define RANDOM_FILL      0b0000
....................    #define ADDRESS_FILL   0b0100
....................    #define PATTERN_SHIFT   0b1000
.................... 
....................    WORD_VAL DMAChecksum, BISTChecksum;
.................... 
.................... 
....................    // Select Bank 0 and disable anything that could have been in progress
....................    WriteReg(ECON1, 0x00);
.................... 
....................    // Set up necessary pointers for the DMA to calculate over the entire
....................    // memory
....................    WriteReg(EDMASTL, 0x00);
....................    WriteReg(EDMASTH, 0x00);
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u));
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u));
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u));
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u));
.................... 
....................    // Enable Test Mode and do an Address Fill
....................    BankSel(EBSTCON);
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME |
....................                    EBSTCON_BISTST |
....................                    ADDRESS_FILL);
.................... 
.................... 
....................    // Wait for the BIST to complete and disable test mode before
....................    // starting any DMA operations.
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST);
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
.................... 
....................    // Begin reading the memory and calculating a checksum over it
....................    // Block until the checksum is generated
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    BankSel(EDMACSL);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Obtain the resulting DMA checksum and the expected BIST checksum
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val;
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val;
....................    BankSel(EBSTCSL);
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val;
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val;
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
....................    // Compare the results
....................    // 0xF807 should always be generated in Address fill mode
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) )
....................       return FALSE;
.................... 
....................    // Seed the random number generator and begin another Random Fill test
....................    // with the DMA and BIST memory access ports swapped.
.................... #ifdef __C30__
....................    WriteReg((BYTE)EBSTSD, TMR1);
.................... #else
....................    WriteReg((BYTE)EBSTSD, TMR0L);
.................... #endif
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME |
....................                  EBSTCON_PSEL |
....................                  EBSTCON_BISTST |
....................                  RANDOM_FILL);
.................... 
.................... 
....................    // Wait for the BIST to complete and disable test mode since
....................    // we won't be needing it anymore
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST);
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME);
.................... 
.................... 
....................    // Begin reading the memory and calculating a checksum over it
....................    // Block until the checksum is generated
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN);
....................    BankSel(EDMACSL);
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST);
.................... 
....................    // Obtain the resulting DMA checksum and the expected BIST checksum
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val;
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val;
....................    BankSel(EBSTCSL);
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val;
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val;
.................... 
....................    return (DMAChecksum.Val == BISTChecksum.Val);
.................... }//end TestMemory
.................... #endif
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           Member of DUPLEX enum:
....................  *                  FULL: Set full duplex mode
....................  *                  HALF: Set half duplex mode
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in
....................  *                         PHYCON.  This is controlled by LEDB on RESET.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    Changes bank bits to Bank 2.
....................  *
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex
....................  *               operation, sets PHY up for full duplex operation, and
....................  *               reenables RX logic.  The back-to-back inter-packet gap
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap.
....................  *
....................  * Note:            If a packet is being transmitted or received while this
....................  *               function is called, it will be aborted.
....................  *****************************************************************************/
.................... void MACSetDuplex(DUPLEX DuplexState)
.................... {
....................    REG Register;
....................    PHYREG PhyReg;
.................... 
....................    // Disable receive logic and abort any packets currently being transmitted
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN);
*
0A2A:  MOVLW  1F
0A2C:  MOVLB  3
0A2E:  MOVWF  x93
0A30:  MOVLW  0C
0A32:  MOVWF  x94
0A34:  MOVLB  0
0A36:  RCALL  085C
.................... 
....................    // Set the PHY to the proper duplex mode
....................    PhyReg = ReadPHYReg(PHCON1);
0A38:  MOVLB  2
0A3A:  CLRF   xE5
0A3C:  MOVLB  0
0A3E:  BRA    098C
0A40:  MOVFF  02,2E4
0A44:  MOVFF  01,2E3
....................    if(DuplexState == USE_PHY)
0A48:  MOVLB  2
0A4A:  MOVF   xE1,W
0A4C:  SUBLW  02
0A4E:  BNZ   0A58
....................    {
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD;
0A50:  CLRF   xE1
0A52:  BTFSC  xE4.0
0A54:  INCF   xE1,F
....................    }
0A56:  BRA    0A6E
....................    else
....................    {
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState;
0A58:  BCF    xE4.0
0A5A:  BTFSC  xE1.0
0A5C:  BSF    xE4.0
....................       WritePHYReg(PHCON1, PhyReg.Val);
0A5E:  CLRF   xE5
0A60:  MOVFF  2E4,2E7
0A64:  MOVFF  2E3,2E6
0A68:  MOVLB  0
0A6A:  RCALL  08FC
0A6C:  MOVLB  2
....................    }
.................... 
....................    // Set the MAC to the proper duplex mode
....................    BankSel(MACON3);
0A6E:  MOVLW  02
0A70:  MOVLB  3
0A72:  MOVWF  x92
0A74:  MOVWF  x91
0A76:  MOVLB  0
0A78:  RCALL  0898
....................    Register = ReadMACReg(MACON3);
0A7A:  MOVLW  02
0A7C:  MOVLB  2
0A7E:  MOVWF  xE8
0A80:  MOVLB  0
0A82:  RCALL  08CA
0A84:  MOVFF  01,2E2
....................    Register.MACON3bits.FULDPX = DuplexState;
0A88:  MOVLB  2
0A8A:  BCF    xE2.0
0A8C:  BTFSC  xE1.0
0A8E:  BSF    xE2.0
....................    WriteReg(MACON3, Register.Val);
0A90:  MOVLW  02
0A92:  MOVLB  3
0A94:  MOVWF  x94
0A96:  MOVFF  2E2,395
0A9A:  MOVLB  0
0A9C:  RCALL  083E
.................... 
....................    // Set the back-to-back inter-packet gap time to IEEE specified
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex
....................    // state, so it must be updated in this function.
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12);
0A9E:  MOVLB  2
0AA0:  MOVF   xE1,F
0AA2:  BZ    0AA8
0AA4:  MOVLW  15
0AA6:  BRA    0AAA
0AA8:  MOVLW  12
0AAA:  MOVWF  xE5
0AAC:  MOVLW  04
0AAE:  MOVLB  3
0AB0:  MOVWF  x94
0AB2:  MOVFF  2E5,395
0AB6:  MOVLB  0
0AB8:  RCALL  083E
.................... 
....................    // Reenable receive logic
....................    BFSReg(ECON1, ECON1_RXEN);
0ABA:  MOVLW  1F
0ABC:  MOVLB  3
0ABE:  MOVWF  x96
0AC0:  MOVLW  04
0AC2:  MOVWF  x97
0AC4:  MOVLB  0
0AC6:  RCALL  087A
0AC8:  GOTO   0C88 (RETURN)
.................... }//end MACSetDuplex
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPowerDown(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In
....................  *               sleep mode, no packets can be transmitted or received.
....................  *               All MAC and PHY registers should not be accessed.
....................  *
....................  * Note:            If a packet is being transmitted while this function is
....................  *                called, this function will block until it is it complete.
....................  *               If anything is being received, it will be completed.
....................  *****************************************************************************/
.................... void MACPowerDown(void)
.................... {
....................    // Disable packet reception
....................    BFCReg(ECON1, ECON1_RXEN);
.................... 
....................    // Make sure any last packet which was in-progress when RXEN was cleared
....................    // is completed
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY);
.................... 
....................    // If a packet is being transmitted, wait for it to finish
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS);
.................... 
....................    // Enter sleep mode
....................    BFSReg(ECON2, ECON2_PWRSV);
.................... }//end MACPowerDown
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void MACPowerUp(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation
....................  *               after a previous call to MACPowerDown().  Calling this
....................  *               function when already powered up will have no effect.
....................  *
....................  * Note:            The first packet transmitted may get lost at the RX end if
....................  *               you don't wait for the link to go up first.  MACIsLinked()
....................  *               can be called to determine if a link is established.
....................  *****************************************************************************/
.................... void MACPowerUp(void)
.................... {
....................    // Leave power down mode
....................    BFCReg(ECON2, ECON2_PWRSV);
.................... 
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This
....................    // delay is required for the PHY module to return to an operational state.
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY);
.................... 
....................    // Enable packet reception
....................    BFSReg(ECON1, ECON1_RXEN);
.................... }//end MACPowerUp
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        void SetCLKOUT(BYTE NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low)
....................  *                        0x01: Divide by 1 (25 MHz)
....................  *                        0x02: Divide by 2 (12.5 MHz)
....................  *                        0x03: Divide by 3 (8.333333 MHz)
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default)
....................  *                        0x05: Divide by 8 (3.125 MHz)
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the ECOCON register.
....................  *               The CLKOUT pin will beginning outputting the new frequency
....................  *               immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... void SetCLKOUT(BYTE NewConfig)
.................... {
....................    BankSel(ECOCON);
....................    WriteReg(ECOCON, NewConfig);
.................... }//end SetCLKOUT
.................... 
.................... 
.................... /******************************************************************************
....................  * Function:        BYTE GetCLKOUT(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low)
....................  *                     0x01: Divide by 1 (25 MHz)
....................  *                     0x02: Divide by 2 (12.5 MHz)
....................  *                     0x03: Divide by 3 (8.333333 MHz)
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default)
....................  *                     0x05: Divide by 8 (3.125 MHz)
....................  *                     0x06: Reserved
....................  *                     0x07: Reserved
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the ECOCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... BYTE GetCLKOUT(void)
.................... {
....................    BankSel(ECOCON);
....................    return ReadETHReg(ECOCON).Val;
.................... }//end GetCLKOUT
.................... 
....................    #elif STACK_USE_MCPINC
....................     #include "tcpip/eth97j60.c"
....................    #else
....................     #include "tcpip/rtl8019AS.c"
....................    #endif
.................... #endif
.................... 
.................... #if STACK_USE_PPP
....................    #include "tcpip/modem.c"
....................    #include "tcpip/ppp.c"
....................    #include "tcpip/pppwrap.c"
.................... #endif
.................... 
.................... #if STACK_USE_SLIP
....................    #include "tcpip/slip.c"
.................... #ENDIF
.................... 
.................... #if STACK_USE_UDP
....................    #include "tcpip/udp.h"
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    #include "tcpip/dhcp.h"
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    #include "tcpip/smtp.h"
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    #include "tcpip/http.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///                                                                     ///
.................... ///                              HTTP.H                                 ///
.................... ///                                                                     ///
.................... /// Simple webserver for the Microchip TCP/IP stack.                    ///
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       ///
.................... ///                                                                     ///
.................... /// See HTTP.C for documenation                                         ///
.................... ///                                                                     ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef HTTP_USE_CHUNKS
.................... #define HTTP_USE_CHUNKS   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_CONTENT_TYPE
.................... #define HTTP_USE_CONTENT_TYPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_PORT
.................... #define HTTP_PORT             80
.................... #endif
.................... 
.................... #ifndef HTTP_NUM_SOCKETS
.................... #define HTTP_NUM_SOCKETS      1
.................... #endif
.................... 
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE
.................... #define HTTP_GET_PARAM_MAX_SIZE  254
.................... #endif
.................... 
.................... void HTTP_Init(void);
.................... void HTTP_Task(void);
.................... 
.................... //**** CALLBACKS START ******///
.................... 
.................... /// the following three functions are callbacks and
.................... /// must be written in your main application!!!  see the documentation above
.................... /// for more help.
.................... 
.................... #if HTTP_USE_CONTENT_TYPE
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... #else
....................  int32 http_get_page(char *file_str);
.................... #endif
.................... 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... void http_exec_cgi(int32 file, char *key, char *val);
.................... 
.................... //**** CALLBACKS END ******///
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP2
....................    #include "tcpip/http2.h"
.................... #endif
.................... 
.................... #if STACK_USE_DNS
....................    #include "tcpip/dns.h"
.................... #endif
.................... 
.................... #if STACK_USE_SNMP
....................    #include "tcpip/snmp.h"
.................... #endif
.................... 
.................... #if STACK_USE_MPFS
....................    #include "tcpip/mpfs.h"
.................... #endif
.................... 
.................... #include "tcpip/ip.c"
.................... /*********************************************************************
....................  *
....................  *                  PIC IP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.C
....................  * Dependencies:    string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                  IP.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail)
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... // This is left shifted by 4.  Actual value is 0x04.
.................... #define IPv4                (0x40u)
.................... #define IP_VERSION          IPv4
.................... 
.................... #define debug_ip
.................... //#define debug_ip  debug_printf
.................... 
.................... // IHL (Internet Header Length) is # of DWORDs in a header.
.................... // Since, we do not support options, our IP header length will be
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5.
.................... #define IP_IHL              (0x05)
.................... 
.................... #define IP_SERVICE_NW_CTRL  (0x07)
.................... #define IP_SERVICE_IN_CTRL  (0x06)
.................... #define IP_SERVICE_ECP      (0x05)
.................... #define IP_SERVICE_OVR      (0x04)
.................... #define IP_SERVICE_FLASH    (0x03)
.................... #define IP_SERVICE_IMM      (0x02)
.................... #define IP_SERVICE_PRIOR    (0x01)
.................... #define IP_SERVICE_ROUTINE  (0x00)
.................... 
.................... #define IP_SERVICE_N_DELAY  (0x00)
.................... #define IP_SERCICE_L_DELAY  (0x08)
.................... #define IP_SERVICE_N_THRPT  (0x00)
.................... #define IP_SERVICE_H_THRPT  (0x10)
.................... #define IP_SERVICE_N_RELIB  (0x00)
.................... #define IP_SERVICE_H_RELIB  (0x20)
.................... 
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY)
.................... 
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds
.................... 
.................... 
.................... 
.................... 
.................... static WORD _Identifier = 0;
.................... static BYTE IPHeaderLen;
.................... 
.................... static void SwapIPHeader(IP_HEADER* h);
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len)
.................... {
....................     WORD_VAL    CalcChecksum;
....................     IP_HEADER   header;
.................... 
.................... #if !defined(MCHP_MAC)
....................     WORD_VAL    ReceivedChecksum;
....................     WORD        checksums[2];
....................     BYTE        optionsLen;
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791.
....................     BYTE        options[MAX_OPTIONS_LEN];
.................... #endif
.................... 
....................     // Read IP header.
....................     MACGetArray((BYTE*)&header, sizeof(header));
*
1D9A:  MOVLW  02
1D9C:  MOVLB  3
1D9E:  MOVWF  x05
1DA0:  MOVLW  F0
1DA2:  MOVWF  x04
1DA4:  MOVFF  305,37E
1DA8:  MOVWF  x7D
1DAA:  CLRF   x80
1DAC:  MOVLW  14
1DAE:  MOVWF  x7F
1DB0:  MOVLB  0
1DB2:  CALL   11D0
.................... 
....................     // Make sure that this is an IPv4 packet.
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION )
1DB6:  MOVLB  2
1DB8:  MOVF   xF0,W
1DBA:  ANDLW  F0
1DBC:  SUBLW  40
1DBE:  BZ    1DC6
....................     	return FALSE;
1DC0:  MOVLW  00
1DC2:  MOVWF  01
1DC4:  BRA    1E7A
.................... 
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2;
1DC6:  MOVF   xF0,W
1DC8:  ANDLW  0F
1DCA:  MOVWF  00
1DCC:  RLCF   00,W
1DCE:  MOVWF  5F
1DD0:  RLCF   5F,F
1DD2:  MOVLW  FC
1DD4:  ANDWF  5F,F
.................... 
.................... #if defined(MCHP_MAC)
.................... 	// Validate the IP header.  If it is correct, the checksum
.................... 	// will come out to 0x0000 (because the header contains a
.................... 	// precomputed checksum).  A corrupt header will have a
.................... 	// nonzero checksum.
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen);
1DD6:  MOVLB  3
1DD8:  CLRF   x40
1DDA:  CLRF   x3F
1DDC:  CLRF   x42
1DDE:  MOVFF  5F,341
1DE2:  MOVLB  0
1DE4:  RCALL  1B4E
1DE6:  MOVFF  02,2EF
1DEA:  MOVFF  01,2EE
.................... 
.................... 	// Seek to the end of the IP header
.................... 	MACSetRxBuffer(IPHeaderLen);
1DEE:  MOVLB  3
1DF0:  CLRF   x18
1DF2:  MOVFF  5F,317
1DF6:  MOVLB  0
1DF8:  RCALL  1C56
.................... 
....................     if(CalcChecksum.Val)
1DFA:  MOVLB  2
1DFC:  MOVF   xEE,W
1DFE:  IORWF  xEF,W
1E00:  BZ    1E08
.................... #else
.................... 
....................     // Calculate options length in this header, if there is any.
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual
....................     // length is 4 times IHL.
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header);
.................... 
....................     // If there is any option(s), read it so that we can include them
....................     // in checksum calculation.
....................     if ( optionsLen > MAX_OPTIONS_LEN )
....................         return FALSE;
.................... 
....................     if ( optionsLen > 0 )
....................         MACGetArray(options, optionsLen);
.................... 
....................     // Save header checksum; clear it and recalculate it ourselves.
....................     ReceivedChecksum.Val = header.HeaderChecksum;
....................     header.HeaderChecksum = 0;
.................... 
....................     // Calculate checksum of header including options bytes.
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header));
.................... 
....................     // Calculate Options checksum too, if they are present.
....................     if ( optionsLen > 0 )
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen);
....................     else
....................         checksums[1] = 0;
.................... 
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums,
....................                                             2 * sizeof(WORD));
.................... 
....................     // Make sure that checksum is correct
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val )
.................... #endif
....................     {
....................         // Bad packet. The function caller will be notified by means of the FALSE
....................         // return value and it should discard the packet.
....................         return FALSE;
1E02:  MOVLW  00
1E04:  MOVWF  01
1E06:  BRA    1E7A
....................     }
.................... 
....................     // Network to host conversion.
....................     SwapIPHeader(&header);
1E08:  MOVLW  02
1E0A:  MOVLB  3
1E0C:  MOVWF  x89
1E0E:  MOVLW  F0
1E10:  MOVWF  x88
1E12:  MOVLB  0
1E14:  RCALL  1CD2
.................... 
....................     // If caller is intrested, return destination IP address
....................     // as seen in this IP header.
....................     if ( localIP )
1E16:  MOVLB  2
1E18:  MOVF   xE6,W
1E1A:  IORWF  xE7,W
1E1C:  BZ    1E36
....................         localIP->Val    = header.DestAddress.Val;
1E1E:  MOVFF  2E6,FE9
1E22:  MOVFF  2E7,FEA
1E26:  MOVFF  300,FEF
1E2A:  MOVFF  301,FEC
1E2E:  MOVFF  302,FEC
1E32:  MOVFF  303,FEC
.................... 
....................     remote->IPAddr.Val  = header.SourceAddress.Val;
1E36:  MOVLW  06
1E38:  ADDWF  xE8,W
1E3A:  MOVWF  FE9
1E3C:  MOVLW  00
1E3E:  ADDWFC xE9,W
1E40:  MOVWF  FEA
1E42:  MOVFF  2FC,FEF
1E46:  MOVFF  2FD,FEC
1E4A:  MOVFF  2FE,FEC
1E4E:  MOVFF  2FF,FEC
....................     *protocol           = header.Protocol;
1E52:  MOVFF  2EB,FEA
1E56:  MOVFF  2EA,FE9
1E5A:  MOVFF  2F9,FEF
.................... #if defined(MCHP_MAC)
....................     *len 				= header.TotalLength - IPHeaderLen;
1E5E:  MOVFF  2ED,FEA
1E62:  MOVFF  2EC,FE9
1E66:  MOVF   5F,W
1E68:  SUBWF  xF2,W
1E6A:  MOVWF  00
1E6C:  MOVLW  00
1E6E:  SUBWFB xF3,W
1E70:  MOVFF  00,FEF
1E74:  MOVWF  FEC
.................... #else
....................     *len                = header.TotalLength - optionsLen -
....................                             sizeof(header);
.................... #endif
.................... 
....................     return TRUE;
1E76:  MOVLW  01
1E78:  MOVWF  01
1E7A:  MOVLB  0
1E7C:  GOTO   6CFE (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function: WORD IPPutHeader(NODE_INFO *remote,
....................  *           				  BYTE protocol,
....................  *                			  WORD len)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           *remote     - Destination node address
....................  *                  protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          (WORD)0
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  ********************************************************************/
.................... WORD IPPutHeader(NODE_INFO *remote,
....................                 BYTE protocol,
....................                 WORD    len)
.................... {
....................     IP_HEADER   header;
.................... 
....................     IPHeaderLen = sizeof(IP_HEADER);
*
280A:  MOVLW  14
280C:  MOVWF  5F
.................... 
....................     header.VersionIHL       = IP_VERSION | IP_IHL;
280E:  MOVLW  45
2810:  MOVLB  3
2812:  MOVWF  x74
....................     header.TypeOfService    = IP_SERVICE;
2814:  CLRF   x75
....................     header.TotalLength      = sizeof(header) + len;
2816:  MOVLW  14
2818:  ADDWF  x72,W
281A:  MOVWF  x76
281C:  MOVLW  00
281E:  ADDWFC x73,W
2820:  MOVWF  x77
....................     header.Identification   = ++_Identifier;
2822:  INCF   5D,F
2824:  BTFSC  FD8.2
2826:  INCF   5E,F
2828:  MOVFF  5E,379
282C:  MOVFF  5D,378
....................     header.FragmentInfo     = 0;
2830:  CLRF   x7B
2832:  CLRF   x7A
....................     header.TimeToLive       = MY_IP_TTL;
2834:  MOVLW  64
2836:  MOVWF  x7C
....................     header.Protocol         = protocol;
2838:  MOVFF  371,37D
....................     header.HeaderChecksum   = 0;
283C:  CLRF   x7F
283E:  CLRF   x7E
.................... 	header.SourceAddress = AppConfig.MyIPAddr;
2840:  MOVFF  20,383
2844:  MOVFF  1F,382
2848:  MOVFF  1E,381
284C:  MOVFF  1D,380
.................... 
....................     header.DestAddress.Val = remote->IPAddr.Val;
2850:  MOVLW  06
2852:  ADDWF  x6F,W
2854:  MOVWF  FE9
2856:  MOVLW  00
2858:  ADDWFC x70,W
285A:  MOVWF  FEA
285C:  MOVFF  FEF,384
2860:  MOVFF  FEC,385
2864:  MOVFF  FEC,386
2868:  MOVFF  FEC,387
.................... 
....................     SwapIPHeader(&header);
286C:  MOVLW  03
286E:  MOVWF  x89
2870:  MOVLW  74
2872:  MOVWF  x88
2874:  MOVLB  0
2876:  CALL   1CD2
.................... 
.................... #if !defined(MCHP_MAC)
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header,
....................                                                 sizeof(header));
.................... #endif
.................... 
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len));
287A:  MOVLB  3
287C:  MOVFF  36F,01
2880:  MOVFF  370,03
2884:  MOVFF  01,388
2888:  MOVFF  03,389
288C:  MOVLW  14
288E:  ADDWF  x72,W
2890:  MOVWF  x8A
2892:  MOVLW  00
2894:  ADDWFC x73,W
2896:  MOVWF  x8B
2898:  MOVFF  03,38D
289C:  MOVFF  01,38C
28A0:  CLRF   x8E
28A2:  MOVWF  x90
28A4:  MOVFF  38A,38F
28A8:  MOVLB  0
28AA:  CALL   1652
....................     MACPutArray((BYTE*)&header, sizeof(header));
28AE:  MOVLW  03
28B0:  MOVLB  3
28B2:  MOVWF  x89
28B4:  MOVLW  74
28B6:  MOVWF  x88
28B8:  MOVFF  389,394
28BC:  MOVWF  x93
28BE:  CLRF   x96
28C0:  MOVLW  14
28C2:  MOVWF  x95
28C4:  MOVLB  0
28C6:  CALL   160C
.................... 
.................... #if defined(MCHP_MAC)
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header));
28CA:  MOVLB  3
28CC:  CLRF   x89
28CE:  CLRF   x88
28D0:  CLRF   x8B
28D2:  MOVLW  14
28D4:  MOVWF  x8A
28D6:  MOVLB  0
28D8:  RCALL  2732
28DA:  MOVFF  02,37F
28DE:  MOVFF  01,37E
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member
28E2:  MOVFF  52,388
28E6:  MOVLB  3
28E8:  CLRF   x8A
28EA:  MOVLW  0A
28EC:  MOVWF  x89
28EE:  MOVLB  0
28F0:  CALL   1550
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2);
28F4:  MOVLW  03
28F6:  MOVLB  3
28F8:  MOVWF  x89
28FA:  MOVLW  7E
28FC:  MOVWF  x88
28FE:  MOVFF  389,394
2902:  MOVWF  x93
2904:  CLRF   x96
2906:  MOVLW  02
2908:  MOVWF  x95
290A:  MOVLB  0
290C:  CALL   160C
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet
2910:  MOVFF  52,388
2914:  MOVLB  3
2916:  CLRF   x8A
2918:  MOVLW  14
291A:  MOVWF  x89
291C:  MOVLB  0
291E:  CALL   1550
.................... #endif
.................... 
....................     return 0x0;
2922:  MOVLW  00
2924:  MOVWF  01
2926:  MOVWF  02
2928:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset)
.................... {
.................... 	MACSetRxBuffer(Offset+IPHeaderLen);
*
20F2:  MOVF   5F,W
20F4:  MOVLB  3
20F6:  ADDWF  x13,W
20F8:  MOVWF  x15
20FA:  MOVLW  00
20FC:  ADDWFC x14,W
20FE:  MOVWF  x16
2100:  MOVWF  x18
2102:  MOVFF  315,317
2106:  MOVLB  0
2108:  RCALL  1C56
210A:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... static void SwapIPHeader(IP_HEADER* h)
.................... {
....................     h->TotalLength      = swaps(h->TotalLength);
*
1CD2:  MOVLW  02
1CD4:  MOVLB  3
1CD6:  ADDWF  x88,W
1CD8:  MOVWF  01
1CDA:  MOVLW  00
1CDC:  ADDWFC x89,W
1CDE:  MOVWF  03
1CE0:  MOVFF  01,38A
1CE4:  MOVWF  x8B
1CE6:  MOVLW  02
1CE8:  ADDWF  x88,W
1CEA:  MOVWF  FE9
1CEC:  MOVLW  00
1CEE:  ADDWFC x89,W
1CF0:  MOVWF  FEA
1CF2:  MOVFF  FEC,38F
1CF6:  MOVF   FED,F
1CF8:  MOVFF  FEF,38E
1CFC:  MOVLB  0
1CFE:  CALL   1230
1D02:  MOVFF  38B,FEA
1D06:  MOVFF  38A,FE9
1D0A:  MOVFF  02,FEC
1D0E:  MOVF   FED,F
1D10:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification);
1D14:  MOVLW  04
1D16:  MOVLB  3
1D18:  ADDWF  x88,W
1D1A:  MOVWF  01
1D1C:  MOVLW  00
1D1E:  ADDWFC x89,W
1D20:  MOVWF  03
1D22:  MOVFF  01,38A
1D26:  MOVWF  x8B
1D28:  MOVLW  04
1D2A:  ADDWF  x88,W
1D2C:  MOVWF  FE9
1D2E:  MOVLW  00
1D30:  ADDWFC x89,W
1D32:  MOVWF  FEA
1D34:  MOVFF  FEC,38F
1D38:  MOVF   FED,F
1D3A:  MOVFF  FEF,38E
1D3E:  MOVLB  0
1D40:  CALL   1230
1D44:  MOVFF  38B,FEA
1D48:  MOVFF  38A,FE9
1D4C:  MOVFF  02,FEC
1D50:  MOVF   FED,F
1D52:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum);
1D56:  MOVLW  0A
1D58:  MOVLB  3
1D5A:  ADDWF  x88,W
1D5C:  MOVWF  01
1D5E:  MOVLW  00
1D60:  ADDWFC x89,W
1D62:  MOVWF  03
1D64:  MOVFF  01,38A
1D68:  MOVWF  x8B
1D6A:  MOVLW  0A
1D6C:  ADDWF  x88,W
1D6E:  MOVWF  FE9
1D70:  MOVLW  00
1D72:  ADDWFC x89,W
1D74:  MOVWF  FEA
1D76:  MOVFF  FEC,38F
1D7A:  MOVF   FED,F
1D7C:  MOVFF  FEF,38E
1D80:  MOVLB  0
1D82:  CALL   1230
1D86:  MOVFF  38B,FEA
1D8A:  MOVFF  38A,FE9
1D8E:  MOVFF  02,FEC
1D92:  MOVF   FED,F
1D94:  MOVFF  01,FEF
1D98:  RETURN 0
.................... }
.................... 
.................... 
.................... #if STACK_USE_TCP
....................    #include "tcpip/tcp.c"
.................... /*********************************************************************
....................  *
....................  *                  TCP Module for Microchip TCP/IP Stack
....................  *               Based on RFC 793
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
.................... * FileName:        TCP.C
.................... * Dependencies:    string.h
.................... *                  StackTsk.h
.................... *                  Helpers.h
.................... *                  IP.h
.................... *                  MAC.h
.................... *                  ARP.h
.................... *                  Tick.h
.................... *                  TCP.h
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F
.................... * Complier:        CCS PCH
.................... * Company:         Microchip Technology, Inc.
.................... *
.................... * Software License Agreement
.................... *
.................... * This software is owned by Microchip Technology Inc. ("Microchip")
.................... * and is supplied to you for use exclusively as described in the
.................... * associated software agreement.  This software is protected by
.................... * software and other intellectual property laws.  Any use in
.................... * violation of the software license may subject the user to criminal
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip
.................... * Technology Inc.  All rights reserved.
.................... *
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special,
.................... * incidental, or consequential damages.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug.
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above)
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode.
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case)
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess()
....................  *                              to include localIP as third param.
....................  *                              This was done to allow this function
....................  *                              to calculate checksum correctly.
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix.
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected
....................  *                         discard problem identified by Richard
....................  *                         Shelquist.
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug
....................  *                        when using a Microchip Ethernet controller)
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable()
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check
....................  *                        reported by DouglasPunch on Microchip Forum.
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX
....................  *                        Buffers to be obtained but not
....................  *                        released when many web requests were
....................  *                        received concurrently.
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tcp.h"
.................... /*********************************************************************
....................  *
....................  *                  TCP Module Defs for Microchip TCP/IP Stack
....................  *
....................  *********************************************************************
....................  * FileName:        TCP.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F
....................  * Complier:        CCS PCH
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype.
....................  *                              See TCP.c for more information.
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef TCP_H
.................... #define TCP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/tick.h"
.................... /*********************************************************************
....................  *
....................  *                  Tick Manager for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Tick.h
....................  * Dependencies:    None
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b
....................  ********************************************************************/
.................... 
.................... #ifndef TICK_H
.................... #define TICK_H
.................... 
.................... typedef int16 TICKTYPE;
.................... 
.................... /*
....................  * This value is used by TCP to implement timeout actions.
....................  */
.................... #define TICKS_PER_SECOND               10
.................... 
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255)
.................... #error Invalid TICKS_PER_SECONDS specified.
.................... #endif
.................... 
.................... //16 is the prescalar
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND)
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF)
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND
.................... #endif
.................... 
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100)
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND
.................... #endif
.................... 
.................... 
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND
.................... 
.................... /*
.................... #if (getenv("CLOCK")==20000000)
....................    #define TICK_COUNTER 34250
.................... #elif (getenv("CLOCK")==40000000)
....................    #define TICK_COUNTER 3035
.................... #elif (getenv("CLOCK")==19600000)
....................    #define TICK_COUNTER 34910
.................... #else
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit()
.................... #endif
.................... */
.................... 
.................... #define TICK_SECOND  TICKS_PER_SECOND
.................... 
.................... 
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b))
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Tick manager is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initializes Timer0 as a tick counter.
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void TickInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TICK TickGet(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current second value is given
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TICKTYPE TickGet(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TickUpdate(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Internal Tick and Seconds count are updated.
....................  *
....................  * Note:            None
....................  *
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt.
....................  *                  You do not have to call TickUpdate() at a regular interval.
....................  ********************************************************************/
.................... //void TickUpdate(void);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef BYTE TCP_SOCKET;
.................... typedef WORD TCP_PORT;
.................... 
.................... #ifndef TCP_NO_WAIT_FOR_ACK
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE
.................... #endif
.................... 
.................... /*
....................  * Maximum number of times a connection be retried before
....................  * closing it down.
....................  */
.................... #define MAX_RETRY_COUNTS    (3)
.................... 
.................... #define INVALID_SOCKET      (0xfe)
.................... #define UNKNOWN_SOCKET      (0xff)
.................... 
.................... #define REMOTE_HOST(s)      (TCB[s].remote)
.................... 
.................... /*
....................  * TCP States as defined by rfc793
....................  */
.................... typedef enum _TCP_STATE
.................... {
....................     TCP_LISTEN = 0,
....................     TCP_SYN_SENT,
....................     TCP_SYN_RECEIVED,
....................     TCP_ESTABLISHED,
....................     TCP_FIN_WAIT_1,
....................     TCP_FIN_WAIT_2,
....................     TCP_CLOSING,
....................     TCP_TIME_WAIT,
.................... 	TCP_CLOSE_WAIT,
....................     TCP_LAST_ACK,
....................     TCP_CLOSED,
.................... } TCP_STATE;
.................... 
.................... /*
....................  * Socket info.
....................  * Union is used to create anonymous structure members.
....................  */
.................... typedef struct _SOCKET_INFO
.................... {
....................     TCP_STATE smState;
.................... 
....................     NODE_INFO remote;
....................     TCP_PORT localPort;
....................     TCP_PORT remotePort;
.................... 
....................     BUFFER TxBuffer;
....................     WORD TxCount;
....................     WORD RxCount;
.................... 	WORD RemoteWindow;
.................... 	
....................     DWORD SND_SEQ;
....................     DWORD SND_ACK;
.................... 
....................     BYTE RetryCount;
....................     TICKTYPE startTick;
....................     TICKTYPE TimeOut;
.................... 
....................     struct
....................     {
....................         int1 bServer        : 1;
....................         int1 bIsPutReady    : 1;
....................         int1 bFirstRead     : 1;
....................         int1 bIsGetReady    : 1;
....................         int1 bIsTxInProgress : 1;
....................         int1 bACKValid : 1;
....................     } Flags;
.................... 
.................... } SOCKET_INFO;
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TCP is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Initialize all socket info.
....................  *
....................  * Note:            This function is called only one during lifetime
....................  *                  of the application.
....................  ********************************************************************/
.................... void        TCPInit(void);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           port    - A TCP port to be opened.
....................  *
....................  * Output:          Given port is opened and returned on success
....................  *                  INVALID_SOCKET if no more sockets left.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... TCP_SOCKET  TCPListen(TCP_PORT port);
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote,
....................  *                                      TCP_PORT remotePort)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           remote      - Remote node address info
....................  *                  remotePort  - remote port to be connected.
....................  *
....................  * Output:          A new socket is created, connection request is
....................  *                  sent and socket handle is returned.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket to be checked for connection.
....................  *
....................  * Output:          TRUE    if given socket is connected
....................  *                  FALSE   if given socket is not connected.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            A socket is said to be connected if it is not
....................  *                  in LISTEN and CLOSED mode.  Socket may be in
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket
....................  *                  data.
....................  ********************************************************************/
.................... BOOL        TCPIsConnected(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPDisconnect(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsPutReady(s) == TRUE
....................  *
....................  * Input:           s       - Socket to be disconnected.
....................  *
....................  * Output:          A disconnect request is sent for given socket.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void        TCPDisconnect(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' is free to transmit
....................  *                  FALSE if socket 's' is not free to transmit.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Each socket maintains only transmit buffer.
....................  *                  Hence until a data packet is acknowledeged by
....................  *                  remote node, socket will not be ready for
....................  *                  next transmission.
....................  *                  All control transmission such as Connect,
....................  *                  Disconnect do not consume/reserve any transmit
....................  *                  buffer.
....................  ********************************************************************/
.................... BOOL        TCPIsPutReady(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s       - socket to use
....................  *                  byte    - a data byte to send
....................  *
....................  * Output:          TRUE if given byte was put in transmit buffer
....................  *                  FALSE if transmit buffer is full.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket whose data is to be transmitted.
....................  *
....................  * Output:          All and any data associated with this socket
....................  *                  is marked as ready for transmission.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPFlush(TCP_SOCKET socket);
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' contains any data.
....................  *                  FALSE if socket 's' does not contain any data.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPIsGetReady(TCP_SOCKET s);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  byte    - Pointer to a byte.
....................  *
....................  * Output:          TRUE if a byte was read.
....................  *                  FALSE if byte was not read.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer,
....................  *                                      WORD count)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  buffer  - Buffer to hold received data.
....................  *                  count   - Buffer length
....................  *
....................  * Output:          Number of bytes loaded into buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket
....................  *
....................  * Output:          TRUE if socket received data was discarded
....................  *                  FALSE if socket received data was already
....................  *                          discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPDiscard(TCP_SOCKET socket);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote,
....................  *                                  IP_ADDR *localIP,
....................  *                                  WORD len)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCP segment is ready in MAC buffer
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  len         - Total length of TCP semgent.
....................  *
....................  * Output:          TRUE if this function has completed its task
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL        TCPProcess(NODE_INFO *remote,
....................                        IP_ADDR *localIP,
....................                        WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void TCPTick(void)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Each socket FSM is executed for any timeout
....................  *                  situation.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void        TCPTick(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u)
.................... //#define debug_tcp debug_printf
.................... 
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) -
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER)
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54)
.................... 
.................... // TCP Timeout value to begin with.
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3)
.................... 
.................... // TCP Flags defined in RFC
.................... #define FIN     (0x01)
.................... #define SYN     (0x02)
.................... #define RST     (0x04)
.................... #define PSH     (0x08)
.................... #define ACK     (0x10)
.................... #define URG     (0x20)
.................... 
.................... 
.................... // TCP Header
.................... typedef struct _TCP_HEADER
.................... {
....................     WORD    SourcePort;
....................     WORD    DestPort;
....................     DWORD   SeqNumber;
....................     DWORD   AckNumber;
.................... 
....................     struct
....................     {
....................        BYTE Reserved3:4;
....................        BYTE Val:4;
....................     } DataOffset;
.................... 
.................... 
....................     union
....................     {
....................         struct
....................         {
....................              int1 flagFIN    : 1;
....................              int1 flagSYN    : 1;
....................              int1 flagRST    : 1;
....................              int1 flagPSH    : 1;
....................              int1 flagACK    : 1;
....................              int1 flagURG    : 1;
....................              int1 Reserved2  : 2;
....................         } bits;
....................         BYTE b;
....................     } Flags;
.................... 
....................     WORD    Window;
....................     WORD    Checksum;
....................     WORD    UrgentPointer;
.................... } TCP_HEADER;
.................... 
.................... 
.................... // TCP Options as defined by RFC
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00)
.................... #define TCP_OPTIONS_NO_OP           (0x01)
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02)
.................... typedef struct _TCP_OPTIONS
.................... {
....................     BYTE        Kind;
....................     BYTE        Length;
....................     WORD_VAL    MaxSegSize;
.................... } TCP_OPTIONS;
.................... 
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength))
.................... 
.................... // IP pseudo header as defined by RFC 793
.................... typedef struct _PSEUDO_HEADER
.................... {
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
....................     BYTE Zero;
....................     BYTE Protocol;
....................     WORD TCPLength;
.................... } PSEUDO_HEADER;
.................... 
.................... #define LOCAL_PORT_START_NUMBER (1024)
.................... #define LOCAL_PORT_END_NUMBER   (5000)
.................... 
.................... // Local temp port numbers.
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER;
.................... 
.................... // The TCB array is very large.  With the C18 compiler, one must
.................... // modify the linker script to make an array that spans more than
.................... // one memory bank.  To do this, make the necessary changes to your
.................... // processor's linker script (.lkr).  Here is an example showing
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte
.................... // block used exclusively by the TCB_MEM data section:
.................... // ...
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF
.................... // ...
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b
.................... // ...
.................... //#pragma udata TCB_MEM   //not needed in ccs
.................... SOCKET_INFO TCB[MAX_SOCKETS];
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs
.................... 
.................... static void    HandleTCPSeg(TCP_SOCKET s,
....................                                NODE_INFO *remote,
....................                                TCP_HEADER *h,
....................                                WORD len);
.................... 
.................... static void TransmitTCP(NODE_INFO *remote,
....................                         TCP_PORT localPort,
....................                         TCP_PORT remotePort,
....................                         DWORD tseq,
....................                         DWORD tack,
....................                         BYTE flags,
....................                         BUFFER buff,
....................                         WORD len);
.................... 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h,
....................                                     NODE_INFO *remote);
.................... static void    SwapTCPHeader(TCP_HEADER* header);
.................... static void CloseSocket(SOCKET_INFO* ps);
.................... 
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \
....................                     INVALID_BUFFER, 0)
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPInit(void)
.................... *
.................... * PreCondition:    None
.................... *
.................... * Input:           None
.................... *
.................... * Output:          TCP is initialized.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        Initialize all socket states
.................... *
.................... * Note:            This function is called only once during lifetime
.................... *                  of the application.
.................... ********************************************************************/
.................... int16 TCPInit_RandSeed;
.................... void TCPInit(void)
.................... {
....................     TCP_SOCKET s;
....................     SOCKET_INFO* ps;
.................... 
.................... 
....................     // Initialize all sockets.
....................     for ( s = 0; s < MAX_SOCKETS; s++ )
*
0DDE:  MOVLB  2
0DE0:  CLRF   xE0
0DE2:  MOVF   xE0,W
0DE4:  SUBLW  04
0DE6:  BNC   0EB4
....................     {
....................         ps = &TCB[s];
0DE8:  MOVF   xE0,W
0DEA:  MULLW  24
0DEC:  MOVF   FF3,W
0DEE:  CLRF   03
0DF0:  ADDLW  88
0DF2:  MOVWF  01
0DF4:  MOVLW  00
0DF6:  ADDWFC 03,F
0DF8:  MOVFF  01,2E1
0DFC:  MOVFF  03,2E2
.................... 
....................         ps->smState             = TCP_CLOSED;
0E00:  MOVFF  2E1,FE9
0E04:  MOVFF  2E2,FEA
0E08:  MOVLW  0A
0E0A:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE;
0E0C:  MOVLW  23
0E0E:  ADDWF  xE1,W
0E10:  MOVWF  FE9
0E12:  MOVLW  00
0E14:  ADDWFC xE2,W
0E16:  MOVWF  FEA
0E18:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE;
0E1A:  MOVLW  23
0E1C:  ADDWF  xE1,W
0E1E:  MOVWF  FE9
0E20:  MOVLW  00
0E22:  ADDWFC xE2,W
0E24:  MOVWF  FEA
0E26:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE;
0E28:  MOVLW  23
0E2A:  ADDWF  xE1,W
0E2C:  MOVWF  FE9
0E2E:  MOVLW  00
0E30:  ADDWFC xE2,W
0E32:  MOVWF  FEA
0E34:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE;
0E36:  MOVLW  23
0E38:  ADDWF  xE1,W
0E3A:  MOVWF  FE9
0E3C:  MOVLW  00
0E3E:  ADDWFC xE2,W
0E40:  MOVWF  FEA
0E42:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE;
0E44:  MOVLW  23
0E46:  ADDWF  xE1,W
0E48:  MOVWF  FE9
0E4A:  MOVLW  00
0E4C:  ADDWFC xE2,W
0E4E:  MOVWF  FEA
0E50:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER)
0E52:  MOVLW  0F
0E54:  ADDWF  xE1,W
0E56:  MOVWF  FE9
0E58:  MOVLW  00
0E5A:  ADDWFC xE2,W
0E5C:  MOVWF  FEA
0E5E:  INCFSZ FEF,W
0E60:  BRA    0E64
0E62:  BRA    0E8A
....................       {
....................          MACDiscardTx(ps->TxBuffer);
0E64:  MOVLW  0F
0E66:  ADDWF  xE1,W
0E68:  MOVWF  FE9
0E6A:  MOVLW  00
0E6C:  ADDWFC xE2,W
0E6E:  MOVWF  FEA
0E70:  MOVFF  FEF,333
0E74:  MOVLB  0
0E76:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER;
0E7A:  MOVLW  0F
0E7C:  MOVLB  2
0E7E:  ADDWF  xE1,W
0E80:  MOVWF  FE9
0E82:  MOVLW  00
0E84:  ADDWFC xE2,W
0E86:  MOVWF  FEA
0E88:  SETF   FEF
....................       }
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL;
0E8A:  MOVLW  21
0E8C:  ADDWF  xE1,W
0E8E:  MOVWF  FE9
0E90:  MOVLW  00
0E92:  ADDWFC xE2,W
0E94:  MOVWF  FEA
0E96:  CLRF   FEC
0E98:  MOVF   FED,F
0E9A:  MOVLW  1E
0E9C:  MOVWF  FEF
....................       ps->TxCount            = 0;
0E9E:  MOVLW  10
0EA0:  ADDWF  xE1,W
0EA2:  MOVWF  FE9
0EA4:  MOVLW  00
0EA6:  ADDWFC xE2,W
0EA8:  MOVWF  FEA
0EAA:  CLRF   FEC
0EAC:  MOVF   FED,F
0EAE:  CLRF   FEF
....................    }
.................... 
....................     //_NextPort = LOCAL_PORT_START_NUMBER;
....................     #if getenv("TIMER0")
0EB0:  INCF   xE0,F
0EB2:  BRA    0DE2
....................     TCPInit_RandSeed+=get_timer0();
0EB4:  MOVF   FD6,W
0EB6:  MOVLB  0
0EB8:  ADDWF  x62,F
0EBA:  MOVF   FD7,W
0EBC:  ADDWFC x63,F
....................     #endif
....................     #if getenv("TIMER1")
....................      TCPInit_RandSeed+=get_timer1();
0EBE:  MOVF   FCE,W
0EC0:  ADDWF  x62,F
0EC2:  MOVF   FCF,W
0EC4:  ADDWFC x63,F
....................     #endif
....................     #if getenv("TIMER2")
....................      TCPInit_RandSeed+=get_timer2();
0EC6:  MOVF   FCC,W
0EC8:  ADDWF  x62,F
0ECA:  MOVLW  00
0ECC:  ADDWFC x63,F
....................     #endif
....................     #if getenv("TIMER3")
....................      TCPInit_RandSeed+=get_timer3();
0ECE:  MOVF   FB2,W
0ED0:  ADDWF  x62,F
0ED2:  MOVF   FB3,W
0ED4:  ADDWFC x63,F
....................     #endif
....................     #if getenv("TIMER4")
....................      TCPInit_RandSeed+=get_timer4();
....................     #endif
....................     #if getenv("TIMER5")
....................      TCPInit_RandSeed+=get_timer5();
....................     #endif
....................     srand(TCPInit_RandSeed);
0ED6:  MOVLB  2
0ED8:  CLRF   xE6
0EDA:  CLRF   xE5
0EDC:  MOVFF  63,2E4
0EE0:  MOVFF  62,2E3
0EE4:  MOVLB  0
0EE6:  BRA    0CB4
....................     _NextPort=rand();
0EE8:  BRA    0D6C
0EEA:  MOVFF  02,61
0EEE:  MOVFF  01,60
....................     _NextPort+=LOCAL_PORT_START_NUMBER;
0EF2:  MOVLW  04
0EF4:  ADDWF  x61,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;}
0EF6:  MOVF   x61,W
0EF8:  SUBLW  12
0EFA:  BC    0F10
0EFC:  XORLW  FF
0EFE:  BNZ   0F06
0F00:  MOVF   x60,W
0F02:  SUBLW  87
0F04:  BC    0F10
0F06:  MOVLW  88
0F08:  SUBWF  x60,F
0F0A:  MOVLW  13
0F0C:  SUBWFB x61,F
0F0E:  BRA    0EF6
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;}
0F10:  MOVF   x61,W
0F12:  SUBLW  03
0F14:  BNC   0F1A
0F16:  MOVLW  04
0F18:  ADDWF  x61,F
0F1A:  GOTO   1084 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           port    - A TCP port to be opened.
.................... *
.................... * Output:          Given port is opened and returned on success
.................... *                  INVALID_SOCKET if no more sockets left.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... TCP_SOCKET TCPListen(TCP_PORT port)
.................... {
....................    TCP_SOCKET s;
....................    SOCKET_INFO* ps;
.................... 
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port);
.................... 
....................    for(s = 0; s < MAX_SOCKETS; s++)
0F1E:  MOVLB  2
0F20:  CLRF   xE5
0F22:  MOVF   xE5,W
0F24:  SUBLW  04
0F26:  BNC   1000
....................    {
....................       ps = &TCB[s];
0F28:  MOVF   xE5,W
0F2A:  MULLW  24
0F2C:  MOVF   FF3,W
0F2E:  CLRF   03
0F30:  ADDLW  88
0F32:  MOVWF  01
0F34:  MOVLW  00
0F36:  ADDWFC 03,F
0F38:  MOVFF  01,2E6
0F3C:  MOVFF  03,2E7
.................... 
....................       if(ps->smState == TCP_CLOSED)
0F40:  MOVFF  2E6,FE9
0F44:  MOVFF  2E7,FEA
0F48:  MOVF   FEF,W
0F4A:  SUBLW  0A
0F4C:  BNZ   0FFC
....................       {
....................          // We have a CLOSED socket.
....................          // Initialize it with LISTENing state info.
....................          ps->smState             = TCP_LISTEN;
0F4E:  MOVFF  2E6,FE9
0F52:  MOVFF  2E7,FEA
0F56:  CLRF   FEF
....................          ps->localPort           = port;
0F58:  MOVLW  0B
0F5A:  ADDWF  xE6,W
0F5C:  MOVWF  FE9
0F5E:  MOVLW  00
0F60:  ADDWFC xE7,W
0F62:  MOVWF  FEA
0F64:  MOVFF  2E4,FEC
0F68:  MOVF   FED,F
0F6A:  MOVFF  2E3,FEF
....................          ps->remotePort          = 0;
0F6E:  MOVLW  0D
0F70:  ADDWF  xE6,W
0F72:  MOVWF  FE9
0F74:  MOVLW  00
0F76:  ADDWFC xE7,W
0F78:  MOVWF  FEA
0F7A:  CLRF   FEC
0F7C:  MOVF   FED,F
0F7E:  CLRF   FEF
.................... 
....................          // There is no remote node IP address info yet.
....................          ps->remote.IPAddr.Val   = 0x00;
0F80:  MOVLW  07
0F82:  ADDWF  xE6,W
0F84:  MOVWF  FE9
0F86:  MOVLW  00
0F88:  ADDWFC xE7,W
0F8A:  MOVWF  FEA
0F8C:  CLRF   FEF
0F8E:  CLRF   FEC
0F90:  CLRF   FEC
0F92:  CLRF   FEC
.................... 
....................          // If a socket is listened on, it is a SERVER.
....................          ps->Flags.bServer       = TRUE;
0F94:  MOVLW  23
0F96:  ADDWF  xE6,W
0F98:  MOVWF  FE9
0F9A:  MOVLW  00
0F9C:  ADDWFC xE7,W
0F9E:  MOVWF  FEA
0FA0:  BSF    FEF.0
.................... 
....................          ps->Flags.bIsGetReady   = FALSE;
0FA2:  MOVLW  23
0FA4:  ADDWF  xE6,W
0FA6:  MOVWF  FE9
0FA8:  MOVLW  00
0FAA:  ADDWFC xE7,W
0FAC:  MOVWF  FEA
0FAE:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER)
0FB0:  MOVLW  0F
0FB2:  ADDWF  xE6,W
0FB4:  MOVWF  FE9
0FB6:  MOVLW  00
0FB8:  ADDWFC xE7,W
0FBA:  MOVWF  FEA
0FBC:  INCFSZ FEF,W
0FBE:  BRA    0FC2
0FC0:  BRA    0FE8
....................          {
....................             MACDiscardTx(ps->TxBuffer);
0FC2:  MOVLW  0F
0FC4:  ADDWF  xE6,W
0FC6:  MOVWF  FE9
0FC8:  MOVLW  00
0FCA:  ADDWFC xE7,W
0FCC:  MOVWF  FEA
0FCE:  MOVFF  FEF,333
0FD2:  MOVLB  0
0FD4:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER;
0FD8:  MOVLW  0F
0FDA:  MOVLB  2
0FDC:  ADDWF  xE6,W
0FDE:  MOVWF  FE9
0FE0:  MOVLW  00
0FE2:  ADDWFC xE7,W
0FE4:  MOVWF  FEA
0FE6:  SETF   FEF
....................          }
....................          ps->Flags.bIsPutReady   = TRUE;
0FE8:  MOVLW  23
0FEA:  ADDWF  xE6,W
0FEC:  MOVWF  FE9
0FEE:  MOVLW  00
0FF0:  ADDWFC xE7,W
0FF2:  MOVWF  FEA
0FF4:  BSF    FEF.1
.................... 
....................          debug_tcp("SOCK=%U", s);
.................... 
....................          return s;
0FF6:  MOVFF  2E5,01
0FFA:  BRA    1004
....................       }
0FFC:  INCF   xE5,F
0FFE:  BRA    0F22
....................    }
.................... 
....................    debug_tcp("FAIL");
.................... 
....................    return INVALID_SOCKET;
1000:  MOVLW  FE
1002:  MOVWF  01
1004:  MOVLB  0
1006:  GOTO   1030 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote,
.................... *                                      TCP_PORT remotePort)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           remote      - Remote node address info
.................... *                  remotePort  - remote port to be connected.
.................... *
.................... * Output:          A new socket is created, connection request is
.................... *                  sent and socket handle is returned.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... ********************************************************************/
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort)
.................... {
....................    TCP_SOCKET s;
....................    SOCKET_INFO* ps;
....................    BOOL lbFound;
.................... 
.................... 
....................    lbFound = FALSE;
.................... 
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort);
.................... 
....................    // Find an available socket
....................    for(s = 0; s < MAX_SOCKETS; s++)
....................    {
....................       ps = &TCB[s];
....................       if(ps->smState == TCP_CLOSED)
....................       {
....................          lbFound = TRUE;
....................          break;
....................       }
....................    }
.................... 
....................    // If there is no socket available, return error.
....................    if(!lbFound)
....................       return INVALID_SOCKET;
.................... 
....................    // Each new socket that is opened by this node, gets
....................    // next sequential port number.
....................    ps->localPort = ++_NextPort;
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER)
....................       _NextPort = LOCAL_PORT_START_NUMBER-1;
.................... 
....................    // This is a client socket.
....................    ps->Flags.bServer = FALSE;
.................... 
....................    // This is the port, we are trying to connect to.
....................    ps->remotePort = remotePort;
.................... 
....................    // Each new socket that is opened by this node, will
....................    // start with next the next seqeuence number (essentially random)
....................    ps->SND_SEQ++;
....................    ps->SND_ACK = 0;
.................... 
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote));
.................... 
....................    // Send SYN message.
....................    SendTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       SYN);
.................... 
....................    ps->smState = TCP_SYN_SENT;
....................    ps->SND_SEQ++;
.................... 
....................    // Allow TCPTick() to operate properly
....................    ps->startTick = TickGet();
.................... 
....................    debug_tcp("SOCK=%U", s);
.................... 
....................    return s;
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - Socket to be checked for connection.
....................  *
....................  * Output:          TRUE    if given socket is connected
....................  *                  FALSE   if given socket is not connected.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            A socket is said to be connected if it is not
....................  *                  in LISTEN and CLOSED mode.  Socket may be in
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket
....................  *                  data.
....................  ********************************************************************/
.................... BOOL TCPIsConnected(TCP_SOCKET s)
.................... {
....................     return ( TCB[s].smState == TCP_ESTABLISHED );
*
3E16:  MOVLB  2
3E18:  MOVF   xEE,W
3E1A:  MULLW  24
3E1C:  MOVF   FF3,W
3E1E:  CLRF   xF0
3E20:  MOVWF  xEF
3E22:  MOVLW  88
3E24:  ADDWF  xEF,W
3E26:  MOVWF  FE9
3E28:  MOVLW  00
3E2A:  ADDWFC xF0,W
3E2C:  MOVWF  FEA
3E2E:  MOVF   FEF,W
3E30:  SUBLW  03
3E32:  BZ    3E38
3E34:  MOVLW  00
3E36:  BRA    3E3A
3E38:  MOVLW  01
3E3A:  MOVWF  01
3E3C:  MOVLB  0
3E3E:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPDisconnect(TCP_SOCKET s)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPIsPutReady(s) == TRUE
.................... *
.................... * Input:           s       - Socket to be disconnected.
.................... *
.................... * Output:          A disconnect request is sent for given socket.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... void TCPDisconnect(TCP_SOCKET s)
.................... {
....................    SOCKET_INFO *ps;
.................... 
....................    ps = &TCB[s];
*
5EFE:  MOVLB  2
5F00:  MOVF   xEE,W
5F02:  MULLW  24
5F04:  MOVF   FF3,W
5F06:  CLRF   03
5F08:  ADDLW  88
5F0A:  MOVWF  01
5F0C:  MOVLW  00
5F0E:  ADDWFC 03,F
5F10:  MOVFF  01,2EF
5F14:  MOVFF  03,2F0
.................... 
....................    // If socket is not connected, may be it is already closed
....................    // or in the process of closing.  Since we have called this
....................    // explicitly, close it forcefully.
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED)
5F18:  MOVFF  2EF,FE9
5F1C:  MOVFF  2F0,FEA
5F20:  MOVF   FEF,W
5F22:  SUBLW  03
5F24:  BZ    5F46
5F26:  MOVFF  2EF,FE9
5F2A:  MOVFF  2F0,FEA
5F2E:  MOVF   FEF,W
5F30:  SUBLW  02
5F32:  BZ    5F46
....................    {
....................       CloseSocket(ps);
5F34:  MOVFF  2F0,331
5F38:  MOVFF  2EF,330
5F3C:  MOVLB  0
5F3E:  CALL   24FE
....................       return;
5F42:  BRA    6008
5F44:  MOVLB  2
....................    }
.................... 
....................    // Discard any outstanding data that is to be read.
....................    TCPDiscard(s);
5F46:  MOVFF  2EE,2F1
5F4A:  MOVLB  0
5F4C:  CALL   4F9A
.................... 
....................    // Send FIN message.
....................    SendTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       FIN | ACK);
5F50:  MOVLW  01
5F52:  MOVLB  2
5F54:  ADDWF  xEF,W
5F56:  MOVWF  01
5F58:  MOVLW  00
5F5A:  ADDWFC xF0,W
5F5C:  MOVWF  03
5F5E:  MOVFF  01,2F1
5F62:  MOVWF  xF2
5F64:  MOVLW  0B
5F66:  ADDWF  xEF,W
5F68:  MOVWF  FE9
5F6A:  MOVLW  00
5F6C:  ADDWFC xF0,W
5F6E:  MOVWF  FEA
5F70:  MOVFF  FEC,33A
5F74:  MOVF   FED,F
5F76:  MOVFF  FEF,339
5F7A:  MOVLW  0D
5F7C:  ADDWF  xEF,W
5F7E:  MOVWF  FE9
5F80:  MOVLW  00
5F82:  ADDWFC xF0,W
5F84:  MOVWF  FEA
5F86:  MOVFF  FEC,33C
5F8A:  MOVF   FED,F
5F8C:  MOVFF  FEF,33B
5F90:  MOVLW  16
5F92:  ADDWF  xEF,W
5F94:  MOVWF  FE9
5F96:  MOVLW  00
5F98:  ADDWFC xF0,W
5F9A:  MOVWF  FEA
5F9C:  MOVFF  FEF,33D
5FA0:  MOVFF  FEC,33E
5FA4:  MOVFF  FEC,33F
5FA8:  MOVFF  FEC,340
5FAC:  MOVLW  1A
5FAE:  ADDWF  xEF,W
5FB0:  MOVWF  FE9
5FB2:  MOVLW  00
5FB4:  ADDWFC xF0,W
5FB6:  MOVWF  FEA
5FB8:  MOVFF  FEF,341
5FBC:  MOVFF  FEC,342
5FC0:  MOVFF  FEC,343
5FC4:  MOVFF  FEC,344
5FC8:  MOVFF  03,338
5FCC:  MOVFF  01,337
5FD0:  MOVLW  11
5FD2:  MOVLB  3
5FD4:  MOVWF  x45
5FD6:  SETF   x46
5FD8:  CLRF   x48
5FDA:  CLRF   x47
5FDC:  MOVLB  0
5FDE:  CALL   292A
....................    //DebugPrint(".");
.................... 
....................    ps->SND_SEQ++;
5FE2:  MOVLW  16
5FE4:  MOVLB  2
5FE6:  ADDWF  xEF,W
5FE8:  MOVWF  FE9
5FEA:  MOVLW  00
5FEC:  ADDWFC xF0,W
5FEE:  MOVWF  FEA
5FF0:  MOVLW  01
5FF2:  ADDWF  FEE,F
5FF4:  MOVLW  00
5FF6:  ADDWFC FEE,F
5FF8:  ADDWFC FEE,F
5FFA:  ADDWFC FED,F
.................... 
....................    ps->smState = TCP_FIN_WAIT_1;
5FFC:  MOVFF  2EF,FE9
6000:  MOVFF  2F0,FEA
6004:  MOVLW  04
6006:  MOVWF  FEF
6008:  MOVLB  0
.................... 
....................    return;
600A:  GOTO   6C36 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           s       - Socket whose data is to be transmitted.
.................... *
.................... * Output:          All and any data associated with this socket
.................... *                  is marked as ready for transmission.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... BOOL TCPFlush(TCP_SOCKET s)
.................... {
....................    SOCKET_INFO *ps;
.................... 
....................    ps = &TCB[s];
*
508C:  MOVLB  3
508E:  MOVF   x23,W
5090:  MULLW  24
5092:  MOVF   FF3,W
5094:  CLRF   03
5096:  ADDLW  88
5098:  MOVWF  01
509A:  MOVLW  00
509C:  ADDWFC 03,F
509E:  MOVFF  01,324
50A2:  MOVFF  03,325
.................... 
....................    // Make sure that there is TxBuffer assigned to this socket.
....................    if ( ps->TxBuffer == INVALID_BUFFER )
50A6:  MOVLW  0F
50A8:  ADDWF  x24,W
50AA:  MOVWF  FE9
50AC:  MOVLW  00
50AE:  ADDWFC x25,W
50B0:  MOVWF  FEA
50B2:  INCFSZ FEF,W
50B4:  BRA    50BC
....................       return FALSE;
50B6:  MOVLW  00
50B8:  MOVWF  01
50BA:  BRA    5216
.................... 
....................    if ( ps->Flags.bIsPutReady == FALSE )
50BC:  MOVLW  23
50BE:  ADDWF  x24,W
50C0:  MOVWF  01
50C2:  MOVLW  00
50C4:  ADDWFC x25,W
50C6:  MOVWF  03
50C8:  MOVFF  01,FE9
50CC:  MOVWF  FEA
50CE:  BTFSC  FEF.1
50D0:  BRA    50D8
....................       return FALSE;
50D2:  MOVLW  00
50D4:  MOVWF  01
50D6:  BRA    5216
.................... 
....................    TransmitTCP(&ps->remote,
....................       ps->localPort,
....................       ps->remotePort,
....................       ps->SND_SEQ,
....................       ps->SND_ACK,
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away
....................       ps->TxBuffer,
....................       ps->TxCount);
50D8:  MOVLW  01
50DA:  ADDWF  x24,W
50DC:  MOVWF  01
50DE:  MOVLW  00
50E0:  ADDWFC x25,W
50E2:  MOVWF  03
50E4:  MOVFF  01,326
50E8:  MOVWF  x27
50EA:  MOVLW  0B
50EC:  ADDWF  x24,W
50EE:  MOVWF  FE9
50F0:  MOVLW  00
50F2:  ADDWFC x25,W
50F4:  MOVWF  FEA
50F6:  MOVFF  FEC,33A
50FA:  MOVF   FED,F
50FC:  MOVFF  FEF,339
5100:  MOVLW  0D
5102:  ADDWF  x24,W
5104:  MOVWF  FE9
5106:  MOVLW  00
5108:  ADDWFC x25,W
510A:  MOVWF  FEA
510C:  MOVFF  FEC,33C
5110:  MOVF   FED,F
5112:  MOVFF  FEF,33B
5116:  MOVLW  16
5118:  ADDWF  x24,W
511A:  MOVWF  FE9
511C:  MOVLW  00
511E:  ADDWFC x25,W
5120:  MOVWF  FEA
5122:  MOVFF  FEF,33D
5126:  MOVFF  FEC,33E
512A:  MOVFF  FEC,33F
512E:  MOVFF  FEC,340
5132:  MOVLW  1A
5134:  ADDWF  x24,W
5136:  MOVWF  FE9
5138:  MOVLW  00
513A:  ADDWFC x25,W
513C:  MOVWF  FEA
513E:  MOVFF  FEF,341
5142:  MOVFF  FEC,342
5146:  MOVFF  FEC,343
514A:  MOVFF  FEC,344
514E:  MOVLW  0F
5150:  ADDWF  x24,W
5152:  MOVWF  FE9
5154:  MOVLW  00
5156:  ADDWFC x25,W
5158:  MOVWF  FEA
515A:  MOVFF  FEF,346
515E:  MOVLW  10
5160:  ADDWF  x24,W
5162:  MOVWF  FE9
5164:  MOVLW  00
5166:  ADDWFC x25,W
5168:  MOVWF  FEA
516A:  MOVFF  FEC,348
516E:  MOVF   FED,F
5170:  MOVFF  FEF,347
5174:  MOVFF  03,338
5178:  MOVFF  01,337
517C:  MOVLW  18
517E:  MOVWF  x45
5180:  MOVLB  0
5182:  CALL   292A
.................... 
....................    ps->SND_SEQ += (DWORD)ps->TxCount;
5186:  MOVLW  16
5188:  MOVLB  3
518A:  ADDWF  x24,W
518C:  MOVWF  01
518E:  MOVLW  00
5190:  ADDWFC x25,W
5192:  MOVWF  03
5194:  MOVFF  01,326
5198:  MOVWF  x27
519A:  MOVWF  FEA
519C:  MOVFF  01,FE9
51A0:  MOVFF  FEF,328
51A4:  MOVFF  FEC,329
51A8:  MOVFF  FEC,32A
51AC:  MOVFF  FEC,32B
51B0:  MOVLW  10
51B2:  ADDWF  x24,W
51B4:  MOVWF  FE9
51B6:  MOVLW  00
51B8:  ADDWFC x25,W
51BA:  MOVWF  FEA
51BC:  MOVFF  FEC,03
51C0:  MOVF   FED,F
51C2:  MOVFF  FEF,00
51C6:  MOVFF  03,01
51CA:  CLRF   02
51CC:  CLRF   03
51CE:  MOVF   x28,W
51D0:  ADDWF  00,F
51D2:  MOVF   x29,W
51D4:  ADDWFC 01,F
51D6:  MOVF   x2A,W
51D8:  ADDWFC 02,F
51DA:  MOVF   x2B,W
51DC:  ADDWFC 03,F
51DE:  MOVFF  327,FEA
51E2:  MOVFF  326,FE9
51E6:  MOVFF  00,FEF
51EA:  MOVFF  01,FEC
51EE:  MOVFF  02,FEC
51F2:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE;
51F6:  MOVLW  23
51F8:  ADDWF  x24,W
51FA:  MOVWF  FE9
51FC:  MOVLW  00
51FE:  ADDWFC x25,W
5200:  MOVWF  FEA
5202:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE;
5204:  MOVLW  23
5206:  ADDWF  x24,W
5208:  MOVWF  FE9
520A:  MOVLW  00
520C:  ADDWFC x25,W
520E:  MOVWF  FEA
5210:  BCF    FEF.4
.................... 
.................... #if TCP_NO_WAIT_FOR_ACK
....................    if(ps->TxBuffer != INVALID_BUFFER)
....................    {
....................       MACDiscardTx(ps->TxBuffer);
....................       ps->TxBuffer        = INVALID_BUFFER;
....................    }
....................    ps->Flags.bIsPutReady       = TRUE;
.................... #endif
.................... 
....................    return TRUE;
5212:  MOVLW  01
5214:  MOVWF  01
5216:  MOVLB  0
5218:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' is free to transmit
....................  *                  FALSE if socket 's' is not free to transmit.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            Each socket maintains only transmit buffer.
....................  *                  Hence until a data packet is acknowledeged by
....................  *                  remote node, socket will not be ready for
....................  *                  next transmission.
....................  *                  All control transmission such as Connect,
....................  *                  Disconnect do not consume/reserve any transmit
....................  *                  buffer.
....................  ********************************************************************/
.................... BOOL TCPIsPutReady(TCP_SOCKET s)
.................... {
....................    if(TCB[s].RemoteWindow == 0)
*
4FE8:  MOVLB  3
4FEA:  MOVF   x11,W
4FEC:  MULLW  24
4FEE:  MOVF   FF3,W
4FF0:  CLRF   x13
4FF2:  MOVWF  x12
4FF4:  MOVLW  14
4FF6:  ADDWF  x12,W
4FF8:  MOVWF  01
4FFA:  MOVLW  00
4FFC:  ADDWFC x13,W
4FFE:  MOVWF  03
5000:  MOVF   01,W
5002:  ADDLW  88
5004:  MOVWF  FE9
5006:  MOVLW  00
5008:  ADDWFC 03,W
500A:  MOVWF  FEA
500C:  MOVFF  FEC,313
5010:  MOVF   FED,F
5012:  MOVFF  FEF,312
5016:  MOVF   x12,F
5018:  BNZ   5024
501A:  MOVF   x13,F
501C:  BNZ   5024
....................       return FALSE;
501E:  MOVLW  00
5020:  MOVWF  01
5022:  BRA    5080
.................... 
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER )
5024:  MOVF   x11,W
5026:  MULLW  24
5028:  MOVF   FF3,W
502A:  CLRF   x13
502C:  MOVWF  x12
502E:  MOVLW  0F
5030:  ADDWF  x12,W
5032:  MOVWF  01
5034:  MOVLW  00
5036:  ADDWFC x13,W
5038:  MOVWF  03
503A:  MOVF   01,W
503C:  ADDLW  88
503E:  MOVWF  FE9
5040:  MOVLW  00
5042:  ADDWFC 03,W
5044:  MOVWF  FEA
5046:  INCFSZ FEF,W
5048:  BRA    505A
....................       return IPIsTxReady(FALSE);
504A:  CLRF   x6F
504C:  MOVLB  0
504E:  CALL   25F2
5052:  MOVF   01,W
5054:  MOVLB  3
5056:  BRA    5080
5058:  BRA    5080
....................    else
....................       return TCB[s].Flags.bIsPutReady;
505A:  MOVF   x11,W
505C:  MULLW  24
505E:  MOVF   FF3,W
5060:  CLRF   x13
5062:  MOVWF  x12
5064:  MOVLW  23
5066:  ADDWF  x12,F
5068:  MOVLW  00
506A:  ADDWFC x13,F
506C:  MOVLW  88
506E:  ADDWF  x12,W
5070:  MOVWF  FE9
5072:  MOVLW  00
5074:  ADDWFC x13,W
5076:  MOVWF  FEA
5078:  MOVLW  00
507A:  BTFSC  FEF.1
507C:  MOVLW  01
507E:  MOVWF  01
5080:  MOVLB  0
5082:  RETURN 0
.................... }
.................... 
.................... 
.................... int16 TCPPutAvailable(TCP_SOCKET s)
.................... {
....................    int16 txCount, txAvail;
.................... 
....................    if (!TCPIsPutReady(s))
*
54AE:  MOVFF  30C,311
54B2:  RCALL  4FE8
54B4:  MOVF   01,F
54B6:  BNZ   54C0
....................       return(0);
54B8:  MOVLW  00
54BA:  MOVWF  01
54BC:  MOVWF  02
54BE:  BRA    55A4
.................... 
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER )
54C0:  MOVLB  3
54C2:  MOVF   x0C,W
54C4:  MULLW  24
54C6:  MOVF   FF3,W
54C8:  CLRF   x12
54CA:  MOVWF  x11
54CC:  MOVLW  0F
54CE:  ADDWF  x11,W
54D0:  MOVWF  01
54D2:  MOVLW  00
54D4:  ADDWFC x12,W
54D6:  MOVWF  03
54D8:  MOVF   01,W
54DA:  ADDLW  88
54DC:  MOVWF  FE9
54DE:  MOVLW  00
54E0:  ADDWFC 03,W
54E2:  MOVWF  FEA
54E4:  INCFSZ FEF,W
54E6:  BRA    54EE
....................       txCount = 0;
54E8:  CLRF   x0E
54EA:  CLRF   x0D
54EC:  BRA    551A
....................    else
....................       txCount = TCB[s].TxCount;
54EE:  MOVF   x0C,W
54F0:  MULLW  24
54F2:  MOVF   FF3,W
54F4:  CLRF   x12
54F6:  MOVWF  x11
54F8:  MOVLW  10
54FA:  ADDWF  x11,W
54FC:  MOVWF  01
54FE:  MOVLW  00
5500:  ADDWFC x12,W
5502:  MOVWF  03
5504:  MOVF   01,W
5506:  ADDLW  88
5508:  MOVWF  FE9
550A:  MOVLW  00
550C:  ADDWFC 03,W
550E:  MOVWF  FEA
5510:  MOVFF  FEC,30E
5514:  MOVF   FED,F
5516:  MOVFF  FEF,30D
.................... 
....................    txAvail = MAX_TCP_DATA_LEN - txCount;
551A:  MOVLW  CA
551C:  BSF    FD8.0
551E:  SUBFWB x0D,W
5520:  MOVWF  x0F
5522:  MOVLW  03
5524:  SUBFWB x0E,W
5526:  MOVWF  x10
.................... 
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail;
5528:  MOVF   x0C,W
552A:  MULLW  24
552C:  MOVF   FF3,W
552E:  CLRF   x12
5530:  MOVWF  x11
5532:  MOVLW  14
5534:  ADDWF  x11,W
5536:  MOVWF  01
5538:  MOVLW  00
553A:  ADDWFC x12,W
553C:  MOVWF  03
553E:  MOVF   01,W
5540:  ADDLW  88
5542:  MOVWF  FE9
5544:  MOVLW  00
5546:  ADDWFC 03,W
5548:  MOVWF  FEA
554A:  MOVFF  FEC,03
554E:  MOVF   FED,F
5550:  MOVFF  FEF,01
5554:  MOVF   03,W
5556:  SUBWF  x10,W
5558:  BNC   558E
555A:  BNZ   5562
555C:  MOVF   x0F,W
555E:  SUBWF  01,W
5560:  BC    558E
5562:  MOVF   x0C,W
5564:  MULLW  24
5566:  MOVF   FF3,W
5568:  CLRF   x12
556A:  MOVWF  x11
556C:  MOVLW  14
556E:  ADDWF  x11,W
5570:  MOVWF  01
5572:  MOVLW  00
5574:  ADDWFC x12,W
5576:  MOVWF  03
5578:  MOVF   01,W
557A:  ADDLW  88
557C:  MOVWF  FE9
557E:  MOVLW  00
5580:  ADDWFC 03,W
5582:  MOVWF  FEA
5584:  MOVFF  FEC,03
5588:  MOVF   FED,F
558A:  MOVF   FEF,W
558C:  BRA    5594
558E:  MOVFF  310,03
5592:  MOVF   x0F,W
5594:  MOVWF  x0F
5596:  MOVFF  03,310
.................... 
....................    return(txAvail);
559A:  MOVFF  30F,01
559E:  MOVFF  310,02
55A2:  MOVLB  0
55A4:  RETURN 0
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s      - socket to use
....................  *                  ptr    - Block of data to send over TCP
....................  *                  len    - number of bytes to send over TCP
....................  *
....................  * Output:          Total number of bytes written to TCP.  If this value
....................  *                  is not equal len that means we ran out of space in the
....................  *                  TX buffer -OR- we ran out of space in the remote node's
....................  *                  window.  In either case you will have to continue later.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len)
.................... {
....................    SOCKET_INFO* ps;
....................    WORD n;
.................... 
....................    ps = &TCB[s];
.................... 
....................    // Make sure that the remote node is able to accept our data
....................    if(ps->RemoteWindow == 0)
....................       return 0;
.................... 
....................    if(ps->TxBuffer == INVALID_BUFFER)
....................    {
....................       ps->TxBuffer = MACGetTxBuffer(FALSE);
.................... 
....................       // Check to make sure that we received a TX Buffer
....................       if(ps->TxBuffer == INVALID_BUFFER)
....................          return 0;
.................... 
....................       ps->TxCount = 0;
.................... 
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER));
....................    }
.................... 
....................    n = TCPPutAvailable(s);
.................... 
....................    ps->Flags.bIsTxInProgress = TRUE;
.................... 
....................    while (n--)
....................    {
....................       MACPut(*ptr++);
....................       ps->RemoteWindow -= 1;
....................       ps->TxCount += 1;
....................    }
.................... 
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN)
....................       TCPFlush(s);
.................... 
....................    return(len);
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len)
....................  *
....................  * PreCondition:    TCPIsPutReady() == TRUE
....................  *
....................  * Input:           s      - socket to use
....................  *                  ptr    - Block of data to send over TCP
....................  *                  len    - number of bytes to send over TCP
....................  *
....................  * Output:          Total number of bytes written to TCP.  If this value
....................  *                  is not equal len that means we ran out of space in the
....................  *                  TX buffer and you will have to continue later.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte)
.................... {
....................    SOCKET_INFO* ps;
....................    WORD tempCount;
.................... 
....................    ps = &TCB[s];
*
521A:  MOVLB  3
521C:  MOVF   x1D,W
521E:  MULLW  24
5220:  MOVF   FF3,W
5222:  CLRF   03
5224:  ADDLW  88
5226:  MOVWF  01
5228:  MOVLW  00
522A:  ADDWFC 03,F
522C:  MOVFF  01,31F
5230:  MOVFF  03,320
.................... 
....................    // Make sure that the remote node is able to accept our data
....................    if(ps->RemoteWindow == 0)
5234:  MOVLW  14
5236:  ADDWF  x1F,W
5238:  MOVWF  FE9
523A:  MOVLW  00
523C:  ADDWFC x20,W
523E:  MOVWF  FEA
5240:  MOVFF  FEC,324
5244:  MOVF   FED,F
5246:  MOVFF  FEF,323
524A:  MOVF   x23,F
524C:  BNZ   5258
524E:  MOVF   x24,F
5250:  BNZ   5258
....................       return FALSE;
5252:  MOVLW  00
5254:  MOVWF  01
5256:  BRA    5356
.................... 
....................    if(ps->TxBuffer == INVALID_BUFFER)
5258:  MOVLW  0F
525A:  ADDWF  x1F,W
525C:  MOVWF  FE9
525E:  MOVLW  00
5260:  ADDWFC x20,W
5262:  MOVWF  FEA
5264:  INCFSZ FEF,W
5266:  BRA    52D6
....................    {
....................       ps->TxBuffer = MACGetTxBuffer(FALSE);
5268:  MOVLW  0F
526A:  ADDWF  x1F,W
526C:  MOVWF  01
526E:  MOVLW  00
5270:  ADDWFC x20,W
5272:  MOVWF  03
5274:  MOVFF  01,323
5278:  MOVWF  x24
527A:  CLRF   x6F
527C:  MOVLB  0
527E:  CALL   1528
5282:  MOVFF  324,FEA
5286:  MOVFF  323,FE9
528A:  MOVFF  01,FEF
.................... 
....................       // Check to make sure that we received a TX Buffer
....................       if(ps->TxBuffer == INVALID_BUFFER)
528E:  MOVLW  0F
5290:  MOVLB  3
5292:  ADDWF  x1F,W
5294:  MOVWF  FE9
5296:  MOVLW  00
5298:  ADDWFC x20,W
529A:  MOVWF  FEA
529C:  INCFSZ FEF,W
529E:  BRA    52A6
....................          return FALSE;
52A0:  MOVLW  00
52A2:  MOVWF  01
52A4:  BRA    5356
.................... 
....................       ps->TxCount = 0;
52A6:  MOVLW  10
52A8:  ADDWF  x1F,W
52AA:  MOVWF  FE9
52AC:  MOVLW  00
52AE:  ADDWFC x20,W
52B0:  MOVWF  FEA
52B2:  CLRF   FEC
52B4:  MOVF   FED,F
52B6:  CLRF   FEF
.................... 
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER));
52B8:  MOVLW  0F
52BA:  ADDWF  x1F,W
52BC:  MOVWF  FE9
52BE:  MOVLW  00
52C0:  ADDWFC x20,W
52C2:  MOVWF  FEA
52C4:  MOVFF  FEF,388
52C8:  CLRF   x8A
52CA:  MOVLW  28
52CC:  MOVWF  x89
52CE:  MOVLB  0
52D0:  CALL   1550
52D4:  MOVLB  3
....................    }
.................... 
....................    ps->Flags.bIsTxInProgress = TRUE;
52D6:  MOVLW  23
52D8:  ADDWF  x1F,W
52DA:  MOVWF  FE9
52DC:  MOVLW  00
52DE:  ADDWFC x20,W
52E0:  MOVWF  FEA
52E2:  BSF    FEF.4
.................... 
....................    MACPut(byte);
52E4:  MOVFF  31E,392
52E8:  MOVLB  0
52EA:  CALL   15EE
....................    ps->RemoteWindow--;
52EE:  MOVLW  14
52F0:  MOVLB  3
52F2:  ADDWF  x1F,W
52F4:  MOVWF  FE9
52F6:  MOVLW  00
52F8:  ADDWFC x20,W
52FA:  MOVWF  FEA
52FC:  MOVLW  FF
52FE:  ADDWF  FEF,F
5300:  BC    5306
5302:  MOVF   FEE,F
5304:  DECF   FED,F
.................... 
....................    tempCount = ps->TxCount;
5306:  MOVLW  10
5308:  ADDWF  x1F,W
530A:  MOVWF  FE9
530C:  MOVLW  00
530E:  ADDWFC x20,W
5310:  MOVWF  FEA
5312:  MOVFF  FEC,322
5316:  MOVF   FED,F
5318:  MOVFF  FEF,321
....................    tempCount++;
531C:  INCF   x21,F
531E:  BTFSC  FD8.2
5320:  INCF   x22,F
....................    ps->TxCount = tempCount;
5322:  MOVLW  10
5324:  ADDWF  x1F,W
5326:  MOVWF  FE9
5328:  MOVLW  00
532A:  ADDWFC x20,W
532C:  MOVWF  FEA
532E:  MOVFF  322,FEC
5332:  MOVF   FED,F
5334:  MOVFF  321,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN)
5338:  MOVF   x22,W
533A:  SUBLW  02
533C:  BC    5352
533E:  XORLW  FF
5340:  BNZ   5348
5342:  MOVF   x21,W
5344:  SUBLW  C9
5346:  BC    5352
....................       TCPFlush(s);
5348:  MOVFF  31D,323
534C:  MOVLB  0
534E:  RCALL  508C
5350:  MOVLB  3
.................... 
....................    return TRUE;
5352:  MOVLW  01
5354:  MOVWF  01
5356:  MOVLB  0
5358:  GOTO   5366 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket
....................  *
....................  * Output:          TRUE if socket received data was discarded
....................  *                  FALSE if socket received data was already
....................  *                          discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPDiscard(TCP_SOCKET s)
.................... {
....................     SOCKET_INFO* ps;
.................... 
....................     ps = &TCB[s];
*
4F9A:  MOVLB  2
4F9C:  MOVF   xF1,W
4F9E:  MULLW  24
4FA0:  MOVF   FF3,W
4FA2:  CLRF   03
4FA4:  ADDLW  88
4FA6:  MOVWF  01
4FA8:  MOVLW  00
4FAA:  ADDWFC 03,F
4FAC:  MOVFF  01,2F2
4FB0:  MOVFF  03,2F3
.................... 
....................     // This socket must contain data for it to be discarded.
....................     if ( !ps->Flags.bIsGetReady )
4FB4:  MOVLW  23
4FB6:  ADDWF  xF2,W
4FB8:  MOVWF  FE9
4FBA:  MOVLW  00
4FBC:  ADDWFC xF3,W
4FBE:  MOVWF  FEA
4FC0:  BTFSC  FEF.3
4FC2:  BRA    4FCA
....................         return FALSE;
4FC4:  MOVLW  00
4FC6:  MOVWF  01
4FC8:  BRA    4FE4
.................... 
....................     MACDiscardRx();
4FCA:  MOVLB  0
4FCC:  CALL   1164
....................     ps->Flags.bIsGetReady = FALSE;
4FD0:  MOVLW  23
4FD2:  MOVLB  2
4FD4:  ADDWF  xF2,W
4FD6:  MOVWF  FE9
4FD8:  MOVLW  00
4FDA:  ADDWFC xF3,W
4FDC:  MOVWF  FEA
4FDE:  BCF    FEF.3
.................... 
....................     return TRUE;
4FE0:  MOVLW  01
4FE2:  MOVWF  01
4FE4:  MOVLB  0
4FE6:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer,
....................  *                                      WORD count)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  buffer  - Buffer to hold received data.
....................  *                  count   - Buffer length
....................  *
....................  * Output:          Number of bytes loaded into buffer.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count)
.................... {
....................     SOCKET_INFO *ps;
.................... 
....................     ps = &TCB[s];
.................... 
....................     if ( ps->Flags.bIsGetReady )
....................     {
....................         if ( ps->Flags.bFirstRead )
....................         {
....................          // Position read pointer to begining of TCP data
....................             IPSetRxBuffer(sizeof(TCP_HEADER));
.................... 
....................             ps->Flags.bFirstRead = FALSE;
....................         }
.................... 
....................         ps->Flags.bIsTxInProgress = TRUE;
.................... 
....................         return MACGetArray(buff, count);
....................     }
....................     else
....................         return 0;
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte)
....................  *
....................  * PreCondition:    TCPInit() is already called     AND
....................  *                  TCPIsGetReady(s) == TRUE
....................  *
....................  * Input:           s       - socket
....................  *                  byte    - Pointer to a byte.
....................  *
....................  * Output:          TRUE if a byte was read.
....................  *                  FALSE if byte was not read.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data)
.................... {
....................     SOCKET_INFO* ps;
.................... 
....................     ps = &TCB[s];
*
3E6C:  MOVLB  2
3E6E:  MOVF   xEE,W
3E70:  MULLW  24
3E72:  MOVF   FF3,W
3E74:  CLRF   03
3E76:  ADDLW  88
3E78:  MOVWF  01
3E7A:  MOVLW  00
3E7C:  ADDWFC 03,F
3E7E:  MOVFF  01,2F1
3E82:  MOVFF  03,2F2
.................... 
....................     if ( ps->Flags.bIsGetReady )
3E86:  MOVLW  23
3E88:  ADDWF  xF1,W
3E8A:  MOVWF  FE9
3E8C:  MOVLW  00
3E8E:  ADDWFC xF2,W
3E90:  MOVWF  FEA
3E92:  BTFSS  FEF.3
3E94:  BRA    3F36
....................     {
....................         if ( ps->Flags.bFirstRead )
3E96:  MOVLW  23
3E98:  ADDWF  xF1,W
3E9A:  MOVWF  FE9
3E9C:  MOVLW  00
3E9E:  ADDWFC xF2,W
3EA0:  MOVWF  FEA
3EA2:  BTFSS  FEF.2
3EA4:  BRA    3EC4
....................         {
....................             // Position read pointer to begining of correct
....................             // buffer.
....................             IPSetRxBuffer(sizeof(TCP_HEADER));
3EA6:  MOVLB  3
3EA8:  CLRF   x14
3EAA:  MOVLW  14
3EAC:  MOVWF  x13
3EAE:  MOVLB  0
3EB0:  CALL   20F2
.................... 
....................             ps->Flags.bFirstRead = FALSE;
3EB4:  MOVLW  23
3EB6:  MOVLB  2
3EB8:  ADDWF  xF1,W
3EBA:  MOVWF  FE9
3EBC:  MOVLW  00
3EBE:  ADDWFC xF2,W
3EC0:  MOVWF  FEA
3EC2:  BCF    FEF.2
....................         }
.................... 
....................         if ( ps->RxCount == 0 )
3EC4:  MOVLW  12
3EC6:  ADDWF  xF1,W
3EC8:  MOVWF  FE9
3ECA:  MOVLW  00
3ECC:  ADDWFC xF2,W
3ECE:  MOVWF  FEA
3ED0:  MOVFF  FEC,2F4
3ED4:  MOVF   FED,F
3ED6:  MOVFF  FEF,2F3
3EDA:  MOVF   xF3,F
3EDC:  BNZ   3EFE
3EDE:  MOVF   xF4,F
3EE0:  BNZ   3EFE
....................         {
....................             MACDiscardRx();
3EE2:  MOVLB  0
3EE4:  CALL   1164
....................             ps->Flags.bIsGetReady = FALSE;
3EE8:  MOVLW  23
3EEA:  MOVLB  2
3EEC:  ADDWF  xF1,W
3EEE:  MOVWF  FE9
3EF0:  MOVLW  00
3EF2:  ADDWFC xF2,W
3EF4:  MOVWF  FEA
3EF6:  BCF    FEF.3
....................             return FALSE;
3EF8:  MOVLW  00
3EFA:  MOVWF  01
3EFC:  BRA    3F3A
....................         }
.................... 
....................          ps->RxCount--;
3EFE:  MOVLW  12
3F00:  ADDWF  xF1,W
3F02:  MOVWF  FE9
3F04:  MOVLW  00
3F06:  ADDWFC xF2,W
3F08:  MOVWF  FEA
3F0A:  MOVLW  FF
3F0C:  ADDWF  FEF,F
3F0E:  BC    3F14
3F10:  MOVF   FEE,F
3F12:  DECF   FED,F
....................          *data = MACGet();
3F14:  MOVFF  2F0,2F4
3F18:  MOVFF  2EF,2F3
3F1C:  MOVLB  0
3F1E:  CALL   1F6E
3F22:  MOVFF  2F4,FEA
3F26:  MOVFF  2F3,FE9
3F2A:  MOVFF  01,FEF
....................         return TRUE;
3F2E:  MOVLW  01
3F30:  MOVWF  01
3F32:  MOVLB  2
3F34:  BRA    3F3A
....................     }
....................     return FALSE;
3F36:  MOVLW  00
3F38:  MOVWF  01
3F3A:  MOVLB  0
3F3C:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s)
....................  *
....................  * PreCondition:    TCPInit() is already called.
....................  *
....................  * Input:           s       - socket to test
....................  *
....................  * Output:          TRUE if socket 's' contains any data.
....................  *                  FALSE if socket 's' does not contain any data.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL TCPIsGetReady(TCP_SOCKET s)
.................... {
....................     /*
....................      * A socket is said to be "Get" ready when it has already
....................      * received some data.  Sometime, a socket may be closed,
....................      * but it still may contain data.  Thus in order to ensure
....................      * reuse of a socket, caller must make sure that it reads
....................      * a socket, if is ready.
....................      */
....................     return (TCB[s].Flags.bIsGetReady );
*
3E40:  MOVLB  2
3E42:  MOVF   xEE,W
3E44:  MULLW  24
3E46:  MOVF   FF3,W
3E48:  CLRF   xF0
3E4A:  MOVWF  xEF
3E4C:  MOVLW  23
3E4E:  ADDWF  xEF,F
3E50:  MOVLW  00
3E52:  ADDWFC xF0,F
3E54:  MOVLW  88
3E56:  ADDWF  xEF,W
3E58:  MOVWF  FE9
3E5A:  MOVLW  00
3E5C:  ADDWFC xF0,W
3E5E:  MOVWF  FEA
3E60:  MOVLW  00
3E62:  BTFSC  FEF.3
3E64:  MOVLW  01
3E66:  MOVWF  01
3E68:  MOVLB  0
3E6A:  RETURN 0
.................... }
.................... 
.................... //// internal functions /////
.................... 
.................... void DebugTCPDisplayState(TCP_STATE st)
.................... {
....................    switch(st)
....................    {
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break;
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break;
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break;
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break;
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break;
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break;
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break;
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break;
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break;
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break;
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break;
....................       default:                debug_tcp("UNKNOWN %U",st); break;
....................    }
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        void TCPTick(void)
.................... *
.................... * PreCondition:    TCPInit() is already called.
.................... *
.................... * Input:           None
.................... *
.................... * Output:          Each socket FSM is executed for any timeout
.................... *                  situation.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... void TCPTick(void)
.................... {
....................    TCP_SOCKET s;
....................    TICKTYPE diffTicks;
....................    TICKTYPE tick;
....................    SOCKET_INFO* ps;
....................    DWORD seq;
....................    BYTE flags;
....................    //BYTE debugLastState;
.................... 
....................    flags = 0x00;
*
399C:  MOVLB  2
399E:  CLRF   xF1
....................    // Periodically all "not closed" sockets must perform timed operations
....................    for(s = 0; s < MAX_SOCKETS; s++)
39A0:  CLRF   xE6
39A2:  MOVF   xE6,W
39A4:  SUBLW  04
39A6:  BTFSS  FD8.0
39A8:  BRA    3DE4
....................    {
....................       ps = &TCB[s];
39AA:  MOVF   xE6,W
39AC:  MULLW  24
39AE:  MOVF   FF3,W
39B0:  CLRF   03
39B2:  ADDLW  88
39B4:  MOVWF  01
39B6:  MOVLW  00
39B8:  ADDWFC 03,F
39BA:  MOVFF  01,2EB
39BE:  MOVFF  03,2EC
.................... 
....................       //debugLastState = TCB[s].smState;
.................... 
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress )
39C2:  MOVLW  23
39C4:  ADDWF  xEB,W
39C6:  MOVWF  FE9
39C8:  MOVLW  00
39CA:  ADDWFC xEC,W
39CC:  MOVWF  FEA
39CE:  BTFSC  FEF.3
39D0:  BRA    39E2
39D2:  MOVLW  23
39D4:  ADDWF  xEB,W
39D6:  MOVWF  FE9
39D8:  MOVLW  00
39DA:  ADDWFC xEC,W
39DC:  MOVWF  FEA
39DE:  BTFSS  FEF.4
39E0:  BRA    39E4
....................          continue;
39E2:  BRA    3DE0
.................... 
.................... 
....................       // Closed or Passively Listening socket do not care
....................       // about timeout conditions.
....................       if ( (ps->smState == TCP_CLOSED) ||
....................          (ps->smState == TCP_LISTEN &&
....................          ps->Flags.bServer == TRUE) )
39E4:  MOVFF  2EB,FE9
39E8:  MOVFF  2EC,FEA
39EC:  MOVF   FEF,W
39EE:  SUBLW  0A
39F0:  BZ    3A14
39F2:  MOVFF  2EB,FE9
39F6:  MOVFF  2EC,FEA
39FA:  MOVF   FEF,F
39FC:  BNZ   3A16
39FE:  MOVLW  23
3A00:  ADDWF  xEB,W
3A02:  MOVWF  01
3A04:  MOVLW  00
3A06:  ADDWFC xEC,W
3A08:  MOVWF  03
3A0A:  MOVFF  01,FE9
3A0E:  MOVWF  FEA
3A10:  BTFSS  FEF.0
3A12:  BRA    3A16
....................          continue;
3A14:  BRA    3DE0
.................... 
....................       //TODO: review this
....................       //DSR ADD 063004
....................         //i do this because if i am a server, i don't want to timeout.
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) )
3A16:  MOVFF  2EB,FE9
3A1A:  MOVFF  2EC,FEA
3A1E:  MOVF   FEF,W
3A20:  SUBLW  03
3A22:  BNZ   3A3C
3A24:  MOVLW  23
3A26:  ADDWF  xEB,W
3A28:  MOVWF  01
3A2A:  MOVLW  00
3A2C:  ADDWFC xEC,W
3A2E:  MOVWF  03
3A30:  MOVFF  01,FE9
3A34:  MOVWF  FEA
3A36:  BTFSS  FEF.0
3A38:  BRA    3A3C
....................          continue;
3A3A:  BRA    3DE0
.................... 
.................... 
....................       tick = TickGet();
3A3C:  MOVLB  0
3A3E:  CALL   24E4
3A42:  MOVFF  02,2EA
3A46:  MOVFF  01,2E9
.................... 
....................       // Calculate timeout value for this socket.
....................       diffTicks = TickGetDiff(tick, ps->startTick);
3A4A:  MOVLW  1F
3A4C:  MOVLB  2
3A4E:  ADDWF  xEB,W
3A50:  MOVWF  FE9
3A52:  MOVLW  00
3A54:  ADDWFC xEC,W
3A56:  MOVWF  FEA
3A58:  MOVFF  FEC,03
3A5C:  MOVF   FED,F
3A5E:  MOVFF  FEF,01
3A62:  MOVF   xEA,W
3A64:  SUBWF  03,W
3A66:  BNC   3A70
3A68:  BNZ   3A74
3A6A:  MOVF   01,W
3A6C:  SUBWF  xE9,W
3A6E:  BNC   3A74
3A70:  MOVLW  00
3A72:  BRA    3A76
3A74:  MOVLW  01
3A76:  CLRF   03
3A78:  IORWF  03,W
3A7A:  BZ    3AB2
3A7C:  MOVLW  1F
3A7E:  ADDWF  xEB,W
3A80:  MOVWF  FE9
3A82:  MOVLW  00
3A84:  ADDWFC xEC,W
3A86:  MOVWF  FEA
3A88:  MOVFF  FEC,03
3A8C:  MOVF   FED,F
3A8E:  MOVF   FEF,W
3A90:  SUBLW  FF
3A92:  MOVWF  xF2
3A94:  MOVLW  FF
3A96:  SUBFWB 03,W
3A98:  MOVWF  xF3
3A9A:  MOVF   xE9,W
3A9C:  ADDWF  xF2,F
3A9E:  MOVF   xEA,W
3AA0:  ADDWFC xF3,F
3AA2:  MOVLW  01
3AA4:  ADDWF  xF2,W
3AA6:  MOVWF  01
3AA8:  MOVLW  00
3AAA:  ADDWFC xF3,W
3AAC:  MOVWF  03
3AAE:  MOVF   01,W
3AB0:  BRA    3AD2
3AB2:  MOVLW  1F
3AB4:  ADDWF  xEB,W
3AB6:  MOVWF  FE9
3AB8:  MOVLW  00
3ABA:  ADDWFC xEC,W
3ABC:  MOVWF  FEA
3ABE:  MOVFF  FEC,03
3AC2:  MOVF   FED,F
3AC4:  MOVF   FEF,W
3AC6:  SUBWF  xE9,W
3AC8:  MOVWF  00
3ACA:  MOVF   03,W
3ACC:  SUBWFB xEA,W
3ACE:  MOVWF  03
3AD0:  MOVF   00,W
3AD2:  MOVWF  xE7
3AD4:  MOVFF  03,2E8
.................... 
....................       // If timeout has not occured, do not do anything.
....................       if(diffTicks <= ps->TimeOut)
3AD8:  MOVLW  21
3ADA:  ADDWF  xEB,W
3ADC:  MOVWF  FE9
3ADE:  MOVLW  00
3AE0:  ADDWFC xEC,W
3AE2:  MOVWF  FEA
3AE4:  MOVFF  FEC,03
3AE8:  MOVF   FED,F
3AEA:  MOVFF  FEF,01
3AEE:  MOVF   xE8,W
3AF0:  SUBWF  03,W
3AF2:  BNC   3AFE
3AF4:  BNZ   3AFC
3AF6:  MOVF   xE7,W
3AF8:  SUBWF  01,W
3AFA:  BNC   3AFE
....................          continue;
3AFC:  BRA    3DE0
.................... 
....................       // Most states require retransmission, so check for transmitter
....................       // availability right here - common for all.
....................       if(!IPIsTxReady(TRUE))
3AFE:  MOVLW  01
3B00:  MOVLB  3
3B02:  MOVWF  x6F
3B04:  MOVLB  0
3B06:  CALL   25F2
3B0A:  MOVF   01,F
3B0C:  BNZ   3B10
....................          return;
3B0E:  BRA    3DE4
.................... 
....................       // Restart timeout reference.
....................       ps->startTick = TickGet();
3B10:  MOVLW  1F
3B12:  MOVLB  2
3B14:  ADDWF  xEB,W
3B16:  MOVWF  01
3B18:  MOVLW  00
3B1A:  ADDWFC xEC,W
3B1C:  MOVWF  03
3B1E:  MOVFF  01,2F2
3B22:  MOVWF  xF3
3B24:  MOVLB  0
3B26:  CALL   24E4
3B2A:  MOVFF  2F3,FEA
3B2E:  MOVFF  2F2,FE9
3B32:  MOVFF  02,FEC
3B36:  MOVF   FED,F
3B38:  MOVFF  01,FEF
.................... 
....................       // Update timeout value if there is need to wait longer.
....................       ps->TimeOut <<= 1;
3B3C:  MOVLW  21
3B3E:  MOVLB  2
3B40:  ADDWF  xEB,W
3B42:  MOVWF  FE9
3B44:  MOVLW  00
3B46:  ADDWFC xEC,W
3B48:  MOVWF  FEA
3B4A:  BCF    FD8.0
3B4C:  RLCF   FEF,W
3B4E:  MOVWF  02
3B50:  RLCF   FEC,W
3B52:  MOVWF  03
3B54:  MOVF   02,W
3B56:  MOVF   FED,F
3B58:  MOVWF  FEF
3B5A:  MOVFF  03,FEC
.................... 
....................       // This will be one more attempt.
....................       ps->RetryCount++;
3B5E:  MOVLW  1E
3B60:  ADDWF  xEB,W
3B62:  MOVWF  FE9
3B64:  MOVLW  00
3B66:  ADDWFC xEC,W
3B68:  MOVWF  FEA
3B6A:  INCF   FEF,F
.................... 
....................       // A timeout has occured.  Respond to this timeout condition
....................       // depending on what state this socket is in.
....................       switch(ps->smState)
3B6C:  MOVFF  2EB,FE9
3B70:  MOVFF  2EC,FEA
3B74:  MOVLW  01
3B76:  SUBWF  FEF,W
3B78:  ADDLW  F7
3B7A:  BTFSC  FD8.0
3B7C:  BRA    3D06
3B7E:  ADDLW  09
3B80:  MOVLB  0
3B82:  GOTO   3DEA
....................       {
....................       case TCP_SYN_SENT:
....................          // Keep sending SYN until we hear from remote node.
....................          // This may be for infinite time, in that case
....................          // caller must detect it and do something.
....................          // Bug Fix: 11/1/02
....................          flags = SYN;
3B86:  MOVLW  02
3B88:  MOVLB  2
3B8A:  MOVWF  xF1
....................          break;
3B8C:  BRA    3D06
.................... 
....................       case TCP_SYN_RECEIVED:
....................          // We must receive ACK before timeout expires.
....................          // If not, resend SYN+ACK.
....................          // Abort, if maximum attempts counts are reached.
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3B8E:  MOVLW  1E
3B90:  MOVLB  2
3B92:  ADDWF  xEB,W
3B94:  MOVWF  FE9
3B96:  MOVLW  00
3B98:  ADDWFC xEC,W
3B9A:  MOVWF  FEA
3B9C:  MOVF   FEF,W
3B9E:  SUBLW  03
3BA0:  BNC   3BA8
....................          {
....................             flags = SYN | ACK;
3BA2:  MOVLW  12
3BA4:  MOVWF  xF1
....................          }
3BA6:  BRA    3BD4
....................          else
....................          {
....................             if(ps->Flags.bServer)
3BA8:  MOVLW  23
3BAA:  ADDWF  xEB,W
3BAC:  MOVWF  FE9
3BAE:  MOVLW  00
3BB0:  ADDWFC xEC,W
3BB2:  MOVWF  FEA
3BB4:  BTFSS  FEF.0
3BB6:  BRA    3BC4
....................             {
....................                ps->smState = TCP_LISTEN;
3BB8:  MOVFF  2EB,FE9
3BBC:  MOVFF  2EC,FEA
3BC0:  CLRF   FEF
....................             }
3BC2:  BRA    3BD4
....................             else
....................             {
....................                flags = SYN;
3BC4:  MOVLW  02
3BC6:  MOVWF  xF1
....................                ps->smState = TCP_SYN_SENT;
3BC8:  MOVFF  2EB,FE9
3BCC:  MOVFF  2EC,FEA
3BD0:  MOVLW  01
3BD2:  MOVWF  FEF
....................             }
....................          }
....................          break;
3BD4:  BRA    3D06
.................... 
....................       case TCP_ESTABLISHED:
.................... #if !TCP_NO_WAIT_FOR_ACK
....................          // Don't let this connection idle for very long time.
....................          // If we did not receive or send any message before timeout
....................          // expires, close this connection.
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3BD6:  MOVLW  1E
3BD8:  MOVLB  2
3BDA:  ADDWF  xEB,W
3BDC:  MOVWF  FE9
3BDE:  MOVLW  00
3BE0:  ADDWFC xEC,W
3BE2:  MOVWF  FEA
3BE4:  MOVF   FEF,W
3BE6:  SUBLW  03
3BE8:  BNC   3C2A
....................          {
....................             if(ps->TxBuffer != INVALID_BUFFER)
3BEA:  MOVLW  0F
3BEC:  ADDWF  xEB,W
3BEE:  MOVWF  FE9
3BF0:  MOVLW  00
3BF2:  ADDWFC xEC,W
3BF4:  MOVWF  FEA
3BF6:  INCFSZ FEF,W
3BF8:  BRA    3BFC
3BFA:  BRA    3C20
....................             {
....................                MACSetTxBuffer(ps->TxBuffer, 0);
3BFC:  MOVLW  0F
3BFE:  ADDWF  xEB,W
3C00:  MOVWF  FE9
3C02:  MOVLW  00
3C04:  ADDWFC xEC,W
3C06:  MOVWF  FEA
3C08:  MOVFF  FEF,388
3C0C:  MOVLB  3
3C0E:  CLRF   x8A
3C10:  CLRF   x89
3C12:  MOVLB  0
3C14:  CALL   1550
....................                MACFlush();
3C18:  CALL   171A
....................             }
3C1C:  BRA    3C26
3C1E:  MOVLB  2
....................             else
....................                flags = ACK;
3C20:  MOVLW  10
3C22:  MOVWF  xF1
3C24:  MOVLB  0
....................          }
3C26:  BRA    3C74
3C28:  MOVLB  2
....................          else
....................          {
....................             // Forget about previous transmission.
....................             if(ps->TxBuffer != INVALID_BUFFER)
3C2A:  MOVLW  0F
3C2C:  ADDWF  xEB,W
3C2E:  MOVWF  FE9
3C30:  MOVLW  00
3C32:  ADDWFC xEC,W
3C34:  MOVWF  FEA
3C36:  INCFSZ FEF,W
3C38:  BRA    3C3C
3C3A:  BRA    3C62
....................             {
....................                MACDiscardTx(ps->TxBuffer);
3C3C:  MOVLW  0F
3C3E:  ADDWF  xEB,W
3C40:  MOVWF  FE9
3C42:  MOVLW  00
3C44:  ADDWFC xEC,W
3C46:  MOVWF  FEA
3C48:  MOVFF  FEF,333
3C4C:  MOVLB  0
3C4E:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER;
3C52:  MOVLW  0F
3C54:  MOVLB  2
3C56:  ADDWF  xEB,W
3C58:  MOVWF  FE9
3C5A:  MOVLW  00
3C5C:  ADDWFC xEC,W
3C5E:  MOVWF  FEA
3C60:  SETF   FEF
....................             }
.................... 
.................... #endif
....................             // Request closure.
....................             flags = FIN | ACK;
3C62:  MOVLW  11
3C64:  MOVWF  xF1
....................             //DebugPrint("!");
.................... 
....................             ps->smState = TCP_FIN_WAIT_1;
3C66:  MOVFF  2EB,FE9
3C6A:  MOVFF  2EC,FEA
3C6E:  MOVLW  04
3C70:  MOVWF  FEF
3C72:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK
....................          }
.................... #endif
....................          break;
3C74:  MOVLB  2
3C76:  BRA    3D06
.................... 
....................       case TCP_FIN_WAIT_1:
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3C78:  MOVLW  1E
3C7A:  MOVLB  2
3C7C:  ADDWF  xEB,W
3C7E:  MOVWF  FE9
3C80:  MOVLW  00
3C82:  ADDWFC xEC,W
3C84:  MOVWF  FEA
3C86:  MOVF   FEF,W
3C88:  SUBLW  03
3C8A:  BNC   3C92
....................          {
....................                // Send another FIN
....................                flags = FIN;
3C8C:  MOVLW  01
3C8E:  MOVWF  xF1
....................          }
3C90:  BRA    3CA2
....................          else
....................          {
....................             // Close on our own, we can't seem to communicate
....................             // with the remote node anymore
....................             CloseSocket(ps);
3C92:  MOVFF  2EC,331
3C96:  MOVFF  2EB,330
3C9A:  MOVLB  0
3C9C:  CALL   24FE
3CA0:  MOVLB  2
....................          }
....................          break;
3CA2:  BRA    3D06
.................... 
....................       case TCP_FIN_WAIT_2:
....................       case TCP_CLOSING:
....................          // Close on our own, we can't seem to communicate
....................          // with the remote node anymore
....................          CloseSocket(ps);
3CA4:  MOVFF  2EC,331
3CA8:  MOVFF  2EB,330
3CAC:  CALL   24FE
....................          break;
3CB0:  MOVLB  2
3CB2:  BRA    3D06
.................... 
....................       case TCP_TIME_WAIT:
....................          // Wait around for a while (2MSL) and then goto closed state
....................          CloseSocket(ps);
3CB4:  MOVFF  2EC,331
3CB8:  MOVFF  2EB,330
3CBC:  CALL   24FE
....................          break;
3CC0:  MOVLB  2
3CC2:  BRA    3D06
.................... 
....................       case TCP_CLOSE_WAIT:
....................          flags = FIN;
3CC4:  MOVLW  01
3CC6:  MOVLB  2
3CC8:  MOVWF  xF1
....................          ps->smState = TCP_LAST_ACK;
3CCA:  MOVFF  2EB,FE9
3CCE:  MOVFF  2EC,FEA
3CD2:  MOVLW  09
3CD4:  MOVWF  FEF
....................          break;
3CD6:  BRA    3D06
.................... 
....................       case TCP_LAST_ACK:
....................          // Send some more FINs or close anyway
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS)
3CD8:  MOVLW  1E
3CDA:  MOVLB  2
3CDC:  ADDWF  xEB,W
3CDE:  MOVWF  FE9
3CE0:  MOVLW  00
3CE2:  ADDWFC xEC,W
3CE4:  MOVWF  FEA
3CE6:  MOVF   FEF,W
3CE8:  SUBLW  03
3CEA:  BNC   3CF2
....................             flags = FIN;
3CEC:  MOVLW  01
3CEE:  MOVWF  xF1
3CF0:  BRA    3D02
....................          else
....................             CloseSocket(ps);
3CF2:  MOVFF  2EC,331
3CF6:  MOVFF  2EB,330
3CFA:  MOVLB  0
3CFC:  CALL   24FE
3D00:  MOVLB  2
....................          break;
3D02:  BRA    3D06
3D04:  MOVLB  2
....................       }
.................... 
.................... 
....................       if(flags)
3D06:  MOVF   xF1,F
3D08:  BZ    3DE0
....................       {
....................          if(flags & ACK)
3D0A:  BTFSS  xF1.4
3D0C:  BRA    3D2C
....................             seq = ps->SND_SEQ;
3D0E:  MOVLW  16
3D10:  ADDWF  xEB,W
3D12:  MOVWF  FE9
3D14:  MOVLW  00
3D16:  ADDWFC xEC,W
3D18:  MOVWF  FEA
3D1A:  MOVFF  FEF,2ED
3D1E:  MOVFF  FEC,2EE
3D22:  MOVFF  FEC,2EF
3D26:  MOVFF  FEC,2F0
3D2A:  BRA    3D5A
....................          else
....................             seq = ps->SND_SEQ++;
3D2C:  MOVLW  16
3D2E:  ADDWF  xEB,W
3D30:  MOVWF  FE9
3D32:  MOVLW  00
3D34:  ADDWFC xEC,W
3D36:  MOVWF  FEA
3D38:  MOVF   FEE,F
3D3A:  MOVF   FEE,F
3D3C:  MOVF   FEE,F
3D3E:  MOVFF  FED,2F0
3D42:  MOVFF  FED,2EF
3D46:  MOVFF  FED,2EE
3D4A:  MOVFF  FEF,2ED
3D4E:  MOVLW  01
3D50:  ADDWF  FEE,F
3D52:  MOVLW  00
3D54:  ADDWFC FEE,F
3D56:  ADDWFC FEE,F
3D58:  ADDWFC FED,F
.................... 
....................          SendTCP(&ps->remote,
....................             ps->localPort,
....................             ps->remotePort,
....................             seq,
....................             ps->SND_ACK,
....................             flags);
3D5A:  MOVLW  01
3D5C:  ADDWF  xEB,W
3D5E:  MOVWF  01
3D60:  MOVLW  00
3D62:  ADDWFC xEC,W
3D64:  MOVWF  03
3D66:  MOVFF  01,2F2
3D6A:  MOVWF  xF3
3D6C:  MOVLW  0B
3D6E:  ADDWF  xEB,W
3D70:  MOVWF  FE9
3D72:  MOVLW  00
3D74:  ADDWFC xEC,W
3D76:  MOVWF  FEA
3D78:  MOVFF  FEC,33A
3D7C:  MOVF   FED,F
3D7E:  MOVFF  FEF,339
3D82:  MOVLW  0D
3D84:  ADDWF  xEB,W
3D86:  MOVWF  FE9
3D88:  MOVLW  00
3D8A:  ADDWFC xEC,W
3D8C:  MOVWF  FEA
3D8E:  MOVFF  FEC,33C
3D92:  MOVF   FED,F
3D94:  MOVFF  FEF,33B
3D98:  MOVLW  1A
3D9A:  ADDWF  xEB,W
3D9C:  MOVWF  FE9
3D9E:  MOVLW  00
3DA0:  ADDWFC xEC,W
3DA2:  MOVWF  FEA
3DA4:  MOVFF  FEF,341
3DA8:  MOVFF  FEC,342
3DAC:  MOVFF  FEC,343
3DB0:  MOVFF  FEC,344
3DB4:  MOVFF  2F3,338
3DB8:  MOVFF  2F2,337
3DBC:  MOVFF  2F0,340
3DC0:  MOVFF  2EF,33F
3DC4:  MOVFF  2EE,33E
3DC8:  MOVFF  2ED,33D
3DCC:  MOVFF  2F1,345
3DD0:  MOVLB  3
3DD2:  SETF   x46
3DD4:  CLRF   x48
3DD6:  CLRF   x47
3DD8:  MOVLB  0
3DDA:  CALL   292A
3DDE:  MOVLB  2
....................       }
3DE0:  INCF   xE6,F
3DE2:  BRA    39A2
3DE4:  MOVLB  0
.................... 
....................       /*if (debugLastState != ps->smState)
....................       {
....................          debug_tcp("\r\nTCP TICK %u - ", s);
....................          DebugTCPDisplayState(debugLastState);
....................          debug_tcp(" -> ");
....................          DebugTCPDisplayState(ps->smState);
....................       }*/
....................    }
3DE6:  GOTO   6E18 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote,
.................... *                                  IP_ADDR *localIP,
.................... *                                  WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCP segment is ready in MAC buffer
.................... *
.................... * Input:           remote      - Remote node info
.................... *                  len         - Total length of TCP semgent.
.................... *
.................... * Output:          TRUE if this function has completed its task
.................... *                  FALSE otherwise
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len)
.................... {
....................    TCP_HEADER      TCPHeader;
....................    PSEUDO_HEADER   pseudoHeader;
....................    TCP_SOCKET      socket;
....................    WORD_VAL        checksum1;
....................    WORD_VAL        checksum2;
....................    BYTE            optionsSize;
....................   
....................    // Calculate IP pseudoheader checksum.
....................    pseudoHeader.SourceAddress      = remote->IPAddr;
*
3548:  MOVLW  06
354A:  MOVLB  2
354C:  ADDWF  xE6,W
354E:  MOVWF  FE9
3550:  MOVLW  00
3552:  ADDWFC xE7,W
3554:  MOVWF  FEA
3556:  MOVFF  FEF,300
355A:  MOVFF  FEC,301
355E:  MOVFF  FEC,302
3562:  MOVFF  FEC,303
....................    pseudoHeader.DestAddress        = *localIP;
3566:  MOVFF  2E9,FEA
356A:  MOVFF  2E8,FE9
356E:  MOVFF  FEF,304
3572:  MOVFF  FEC,305
3576:  MOVFF  FEC,306
357A:  MOVFF  FEC,307
....................    pseudoHeader.Zero               = 0x0;
357E:  MOVLB  3
3580:  CLRF   x08
....................    pseudoHeader.Protocol           = IP_PROT_TCP;
3582:  MOVLW  06
3584:  MOVWF  x09
....................    pseudoHeader.TCPLength          = len;
3586:  MOVFF  2EB,30B
358A:  MOVFF  2EA,30A
.................... 
....................    SwapPseudoTCPHeader(pseudoHeader);
358E:  MOVFF  30B,38F
3592:  MOVFF  30A,38E
3596:  MOVLB  0
3598:  CALL   1230
359C:  MOVFF  02,30B
35A0:  MOVFF  01,30A
.................... 
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader,
....................       sizeof(pseudoHeader));
35A4:  MOVLW  03
35A6:  MOVLB  3
35A8:  MOVWF  x13
35AA:  MOVWF  x72
35AC:  CLRF   x71
35AE:  CLRF   x74
35B0:  MOVLW  0C
35B2:  MOVWF  x73
35B4:  MOVLB  0
35B6:  CALL   1E80
35BA:  MOVFF  01,30D
35BE:  MOVLB  3
35C0:  COMF   x0D,F
35C2:  MOVFF  02,30E
35C6:  COMF   x0E,F
.................... 
.................... 
....................    // Now calculate TCP packet checksum in NIC RAM - should match
....................    // pesudo header checksum
....................    checksum2.Val = CalcIPBufferChecksum(len);
35C8:  MOVFF  2EB,370
35CC:  MOVFF  2EA,36F
35D0:  MOVLB  0
35D2:  CALL   1F9A
35D6:  MOVFF  02,310
35DA:  MOVFF  01,30F
.................... 
....................    // Compare checksums.  Note that the endianness is different.
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0])
35DE:  MOVLB  3
35E0:  MOVF   x10,W
35E2:  SUBWF  x0D,W
35E4:  BNZ   35EC
35E6:  MOVF   x0F,W
35E8:  SUBWF  x0E,W
35EA:  BZ    35FA
....................    {
....................       MACDiscardRx();
35EC:  MOVLB  0
35EE:  CALL   1164
....................       return TRUE;
35F2:  MOVLW  01
35F4:  MOVWF  01
35F6:  BRA    36E6
35F8:  MOVLB  3
....................    }
.................... 
....................    // Retrieve TCP header.
....................    IPSetRxBuffer(0);
35FA:  CLRF   x14
35FC:  CLRF   x13
35FE:  MOVLB  0
3600:  CALL   20F2
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader));
3604:  MOVLW  02
3606:  MOVLB  3
3608:  MOVWF  x13
360A:  MOVLW  EC
360C:  MOVWF  x12
360E:  MOVFF  313,37E
3612:  MOVWF  x7D
3614:  CLRF   x80
3616:  MOVLW  14
3618:  MOVWF  x7F
361A:  MOVLB  0
361C:  CALL   11D0
....................    SwapTCPHeader(&TCPHeader);
3620:  MOVLW  02
3622:  MOVLB  3
3624:  MOVWF  x70
3626:  MOVLW  EC
3628:  MOVWF  x6F
362A:  MOVLB  0
362C:  CALL   212E
.................... 
.................... 
....................    // Skip over options and retrieve all data bytes.
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)-
....................       sizeof(TCPHeader));
3630:  MOVFF  2F8,00
3634:  SWAPF  00,W
3636:  ANDLW  0F
3638:  MOVWF  00
363A:  RLCF   00,F
363C:  RLCF   00,F
363E:  MOVLW  FC
3640:  ANDWF  00,F
3642:  MOVF   00,W
3644:  ADDLW  EC
3646:  MOVLB  3
3648:  MOVWF  x11
....................    len = len - optionsSize - sizeof(TCPHeader);
364A:  MOVF   x11,W
364C:  MOVLB  2
364E:  SUBWF  xEA,W
3650:  MOVLB  3
3652:  MOVWF  x12
3654:  MOVLW  00
3656:  MOVLB  2
3658:  SUBWFB xEB,W
365A:  MOVLB  3
365C:  MOVWF  x13
365E:  MOVLW  14
3660:  SUBWF  x12,W
3662:  MOVLB  2
3664:  MOVWF  xEA
3666:  MOVLW  00
3668:  MOVLB  3
366A:  SUBWFB x13,W
366C:  MOVLB  2
366E:  MOVWF  xEB
.................... 
....................    // Position packet read pointer to start of data area.
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2));
3670:  MOVFF  2F8,00
3674:  SWAPF  00,W
3676:  ANDLW  0F
3678:  MOVWF  00
367A:  RLCF   00,W
367C:  MOVLB  3
367E:  MOVWF  x12
3680:  RLCF   x12,F
3682:  MOVLW  FC
3684:  ANDWF  x12,F
3686:  CLRF   x14
3688:  MOVFF  312,313
368C:  MOVLB  0
368E:  CALL   20F2
.................... 
....................    // Find matching socket.
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote);
3692:  MOVLW  02
3694:  MOVLB  3
3696:  MOVWF  x13
3698:  MOVLW  EC
369A:  MOVWF  x12
369C:  MOVFF  2E7,315
36A0:  MOVFF  2E6,314
36A4:  MOVLB  0
36A6:  GOTO   2306
36AA:  MOVFF  01,30C
....................    if(socket != INVALID_SOCKET)
36AE:  MOVLB  3
36B0:  MOVF   x0C,W
36B2:  SUBLW  FE
36B4:  BZ    36DC
....................    {
....................       HandleTCPSeg(socket, remote, &TCPHeader, len);
36B6:  MOVFF  30C,312
36BA:  MOVFF  2E7,314
36BE:  MOVFF  2E6,313
36C2:  MOVLW  02
36C4:  MOVWF  x16
36C6:  MOVLW  EC
36C8:  MOVWF  x15
36CA:  MOVFF  2EB,318
36CE:  MOVFF  2EA,317
36D2:  MOVLB  0
36D4:  GOTO   2B4E
....................    }
36D8:  BRA    36E2
36DA:  MOVLB  3
....................    else
....................    {
....................       // If this is an unknown socket, or we don't have any
....................       // listening sockets available, discard it we can't
....................       // process it right now
....................       MACDiscardRx();
36DC:  MOVLB  0
36DE:  CALL   1164
.................... 
.................... //      // Send a RESET to the remote node is it knows that we
.................... //      // are not available
.................... //      TCPHeader.AckNumber += len;
.................... //      if( TCPHeader.Flags.bits.flagSYN ||
.................... //         TCPHeader.Flags.bits.flagFIN )
.................... //         TCPHeader.AckNumber++;
.................... //
.................... //      SendTCP(remote,
.................... //         TCPHeader.DestPort,
.................... //         TCPHeader.SourcePort,
.................... //         TCPHeader.AckNumber,
.................... //         TCPHeader.SeqNumber,
.................... //         RST);
....................    }
.................... 
....................    return TRUE;
36E2:  MOVLW  01
36E4:  MOVWF  01
36E6:  GOTO   6D56 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
.................... * Function:        static void TransmitTCP(NODE_INFO* remote
.................... *                                          TCP_PORT localPort,
.................... *                                          TCP_PORT remotePort,
.................... *                                          DWORD seq,
.................... *                                          DWORD ack,
.................... *                                          BYTE flags,
.................... *                                          BUFFER buffer,
.................... *                                          WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPIsPutReady() == TRUE
.................... *
.................... * Input:           remote      - Remote node info
.................... *                  localPort   - Source port number
.................... *                  remotePort  - Destination port number
.................... *                  seq         - Segment sequence number
.................... *                  ack         - Segment acknowledge number
.................... *                  flags       - Segment flags
.................... *                  buffer      - Buffer to which this segment
.................... *                                is to be transmitted
.................... *                  len         - Total data length for this segment.
.................... *
.................... * Output:          A TCP segment is assembled and put to transmit.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... static void TransmitTCP(NODE_INFO *remote,
....................                   TCP_PORT localPort,
....................                   TCP_PORT remotePort,
....................                   DWORD tseq,
....................                   DWORD tack,
....................                   BYTE flags,
....................                   BUFFER buff,
....................                   WORD len)
.................... {
....................    WORD_VAL        checkSum;
....................    TCP_HEADER      header;
....................    TCP_OPTIONS     options;
....................    PSEUDO_HEADER   pseudoHeader;
.................... 
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X",
....................       localPort,
....................       remotePort,
....................       tseq,
....................       tack,
....................       len,
....................       flags
....................    );
.................... 
....................    //  Make sure that this Tx buffer isn't currently being transmitted
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false
*
292A:  MOVLW  01
292C:  MOVLB  3
292E:  MOVWF  x6F
2930:  MOVLB  0
2932:  RCALL  25F2
2934:  MOVF   01,F
2936:  BZ    292A
.................... 
....................    // Obtain an AutoFree buffer if this packet is a control packet
....................    // only (contains no application data in an already allocated
....................    // buffer)
....................    if(buff == INVALID_BUFFER)
2938:  MOVLB  3
293A:  INCFSZ x46,W
293C:  BRA    294E
....................       buff = MACGetTxBuffer(TRUE);
293E:  MOVLW  01
2940:  MOVWF  x6F
2942:  MOVLB  0
2944:  CALL   1528
2948:  MOVFF  01,346
294C:  MOVLB  3
.................... 
....................    if(buff == INVALID_BUFFER)
294E:  INCFSZ x46,W
2950:  BRA    2954
....................       return;
2952:  BRA    2B4A
.................... 
....................    IPSetTxBuffer(buff, 0);
2954:  MOVFF  346,388
2958:  CLRF   x8A
295A:  MOVLW  14
295C:  MOVWF  x89
295E:  MOVLB  0
2960:  CALL   1550
.................... 
....................    header.SourcePort           = localPort;
2964:  MOVFF  33A,34C
2968:  MOVFF  339,34B
....................    header.DestPort             = remotePort;
296C:  MOVFF  33C,34E
2970:  MOVFF  33B,34D
....................    header.SeqNumber            = tseq;
2974:  MOVFF  340,352
2978:  MOVFF  33F,351
297C:  MOVFF  33E,350
2980:  MOVFF  33D,34F
....................    header.AckNumber            = tack;
2984:  MOVFF  344,356
2988:  MOVFF  343,355
298C:  MOVFF  342,354
2990:  MOVFF  341,353
....................    header.Flags.bits.Reserved2 = 0;
2994:  MOVLW  3F
2996:  MOVLB  3
2998:  ANDWF  x58,W
299A:  MOVWF  x58
....................    header.DataOffset.Reserved3 = 0;
299C:  MOVLW  F0
299E:  ANDWF  x57,W
29A0:  MOVWF  x57
....................    header.Flags.b              = flags;
29A2:  MOVFF  345,358
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20)
....................    //                  - ETHERNET header (14 if using NIC) .
....................    header.Window               = MACGetFreeRxSize();
29A6:  MOVLB  0
29A8:  BRA    261A
29AA:  MOVFF  02,35A
29AE:  MOVFF  01,359
.................... #if !defined(STACK_USE_SLIP)
....................    /*
....................    * Limit one segment at a time from remote host.
....................    * This limit increases overall throughput as remote host does not
....................    * flood us with packets and later retry with significant delay.
....................    */
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE )
....................       header.Window = MAC_RX_BUFFER_SIZE;
.................... 
....................    else if ( header.Window > 54 )
....................    {
....................       header.Window -= 54;
....................    }
....................    else
....................       header.Window = 0;
.................... #else
....................    if ( header.Window > 40 )
29B2:  MOVLB  3
29B4:  MOVF   x5A,F
29B6:  BNZ   29BE
29B8:  MOVF   x59,W
29BA:  SUBLW  28
29BC:  BC    29C8
....................    {
....................       header.Window -= 40;
29BE:  MOVLW  28
29C0:  SUBWF  x59,F
29C2:  MOVLW  00
29C4:  SUBWFB x5A,F
....................    }
29C6:  BRA    29CC
....................    else
....................       header.Window = 0;
29C8:  CLRF   x5A
29CA:  CLRF   x59
.................... #endif
.................... 
....................    header.Checksum             = 0;
29CC:  CLRF   x5C
29CE:  CLRF   x5B
....................    header.UrgentPointer        = 0;
29D0:  CLRF   x5E
29D2:  CLRF   x5D
.................... 
....................    SwapTCPHeader(&header);
29D4:  MOVLW  03
29D6:  MOVWF  x70
29D8:  MOVLW  4B
29DA:  MOVWF  x6F
29DC:  MOVLB  0
29DE:  CALL   212E
.................... 
....................    len += sizeof(header);
29E2:  MOVLW  14
29E4:  MOVLB  3
29E6:  ADDWF  x47,F
29E8:  MOVLW  00
29EA:  ADDWFC x48,F
.................... 
....................    if ( flags & SYN )
29EC:  BTFSS  x45.1
29EE:  BRA    2A0E
....................    {
....................       len += sizeof(options);
29F0:  MOVLW  04
29F2:  ADDWF  x47,F
29F4:  MOVLW  00
29F6:  ADDWFC x48,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
29F8:  MOVLW  02
29FA:  MOVWF  x5F
....................       options.Length = 0x04;
29FC:  MOVLW  04
29FE:  MOVWF  x60
.................... 
....................       // Load MSS in already swapped order.
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05;
2A00:  MOVWF  x61
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4;
2A02:  CLRF   x62
.................... 
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2;
2A04:  MOVLW  0F
2A06:  ANDWF  x57,W
2A08:  IORLW  60
2A0A:  MOVWF  x57
....................    }
2A0C:  BRA    2A16
....................    else
....................       header.DataOffset.Val   = sizeof(header) >> 2;
2A0E:  MOVLW  0F
2A10:  ANDWF  x57,W
2A12:  IORLW  50
2A14:  MOVWF  x57
.................... 
.................... 
....................    // Calculate IP pseudoheader checksum.
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr;
2A16:  MOVFF  20,366
2A1A:  MOVFF  1F,365
2A1E:  MOVFF  1E,364
2A22:  MOVFF  1D,363
....................    pseudoHeader.DestAddress    = remote->IPAddr;
2A26:  MOVLW  06
2A28:  ADDWF  x37,W
2A2A:  MOVWF  FE9
2A2C:  MOVLW  00
2A2E:  ADDWFC x38,W
2A30:  MOVWF  FEA
2A32:  MOVFF  FEF,367
2A36:  MOVFF  FEC,368
2A3A:  MOVFF  FEC,369
2A3E:  MOVFF  FEC,36A
....................    pseudoHeader.Zero           = 0x0;
2A42:  CLRF   x6B
....................    pseudoHeader.Protocol       = IP_PROT_TCP;
2A44:  MOVLW  06
2A46:  MOVWF  x6C
....................    pseudoHeader.TCPLength      = len;
2A48:  MOVFF  348,36E
2A4C:  MOVFF  347,36D
.................... 
....................    SwapPseudoTCPHeader(pseudoHeader);
2A50:  MOVFF  36E,38F
2A54:  MOVFF  36D,38E
2A58:  MOVLB  0
2A5A:  CALL   1230
2A5E:  MOVFF  02,36E
2A62:  MOVFF  01,36D
.................... 
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader,
....................       sizeof(pseudoHeader));
2A66:  MOVLW  03
2A68:  MOVLB  3
2A6A:  MOVWF  x70
2A6C:  MOVLW  63
2A6E:  MOVWF  x6F
2A70:  MOVFF  370,372
2A74:  MOVWF  x71
2A76:  CLRF   x74
2A78:  MOVLW  0C
2A7A:  MOVWF  x73
2A7C:  MOVLB  0
2A7E:  CALL   1E80
2A82:  MOVFF  01,35B
2A86:  MOVLB  3
2A88:  COMF   x5B,F
2A8A:  MOVFF  02,35C
2A8E:  COMF   x5C,F
....................    checkSum.Val = header.Checksum;
2A90:  MOVFF  35C,34A
2A94:  MOVFF  35B,349
.................... 
....................    // Write IP header.
....................    IPPutHeader(remote, IP_PROT_TCP, len);
2A98:  MOVFF  338,370
2A9C:  MOVFF  337,36F
2AA0:  MOVLW  06
2AA2:  MOVWF  x71
2AA4:  MOVFF  348,373
2AA8:  MOVFF  347,372
2AAC:  MOVLB  0
2AAE:  RCALL  280A
....................    IPPutArray((BYTE*)&header, sizeof(header));
2AB0:  MOVLW  03
2AB2:  MOVLB  3
2AB4:  MOVWF  x70
2AB6:  MOVLW  4B
2AB8:  MOVWF  x6F
2ABA:  MOVFF  370,394
2ABE:  MOVWF  x93
2AC0:  CLRF   x96
2AC2:  MOVLW  14
2AC4:  MOVWF  x95
2AC6:  MOVLB  0
2AC8:  CALL   160C
.................... 
....................    if ( flags & SYN )
2ACC:  MOVLB  3
2ACE:  BTFSS  x45.1
2AD0:  BRA    2AEE
....................       IPPutArray((BYTE*)&options, sizeof(options));
2AD2:  MOVLW  03
2AD4:  MOVWF  x70
2AD6:  MOVLW  5F
2AD8:  MOVWF  x6F
2ADA:  MOVFF  370,394
2ADE:  MOVWF  x93
2AE0:  CLRF   x96
2AE2:  MOVLW  04
2AE4:  MOVWF  x95
2AE6:  MOVLB  0
2AE8:  CALL   160C
2AEC:  MOVLB  3
.................... 
....................    IPSetTxBuffer(buff, 0);
2AEE:  MOVFF  346,388
2AF2:  CLRF   x8A
2AF4:  MOVLW  14
2AF6:  MOVWF  x89
2AF8:  MOVLB  0
2AFA:  CALL   1550
.................... 
....................    checkSum.Val = CalcIPBufferChecksum(len);
2AFE:  MOVFF  348,370
2B02:  MOVFF  347,36F
2B06:  CALL   1F9A
2B0A:  MOVFF  02,34A
2B0E:  MOVFF  01,349
.................... 
....................    // Update the checksum.
....................    IPSetTxBuffer(buff, 16);
2B12:  MOVFF  346,388
2B16:  MOVLB  3
2B18:  CLRF   x8A
2B1A:  MOVLW  24
2B1C:  MOVWF  x89
2B1E:  MOVLB  0
2B20:  CALL   1550
....................    MACPut(checkSum.v[1]);
2B24:  MOVFF  34A,392
2B28:  CALL   15EE
....................    MACPut(checkSum.v[0]);
2B2C:  MOVFF  349,392
2B30:  CALL   15EE
....................    MACSetTxBuffer(buff, 0);
2B34:  MOVFF  346,388
2B38:  MOVLB  3
2B3A:  CLRF   x8A
2B3C:  CLRF   x89
2B3E:  MOVLB  0
2B40:  CALL   1550
.................... 
....................    MACFlush();
2B44:  CALL   171A
2B48:  MOVLB  3
.................... 
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/
....................    // If we send the packet again, the remote node might think that we timed
....................    // out and retransmitted.  It could thus immediately send back an ACK and
....................    // dramatically improve throuput.
....................    //while(!IPIsTxReady(TRUE));
....................    //MACFlush();
.................... #endif
2B4A:  MOVLB  0
2B4C:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h,
....................  *                                      NODE_INFO* remote)
....................  *
....................  * PreCondition:    TCPInit() is already called
....................  *
....................  * Input:           h           - TCP Header to be matched against.
....................  *                  remote      - Node who sent this header.
....................  *
....................  * Output:          A socket that matches with given header and remote
....................  *                  node is searched.
....................  *                  If such socket is found, its index is returned
....................  *                  else INVALID_SOCKET is returned.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote)
.................... {
....................    SOCKET_INFO *ps;
....................    TCP_SOCKET s;
....................    TCP_SOCKET partialMatch;
.................... 
....................    partialMatch = INVALID_SOCKET;
*
2306:  MOVLW  FE
2308:  MOVLB  3
230A:  MOVWF  x19
.................... 
....................    for ( s = 0; s < MAX_SOCKETS; s++ )
230C:  CLRF   x18
230E:  MOVF   x18,W
2310:  SUBLW  04
2312:  BTFSS  FD8.0
2314:  BRA    240A
....................    {
....................       ps = &TCB[s];
2316:  MOVF   x18,W
2318:  MULLW  24
231A:  MOVF   FF3,W
231C:  CLRF   03
231E:  ADDLW  88
2320:  MOVWF  01
2322:  MOVLW  00
2324:  ADDWFC 03,F
2326:  MOVFF  01,316
232A:  MOVFF  03,317
.................... 
....................       if ( ps->smState != TCP_CLOSED )
232E:  MOVFF  316,FE9
2332:  MOVFF  317,FEA
2336:  MOVF   FEF,W
2338:  SUBLW  0A
233A:  BZ    2406
....................       {
....................          if ( ps->localPort == h->DestPort )
233C:  MOVLW  0B
233E:  ADDWF  x16,W
2340:  MOVWF  FE9
2342:  MOVLW  00
2344:  ADDWFC x17,W
2346:  MOVWF  FEA
2348:  MOVFF  FEC,31B
234C:  MOVF   FED,F
234E:  MOVFF  FEF,31A
2352:  MOVLW  02
2354:  ADDWF  x12,W
2356:  MOVWF  FE9
2358:  MOVLW  00
235A:  ADDWFC x13,W
235C:  MOVWF  FEA
235E:  MOVFF  FEC,03
2362:  MOVF   FED,F
2364:  MOVF   FEF,W
2366:  SUBWF  x1A,W
2368:  BNZ   2406
236A:  MOVF   03,W
236C:  SUBWF  x1B,W
236E:  BNZ   2406
....................          {
....................             if ( ps->smState == TCP_LISTEN )
2370:  MOVFF  316,FE9
2374:  MOVFF  317,FEA
2378:  MOVF   FEF,F
237A:  BNZ   2380
....................                partialMatch = s;
237C:  MOVFF  318,319
.................... 
....................             if ( ps->remotePort == h->SourcePort &&
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val )
2380:  MOVLW  0D
2382:  ADDWF  x16,W
2384:  MOVWF  FE9
2386:  MOVLW  00
2388:  ADDWFC x17,W
238A:  MOVWF  FEA
238C:  MOVFF  FEC,31B
2390:  MOVF   FED,F
2392:  MOVFF  FEF,31A
2396:  MOVFF  312,FE9
239A:  MOVFF  313,FEA
239E:  MOVFF  FEC,03
23A2:  MOVF   FED,F
23A4:  MOVF   FEF,W
23A6:  SUBWF  x1A,W
23A8:  BNZ   2406
23AA:  MOVF   03,W
23AC:  SUBWF  x1B,W
23AE:  BNZ   2406
23B0:  MOVLW  07
23B2:  ADDWF  x16,W
23B4:  MOVWF  FE9
23B6:  MOVLW  00
23B8:  ADDWFC x17,W
23BA:  MOVWF  FEA
23BC:  MOVFF  FEF,31A
23C0:  MOVFF  FEC,31B
23C4:  MOVFF  FEC,31C
23C8:  MOVFF  FEC,31D
23CC:  MOVLW  06
23CE:  ADDWF  x14,W
23D0:  MOVWF  FE9
23D2:  MOVLW  00
23D4:  ADDWFC x15,W
23D6:  MOVWF  FEA
23D8:  MOVFF  FEF,00
23DC:  MOVFF  FEC,01
23E0:  MOVFF  FEC,02
23E4:  MOVFF  FEC,03
23E8:  MOVF   00,W
23EA:  SUBWF  x1A,W
23EC:  BNZ   2406
23EE:  MOVF   01,W
23F0:  SUBWF  x1B,W
23F2:  BNZ   2406
23F4:  MOVF   02,W
23F6:  SUBWF  x1C,W
23F8:  BNZ   2406
23FA:  MOVF   03,W
23FC:  SUBWF  x1D,W
23FE:  BNZ   2406
....................             {
....................                return s;
2400:  MOVFF  318,01
2404:  BRA    24DE
....................             }
....................          }
....................       }
2406:  INCF   x18,F
2408:  BRA    230E
....................    }
.................... 
....................    // We are not listening on this port
....................    if(partialMatch == INVALID_SOCKET)
240A:  MOVF   x19,W
240C:  SUBLW  FE
240E:  BNZ   2416
....................       return INVALID_SOCKET;
2410:  MOVLW  FE
2412:  MOVWF  01
2414:  BRA    24DE
.................... 
....................    // Copy the remote node IP/MAC address and source TCP port
....................    // number into our TCB and return this socket to the caller
....................    ps = &TCB[partialMatch];
2416:  MOVF   x19,W
2418:  MULLW  24
241A:  MOVF   FF3,W
241C:  CLRF   03
241E:  ADDLW  88
2420:  MOVWF  01
2422:  MOVLW  00
2424:  ADDWFC 03,F
2426:  MOVFF  01,316
242A:  MOVFF  03,317
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote));
242E:  MOVLW  01
2430:  ADDWF  x16,W
2432:  MOVWF  01
2434:  MOVLW  00
2436:  ADDWFC x17,W
2438:  MOVWF  03
243A:  MOVFF  01,31A
243E:  MOVWF  x1B
2440:  MOVWF  FEA
2442:  MOVFF  01,FE9
2446:  MOVFF  315,FE2
244A:  MOVFF  314,FE1
244E:  MOVLW  0A
2450:  MOVWF  01
2452:  MOVFF  FE6,FEE
2456:  DECFSZ 01,F
2458:  BRA    2452
....................    ps->remotePort          = h->SourcePort;
245A:  MOVLW  0D
245C:  ADDWF  x16,W
245E:  MOVWF  01
2460:  MOVLW  00
2462:  ADDWFC x17,W
2464:  MOVFF  312,FE9
2468:  MOVFF  313,FEA
246C:  MOVFF  FEC,03
2470:  MOVF   FED,F
2472:  MOVFF  FEF,31C
2476:  MOVWF  FEA
2478:  MOVFF  01,FE9
247C:  MOVFF  03,FEC
2480:  MOVF   FED,F
2482:  MOVFF  31C,FEF
....................    ps->Flags.bIsGetReady   = FALSE;
2486:  MOVLW  23
2488:  ADDWF  x16,W
248A:  MOVWF  FE9
248C:  MOVLW  00
248E:  ADDWFC x17,W
2490:  MOVWF  FEA
2492:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER)
2494:  MOVLW  0F
2496:  ADDWF  x16,W
2498:  MOVWF  FE9
249A:  MOVLW  00
249C:  ADDWFC x17,W
249E:  MOVWF  FEA
24A0:  INCFSZ FEF,W
24A2:  BRA    24A6
24A4:  BRA    24CC
....................    {
....................       MACDiscardTx(ps->TxBuffer);
24A6:  MOVLW  0F
24A8:  ADDWF  x16,W
24AA:  MOVWF  FE9
24AC:  MOVLW  00
24AE:  ADDWFC x17,W
24B0:  MOVWF  FEA
24B2:  MOVFF  FEF,333
24B6:  MOVLB  0
24B8:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER;
24BC:  MOVLW  0F
24BE:  MOVLB  3
24C0:  ADDWF  x16,W
24C2:  MOVWF  FE9
24C4:  MOVLW  00
24C6:  ADDWFC x17,W
24C8:  MOVWF  FEA
24CA:  SETF   FEF
....................    }
....................    ps->Flags.bIsPutReady   = TRUE;
24CC:  MOVLW  23
24CE:  ADDWF  x16,W
24D0:  MOVWF  FE9
24D2:  MOVLW  00
24D4:  ADDWFC x17,W
24D6:  MOVWF  FEA
24D8:  BSF    FEF.1
.................... 
....................    return partialMatch;
24DA:  MOVFF  319,01
24DE:  MOVLB  0
24E0:  GOTO   36AA (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           header      - TCP Header to be swapped.
....................  *
....................  * Output:          Given header is swapped.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void SwapTCPHeader(TCP_HEADER* header)
.................... {
....................     header->SourcePort      = swaps(header->SourcePort);
*
212E:  MOVFF  36F,01
2132:  MOVFF  370,372
2136:  MOVFF  01,371
213A:  MOVFF  36F,FE9
213E:  MOVFF  370,FEA
2142:  MOVFF  FEC,38F
2146:  MOVF   FED,F
2148:  MOVFF  FEF,38E
214C:  MOVLB  0
214E:  CALL   1230
2152:  MOVFF  372,FEA
2156:  MOVFF  371,FE9
215A:  MOVFF  02,FEC
215E:  MOVF   FED,F
2160:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort);
2164:  MOVLW  02
2166:  MOVLB  3
2168:  ADDWF  x6F,W
216A:  MOVWF  01
216C:  MOVLW  00
216E:  ADDWFC x70,W
2170:  MOVWF  03
2172:  MOVFF  01,371
2176:  MOVWF  x72
2178:  MOVLW  02
217A:  ADDWF  x6F,W
217C:  MOVWF  FE9
217E:  MOVLW  00
2180:  ADDWFC x70,W
2182:  MOVWF  FEA
2184:  MOVFF  FEC,38F
2188:  MOVF   FED,F
218A:  MOVFF  FEF,38E
218E:  MOVLB  0
2190:  CALL   1230
2194:  MOVFF  372,FEA
2198:  MOVFF  371,FE9
219C:  MOVFF  02,FEC
21A0:  MOVF   FED,F
21A2:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber);
21A6:  MOVLW  04
21A8:  MOVLB  3
21AA:  ADDWF  x6F,W
21AC:  MOVWF  01
21AE:  MOVLW  00
21B0:  ADDWFC x70,W
21B2:  MOVWF  03
21B4:  MOVFF  01,371
21B8:  MOVWF  x72
21BA:  MOVLW  04
21BC:  ADDWF  x6F,W
21BE:  MOVWF  FE9
21C0:  MOVLW  00
21C2:  ADDWFC x70,W
21C4:  MOVWF  FEA
21C6:  MOVFF  FEF,377
21CA:  MOVFF  FEC,378
21CE:  MOVFF  FEC,379
21D2:  MOVFF  FEC,37A
21D6:  MOVLB  0
21D8:  RCALL  210C
21DA:  MOVFF  372,FEA
21DE:  MOVFF  371,FE9
21E2:  MOVFF  00,FEF
21E6:  MOVFF  01,FEC
21EA:  MOVFF  02,FEC
21EE:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber);
21F2:  MOVLW  08
21F4:  MOVLB  3
21F6:  ADDWF  x6F,W
21F8:  MOVWF  01
21FA:  MOVLW  00
21FC:  ADDWFC x70,W
21FE:  MOVWF  03
2200:  MOVFF  01,371
2204:  MOVWF  x72
2206:  MOVLW  08
2208:  ADDWF  x6F,W
220A:  MOVWF  FE9
220C:  MOVLW  00
220E:  ADDWFC x70,W
2210:  MOVWF  FEA
2212:  MOVFF  FEF,377
2216:  MOVFF  FEC,378
221A:  MOVFF  FEC,379
221E:  MOVFF  FEC,37A
2222:  MOVLB  0
2224:  RCALL  210C
2226:  MOVFF  372,FEA
222A:  MOVFF  371,FE9
222E:  MOVFF  00,FEF
2232:  MOVFF  01,FEC
2236:  MOVFF  02,FEC
223A:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window);
223E:  MOVLW  0E
2240:  MOVLB  3
2242:  ADDWF  x6F,W
2244:  MOVWF  01
2246:  MOVLW  00
2248:  ADDWFC x70,W
224A:  MOVWF  03
224C:  MOVFF  01,371
2250:  MOVWF  x72
2252:  MOVLW  0E
2254:  ADDWF  x6F,W
2256:  MOVWF  FE9
2258:  MOVLW  00
225A:  ADDWFC x70,W
225C:  MOVWF  FEA
225E:  MOVFF  FEC,38F
2262:  MOVF   FED,F
2264:  MOVFF  FEF,38E
2268:  MOVLB  0
226A:  CALL   1230
226E:  MOVFF  372,FEA
2272:  MOVFF  371,FE9
2276:  MOVFF  02,FEC
227A:  MOVF   FED,F
227C:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum);
2280:  MOVLW  10
2282:  MOVLB  3
2284:  ADDWF  x6F,W
2286:  MOVWF  01
2288:  MOVLW  00
228A:  ADDWFC x70,W
228C:  MOVWF  03
228E:  MOVFF  01,371
2292:  MOVWF  x72
2294:  MOVLW  10
2296:  ADDWF  x6F,W
2298:  MOVWF  FE9
229A:  MOVLW  00
229C:  ADDWFC x70,W
229E:  MOVWF  FEA
22A0:  MOVFF  FEC,38F
22A4:  MOVF   FED,F
22A6:  MOVFF  FEF,38E
22AA:  MOVLB  0
22AC:  CALL   1230
22B0:  MOVFF  372,FEA
22B4:  MOVFF  371,FE9
22B8:  MOVFF  02,FEC
22BC:  MOVF   FED,F
22BE:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer);
22C2:  MOVLW  12
22C4:  MOVLB  3
22C6:  ADDWF  x6F,W
22C8:  MOVWF  01
22CA:  MOVLW  00
22CC:  ADDWFC x70,W
22CE:  MOVWF  03
22D0:  MOVFF  01,371
22D4:  MOVWF  x72
22D6:  MOVLW  12
22D8:  ADDWF  x6F,W
22DA:  MOVWF  FE9
22DC:  MOVLW  00
22DE:  ADDWFC x70,W
22E0:  MOVWF  FEA
22E2:  MOVFF  FEC,38F
22E6:  MOVF   FED,F
22E8:  MOVFF  FEF,38E
22EC:  MOVLB  0
22EE:  CALL   1230
22F2:  MOVFF  372,FEA
22F6:  MOVFF  371,FE9
22FA:  MOVFF  02,FEC
22FE:  MOVF   FED,F
2300:  MOVFF  01,FEF
2304:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps)
....................  *
....................  * PreCondition:    TCPInit() is already called
....................  *
....................  * Input:           ps  - Pointer to a socket info that is to be
....................  *                          closed.
....................  *
....................  * Output:          Given socket information is reset and any
....................  *                  buffer held by this socket is discarded.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void CloseSocket(SOCKET_INFO* ps)
.................... {
....................    debug_tcp("\r\nTCP SOCKET CLOSED");
.................... 
....................     if ( ps->TxBuffer != INVALID_BUFFER )
*
24FE:  MOVLW  0F
2500:  MOVLB  3
2502:  ADDWF  x30,W
2504:  MOVWF  FE9
2506:  MOVLW  00
2508:  ADDWFC x31,W
250A:  MOVWF  FEA
250C:  INCFSZ FEF,W
250E:  BRA    2512
2510:  BRA    2546
....................     {
....................         MACDiscardTx(ps->TxBuffer);
2512:  MOVLW  0F
2514:  ADDWF  x30,W
2516:  MOVWF  FE9
2518:  MOVLW  00
251A:  ADDWFC x31,W
251C:  MOVWF  FEA
251E:  MOVFF  FEF,333
2522:  MOVLB  0
2524:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER;
2528:  MOVLW  0F
252A:  MOVLB  3
252C:  ADDWF  x30,W
252E:  MOVWF  FE9
2530:  MOVLW  00
2532:  ADDWFC x31,W
2534:  MOVWF  FEA
2536:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE;
2538:  MOVLW  23
253A:  ADDWF  x30,W
253C:  MOVWF  FE9
253E:  MOVLW  00
2540:  ADDWFC x31,W
2542:  MOVWF  FEA
2544:  BSF    FEF.1
....................     }
.................... 
....................     ps->remote.IPAddr.Val = 0x00;
2546:  MOVLW  07
2548:  ADDWF  x30,W
254A:  MOVWF  FE9
254C:  MOVLW  00
254E:  ADDWFC x31,W
2550:  MOVWF  FEA
2552:  CLRF   FEF
2554:  CLRF   FEC
2556:  CLRF   FEC
2558:  CLRF   FEC
....................     ps->remotePort = 0x00;
255A:  MOVLW  0D
255C:  ADDWF  x30,W
255E:  MOVWF  FE9
2560:  MOVLW  00
2562:  ADDWFC x31,W
2564:  MOVWF  FEA
2566:  CLRF   FEC
2568:  MOVF   FED,F
256A:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady )
256C:  MOVLW  23
256E:  ADDWF  x30,W
2570:  MOVWF  FE9
2572:  MOVLW  00
2574:  ADDWFC x31,W
2576:  MOVWF  FEA
2578:  BTFSS  FEF.3
257A:  BRA    2584
....................     {
....................         MACDiscardRx();
257C:  MOVLB  0
257E:  CALL   1164
2582:  MOVLB  3
....................     }
....................     ps->Flags.bIsGetReady       = FALSE;
2584:  MOVLW  23
2586:  ADDWF  x30,W
2588:  MOVWF  FE9
258A:  MOVLW  00
258C:  ADDWFC x31,W
258E:  MOVWF  FEA
2590:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL;
2592:  MOVLW  21
2594:  ADDWF  x30,W
2596:  MOVWF  FE9
2598:  MOVLW  00
259A:  ADDWFC x31,W
259C:  MOVWF  FEA
259E:  CLRF   FEC
25A0:  MOVF   FED,F
25A2:  MOVLW  1E
25A4:  MOVWF  FEF
.................... 
....................     ps->Flags.bIsTxInProgress   = FALSE;
25A6:  MOVLW  23
25A8:  ADDWF  x30,W
25AA:  MOVWF  FE9
25AC:  MOVLW  00
25AE:  ADDWFC x31,W
25B0:  MOVWF  FEA
25B2:  BCF    FEF.4
.................... 
....................     if ( ps->Flags.bServer )
25B4:  MOVLW  23
25B6:  ADDWF  x30,W
25B8:  MOVWF  FE9
25BA:  MOVLW  00
25BC:  ADDWFC x31,W
25BE:  MOVWF  FEA
25C0:  BTFSS  FEF.0
25C2:  BRA    25D0
....................     {
....................         ps->smState = TCP_LISTEN;
25C4:  MOVFF  330,FE9
25C8:  MOVFF  331,FEA
25CC:  CLRF   FEF
....................     }
25CE:  BRA    25DC
....................     else
....................     {
....................         ps->smState = TCP_CLOSED;
25D0:  MOVFF  330,FE9
25D4:  MOVFF  331,FEA
25D8:  MOVLW  0A
25DA:  MOVWF  FEF
....................     }
.................... 
....................    ps->TxCount = 0;
25DC:  MOVLW  10
25DE:  ADDWF  x30,W
25E0:  MOVWF  FE9
25E2:  MOVLW  00
25E4:  ADDWFC x31,W
25E6:  MOVWF  FEA
25E8:  CLRF   FEC
25EA:  MOVF   FED,F
25EC:  CLRF   FEF
.................... 
....................     return;
25EE:  MOVLB  0
25F0:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s,
.................... *                                      NODE_INFO *remote,
.................... *                                      TCP_HEADER* h,
.................... *                                      WORD len)
.................... *
.................... * PreCondition:    TCPInit() is already called     AND
.................... *                  TCPProcess() is the caller.
.................... *
.................... * Input:           s           - Socket that owns this segment
.................... *                  remote      - Remote node info
.................... *                  h           - TCP Header
.................... *                  len         - Total buffer length.
.................... *
.................... * Output:          TCP FSM is executed on given socket with
.................... *                  given TCP segment.
.................... *
.................... * Side Effects:    None
.................... *
.................... * Overview:        None
.................... *
.................... * Note:            None
.................... ********************************************************************/
.................... static void HandleTCPSeg(TCP_SOCKET s,
....................                    NODE_INFO *remote,
....................                    TCP_HEADER *h,
....................                    WORD len)
.................... {
....................    DWORD ack;
....................    DWORD seq;
....................    DWORD prevAck, prevSeq;
....................    SOCKET_INFO *ps;
....................    BYTE flags;
....................    //BYTE debugLastState;
....................    signed int32 temp;
.................... 
....................    ps = &TCB[s];
*
2B4E:  MOVLB  3
2B50:  MOVF   x12,W
2B52:  MULLW  24
2B54:  MOVF   FF3,W
2B56:  CLRF   03
2B58:  ADDLW  88
2B5A:  MOVWF  01
2B5C:  MOVLW  00
2B5E:  ADDWFC 03,F
2B60:  MOVFF  01,329
2B64:  MOVFF  03,32A
....................    //debugLastState = TCB[s].smState;
.................... 
....................    flags = 0x00;
2B68:  CLRF   x2B
.................... 
....................    // Clear timeout info
....................    ps->RetryCount  = 0;
2B6A:  MOVLW  1E
2B6C:  ADDWF  x29,W
2B6E:  MOVWF  FE9
2B70:  MOVLW  00
2B72:  ADDWFC x2A,W
2B74:  MOVWF  FEA
2B76:  CLRF   FEF
....................    ps->startTick   = TickGet();
2B78:  MOVLW  1F
2B7A:  ADDWF  x29,W
2B7C:  MOVWF  01
2B7E:  MOVLW  00
2B80:  ADDWFC x2A,W
2B82:  MOVWF  03
2B84:  MOVFF  01,330
2B88:  MOVWF  x31
2B8A:  MOVLB  0
2B8C:  RCALL  24E4
2B8E:  MOVFF  331,FEA
2B92:  MOVFF  330,FE9
2B96:  MOVFF  02,FEC
2B9A:  MOVF   FED,F
2B9C:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL;
2BA0:  MOVLW  21
2BA2:  MOVLB  3
2BA4:  ADDWF  x29,W
2BA6:  MOVWF  FE9
2BA8:  MOVLW  00
2BAA:  ADDWFC x2A,W
2BAC:  MOVWF  FEA
2BAE:  CLRF   FEC
2BB0:  MOVF   FED,F
2BB2:  MOVLW  1E
2BB4:  MOVWF  FEF
.................... 
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n",
....................       h->SourcePort,
....................       h->DestPort,
....................       h->SeqNumber,
....................       h->AckNumber,
....................       len,
....................       h->Flags
....................    );
.................... 
.................... 
....................    // Reset FSM, if RST is received.
....................    if(h->Flags.bits.flagRST)
2BB6:  MOVLW  0D
2BB8:  ADDWF  x15,W
2BBA:  MOVWF  FE9
2BBC:  MOVLW  00
2BBE:  ADDWFC x16,W
2BC0:  MOVWF  FEA
2BC2:  BTFSS  FEF.2
2BC4:  BRA    2BFA
....................    {
....................       MACDiscardRx();
2BC6:  MOVLB  0
2BC8:  CALL   1164
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT;
2BCC:  MOVLB  3
2BCE:  MOVFF  329,330
2BD2:  MOVFF  32A,331
2BD6:  MOVLW  23
2BD8:  ADDWF  x29,W
2BDA:  MOVWF  FE9
2BDC:  MOVLW  00
2BDE:  ADDWFC x2A,W
2BE0:  MOVWF  FEA
2BE2:  BTFSS  FEF.0
2BE4:  BRA    2BEA
2BE6:  MOVLW  00
2BE8:  BRA    2BEC
2BEA:  MOVLW  01
2BEC:  MOVFF  331,FEA
2BF0:  MOVFF  330,FE9
2BF4:  MOVWF  FEF
....................       return;
2BF6:  GOTO   3542
....................    }
.................... 
....................    seq = ps->SND_SEQ;
2BFA:  MOVLW  16
2BFC:  ADDWF  x29,W
2BFE:  MOVWF  FE9
2C00:  MOVLW  00
2C02:  ADDWFC x2A,W
2C04:  MOVWF  FEA
2C06:  MOVFF  FEF,31D
2C0A:  MOVFF  FEC,31E
2C0E:  MOVFF  FEC,31F
2C12:  MOVFF  FEC,320
.................... 
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount;
2C16:  MOVLW  0E
2C18:  ADDWF  x15,W
2C1A:  MOVWF  FE9
2C1C:  MOVLW  00
2C1E:  ADDWFC x16,W
2C20:  MOVWF  FEA
2C22:  MOVFF  FEC,331
2C26:  MOVF   FED,F
2C28:  MOVFF  FEF,330
2C2C:  CLRF   x32
2C2E:  CLRF   x33
2C30:  MOVLW  08
2C32:  ADDWF  x15,W
2C34:  MOVWF  FE9
2C36:  MOVLW  00
2C38:  ADDWFC x16,W
2C3A:  MOVWF  FEA
2C3C:  MOVFF  FEF,00
2C40:  MOVFF  FEC,01
2C44:  MOVFF  FEC,02
2C48:  MOVFF  FEC,03
2C4C:  MOVF   00,W
2C4E:  SUBWF  x1D,W
2C50:  MOVWF  00
2C52:  MOVF   01,W
2C54:  SUBWFB x1E,W
2C56:  MOVWF  01
2C58:  MOVF   02,W
2C5A:  SUBWFB x1F,W
2C5C:  MOVWF  02
2C5E:  MOVF   03,W
2C60:  SUBWFB x20,W
2C62:  MOVWF  03
2C64:  MOVF   00,W
2C66:  SUBWF  x30,F
2C68:  MOVF   01,W
2C6A:  SUBWFB x31,F
2C6C:  MOVF   02,W
2C6E:  SUBWFB x32,F
2C70:  MOVF   03,W
2C72:  SUBWFB x33,F
2C74:  MOVLW  10
2C76:  ADDWF  x29,W
2C78:  MOVWF  FE9
2C7A:  MOVLW  00
2C7C:  ADDWFC x2A,W
2C7E:  MOVWF  FEA
2C80:  MOVFF  FEC,03
2C84:  MOVF   FED,F
2C86:  MOVFF  FEF,00
2C8A:  MOVFF  03,01
2C8E:  CLRF   02
2C90:  CLRF   03
2C92:  MOVF   00,W
2C94:  SUBWF  x30,W
2C96:  MOVWF  x2C
2C98:  MOVF   01,W
2C9A:  SUBWFB x31,W
2C9C:  MOVWF  x2D
2C9E:  MOVF   02,W
2CA0:  SUBWFB x32,W
2CA2:  MOVWF  x2E
2CA4:  MOVF   03,W
2CA6:  SUBWFB x33,W
2CA8:  MOVWF  x2F
....................    if(temp < 0)
2CAA:  BTFSS  x2F.7
2CAC:  BRA    2CC2
....................    {
....................       ps->RemoteWindow = 0;
2CAE:  MOVLW  14
2CB0:  ADDWF  x29,W
2CB2:  MOVWF  FE9
2CB4:  MOVLW  00
2CB6:  ADDWFC x2A,W
2CB8:  MOVWF  FEA
2CBA:  CLRF   FEC
2CBC:  MOVF   FED,F
2CBE:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n",
....................             ps->RemoteWindow,
....................             temp,
....................             h->Window,
....................             seq,
....................             h->AckNumber,
....................             ps->TxCount
....................          );
....................    }
2CC0:  BRA    2CD6
....................    else
....................    {
....................       ps->RemoteWindow = ack;
2CC2:  MOVLW  14
2CC4:  ADDWF  x29,W
2CC6:  MOVWF  FE9
2CC8:  MOVLW  00
2CCA:  ADDWFC x2A,W
2CCC:  MOVWF  FEA
2CCE:  MOVFF  319,FEF
2CD2:  MOVFF  31A,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow);
....................    }
.................... 
....................    // Handle TCP_SYN_SENT state
....................    // The TCP_SYN_SENT state occurs when an application
....................    // calls TCPConnect().  After an initial SYN is sent,
....................    // we expect a SYN + ACK before establishing the
....................    // connection.
....................    if(ps->smState == TCP_SYN_SENT)
2CD6:  MOVFF  329,FE9
2CDA:  MOVFF  32A,FEA
2CDE:  DECFSZ FEF,W
2CE0:  BRA    2E4C
....................    {
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot
....................       // handle any other packet types.
....................       if(!h->Flags.bits.flagSYN)
2CE2:  MOVLW  0D
2CE4:  ADDWF  x15,W
2CE6:  MOVWF  FE9
2CE8:  MOVLW  00
2CEA:  ADDWFC x16,W
2CEC:  MOVWF  FEA
2CEE:  BTFSC  FEF.1
2CF0:  BRA    2D16
....................       {
....................          MACDiscardRx();
2CF2:  MOVLB  0
2CF4:  CALL   1164
.................... 
....................          // Send out a RESET if the remote node thinks a connection is already established
....................           if(h->Flags.bits.flagACK)
2CF8:  MOVLW  0D
2CFA:  MOVLB  3
2CFC:  ADDWF  x15,W
2CFE:  MOVWF  FE9
2D00:  MOVLW  00
2D02:  ADDWFC x16,W
2D04:  MOVWF  FEA
2D06:  BTFSS  FEF.4
2D08:  BRA    2D12
....................           {
....................             flags = RST;
2D0A:  MOVLW  04
2D0C:  MOVWF  x2B
....................             goto SendTCPControlPacket;
2D0E:  GOTO   34DA
....................            }
.................... 
....................          return;
2D12:  GOTO   3542
....................       }
.................... 
....................       // We now have a sequence number for the remote node
....................       ps->SND_ACK = h->SeqNumber + len + 1;
2D16:  MOVLW  1A
2D18:  ADDWF  x29,W
2D1A:  MOVWF  01
2D1C:  MOVLW  00
2D1E:  ADDWFC x2A,W
2D20:  MOVFF  01,330
2D24:  MOVWF  x31
2D26:  MOVLW  04
2D28:  ADDWF  x15,W
2D2A:  MOVWF  FE9
2D2C:  MOVLW  00
2D2E:  ADDWFC x16,W
2D30:  MOVWF  FEA
2D32:  MOVFF  FEF,332
2D36:  MOVFF  FEC,333
2D3A:  MOVFF  FEC,334
2D3E:  MOVFF  FEC,335
2D42:  MOVF   x17,W
2D44:  ADDWF  x32,F
2D46:  MOVF   x18,W
2D48:  ADDWFC x33,F
2D4A:  MOVLW  00
2D4C:  ADDWFC x34,F
2D4E:  ADDWFC x35,F
2D50:  MOVLW  01
2D52:  ADDWF  x32,W
2D54:  MOVWF  00
2D56:  MOVLW  00
2D58:  ADDWFC x33,W
2D5A:  MOVWF  01
2D5C:  MOVLW  00
2D5E:  ADDWFC x34,W
2D60:  MOVWF  02
2D62:  MOVLW  00
2D64:  ADDWFC x35,W
2D66:  MOVFF  331,FEA
2D6A:  MOVFF  330,FE9
2D6E:  MOVFF  00,FEF
2D72:  MOVFF  01,FEC
2D76:  MOVFF  02,FEC
2D7A:  MOVWF  FEC
....................       ack = ps->SND_ACK;
2D7C:  MOVLW  1A
2D7E:  ADDWF  x29,W
2D80:  MOVWF  FE9
2D82:  MOVLW  00
2D84:  ADDWFC x2A,W
2D86:  MOVWF  FEA
2D88:  MOVFF  FEF,319
2D8C:  MOVFF  FEC,31A
2D90:  MOVFF  FEC,31B
2D94:  MOVFF  FEC,31C
.................... 
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK,
....................       // we can establish the connection now.
....................       if(!h->Flags.bits.flagACK)
2D98:  MOVLW  0D
2D9A:  ADDWF  x15,W
2D9C:  MOVWF  FE9
2D9E:  MOVLW  00
2DA0:  ADDWFC x16,W
2DA2:  MOVWF  FEA
2DA4:  BTFSC  FEF.4
2DA6:  BRA    2DC2
....................       {
....................          ps->smState = TCP_SYN_RECEIVED;
2DA8:  MOVFF  329,FE9
2DAC:  MOVFF  32A,FEA
2DB0:  MOVLW  02
2DB2:  MOVWF  FEF
....................          MACDiscardRx();
2DB4:  MOVLB  0
2DB6:  CALL   1164
....................          // Send out a SYN+ACK for simultaneous connection open
....................          flags = SYN | ACK;
2DBA:  MOVLW  12
2DBC:  MOVLB  3
2DBE:  MOVWF  x2B
....................          goto SendTCPControlPacket;
2DC0:  BRA    34DA
....................       }
.................... 
....................       // We received SYN+ACK, establish the connection now
....................       ps->smState = TCP_ESTABLISHED;
2DC2:  MOVFF  329,FE9
2DC6:  MOVFF  32A,FEA
2DCA:  MOVLW  03
2DCC:  MOVWF  FEF
....................       // Send out an ACK
....................       flags = ACK;
2DCE:  MOVLW  10
2DD0:  MOVWF  x2B
.................... 
....................       ps->RemoteWindow = h->Window;
2DD2:  MOVLW  14
2DD4:  ADDWF  x29,W
2DD6:  MOVWF  01
2DD8:  MOVLW  00
2DDA:  ADDWFC x2A,W
2DDC:  MOVWF  03
2DDE:  MOVWF  x31
2DE0:  MOVLW  0E
2DE2:  ADDWF  x15,W
2DE4:  MOVWF  FE9
2DE6:  MOVLW  00
2DE8:  ADDWFC x16,W
2DEA:  MOVWF  FEA
2DEC:  MOVFF  FEC,03
2DF0:  MOVF   FED,F
2DF2:  MOVFF  FEF,332
2DF6:  MOVFF  331,FEA
2DFA:  MOVFF  01,FE9
2DFE:  MOVFF  03,FEC
2E02:  MOVF   FED,F
2E04:  MOVFF  332,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow);
.................... 
....................       // Check for application data and make it
....................       // available, if present
....................       if(len)
2E08:  MOVF   x17,W
2E0A:  IORWF  x18,W
2E0C:  BZ    2E42
....................       {
....................          ps->Flags.bIsGetReady   = TRUE;
2E0E:  MOVLW  23
2E10:  ADDWF  x29,W
2E12:  MOVWF  FE9
2E14:  MOVLW  00
2E16:  ADDWFC x2A,W
2E18:  MOVWF  FEA
2E1A:  BSF    FEF.3
....................          ps->RxCount             = len;
2E1C:  MOVLW  12
2E1E:  ADDWF  x29,W
2E20:  MOVWF  FE9
2E22:  MOVLW  00
2E24:  ADDWFC x2A,W
2E26:  MOVWF  FEA
2E28:  MOVFF  318,FEC
2E2C:  MOVF   FED,F
2E2E:  MOVFF  317,FEF
....................          ps->Flags.bFirstRead    = TRUE;
2E32:  MOVLW  23
2E34:  ADDWF  x29,W
2E36:  MOVWF  FE9
2E38:  MOVLW  00
2E3A:  ADDWFC x2A,W
2E3C:  MOVWF  FEA
2E3E:  BSF    FEF.2
....................       }
2E40:  BRA    2E4A
....................       else   // No application data in this packet
....................       {
....................          MACDiscardRx();
2E42:  MOVLB  0
2E44:  CALL   1164
2E48:  MOVLB  3
....................       }
....................       goto SendTCPControlPacket;
2E4A:  BRA    34DA
....................    }
.................... 
....................    // Handle TCP_LISTEN state
....................    if(ps->smState == TCP_LISTEN )
2E4C:  MOVFF  329,FE9
2E50:  MOVFF  32A,FEA
2E54:  MOVF   FEF,F
2E56:  BTFSS  FD8.2
2E58:  BRA    2FC8
....................    {
....................       MACDiscardRx();
2E5A:  MOVLB  0
2E5C:  CALL   1164
.................... 
....................       // Send a RST if this isn't a SYN packet
....................       if(!h->Flags.bits.flagSYN)
2E60:  MOVLW  0D
2E62:  MOVLB  3
2E64:  ADDWF  x15,W
2E66:  MOVWF  FE9
2E68:  MOVLW  00
2E6A:  ADDWFC x16,W
2E6C:  MOVWF  FEA
2E6E:  BTFSC  FEF.1
2E70:  BRA    2E78
....................       {
....................          flags = RST;
2E72:  MOVLW  04
2E74:  MOVWF  x2B
....................          goto SendTCPControlPacket;
2E76:  BRA    34DA
....................       }
.................... 
....................       ps->SND_ACK = h->SeqNumber + len + 1;
2E78:  MOVLW  1A
2E7A:  ADDWF  x29,W
2E7C:  MOVWF  01
2E7E:  MOVLW  00
2E80:  ADDWFC x2A,W
2E82:  MOVFF  01,330
2E86:  MOVWF  x31
2E88:  MOVLW  04
2E8A:  ADDWF  x15,W
2E8C:  MOVWF  FE9
2E8E:  MOVLW  00
2E90:  ADDWFC x16,W
2E92:  MOVWF  FEA
2E94:  MOVFF  FEF,332
2E98:  MOVFF  FEC,333
2E9C:  MOVFF  FEC,334
2EA0:  MOVFF  FEC,335
2EA4:  MOVF   x17,W
2EA6:  ADDWF  x32,F
2EA8:  MOVF   x18,W
2EAA:  ADDWFC x33,F
2EAC:  MOVLW  00
2EAE:  ADDWFC x34,F
2EB0:  ADDWFC x35,F
2EB2:  MOVLW  01
2EB4:  ADDWF  x32,W
2EB6:  MOVWF  00
2EB8:  MOVLW  00
2EBA:  ADDWFC x33,W
2EBC:  MOVWF  01
2EBE:  MOVLW  00
2EC0:  ADDWFC x34,W
2EC2:  MOVWF  02
2EC4:  MOVLW  00
2EC6:  ADDWFC x35,W
2EC8:  MOVFF  331,FEA
2ECC:  MOVFF  330,FE9
2ED0:  MOVFF  00,FEF
2ED4:  MOVFF  01,FEC
2ED8:  MOVFF  02,FEC
2EDC:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window;
2EDE:  MOVLW  14
2EE0:  ADDWF  x29,W
2EE2:  MOVWF  01
2EE4:  MOVLW  00
2EE6:  ADDWFC x2A,W
2EE8:  MOVWF  03
2EEA:  MOVWF  x31
2EEC:  MOVLW  0E
2EEE:  ADDWF  x15,W
2EF0:  MOVWF  FE9
2EF2:  MOVLW  00
2EF4:  ADDWFC x16,W
2EF6:  MOVWF  FEA
2EF8:  MOVFF  FEC,03
2EFC:  MOVF   FED,F
2EFE:  MOVFF  FEF,332
2F02:  MOVFF  331,FEA
2F06:  MOVFF  01,FE9
2F0A:  MOVFF  03,FEC
2F0E:  MOVF   FED,F
2F10:  MOVFF  332,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow);
.................... 
....................       // This socket has received connection request (SYN).
....................       // Remember calling node, assign next segment seq. number
....................       // for this potential connection.
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote));
2F14:  MOVLW  01
2F16:  ADDWF  x29,W
2F18:  MOVWF  01
2F1A:  MOVLW  00
2F1C:  ADDWFC x2A,W
2F1E:  MOVWF  03
2F20:  MOVFF  01,330
2F24:  MOVWF  x31
2F26:  MOVWF  FEA
2F28:  MOVFF  01,FE9
2F2C:  MOVFF  314,FE2
2F30:  MOVFF  313,FE1
2F34:  MOVLW  0A
2F36:  MOVWF  01
2F38:  MOVFF  FE6,FEE
2F3C:  DECFSZ 01,F
2F3E:  BRA    2F38
....................       ps->remotePort = h->SourcePort;
2F40:  MOVLW  0D
2F42:  ADDWF  x29,W
2F44:  MOVWF  01
2F46:  MOVLW  00
2F48:  ADDWFC x2A,W
2F4A:  MOVFF  315,FE9
2F4E:  MOVFF  316,FEA
2F52:  MOVFF  FEC,03
2F56:  MOVF   FED,F
2F58:  MOVFF  FEF,332
2F5C:  MOVWF  FEA
2F5E:  MOVFF  01,FE9
2F62:  MOVFF  03,FEC
2F66:  MOVF   FED,F
2F68:  MOVFF  332,FEF
.................... 
....................       // Grant connection request.
....................       ps->smState = TCP_SYN_RECEIVED;
2F6C:  MOVFF  329,FE9
2F70:  MOVFF  32A,FEA
2F74:  MOVLW  02
2F76:  MOVWF  FEF
....................       seq = ps->SND_SEQ++;
2F78:  MOVLW  16
2F7A:  ADDWF  x29,W
2F7C:  MOVWF  FE9
2F7E:  MOVLW  00
2F80:  ADDWFC x2A,W
2F82:  MOVWF  FEA
2F84:  MOVF   FEE,F
2F86:  MOVF   FEE,F
2F88:  MOVF   FEE,F
2F8A:  MOVFF  FED,320
2F8E:  MOVFF  FED,31F
2F92:  MOVFF  FED,31E
2F96:  MOVFF  FEF,31D
2F9A:  MOVLW  01
2F9C:  ADDWF  FEE,F
2F9E:  MOVLW  00
2FA0:  ADDWFC FEE,F
2FA2:  ADDWFC FEE,F
2FA4:  ADDWFC FED,F
....................       ack =  ps->SND_ACK;
2FA6:  MOVLW  1A
2FA8:  ADDWF  x29,W
2FAA:  MOVWF  FE9
2FAC:  MOVLW  00
2FAE:  ADDWFC x2A,W
2FB0:  MOVWF  FEA
2FB2:  MOVFF  FEF,319
2FB6:  MOVFF  FEC,31A
2FBA:  MOVFF  FEC,31B
2FBE:  MOVFF  FEC,31C
....................       flags = SYN | ACK;
2FC2:  MOVLW  12
2FC4:  MOVWF  x2B
....................       goto SendTCPControlPacket;
2FC6:  BRA    34DA
....................    }
.................... 
.................... 
....................    // Remember current seq and ack for our connection so that if
....................    // we have to silently discard this packet, we can go back to
....................    // previous ack and seq numbers.
....................    prevAck = ps->SND_ACK;
2FC8:  MOVLW  1A
2FCA:  ADDWF  x29,W
2FCC:  MOVWF  FE9
2FCE:  MOVLW  00
2FD0:  ADDWFC x2A,W
2FD2:  MOVWF  FEA
2FD4:  MOVFF  FEF,321
2FD8:  MOVFF  FEC,322
2FDC:  MOVFF  FEC,323
2FE0:  MOVFF  FEC,324
....................    prevSeq = ps->SND_SEQ;
2FE4:  MOVLW  16
2FE6:  ADDWF  x29,W
2FE8:  MOVWF  FE9
2FEA:  MOVLW  00
2FEC:  ADDWFC x2A,W
2FEE:  MOVWF  FEA
2FF0:  MOVFF  FEF,325
2FF4:  MOVFF  FEC,326
2FF8:  MOVFF  FEC,327
2FFC:  MOVFF  FEC,328
.................... 
....................    ack = h->SeqNumber;
3000:  MOVLW  04
3002:  ADDWF  x15,W
3004:  MOVWF  FE9
3006:  MOVLW  00
3008:  ADDWFC x16,W
300A:  MOVWF  FEA
300C:  MOVFF  FEF,319
3010:  MOVFF  FEC,31A
3014:  MOVFF  FEC,31B
3018:  MOVFF  FEC,31C
....................    ack += (DWORD)len;
301C:  MOVFF  317,00
3020:  MOVFF  318,01
3024:  CLRF   02
3026:  CLRF   03
3028:  MOVF   00,W
302A:  ADDWF  x19,F
302C:  MOVF   01,W
302E:  ADDWFC x1A,F
3030:  MOVF   02,W
3032:  ADDWFC x1B,F
3034:  MOVF   03,W
3036:  ADDWFC x1C,F
....................    seq = ps->SND_SEQ;
3038:  MOVLW  16
303A:  ADDWF  x29,W
303C:  MOVWF  FE9
303E:  MOVLW  00
3040:  ADDWFC x2A,W
3042:  MOVWF  FEA
3044:  MOVFF  FEF,31D
3048:  MOVFF  FEC,31E
304C:  MOVFF  FEC,31F
3050:  MOVFF  FEC,320
.................... 
....................    // State is something other than TCP_LISTEN, handle it.
....................    {
....................       // Check to see if the incomming sequence number is what
....................       // we expect (last transmitted ACK value).  Throw this packet
....................       // away if it is wrong.
....................       if(h->SeqNumber == prevAck)
3054:  MOVLW  04
3056:  ADDWF  x15,W
3058:  MOVWF  FE9
305A:  MOVLW  00
305C:  ADDWFC x16,W
305E:  MOVWF  FEA
3060:  MOVFF  FEF,330
3064:  MOVFF  FEC,331
3068:  MOVFF  FEC,332
306C:  MOVFF  FEC,333
3070:  MOVF   x21,W
3072:  SUBWF  x30,W
3074:  BTFSS  FD8.2
3076:  BRA    34BE
3078:  MOVF   x22,W
307A:  SUBWF  x31,W
307C:  BTFSS  FD8.2
307E:  BRA    34BE
3080:  MOVF   x23,W
3082:  SUBWF  x32,W
3084:  BTFSS  FD8.2
3086:  BRA    34BE
3088:  MOVF   x24,W
308A:  SUBWF  x33,W
308C:  BTFSS  FD8.2
308E:  BRA    34BE
....................       {
....................          // After receiving a SYNchronization request, we expect an
....................          // ACK to our transmitted SYN
....................          if(ps->smState == TCP_SYN_RECEIVED)
3090:  MOVFF  329,FE9
3094:  MOVFF  32A,FEA
3098:  MOVF   FEF,W
309A:  SUBLW  02
309C:  BNZ   3124
....................          {
....................             if(h->Flags.bits.flagACK)
309E:  MOVLW  0D
30A0:  ADDWF  x15,W
30A2:  MOVWF  FE9
30A4:  MOVLW  00
30A6:  ADDWFC x16,W
30A8:  MOVWF  FEA
30AA:  BTFSS  FEF.4
30AC:  BRA    311A
....................             {
....................                // ACK received as expected, this connection is
....................                // now established
....................                ps->SND_ACK = ack;
30AE:  MOVLW  1A
30B0:  ADDWF  x29,W
30B2:  MOVWF  FE9
30B4:  MOVLW  00
30B6:  ADDWFC x2A,W
30B8:  MOVWF  FEA
30BA:  MOVFF  319,FEF
30BE:  MOVFF  31A,FEC
30C2:  MOVFF  31B,FEC
30C6:  MOVFF  31C,FEC
....................                ps->smState = TCP_ESTABLISHED;
30CA:  MOVFF  329,FE9
30CE:  MOVFF  32A,FEA
30D2:  MOVLW  03
30D4:  MOVWF  FEF
.................... 
....................                // Check if this first packet has application data
....................                // in it.  Make it available if so.
....................                if(len)
30D6:  MOVF   x17,W
30D8:  IORWF  x18,W
30DA:  BZ    3110
....................                {
....................                   ps->Flags.bIsGetReady   = TRUE;
30DC:  MOVLW  23
30DE:  ADDWF  x29,W
30E0:  MOVWF  FE9
30E2:  MOVLW  00
30E4:  ADDWFC x2A,W
30E6:  MOVWF  FEA
30E8:  BSF    FEF.3
....................                   ps->RxCount             = len;
30EA:  MOVLW  12
30EC:  ADDWF  x29,W
30EE:  MOVWF  FE9
30F0:  MOVLW  00
30F2:  ADDWFC x2A,W
30F4:  MOVWF  FEA
30F6:  MOVFF  318,FEC
30FA:  MOVF   FED,F
30FC:  MOVFF  317,FEF
....................                   ps->Flags.bFirstRead    = TRUE;
3100:  MOVLW  23
3102:  ADDWF  x29,W
3104:  MOVWF  FE9
3106:  MOVLW  00
3108:  ADDWFC x2A,W
310A:  MOVWF  FEA
310C:  BSF    FEF.2
....................                }
310E:  BRA    3118
....................                else
....................                   MACDiscardRx();
3110:  MOVLB  0
3112:  CALL   1164
3116:  MOVLB  3
....................             }
3118:  BRA    3122
....................             else   // No ACK to our SYN
....................             {
....................                MACDiscardRx();
311A:  MOVLB  0
311C:  CALL   1164
3120:  MOVLB  3
....................             }
....................          }
3122:  BRA    34BC
....................          // Connection is established, closing, or otherwise
....................          else
....................          {
.................... 
....................             // Save the seq+len value of the packet for our future
....................             // ACK transmission, and so out of sequence packets
....................             // can be detected in the future.
....................             ps->SND_ACK = ack;
3124:  MOVLW  1A
3126:  ADDWF  x29,W
3128:  MOVWF  FE9
312A:  MOVLW  00
312C:  ADDWFC x2A,W
312E:  MOVWF  FEA
3130:  MOVFF  319,FEF
3134:  MOVFF  31A,FEC
3138:  MOVFF  31B,FEC
313C:  MOVFF  31C,FEC
.................... 
....................             // Handle packets received while connection established.
....................             if(ps->smState == TCP_ESTABLISHED)
3140:  MOVFF  329,FE9
3144:  MOVFF  32A,FEA
3148:  MOVF   FEF,W
314A:  SUBLW  03
314C:  BTFSS  FD8.2
314E:  BRA    32EE
....................             {
....................                // If this packet has the ACK set, mark all
....................                // previous TX packets as no longer needed for
....................                // possible retransmission.
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability.
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady)
3150:  MOVLW  0D
3152:  ADDWF  x15,W
3154:  MOVWF  FE9
3156:  MOVLW  00
3158:  ADDWFC x16,W
315A:  MOVWF  FEA
315C:  BTFSS  FEF.4
315E:  BRA    31B6
3160:  MOVLW  23
3162:  ADDWF  x29,W
3164:  MOVWF  FE9
3166:  MOVLW  00
3168:  ADDWFC x2A,W
316A:  MOVWF  FEA
316C:  BTFSC  FEF.1
316E:  BRA    31B6
....................                {
....................                   if(ps->TxBuffer != INVALID_BUFFER)
3170:  MOVLW  0F
3172:  ADDWF  x29,W
3174:  MOVWF  FE9
3176:  MOVLW  00
3178:  ADDWFC x2A,W
317A:  MOVWF  FEA
317C:  INCFSZ FEF,W
317E:  BRA    3182
3180:  BRA    31B6
....................                   {
....................                      MACDiscardTx(ps->TxBuffer);
3182:  MOVLW  0F
3184:  ADDWF  x29,W
3186:  MOVWF  FE9
3188:  MOVLW  00
318A:  ADDWFC x2A,W
318C:  MOVWF  FEA
318E:  MOVFF  FEF,333
3192:  MOVLB  0
3194:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER;
3198:  MOVLW  0F
319A:  MOVLB  3
319C:  ADDWF  x29,W
319E:  MOVWF  FE9
31A0:  MOVLW  00
31A2:  ADDWFC x2A,W
31A4:  MOVWF  FEA
31A6:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE;
31A8:  MOVLW  23
31AA:  ADDWF  x29,W
31AC:  MOVWF  FE9
31AE:  MOVLW  00
31B0:  ADDWFC x2A,W
31B2:  MOVWF  FEA
31B4:  BSF    FEF.1
....................                   }
....................                }
.................... 
....................                // Check if the remote node is closing the connection
....................                if(h->Flags.bits.flagFIN)
31B6:  MOVLW  0D
31B8:  ADDWF  x15,W
31BA:  MOVWF  FE9
31BC:  MOVLW  00
31BE:  ADDWFC x16,W
31C0:  MOVWF  FEA
31C2:  BTFSS  FEF.0
31C4:  BRA    3256
....................                {
....................                   //DebugPrint("|");
....................                   flags = FIN | ACK;
31C6:  MOVLW  11
31C8:  MOVWF  x2B
....................                   seq = ps->SND_SEQ++;
31CA:  MOVLW  16
31CC:  ADDWF  x29,W
31CE:  MOVWF  FE9
31D0:  MOVLW  00
31D2:  ADDWFC x2A,W
31D4:  MOVWF  FEA
31D6:  MOVF   FEE,F
31D8:  MOVF   FEE,F
31DA:  MOVF   FEE,F
31DC:  MOVFF  FED,320
31E0:  MOVFF  FED,31F
31E4:  MOVFF  FED,31E
31E8:  MOVFF  FEF,31D
31EC:  MOVLW  01
31EE:  ADDWF  FEE,F
31F0:  MOVLW  00
31F2:  ADDWFC FEE,F
31F4:  ADDWFC FEE,F
31F6:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
31F8:  MOVLW  1A
31FA:  ADDWF  x29,W
31FC:  MOVWF  FE9
31FE:  MOVLW  00
3200:  ADDWFC x2A,W
3202:  MOVWF  FEA
3204:  MOVLW  01
3206:  ADDWF  FEF,W
3208:  MOVWF  00
320A:  MOVLW  00
320C:  ADDWFC FEC,W
320E:  MOVWF  01
3210:  MOVLW  00
3212:  ADDWFC FEC,W
3214:  MOVWF  02
3216:  MOVLW  00
3218:  ADDWFC FEC,W
321A:  MOVF   FED,F
321C:  MOVF   FED,F
321E:  MOVF   FED,F
3220:  MOVFF  00,FEF
3224:  MOVFF  01,FEC
3228:  MOVFF  02,FEC
322C:  MOVWF  FEC
....................               ack = ps->SND_ACK;
322E:  MOVLW  1A
3230:  ADDWF  x29,W
3232:  MOVWF  FE9
3234:  MOVLW  00
3236:  ADDWFC x2A,W
3238:  MOVWF  FEA
323A:  MOVFF  FEF,319
323E:  MOVFF  FEC,31A
3242:  MOVFF  FEC,31B
3246:  MOVFF  FEC,31C
....................                   ps->smState = TCP_LAST_ACK;
324A:  MOVFF  329,FE9
324E:  MOVFF  32A,FEA
3252:  MOVLW  09
3254:  MOVWF  FEF
....................                }
.................... 
....................                // Check if there is any application data in
....................                // this packet.
....................                if(len)
3256:  MOVF   x17,W
3258:  IORWF  x18,W
325A:  BZ    32E4
....................                {
....................                   // There is data.  Make it available if we
....................                   // don't already have data available.
....................                   if(!ps->Flags.bIsGetReady)
325C:  MOVLW  23
325E:  ADDWF  x29,W
3260:  MOVWF  FE9
3262:  MOVLW  00
3264:  ADDWFC x2A,W
3266:  MOVWF  FEA
3268:  BTFSC  FEF.3
326A:  BRA    32A2
....................                   {
....................                      ps->Flags.bIsGetReady   = TRUE;
326C:  MOVLW  23
326E:  ADDWF  x29,W
3270:  MOVWF  FE9
3272:  MOVLW  00
3274:  ADDWFC x2A,W
3276:  MOVWF  FEA
3278:  BSF    FEF.3
....................                      ps->RxCount             = len;
327A:  MOVLW  12
327C:  ADDWF  x29,W
327E:  MOVWF  FE9
3280:  MOVLW  00
3282:  ADDWFC x2A,W
3284:  MOVWF  FEA
3286:  MOVFF  318,FEC
328A:  MOVF   FED,F
328C:  MOVFF  317,FEF
....................                      ps->Flags.bFirstRead    = TRUE;
3290:  MOVLW  23
3292:  ADDWF  x29,W
3294:  MOVWF  FE9
3296:  MOVLW  00
3298:  ADDWFC x2A,W
329A:  MOVWF  FEA
329C:  BSF    FEF.2
.................... 
....................                      // 4/1/02
....................                      flags |= ACK;
329E:  BSF    x2B.4
....................                   }
32A0:  BRA    32E2
....................                   // There is data, but we cannot handle it at this time.
....................                   else
....................                   {
....................                      //DebugPrint("D");
....................                      // Since we cannot accept this packet,
....................                      // restore to previous seq and ack.
....................                      // and do not send anything back.
....................                      // Host has to resend this packet when
....................                      // we are ready.
....................                      ps->SND_SEQ = prevSeq;
32A2:  MOVLW  16
32A4:  ADDWF  x29,W
32A6:  MOVWF  FE9
32A8:  MOVLW  00
32AA:  ADDWFC x2A,W
32AC:  MOVWF  FEA
32AE:  MOVFF  325,FEF
32B2:  MOVFF  326,FEC
32B6:  MOVFF  327,FEC
32BA:  MOVFF  328,FEC
....................                      ps->SND_ACK = prevAck;
32BE:  MOVLW  1A
32C0:  ADDWF  x29,W
32C2:  MOVWF  FE9
32C4:  MOVLW  00
32C6:  ADDWFC x2A,W
32C8:  MOVWF  FEA
32CA:  MOVFF  321,FEF
32CE:  MOVFF  322,FEC
32D2:  MOVFF  323,FEC
32D6:  MOVFF  324,FEC
.................... 
....................                      MACDiscardRx();
32DA:  MOVLB  0
32DC:  CALL   1164
32E0:  MOVLB  3
....................                   }
....................                }
32E2:  BRA    32EC
....................                // There is no data in this packet, and thus it
....................                // can be thrown away.
....................                else
....................                {
....................                   MACDiscardRx();
32E4:  MOVLB  0
32E6:  CALL   1164
32EA:  MOVLB  3
....................                }
....................             }
32EC:  BRA    34BC
....................             // Connection is not established; check if we've sent
....................             // a FIN and expect our last ACK
....................             else if(ps->smState == TCP_LAST_ACK)
32EE:  MOVFF  329,FE9
32F2:  MOVFF  32A,FEA
32F6:  MOVF   FEF,W
32F8:  SUBLW  09
32FA:  BNZ   3326
....................             {
....................                MACDiscardRx();
32FC:  MOVLB  0
32FE:  CALL   1164
.................... 
....................                if(h->Flags.bits.flagACK)
3302:  MOVLW  0D
3304:  MOVLB  3
3306:  ADDWF  x15,W
3308:  MOVWF  FE9
330A:  MOVLW  00
330C:  ADDWFC x16,W
330E:  MOVWF  FEA
3310:  BTFSS  FEF.4
3312:  BRA    3324
....................                {
....................                   CloseSocket(ps);
3314:  MOVFF  32A,331
3318:  MOVFF  329,330
331C:  MOVLB  0
331E:  CALL   24FE
3322:  MOVLB  3
....................                }
....................             }
3324:  BRA    34BC
....................             else if(ps->smState == TCP_FIN_WAIT_1)
3326:  MOVFF  329,FE9
332A:  MOVFF  32A,FEA
332E:  MOVF   FEF,W
3330:  SUBLW  04
3332:  BNZ   33F8
....................             {
....................                MACDiscardRx();
3334:  MOVLB  0
3336:  CALL   1164
.................... 
....................                if(h->Flags.bits.flagFIN)
333A:  MOVLW  0D
333C:  MOVLB  3
333E:  ADDWF  x15,W
3340:  MOVWF  FE9
3342:  MOVLW  00
3344:  ADDWFC x16,W
3346:  MOVWF  FEA
3348:  BTFSS  FEF.0
334A:  BRA    33D6
....................                {
....................                   flags = ACK;
334C:  MOVLW  10
334E:  MOVWF  x2B
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
3350:  MOVLW  1A
3352:  ADDWF  x29,W
3354:  MOVWF  FE9
3356:  MOVLW  00
3358:  ADDWFC x2A,W
335A:  MOVWF  FEA
335C:  MOVLW  01
335E:  ADDWF  FEF,W
3360:  MOVWF  00
3362:  MOVLW  00
3364:  ADDWFC FEC,W
3366:  MOVWF  01
3368:  MOVLW  00
336A:  ADDWFC FEC,W
336C:  MOVWF  02
336E:  MOVLW  00
3370:  ADDWFC FEC,W
3372:  MOVF   FED,F
3374:  MOVF   FED,F
3376:  MOVF   FED,F
3378:  MOVFF  00,FEF
337C:  MOVFF  01,FEC
3380:  MOVFF  02,FEC
3384:  MOVWF  FEC
....................               ack = ps->SND_ACK;
3386:  MOVLW  1A
3388:  ADDWF  x29,W
338A:  MOVWF  FE9
338C:  MOVLW  00
338E:  ADDWFC x2A,W
3390:  MOVWF  FEA
3392:  MOVFF  FEF,319
3396:  MOVFF  FEC,31A
339A:  MOVFF  FEC,31B
339E:  MOVFF  FEC,31C
....................                   if(h->Flags.bits.flagACK)
33A2:  MOVLW  0D
33A4:  ADDWF  x15,W
33A6:  MOVWF  FE9
33A8:  MOVLW  00
33AA:  ADDWFC x16,W
33AC:  MOVWF  FEA
33AE:  BTFSS  FEF.4
33B0:  BRA    33C4
....................                   {
....................                      CloseSocket(ps);
33B2:  MOVFF  32A,331
33B6:  MOVFF  329,330
33BA:  MOVLB  0
33BC:  CALL   24FE
....................                   }
33C0:  BRA    33D2
33C2:  MOVLB  3
....................                   else
....................                   {
....................                      ps->smState = TCP_CLOSING;
33C4:  MOVFF  329,FE9
33C8:  MOVFF  32A,FEA
33CC:  MOVLW  06
33CE:  MOVWF  FEF
33D0:  MOVLB  0
....................                   }
....................                }
33D2:  BRA    33F4
33D4:  MOVLB  3
....................                else if(h->Flags.bits.flagACK)
33D6:  MOVLW  0D
33D8:  ADDWF  x15,W
33DA:  MOVWF  FE9
33DC:  MOVLW  00
33DE:  ADDWFC x16,W
33E0:  MOVWF  FEA
33E2:  BTFSS  FEF.4
33E4:  BRA    33F2
....................                {
....................                   ps->smState = TCP_FIN_WAIT_2;
33E6:  MOVFF  329,FE9
33EA:  MOVFF  32A,FEA
33EE:  MOVLW  05
33F0:  MOVWF  FEF
33F2:  MOVLB  0
....................                }
....................             }
33F4:  BRA    34BA
33F6:  MOVLB  3
....................             else if(ps->smState == TCP_FIN_WAIT_2)
33F8:  MOVFF  329,FE9
33FC:  MOVFF  32A,FEA
3400:  MOVF   FEF,W
3402:  SUBLW  05
3404:  BNZ   3486
....................             {
....................                MACDiscardRx();
3406:  MOVLB  0
3408:  CALL   1164
.................... 
....................                if(h->Flags.bits.flagFIN)
340C:  MOVLW  0D
340E:  MOVLB  3
3410:  ADDWF  x15,W
3412:  MOVWF  FE9
3414:  MOVLW  00
3416:  ADDWFC x16,W
3418:  MOVWF  FEA
341A:  BTFSS  FEF.0
341C:  BRA    3484
....................                {
....................                   flags = ACK;
341E:  MOVLW  10
3420:  MOVWF  x2B
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE?
....................               ps->SND_ACK += 1;
3422:  MOVLW  1A
3424:  ADDWF  x29,W
3426:  MOVWF  FE9
3428:  MOVLW  00
342A:  ADDWFC x2A,W
342C:  MOVWF  FEA
342E:  MOVLW  01
3430:  ADDWF  FEF,W
3432:  MOVWF  00
3434:  MOVLW  00
3436:  ADDWFC FEC,W
3438:  MOVWF  01
343A:  MOVLW  00
343C:  ADDWFC FEC,W
343E:  MOVWF  02
3440:  MOVLW  00
3442:  ADDWFC FEC,W
3444:  MOVF   FED,F
3446:  MOVF   FED,F
3448:  MOVF   FED,F
344A:  MOVFF  00,FEF
344E:  MOVFF  01,FEC
3452:  MOVFF  02,FEC
3456:  MOVWF  FEC
....................               ack = ps->SND_ACK;
3458:  MOVLW  1A
345A:  ADDWF  x29,W
345C:  MOVWF  FE9
345E:  MOVLW  00
3460:  ADDWFC x2A,W
3462:  MOVWF  FEA
3464:  MOVFF  FEF,319
3468:  MOVFF  FEC,31A
346C:  MOVFF  FEC,31B
3470:  MOVFF  FEC,31C
....................                   CloseSocket(ps);
3474:  MOVFF  32A,331
3478:  MOVFF  329,330
347C:  MOVLB  0
347E:  CALL   24FE
3482:  MOVLB  3
....................                }
....................             }
3484:  BRA    34BC
....................             else if ( ps->smState == TCP_CLOSING )
3486:  MOVFF  329,FE9
348A:  MOVFF  32A,FEA
348E:  MOVF   FEF,W
3490:  SUBLW  06
3492:  BNZ   34BC
....................             {
....................                MACDiscardRx();
3494:  MOVLB  0
3496:  CALL   1164
.................... 
....................                if ( h->Flags.bits.flagACK )
349A:  MOVLW  0D
349C:  MOVLB  3
349E:  ADDWF  x15,W
34A0:  MOVWF  FE9
34A2:  MOVLW  00
34A4:  ADDWFC x16,W
34A6:  MOVWF  FEA
34A8:  BTFSS  FEF.4
34AA:  BRA    34BC
....................                {
....................                   CloseSocket(ps);
34AC:  MOVFF  32A,331
34B0:  MOVFF  329,330
34B4:  MOVLB  0
34B6:  CALL   24FE
34BA:  MOVLB  3
....................                }
....................             }
....................          }
....................       }
34BC:  BRA    34DA
....................       // This packet's sequence number does not match what we were
....................       // expecting (the last value we ACKed).  Throw this packet
....................       // away.  This may happen if packets are delivered out of order.
....................       // Not enough memory is available on our PIC or Ethernet
....................       // controller to implement a robust stream reconstruction
....................       // buffer.  As a result, the remote node will just have to
....................       // retransmit its packets starting with the proper sequence number.
....................       else
....................       {
....................          MACDiscardRx();
34BE:  MOVLB  0
34C0:  CALL   1164
.................... 
....................          // Send a new ACK out in case if the previous one was lost
....................          // (ACKs aren't ACKed).  This is required to prevent an
....................          // unlikely but possible situation which would cause the
....................          // connection to time out if the ACK was lost and the
....................          // remote node keeps sending us older data than we are
....................          // expecting.
....................          flags = ACK;
34C4:  MOVLW  10
34C6:  MOVLB  3
34C8:  MOVWF  x2B
....................          ack = prevAck;
34CA:  MOVFF  324,31C
34CE:  MOVFF  323,31B
34D2:  MOVFF  322,31A
34D6:  MOVFF  321,319
....................       }
....................    }
.................... 
.................... SendTCPControlPacket:
....................    if(flags)
34DA:  MOVLB  3
34DC:  MOVF   x2B,F
34DE:  BZ    3542
....................    {
....................       SendTCP(remote,
....................          h->DestPort,
....................          h->SourcePort,
....................          seq,
....................          ack,
....................          flags);
34E0:  MOVLW  02
34E2:  ADDWF  x15,W
34E4:  MOVWF  FE9
34E6:  MOVLW  00
34E8:  ADDWFC x16,W
34EA:  MOVWF  FEA
34EC:  MOVFF  FEC,33A
34F0:  MOVF   FED,F
34F2:  MOVFF  FEF,339
34F6:  MOVFF  315,FE9
34FA:  MOVFF  316,FEA
34FE:  MOVFF  FEC,33C
3502:  MOVF   FED,F
3504:  MOVFF  FEF,33B
3508:  MOVFF  314,338
350C:  MOVFF  313,337
3510:  MOVFF  320,340
3514:  MOVFF  31F,33F
3518:  MOVFF  31E,33E
351C:  MOVFF  31D,33D
3520:  MOVFF  31C,344
3524:  MOVFF  31B,343
3528:  MOVFF  31A,342
352C:  MOVFF  319,341
3530:  MOVFF  32B,345
3534:  SETF   x46
3536:  CLRF   x48
3538:  CLRF   x47
353A:  MOVLB  0
353C:  CALL   292A
3540:  MOVLB  3
....................    }
3542:  MOVLB  0
3544:  GOTO   36D8 (RETURN)
.................... 
....................    /*if (debugLastState != ps->smState)
....................    {
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s);
....................       DebugTCPDisplayState(debugLastState);
....................       debug_tcp(" -> ");
....................       DebugTCPDisplayState(ps->smState);
....................    }*/
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_ICMP
....................    #include "tcpip/icmp.c"
.................... /*********************************************************************
....................  *
....................  *                  ICMP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ICMP.C
....................  * Dependencies:    ICMP.h
....................  *                  string.h
....................  *                  StackTsk.h
....................  *                  Helpers.h
....................  *                  IP.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/icmp.h"
.................... /*********************************************************************
....................  *
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ICMP.h
....................  * Dependencies:    StackTsk.h
....................  *                  IP.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef ICMP_H
.................... #define ICMP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes.
.................... //#define MAX_ICMP_DATA       (32)
.................... #define MAX_ICMP_DATA       (64)
.................... 
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA)
.................... 
.................... 
.................... typedef enum _ICMP_CODE
.................... {
....................     ICMP_ECHO_REPLY = 0,
....................     ICMP_ECHO_REQUEST = 8
.................... } ICMP_CODE, ICMP_REQUESTS;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPIsTxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is ready
....................  *                  FALSE if transmit buffer is not ready
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ICMPPut(NODE_INFO *remote,
....................  *                               ICMP_CODE code,
....................  *                               BYTE *data,
....................  *                               BYTE len,
....................  *                               WORD id,
....................  *                               WORD seq)
....................  *
....................  * PreCondition:    ICMPIsTxReady() == TRUE
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST
....................  *                  data        - Data bytes
....................  *                  len         - Number of bytes to send
....................  *                  id          - ICMP identifier
....................  *                  seq         - ICMP sequence number
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            A ICMP packet is created and put on MAC.
....................  *
....................  ********************************************************************/
.................... void ICMPPut(NODE_INFO *remote,
....................              ICMP_CODE code,
....................              BYTE *data,
....................              BYTE len,
....................              WORD id,
....................              WORD seq);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code,
....................  *                              BYTE *data,
....................  *                              BYTE *len,
....................  *                              WORD *id,
....................  *                              WORD *seq)
....................  *
....................  * PreCondition:    MAC buffer contains ICMP type packet.
....................  *
....................  * Input:           code    - Buffer to hold ICMP code value
....................  *                  data    - Buffer to hold ICMP data
....................  *                  len     - Buffer to hold ICMP data length
....................  *                  id      - Buffer to hold ICMP id
....................  *                  seq     - Buffer to hold ICMP seq
....................  *
....................  * Output:          TRUE if valid ICMP packet was received
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ICMPGet(ICMP_CODE *code,
....................              BYTE *data,
....................              BYTE *len,
....................              WORD *id,
....................              WORD *seq);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/ip.h"
.................... /*********************************************************************
....................  *
....................  *                  IP Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        IP.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/
.................... 
.................... #ifndef IP_H
.................... #define IP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... 
.................... #define IP_PROT_ICMP    (1)
.................... #define IP_PROT_TCP     (6)
.................... #define IP_PROT_UDP     (17)
.................... 
.................... 
.................... /*
....................  * IP packet header definition
....................  */
.................... typedef struct _IP_HEADER
.................... {
....................     BYTE    VersionIHL;
....................     BYTE    TypeOfService;
....................     WORD    TotalLength;
....................     WORD    Identification;
....................     WORD    FragmentInfo;
....................     BYTE    TimeToLive;
....................     BYTE    Protocol;
....................     WORD    HeaderChecksum;
....................     IP_ADDR SourceAddress;
....................     IP_ADDR DestAddress;
.................... 
.................... } IP_HEADER;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if transmit buffer is empty
....................  *                  FALSE if transmit buffer is not empty
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority)
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPSetTxBuffer(a, b)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           a       - Buffer identifier
....................  *                  b       - Offset
....................  *
....................  * Output:          Next Read/Write access to transmit buffer 'a'
....................  *                  set to offset 'b'
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER))
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest,
....................  *                                      BYTE    Protocol,
....................  *                                      WORD    Identifier,
....................  *                                      WORD    DataLen)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           Src         - Destination node address
....................  *                  Protocol    - Current packet protocol
....................  *                  Identifier  - Current packet identifier
....................  *                  DataLen     - Current packet data length
....................  *
....................  * Output:          Handle to current packet - For use by
....................  *                  IPSendByte() function.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be transmitted at any
....................  *                  time.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... WORD    IPPutHeader(NODE_INFO *remote,
....................                     BYTE protocol,
....................                     WORD len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPPutArray(a, b)
....................  *
....................  * PreCondition:    IPIsTxReady() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied to IP data area.
....................  *
....................  ********************************************************************/
.................... #define IPPutArray(a, b)    MACPutArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP,
....................  *                                    NODE_INFO  *remote,
....................  *                                    BYTE        *Protocol,
....................  *                                    WORD        *len)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           localIP     - Local node IP Address as received
....................  *                                in current IP header.
....................  *                                If this information is not required
....................  *                                caller may pass NULL value.
....................  *                  remote      - Remote node info
....................  *                  Protocol    - Current packet protocol
....................  *                  len         - Current packet data length
....................  *
....................  * Output:          TRUE, if valid packet was received
....................  *                  FALSE otherwise
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Only one IP message can be received.
....................  *                  Caller may not transmit and receive a message
....................  *                  at the same time.
....................  *
....................  ********************************************************************/
.................... BOOL IPGetHeader(IP_ADDR *localIP,
....................                  NODE_INFO *remote,
....................                  BYTE *protocol,
....................                  WORD *len);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPDiscard()
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Current packet is discarded and buffer is
....................  *                  freed-up
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... #define IPDiscard()         MACDiscard()
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           IPGetArray(a, b)
....................  *
....................  * PreCondition:    MACGetHeader() == TRUE
....................  *
....................  * Input:           a       - Data buffer
....................  *                  b       - Buffer length
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            Data is copied from IP data to given buffer
....................  *
....................  ********************************************************************/
.................... #define IPGetArray(a, b)    MACGetArray(a, b)
.................... 
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        IPSetRxBuffer(WORD Offset)
....................  *
....................  * PreCondition:    IPHeaderLen must have been intialized by
....................  *					IPGetHeader() or IPPutHeader()
....................  *
....................  * Input:           Offset from beginning of IP data field
....................  *
....................  * Output:          Next Read/Write access to receive buffer is
....................  *                  set to Offset
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            None
....................  *
....................  ********************************************************************/
.................... void IPSetRxBuffer(WORD Offset);
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define debug_icmp
.................... //#define debug_icmp   debug_printf
.................... 
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h
.................... 
.................... /*
....................  * ICMP packet definition
....................  */
.................... typedef struct _ICMP_PACKET
.................... {
....................     BYTE    Type;
....................     BYTE    Code;
....................     WORD    Checksum;
....................     WORD    Identifier;
....................     WORD    SequenceNumber;
....................     BYTE    Data[MAX_ICMP_DATA];
.................... } ICMP_PACKET;
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA)
.................... 
.................... static void SwapICMPPacket(ICMP_PACKET* p);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code,
....................  *                              BYTE *data,
....................  *                              BYTE *len,
....................  *                              WORD *id,
....................  *                              WORD *seq)
....................  *
....................  * PreCondition:    MAC buffer contains ICMP type packet.
....................  *
....................  * Input:           code    - Buffer to hold ICMP code value
....................  *                  data    - Buffer to hold ICMP data
....................  *                  len     - Buffer to hold ICMP data length
....................  *                  id      - Buffer to hold ICMP id
....................  *                  seq     - Buffer to hold ICMP seq
....................  *
....................  * Output:          TRUE if valid ICMP packet was received
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ICMPGet(ICMP_CODE *code,
....................              BYTE *data,
....................              BYTE *len,
....................              WORD *id,
....................              WORD *seq)
.................... {
....................     ICMP_PACKET packet;
....................     WORD CalcChecksum;
....................     WORD ReceivedChecksum;
.................... #if !defined(MCHP_MAC)
....................     WORD checksums[2];
.................... #endif
.................... 
.................... //    debug_icmp("\r\nICMP GET ");
.................... 
....................     // Obtain the ICMP Header
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE);
*
37B2:  MOVLW  02
37B4:  MOVLB  3
37B6:  MOVWF  x3F
37B8:  MOVLW  F2
37BA:  MOVWF  x3E
37BC:  MOVFF  33F,37E
37C0:  MOVWF  x7D
37C2:  CLRF   x80
37C4:  MOVLW  08
37C6:  MOVWF  x7F
37C8:  MOVLB  0
37CA:  CALL   11D0
.................... 
.................... 
.................... #if defined(MCHP_MAC)
....................    // Calculate the checksum using the Microchip MAC's DMA module
....................    // The checksum data includes the precomputed checksum in the
....................    // header, so a valid packet will always have a checksum of
....................    // 0x0000 if the packet is not disturbed.
....................    ReceivedChecksum = 0x0000;
37CE:  MOVLB  3
37D0:  CLRF   x3D
37D2:  CLRF   x3C
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len);
37D4:  MOVFF  2ED,FEA
37D8:  MOVFF  2EC,FE9
37DC:  MOVFF  FEF,341
37E0:  MOVLB  3
37E2:  CLRF   x40
37E4:  MOVLW  14
37E6:  MOVWF  x3F
37E8:  CLRF   x42
37EA:  MOVLB  0
37EC:  CALL   1B4E
37F0:  MOVFF  02,33B
37F4:  MOVFF  01,33A
.................... #endif
.................... 
....................    // Obtain the ICMP data payload
....................     *len -= ICMP_HEADER_SIZE;
37F8:  MOVFF  2ED,FEA
37FC:  MOVLB  2
37FE:  MOVFF  2EC,FE9
3802:  MOVLW  08
3804:  SUBWF  FEF,W
3806:  MOVWF  FEF
....................     MACGetArray(data, *len);
3808:  MOVFF  2ED,FEA
380C:  MOVFF  2EC,FE9
3810:  MOVFF  FEF,37F
3814:  MOVFF  2EB,37E
3818:  MOVFF  2EA,37D
381C:  MOVLB  3
381E:  CLRF   x80
3820:  MOVLB  0
3822:  CALL   11D0
.................... 
.................... 
.................... #if !defined(MCHP_MAC)
....................    // Calculte the checksum in local memory without hardware help
....................     ReceivedChecksum = packet.Checksum;
....................     packet.Checksum = 0;
.................... 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE);
....................     checksums[1] = ~CalcIPChecksum(data, *len);
.................... 
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD));
.................... #endif
.................... 
....................     SwapICMPPacket(&packet);
3826:  MOVLW  02
3828:  MOVLB  3
382A:  MOVWF  x3F
382C:  MOVLW  F2
382E:  MOVWF  x3E
3830:  MOVLB  0
3832:  RCALL  36EA
.................... 
....................     *code = packet.Type;
3834:  MOVFF  2E9,FEA
3838:  MOVLB  2
383A:  MOVFF  2E8,FE9
383E:  MOVFF  2F2,FEF
....................     *id = packet.Identifier;
3842:  MOVFF  2EF,FEA
3846:  MOVFF  2EE,FE9
384A:  MOVFF  2F7,FEC
384E:  MOVF   FED,F
3850:  MOVFF  2F6,FEF
....................     *seq = packet.SequenceNumber;
3854:  MOVFF  2F1,FEA
3858:  MOVFF  2F0,FE9
385C:  MOVFF  2F9,FEC
3860:  MOVF   FED,F
3862:  MOVFF  2F8,FEF
.................... 
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum);
.................... 
....................     return ( CalcChecksum == ReceivedChecksum );
3866:  MOVLB  3
3868:  MOVF   x3C,W
386A:  SUBWF  x3A,W
386C:  BNZ   3874
386E:  MOVF   x3D,W
3870:  SUBWF  x3B,W
3872:  BZ    3878
3874:  MOVLW  00
3876:  BRA    387A
3878:  MOVLW  01
387A:  MOVWF  01
387C:  MOVLB  0
387E:  GOTO   6DA8 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void ICMPPut(NODE_INFO *remote,
....................  *                               ICMP_CODE code,
....................  *                               BYTE *data,
....................  *                               BYTE len,
....................  *                               WORD id,
....................  *                               WORD seq)
....................  *
....................  * PreCondition:    ICMPIsTxReady() == TRUE
....................  *
....................  * Input:           remote      - Remote node info
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST
....................  *                  data        - Data bytes
....................  *                  len         - Number of bytes to send
....................  *                  id          - ICMP identifier
....................  *                  seq         - ICMP sequence number
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            A ICMP packet is created and put on MAC.
....................  *
....................  ********************************************************************/
.................... void ICMPPut(NODE_INFO *remote,
....................              ICMP_CODE code,
....................              BYTE *data,
....................              BYTE len,
....................              WORD id,
....................              WORD seq)
.................... {
....................     ICMP_PACKET   packet;
....................     WORD ICMPLen;
....................    BUFFER MyTxBuffer;
....................    MyTxBuffer = MACGetTxBuffer(TRUE);
3882:  MOVLW  01
3884:  MOVLB  3
3886:  MOVWF  x6F
3888:  MOVLB  0
388A:  CALL   1528
388E:  MOVFF  01,33A
.................... 
....................    // Abort if there is no where in the Ethernet controller to
....................    // store this packet.
....................    if(MyTxBuffer == INVALID_BUFFER)
3892:  MOVLB  3
3894:  INCFSZ x3A,W
3896:  BRA    389A
....................       return;
3898:  BRA    3996
.................... 
....................    IPSetTxBuffer(MyTxBuffer, 0);
389A:  MOVFF  33A,388
389E:  CLRF   x8A
38A0:  MOVLW  14
38A2:  MOVWF  x89
38A4:  MOVLB  0
38A6:  CALL   1550
.................... 
.................... 
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len;
38AA:  CLRF   03
38AC:  MOVLB  2
38AE:  MOVF   xEB,W
38B0:  ADDLW  08
38B2:  MOVLB  3
38B4:  MOVWF  x38
38B6:  MOVLW  00
38B8:  ADDWFC 03,W
38BA:  MOVWF  x39
.................... 
....................     packet.Code             = 0;
38BC:  MOVLB  2
38BE:  CLRF   xF1
....................     packet.Type             = code;
38C0:  MOVFF  2E8,2F0
....................     packet.Checksum         = 0;
38C4:  CLRF   xF3
38C6:  CLRF   xF2
....................     packet.Identifier       = id;
38C8:  MOVFF  2ED,2F5
38CC:  MOVFF  2EC,2F4
....................     packet.SequenceNumber   = seq;
38D0:  MOVFF  2EF,2F7
38D4:  MOVFF  2EE,2F6
.................... 
....................     memcpy((void*)packet.Data, (void*)data, len);
38D8:  MOVLW  02
38DA:  MOVWF  FEA
38DC:  MOVLW  F8
38DE:  MOVWF  FE9
38E0:  MOVFF  2EA,FE2
38E4:  MOVFF  2E9,FE1
38E8:  MOVF   xEB,W
38EA:  MOVWF  01
38EC:  BZ    38F6
38EE:  MOVFF  FE6,FEE
38F2:  DECFSZ 01,F
38F4:  BRA    38EE
.................... 
....................     SwapICMPPacket(&packet);
38F6:  MOVLW  02
38F8:  MOVLB  3
38FA:  MOVWF  x3F
38FC:  MOVLW  F0
38FE:  MOVWF  x3E
3900:  MOVLB  0
3902:  RCALL  36EA
.................... 
.................... #if !defined(MCHP_MAC)
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet,
....................                                     ICMPLen);
.................... #endif
.................... 
....................     IPPutHeader(remote,
....................                 IP_PROT_ICMP,
....................                 (WORD)(ICMP_HEADER_SIZE + len));
3904:  MOVLW  08
3906:  MOVLB  2
3908:  ADDWF  xEB,W
390A:  MOVLB  3
390C:  MOVWF  x3B
390E:  MOVFF  2E7,370
3912:  MOVFF  2E6,36F
3916:  MOVLW  01
3918:  MOVWF  x71
391A:  CLRF   x73
391C:  MOVFF  33B,372
3920:  MOVLB  0
3922:  CALL   280A
.................... 
....................     IPPutArray((BYTE*)&packet, ICMPLen);
3926:  MOVLW  02
3928:  MOVLB  3
392A:  MOVWF  x3C
392C:  MOVLW  F0
392E:  MOVWF  x3B
3930:  MOVFF  33C,394
3934:  MOVWF  x93
3936:  MOVFF  339,396
393A:  MOVFF  338,395
393E:  MOVLB  0
3940:  CALL   160C
.................... 
.................... #if defined(MCHP_MAC)
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen);
3944:  MOVLB  3
3946:  CLRF   x89
3948:  MOVLW  14
394A:  MOVWF  x88
394C:  MOVFF  339,38B
3950:  MOVFF  338,38A
3954:  MOVLB  0
3956:  CALL   2732
395A:  MOVFF  02,2F3
395E:  MOVFF  01,2F2
....................    IPSetTxBuffer(MyTxBuffer, 2);
3962:  MOVFF  33A,388
3966:  MOVLB  3
3968:  CLRF   x8A
396A:  MOVLW  16
396C:  MOVWF  x89
396E:  MOVLB  0
3970:  CALL   1550
....................    MACPutArray((BYTE*)&packet.Checksum, 2);
3974:  MOVLW  02
3976:  MOVLB  3
3978:  MOVWF  x3C
397A:  MOVLW  F2
397C:  MOVWF  x3B
397E:  MOVFF  33C,394
3982:  MOVWF  x93
3984:  CLRF   x96
3986:  MOVLW  02
3988:  MOVWF  x95
398A:  MOVLB  0
398C:  CALL   160C
.................... #endif
.................... 
.................... 
....................     MACFlush();
3990:  CALL   171A
3994:  MOVLB  3
3996:  MOVLB  0
3998:  GOTO   6E02 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           p - ICMP packet header
....................  *
....................  * Output:          ICMP packet is swapped
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void SwapICMPPacket(ICMP_PACKET* p)
.................... {
....................     p->Identifier           = swaps(p->Identifier);
*
36EA:  MOVLW  04
36EC:  MOVLB  3
36EE:  ADDWF  x3E,W
36F0:  MOVWF  01
36F2:  MOVLW  00
36F4:  ADDWFC x3F,W
36F6:  MOVWF  03
36F8:  MOVFF  01,340
36FC:  MOVWF  x41
36FE:  MOVLW  04
3700:  ADDWF  x3E,W
3702:  MOVWF  FE9
3704:  MOVLW  00
3706:  ADDWFC x3F,W
3708:  MOVWF  FEA
370A:  MOVFF  FEC,38F
370E:  MOVF   FED,F
3710:  MOVFF  FEF,38E
3714:  MOVLB  0
3716:  CALL   1230
371A:  MOVFF  341,FEA
371E:  MOVFF  340,FE9
3722:  MOVFF  02,FEC
3726:  MOVF   FED,F
3728:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber);
372C:  MOVLW  06
372E:  MOVLB  3
3730:  ADDWF  x3E,W
3732:  MOVWF  01
3734:  MOVLW  00
3736:  ADDWFC x3F,W
3738:  MOVWF  03
373A:  MOVFF  01,340
373E:  MOVWF  x41
3740:  MOVLW  06
3742:  ADDWF  x3E,W
3744:  MOVWF  FE9
3746:  MOVLW  00
3748:  ADDWFC x3F,W
374A:  MOVWF  FEA
374C:  MOVFF  FEC,38F
3750:  MOVF   FED,F
3752:  MOVFF  FEF,38E
3756:  MOVLB  0
3758:  CALL   1230
375C:  MOVFF  341,FEA
3760:  MOVFF  340,FE9
3764:  MOVFF  02,FEC
3768:  MOVF   FED,F
376A:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum);
376E:  MOVLW  02
3770:  MOVLB  3
3772:  ADDWF  x3E,W
3774:  MOVWF  01
3776:  MOVLW  00
3778:  ADDWFC x3F,W
377A:  MOVWF  03
377C:  MOVFF  01,340
3780:  MOVWF  x41
3782:  MOVLW  02
3784:  ADDWF  x3E,W
3786:  MOVWF  FE9
3788:  MOVLW  00
378A:  ADDWFC x3F,W
378C:  MOVWF  FEA
378E:  MOVFF  FEC,38F
3792:  MOVF   FED,F
3794:  MOVFF  FEF,38E
3798:  MOVLB  0
379A:  CALL   1230
379E:  MOVFF  341,FEA
37A2:  MOVFF  340,FE9
37A6:  MOVFF  02,FEC
37AA:  MOVF   FED,F
37AC:  MOVFF  01,FEF
37B0:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_UDP
....................    #include "tcpip/udp.c"
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    #include "tcpip/dhcp.c"
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    #include "tcpip/telnet2.c"
.................... #endif
.................... 
.................... #if STACK_USE_ARP
....................    #include "tcpip/arptsk.c"
.................... /*********************************************************************
....................  *
....................  *                  ARP Server Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARPTsk.c
....................  * Dependencies:    compiler.h
....................  *                  string.h
....................  *                  ARP.h
....................  *                  ARPTsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case)
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes].
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP.
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/arp.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.h
....................  * Dependencies:    Stacktsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... #ifndef ARP_H
.................... #define ARP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................  * Following codes are must be used with ARPGet/Put functions.
....................  */
.................... #define ARP_REPLY       (0x00)
.................... #define ARP_REQUEST     (0x01)
.................... #define ARP_UNKNOWN     (0x02)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           ARPIsRxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if ARP receive buffer is full.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE)
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    MACIsTxReady() == TRUE
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode);
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/arptsk.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Server Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARPTsk.h
....................  * Dependencies:    StackTsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes].
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef ARP_TSK_H
.................... #define ARP_TSK_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP Cache is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void ARPInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPProcess(void)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPProcess(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr  - IP Address to be resolved.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        An ARP request is sent.
....................  *
....................  * Note:
....................  ********************************************************************/
.................... void ARPResolve(IP_ADDR *IPAddr);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr,
....................  *                                      MAC_ADDR *MACAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr      - IPAddress to be resolved.
....................  *                  MACAddr     - Buffer to hold corresponding
....................  *                                MAC Address.
....................  *
....................  * Output:          TRUE if given IP Address has been resolved.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr);
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_arptask
.................... //#define debug_arptask   debug_printf
.................... 
.................... /*
....................  * ARP Task FSM States
....................  */
.................... typedef enum _ARP_STATE
.................... {
....................     SM_ARP_IDLE,
....................     SM_ARP_REPLY
.................... } ARP_STATE;
.................... 
.................... 
.................... /*
....................  * This ARP task caches one ARP response.
....................  */
.................... static ARP_STATE smARP;
.................... 
.................... static NODE_INFO Cache;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP Cache is initialized.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... void ARPInit(void)
.................... {
....................     smARP = SM_ARP_IDLE;
*
0C9A:  BCF    5B.1
.................... 
....................     Cache.MACAddr.v[0] = 0xff;
0C9C:  SETF   x64
....................     Cache.MACAddr.v[1] = 0xff;
0C9E:  SETF   x65
....................     Cache.MACAddr.v[2] = 0xff;
0CA0:  SETF   x66
....................     Cache.MACAddr.v[3] = 0xff;
0CA2:  SETF   x67
....................     Cache.MACAddr.v[4] = 0xff;
0CA4:  SETF   x68
....................     Cache.MACAddr.v[5] = 0xff;
0CA6:  SETF   x69
.................... 
....................     Cache.IPAddr.Val = 0x0;
0CA8:  CLRF   x6D
0CAA:  CLRF   x6C
0CAC:  CLRF   x6B
0CAE:  CLRF   x6A
0CB0:  GOTO   1082 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPProcess(void)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          ARP FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPProcess(void)
.................... {
....................     NODE_INFO remoteNode;
....................     BYTE opCode;
.................... 
....................     switch(smARP)
*
1AC0:  MOVLW  00
1AC2:  BTFSC  5B.1
1AC4:  MOVLW  01
1AC6:  XORLW  00
1AC8:  BZ    1ACC
1ACA:  BRA    1B28
....................     {
....................     case SM_ARP_IDLE:
....................         if ( !ARPGet(&remoteNode, &opCode) )
1ACC:  MOVLW  02
1ACE:  MOVLB  2
1AD0:  MOVWF  xF2
1AD2:  MOVLW  E6
1AD4:  MOVWF  xF1
1AD6:  MOVLW  02
1AD8:  MOVWF  xF4
1ADA:  MOVLW  F0
1ADC:  MOVWF  xF3
1ADE:  MOVLB  0
1AE0:  BRA    1440
1AE2:  MOVF   01,F
1AE4:  BNZ   1AE8
....................             break;
1AE6:  BRA    1B46
.................... 
....................          //dsr add 071204
....................          //dsr fix 071206
....................          MACDiscardRx();
1AE8:  CALL   1164
.................... 
....................         if ( opCode == ARP_REPLY )
1AEC:  MOVLB  2
1AEE:  MOVF   xF0,F
1AF0:  BNZ   1B24
....................         {
.................... 			Cache.MACAddr = remoteNode.MACAddr;
1AF2:  CLRF   FEA
1AF4:  MOVLW  64
1AF6:  MOVWF  FE9
1AF8:  MOVLW  02
1AFA:  MOVWF  FE2
1AFC:  MOVLW  E6
1AFE:  MOVWF  FE1
1B00:  MOVLW  06
1B02:  MOVWF  01
1B04:  MOVFF  FE6,FEE
1B08:  DECFSZ 01,F
1B0A:  BRA    1B04
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val;
1B0C:  MOVFF  2EF,6D
1B10:  MOVFF  2EE,6C
1B14:  MOVFF  2ED,6B
1B18:  MOVFF  2EC,6A
....................             break;
1B1C:  MOVLB  0
1B1E:  BRA    1B46
....................         }
1B20:  BRA    1B28
1B22:  MOVLB  2
....................         else
....................             smARP = SM_ARP_REPLY;
1B24:  BSF    5B.1
1B26:  MOVLB  0
.................... 
....................     default:
.................... 		if(ARPPut(&remoteNode, ARP_REPLY))
1B28:  MOVLW  02
1B2A:  MOVLB  2
1B2C:  MOVWF  xF2
1B2E:  MOVLW  E6
1B30:  MOVWF  xF1
1B32:  CLRF   xF3
1B34:  MOVLB  0
1B36:  BRA    1946
1B38:  MOVF   01,F
1B3A:  BZ    1B40
.................... 		{
.................... 			smARP = SM_ARP_IDLE;
1B3C:  BCF    5B.1
.................... 		}
1B3E:  BRA    1B46
....................         else
....................             return FALSE;
1B40:  MOVLW  00
1B42:  MOVWF  01
1B44:  BRA    1B4A
....................         break;
.................... 
....................     }
....................     return TRUE;
1B46:  MOVLW  01
1B48:  MOVWF  01
1B4A:  GOTO   6CC8 (RETURN)
.................... }
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr)
....................  *
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE
....................  *
....................  * Input:           IPAddr  - IP Address to be resolved.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        An ARP request is sent.
....................  ********************************************************************/
.................... void ARPResolve(IP_ADDR *IPAddr)
.................... {
....................     NODE_INFO remoteNode;
.................... 
....................     remoteNode.IPAddr = *IPAddr;
.................... 
....................     ARPPut(&remoteNode, ARP_REQUEST);
.................... }
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr,
....................  *                                      MAC_ADDR *MACAddr)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           IPAddr      - IPAddress to be resolved.
....................  *                  MACAddr     - Buffer to hold corresponding
....................  *                                MAC Address.
....................  *
....................  * Output:          TRUE if given IP Address has been resolved.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  ********************************************************************/
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr)
.................... {
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val)
....................     {
....................         *MACAddr = Cache.MACAddr;
....................         return TRUE;
....................     }
....................     return FALSE;
.................... }
.................... 
.................... 
.................... 
....................    #include "tcpip/arp.c"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.c
....................  * Dependencies:    string.h
....................  *                  stacktsk.h
....................  *                  helpers.h
....................  *                  arp.h
....................  *                  mac.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack
....................  ********************************************************************/
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "tcpip/stacktsk.h"
.................... /*********************************************************************
....................  *
....................  *                  Microchip TCP/IP Stack Definations for PIC18
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        StackTsk.h
....................  * Dependencies:    compiler.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h.
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,
....................                          EEPROM_BUFFER_SIZE, USE_LCD
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... #ifndef STACK_TSK_H
.................... #define STACK_TSK_H
.................... 
.................... #include "tcpip/pic18.h"
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  If a Microchip controller is used and a self memory test
....................  * should be done when the MACInit() function is called,
....................  * uncomment this define.  The test requires ~512 bytes of
....................  * program memory.
....................  */
.................... //#define MAC_POWER_ON_TEST
.................... 
.................... 
.................... /*
....................  * This value is specific to the Microchip Ethernet controllers.
....................  * If a different Ethernet controller is used, this define is not
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all
....................  * broadcast packets that are received would be discarded by the
....................  * hardware, except for ARP requests for our IP address.  This could
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs
....................  * using the patter match filter.  The code for this feature has been
....................  * partially implemented, but it is not complete nor tested, so this
....................  * option should remain unused in this stack version.
....................  */
.................... //#define MAC_FILTER_BROADCASTS
.................... 
.................... /*
....................  * Number of bytes to be reserved before MPFS storage is to start.
....................  *
....................  * These bytes host application configurations such as IP Address,
....................  * MAC Address, and any other required variables.
....................  *
....................  * After making any change to this variable, MPFS.exe must be
....................  * executed with correct block size.
....................  * See MPFS.exe help message by executing MPFS /?
....................  */
.................... #define MPFS_RESERVE_BLOCK              (64)
.................... 
.................... /*
....................  * Modules to include in this project
....................  * For demo purpose only, each sample project defines one or more
....................  * of following defines in compiler command-line options. (See
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu.
....................  * In real applcation, user may want to define them here.
....................  */
.................... #ifndef STACK_USE_MAC
....................    #define  STACK_USE_MAC  TRUE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPENC
....................    #define STACK_USE_MCPENC FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MCPINC
....................    #define STACK_USE_MCPINC FALSE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPENC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... //using MCPENC chip requires MAC
.................... #if STACK_USE_MCPINC
....................    #undef STACK_USE_MAC
....................    #define STACK_USE_MAC TRUE
.................... #endif
.................... 
.................... 
.................... #ifndef STACK_USE_PPP
....................    #define STACK_USE_PPP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SLIP
....................    #define STACK_USE_SLIP FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET)
.................... #endif
.................... 
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC)
....................    #error PLEASE SPECIFY A MAC DRIVER
.................... #endif
.................... 
.................... #ifndef STACK_USE_DNS
....................    #define STACK_USE_DNS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_UDP
....................    #define STACK_USE_UDP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ICMP
....................    #define STACK_USE_ICMP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ARP
....................    #define   STACK_USE_ARP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_TELNET
....................    #define   STACK_USE_TELNET   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP
....................    #define  STACK_USE_HTTP FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SMTP
....................    #define STACK_USE_SMTP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_SNMP
....................    #define STACK_USE_SNMP  FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_ANNOUNCE
....................    #define STACK_USE_ANNOUNCE FALSE
.................... #endif
.................... 
.................... #if (STACK_USE_ARP && STACK_USE_PPP)
....................  #ERROR CANNOT USE ARP WITH PPP
.................... #ENDIF
.................... 
.................... #ifndef   STACK_USE_TCP
....................    #define   STACK_USE_TCP   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_IP_GLEANING
....................    #define STACK_USE_IP_GLEANING   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_MPFS
....................    #define STACK_USE_MPFS   FALSE
.................... #endif
.................... 
.................... #ifndef STACK_USE_HTTP2
....................    #define STACK_USE_HTTP2   FALSE
.................... #endif
.................... 
.................... /*
....................  * When SLIP is used, DHCP is not supported.
....................  */
.................... #if STACK_USE_SLIP
....................    #undef STACK_USE_DHCP
....................    #define STACK_USE_DHCP   FALSE
.................... #endif
.................... 
.................... /*
....................  * When DHCP is enabled, UDP must also be enabled.
....................  */
.................... #if STACK_USE_DHCP
....................     #if defined(STACK_USE_UDP)
....................        #undef STACK_USE_UDP
....................     #endif
....................     #define STACK_USE_UDP TRUE
.................... #endif
.................... 
.................... /*
....................  * When IP Gleaning is enabled, ICMP must also be enabled.
....................  */
.................... #if STACK_USE_IP_GLEANING
....................     #if defined(STACK_USE_ICMP)
....................        #undef STACK_USE_ICMP
....................     #endif
....................         #define STACK_USE_ICMP   TRUE
.................... #endif
.................... 
.................... /*
....................  * This value is for performance enhancing features specific to
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet
....................  * controller is used, this define must be commented out.  When
....................  * defined, checksum computations will be offloaded to the hardware.
....................  */
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC
....................  #define MCHP_MAC
.................... #endif
.................... 
.................... 
.................... /*
....................  * DHCP requires unfragmented packet size of at least 328 bytes,
....................  * and while in SLIP mode, our maximum packet size is less than
....................  * 255.  Hence disallow DHCP module while SLIP is in use.
....................  * If required, one can use DHCP while SLIP is in use by modifying
....................  * C18 linker scipt file such that C18 compiler can allocate
....................  * a static array larger than 255 bytes.
....................  * Due to very specific application that would require this,
....................  * sample stack does not provide such facility.  Interested users
....................  * must do this on their own.
....................  */
.................... #if STACK_USE_SLIP
....................     #if STACK_USE_DHCP
....................         #error DHCP cannot be used when SLIP is enabled.
....................     #endif
.................... #endif
.................... 
.................... #include "tcpip/hardware.h"
.................... 
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0]
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1]
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2]
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3]
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4]
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5]
.................... 
.................... /*
....................  * Subnet mask for this node.
....................  * Must not be all zero's or else this node will never transmit
....................  * anything !!
....................  */
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0]
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1]
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2]
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3]
.................... 
.................... /*
....................  * Hardcoded IP address of this node
....................  * My IP = 10.10.5.10
....................  *
....................  * Gateway = 10.10.5.10
....................  */
.................... 
.................... #define MY_IP                           AppConfig.MyIPAddr
.................... 
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0]
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1]
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2]
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3]
.................... 
.................... /*
....................  * Harcoded Gateway address for this node.
....................  * This should be changed to match actual network environment.
....................  */
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0]
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1]
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2]
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3]
.................... 
.................... #ifndef MAX_SOCKETS
.................... #define MAX_SOCKETS                     5
.................... #endif
.................... 
.................... #ifndef MAX_UDP_SOCKETS
.................... #define MAX_UDP_SOCKETS                 2
.................... #endif
.................... 
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255)
.................... #error Invalid MAX_SOCKETS value specified.
.................... #endif
.................... 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP
.................... #error Invlaid MAX_UDP_SOCKETS value specified
.................... #endif
.................... 
.................... 
.................... 
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 )
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified.
.................... #endif
.................... 
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) )
.................... #error Not enough room for Receive buffer.
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
....................     #if (MAX_UDP_SOCKETS < 1)
....................         #error Set MAX_UDP_SOCKETS to at least one.
....................     #endif
.................... #endif
.................... 
.................... typedef int1 BOOL;
.................... 
.................... typedef BYTE BUFFER;
.................... 
.................... typedef int16 WORD;
.................... typedef int32 DWORD;
.................... 
.................... typedef union _BYTE_VAL
.................... {
....................     BYTE Val;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................     } bits;
.................... } BYTE_VAL;
.................... 
.................... 
.................... typedef union _SWORD_VAL
.................... {
....................     int32 Val;
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................         int8 USB;
....................     } bytes;
.................... } SWORD_VAL;
.................... 
.................... 
.................... typedef union _WORD_VAL
.................... {
....................     int16 Val;
....................     int8 v[2];
....................     struct
....................     {
....................         int8 LSB;
....................         int8 MSB;
....................     } bytes;
.................... } WORD_VAL;
.................... 
.................... /*
.................... typedef union _DWORD_VAL
.................... {
....................     int32 Val;
....................     int8 v[4];
.................... } DWORD_VAL;
.................... */
.................... 
.................... typedef union _DWORD_VAL
.................... {
....................     DWORD Val;
....................    WORD w[2];
....................     BYTE v[4];
....................     struct
....................     {
....................         WORD LW;
....................         WORD HW;
....................     } word;
....................     struct
....................     {
....................         BYTE LB;
....................         BYTE HB;
....................         BYTE UB;
....................         BYTE MB;
....................     } byte;
....................     struct
....................     {
....................         unsigned char b0:1;
....................         unsigned char b1:1;
....................         unsigned char b2:1;
....................         unsigned char b3:1;
....................         unsigned char b4:1;
....................         unsigned char b5:1;
....................         unsigned char b6:1;
....................         unsigned char b7:1;
....................         unsigned char b8:1;
....................         unsigned char b9:1;
....................         unsigned char b10:1;
....................         unsigned char b11:1;
....................         unsigned char b12:1;
....................         unsigned char b13:1;
....................         unsigned char b14:1;
....................         unsigned char b15:1;
....................         unsigned char b16:1;
....................         unsigned char b17:1;
....................         unsigned char b18:1;
....................         unsigned char b19:1;
....................         unsigned char b20:1;
....................         unsigned char b21:1;
....................         unsigned char b22:1;
....................         unsigned char b23:1;
....................         unsigned char b24:1;
....................         unsigned char b25:1;
....................         unsigned char b26:1;
....................         unsigned char b27:1;
....................         unsigned char b28:1;
....................         unsigned char b29:1;
....................         unsigned char b30:1;
....................         unsigned char b31:1;
....................     } bits;
.................... } DWORD_VAL;
.................... 
.................... 
.................... #define LOWER_LSB(a)    (a).v[0]
.................... #define LOWER_MSB(a)   (a).v[1]
.................... #define UPPER_LSB(a)    (a).v[2]
.................... #define UPPER_MSB(a)    (a).v[3]
.................... 
.................... typedef struct _MAC_ADDR
.................... {
....................     BYTE v[6];
.................... } MAC_ADDR;
.................... 
.................... typedef union _IP_ADDR
.................... {
....................     BYTE        v[4];
....................     DWORD       Val;
.................... } IP_ADDR;
.................... 
.................... 
.................... typedef struct _NODE_INFO
.................... {
....................     MAC_ADDR    MACAddr;
....................     IP_ADDR     IPAddr;
.................... } NODE_INFO;
.................... 
.................... typedef struct _APP_CONFIG
.................... {
....................     IP_ADDR     MyIPAddr;
....................     MAC_ADDR    MyMACAddr;
....................     IP_ADDR     MyMask;
....................     IP_ADDR     MyGateway;
....................    IP_ADDR      PrimaryDNSServer;
....................     struct
....................     {
....................         unsigned char bIsDHCPEnabled : 1;
....................         unsigned char bInConfigMode : 1;
....................     } Flags;
....................     WORD_VAL    SerialNumber;
....................     IP_ADDR     SMTPServerAddr;     // Not used.
....................     IP_ADDR     TFTPServerAddr;     // Not used.
....................    BYTE      NetBIOSName[16];
.................... } APP_CONFIG;
.................... 
.................... /*typedef union _STACK_FLAGS
.................... {
....................     struct
....................     {
....................         int1 bInConfigMode : 1;
....................     } bits;
....................     int8 Val;
.................... } STACK_FLAGS;*/
.................... 
.................... APP_CONFIG AppConfig;
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode)
.................... #else
....................     #define StackIsInConfigMode()   FALSE
.................... #endif
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componentns are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines be used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically called
....................  *                  to make sure that timely response.
....................  *
....................  ********************************************************************/
.................... void StackTask(void);
.................... 
.................... 
.................... #endif
.................... 
.................... #include "tcpip/helpers.h"
.................... /*********************************************************************
....................  *
....................  *                  Helper Function Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        Helpers.h
....................  * Dependencies:    stacktsk.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack
....................  ********************************************************************/
.................... 
.................... #ifndef HELPERS_H
.................... #define HELPERS_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... 
.................... #if defined(__C30__) || defined(HI_TECH_C)
.................... void 	itoa(unsigned int Value, char* Buffer);
.................... char *strupr(char *s);
.................... #endif
.................... 
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen);
.................... BYTE	hexatob(WORD_VAL AsciiChars);
.................... BYTE	btohexa_high(BYTE b);
.................... BYTE	btohexa_low(BYTE b);
.................... 
.................... WORD    swaps(WORD_VAL v);
.................... DWORD   swapl(DWORD_VAL v);
.................... 
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... #endif
.................... 
.................... #include "tcpip/arp.h"
.................... /*********************************************************************
....................  *
....................  *                  ARP Module Defs for Microchip TCP/IP Stack
....................  *                 (Modified to work with CCS PCH, by CCS)
....................  *
....................  *********************************************************************
....................  * FileName:        ARP.h
....................  * Dependencies:    Stacktsk.h
....................  *                  MAC.h
....................  * Processor:       PIC18
....................  * Complier:        CCS PCH 3.181 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * The software supplied herewith by Microchip Technology Incorporated
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and
....................  * supplied to you, the Company’s customer, for use solely and
....................  * exclusively on Microchip PICmicro Microcontroller products. The
....................  * software is owned by the Company and/or its supplier, and is
....................  * protected under applicable copyright laws. All rights are reserved.
....................  * Any use in violation of the foregoing restrictions may subject the
....................  * user to criminal sanctions under applicable laws, as well as to
....................  * civil liability for the breach of the terms and conditions of this
....................  * license.
....................  *
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
....................  *
....................  * Author               Date     Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0)
....................  * Nilesh Rajbharti     2/9/02   Cleanup
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail)
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/
.................... #ifndef ARP_H
.................... #define ARP_H
.................... 
.................... #include "tcpip/stacktsk.h"
.................... #include "tcpip/mac.h"
.................... 
.................... /*
....................  * Following codes are must be used with ARPGet/Put functions.
....................  */
.................... #define ARP_REPLY       (0x00)
.................... #define ARP_REQUEST     (0x01)
.................... #define ARP_UNKNOWN     (0x02)
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode);
.................... 
.................... 
.................... /*********************************************************************
....................  * Macro:           ARPIsRxReady()
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          TRUE if ARP receive buffer is full.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE)
.................... 
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    MACIsTxReady() == TRUE
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode);
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "tcpip/mac.h"
.................... /*********************************************************************
....................  *
....................  *                  MAC Module Defs for Microchip Stack
....................  *
....................  *********************************************************************
....................  * FileName:        MAC.h
....................  * Dependencies:    StackTsk.h
....................  * Processor:       PIC18C
....................  * Complier:        MCC18 v1.00.50 or higher
....................  *                  HITECH PICC-18 V8.10PL1 or higher
....................  * Company:         Microchip Technology, Inc.
....................  *
....................  * Software License Agreement
....................  *
....................  * This software is owned by Microchip Technology Inc. ("Microchip")
....................  * and is supplied to you for use exclusively as described in the
....................  * associated software agreement.  This software is protected by
....................  * software and other intellectual property laws.  Any use in
....................  * violation of the software license may subject the user to criminal
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip
....................  * Technology Inc.  All rights reserved.
....................  *
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,
....................  * incidental, or consequential damages.
....................  *
....................  * Author               Date        Comment
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0)
....................  * Nilesh Rajbharti     11/27/01    Added SLIP
....................  * Nilesh Rajbharti     2/9/02      Cleanup
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail)
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros
....................  * Darren Rook          7/11/06  CCS Port
....................  ********************************************************************/
.................... 
.................... #ifndef MAC_H
.................... #define MAC_H
.................... 
.................... #include "tcpip/StackTsk.h"
.................... 
.................... #define MAC_IP      (0u)
.................... #define MAC_ARP     (0x6u)
.................... #define MAC_UNKNOWN (0x0ffu)
.................... 
.................... #define INVALID_BUFFER  (0xffu)
.................... 
.................... /*
....................  * Microchip Ethernet controller specific MAC items
....................  */
.................... #if STACK_USE_MCPENC
.................... #include "tcpip/ENC28J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC
.................... #include "tcpip/ETH97J60.h"
.................... #endif
.................... 
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC
.................... 
.................... // Duplex configuration options
.................... typedef enum _DUPLEX {
....................    HALF = 0,
....................    FULL = 1,
....................    USE_PHY = 2
.................... } DUPLEX;
.................... 
.................... typedef enum _CLK_CONFIG {
....................    Divide1,
....................    Divide2,
....................    Divide3,
....................    Divide4,
....................    Divide8
.................... } CLK_CONFIG;
.................... void   MACSetDuplex(DUPLEX DuplexState);
.................... WORD    CalcIPBufferChecksum(WORD len);
.................... 
.................... void   MACPowerDown(void);
.................... void    MACPowerUp(void);
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len);
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len);
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len);
.................... void   WritePHYReg(BYTE Register, WORD Data);
.................... PHYREG   ReadPHYReg(BYTE Register);
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr);
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           void SetLEDConfig(WORD NewConfig)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled
....................  *                        xxx2: Pulse stretch to 40ms (default)
....................  *                        xxx6: Pulse stretch to 73ms
....................  *                        xxxA: Pulse stretch to 139ms
....................  *
....................  *                        xx1x: LEDB - TX
....................  *                        xx2x: LEDB - RX (default)
....................  *                        xx3x: LEDB - collisions
....................  *                        xx4x: LEDB - link
....................  *                        xx5x: LEDB - duplex
....................  *                        xx7x: LEDB - TX and RX
....................  *                        xx8x: LEDB - on
....................  *                        xx9x: LEDB - off
....................  *                        xxAx: LEDB - blink fast
....................  *                        xxBx: LEDB - blink slow
....................  *                        xxCx: LEDB - link and RX
....................  *                        xxDx: LEDB - link and TX and RX
....................  *                        xxEx: LEDB - duplex and collisions
....................  *
....................  *                        x1xx: LEDA - TX
....................  *                        x2xx: LEDA - RX
....................  *                        x3xx: LEDA - collisions
....................  *                        x4xx: LEDA - link (default)
....................  *                        x5xx: LEDA - duplex
....................  *                        x7xx: LEDA - TX and RX
....................  *                        x8xx: LEDA - on
....................  *                        x9xx: LEDA - off
....................  *                        xAxx: LEDA - blink fast
....................  *                        xBxx: LEDA - blink slow
....................  *                        xCxx: LEDA - link and RX
....................  *                        xDxx: LEDA - link and TX and RX
....................  *                        xExx: LEDA - duplex and collisions
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register.
....................  *               The LED pins will beginning outputting the new
....................  *               configuration immediately.
....................  *
....................  * Note:
....................  *****************************************************************************/
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig)
.................... 
.................... 
.................... /******************************************************************************
....................  * Macro:           WORD GetLEDConfig(void)
....................  *
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()).
....................  *
....................  * Input:           None
....................  *
....................  * Output:          WORD -   xxx0: Pulse stretching disabled
....................  *                     xxx2: Pulse stretch to 40ms (default)
....................  *                     xxx6: Pulse stretch to 73ms
....................  *                     xxxA: Pulse stretch to 139ms
....................  *
....................  *                     xx1x: LEDB - TX
....................  *                     xx2x: LEDB - RX (default)
....................  *                     xx3x: LEDB - collisions
....................  *                     xx4x: LEDB - link
....................  *                     xx5x: LEDB - duplex
....................  *                     xx7x: LEDB - TX and RX
....................  *                     xx8x: LEDB - on
....................  *                     xx9x: LEDB - off
....................  *                     xxAx: LEDB - blink fast
....................  *                     xxBx: LEDB - blink slow
....................  *                     xxCx: LEDB - link and RX
....................  *                     xxDx: LEDB - link and TX and RX
....................  *                     xxEx: LEDB - duplex and collisions
....................  *
....................  *                      x1xx: LEDA - TX
....................  *                     x2xx: LEDA - RX
....................  *                     x3xx: LEDA - collisions
....................  *                     x4xx: LEDA - link (default)
....................  *                     x5xx: LEDA - duplex
....................  *                     x7xx: LEDA - TX and RX
....................  *                     x8xx: LEDA - on
....................  *                     x9xx: LEDA - off
....................  *                     xAxx: LEDA - blink fast
....................  *                     xBxx: LEDA - blink slow
....................  *                     xCxx: LEDA - link and RX
....................  *                     xDxx: LEDA - link and TX and RX
....................  *                     xExx: LEDA - duplex and collisions
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        Returns the current value of the PHLCON register.
....................  *
....................  * Note:            None
....................  *****************************************************************************/
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val
.................... 
.................... #endif
.................... 
.................... 
.................... void    MACInit(void);
.................... BOOL   MACIsLinked(void);
.................... 
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type);
.................... void    MACSetRxBuffer(WORD offset);
.................... BYTE    MACGet(void);
.................... WORD    MACGetArray(BYTE *val, WORD len);
.................... void    MACDiscardRx(void);
.................... WORD    MACGetFreeRxSize(void);
.................... 
.................... void    MACPutHeader(MAC_ADDR *remote,
....................                      BYTE type,
....................                      WORD dataLen);
.................... BOOL    MACIsTxReady(BOOL HighPriority);
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset);
.................... void    MACPut(BYTE val);
.................... void    MACPutArray(BYTE *val, WORD len);
.................... void    MACDiscardTx(BUFFER buffer);
.................... void    MACFlush(void);
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority);
.................... 
.................... 
.................... /* extern */ BUFFER CurrentTxBuffer;
.................... 
.................... #if STACK_USE_SLIP
.................... #define NICCurrentTxBuffer      (0)
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define debug_arp
.................... //#define debug_arp debug_printf
.................... 
.................... // ARP Operation codes.
.................... #define ARP_OPERATION_REQ       0x01u
.................... #define ARP_OPERATION_RESP      0x02u
.................... 
.................... // ETHERNET packet type as defined by IEEE 802.3
.................... #define HW_ETHERNET             (0x0001u)
.................... #define ARP_IP                  (0x0800u)
.................... 
.................... 
.................... 
.................... // ARP packet
.................... typedef struct _ARP_PACKET
.................... {
....................     WORD        HardwareType;
....................     WORD        Protocol;
....................     BYTE        MACAddrLen;
....................     BYTE        ProtocolLen;
....................     WORD        Operation;
....................     MAC_ADDR    SenderMACAddr;
....................     IP_ADDR     SenderIPAddr;
....................     MAC_ADDR    TargetMACAddr;
....................     IP_ADDR     TargetIPAddr;
.................... } ARP_PACKET;
.................... 
.................... // Helper function
.................... static void SwapARPPacket(ARP_PACKET *p);
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode)
....................  *
....................  * PreCondition:    ARP packet is ready in MAC buffer.
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - Buffer to hold ARP op code.
....................  *
....................  * Output:          TRUE if a valid ARP packet was received.
....................  *                  FALSE otherwise.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode)
.................... {
....................     ARP_PACKET packet;
.................... 
....................     //MACGetArray((int8*)&packet, sizeof(packet));
....................     MACGetArray(&packet, sizeof(ARP_PACKET));
*
1440:  MOVLW  02
1442:  MOVLB  3
1444:  MOVWF  x7E
1446:  MOVLW  F5
1448:  MOVWF  x7D
144A:  CLRF   x80
144C:  MOVLW  1C
144E:  MOVWF  x7F
1450:  MOVLB  0
1452:  RCALL  11D0
.................... 
....................     MACDiscardRx();
1454:  RCALL  1164
.................... 
....................     SwapARPPacket(&packet);
1456:  MOVLW  02
1458:  MOVLB  3
145A:  MOVWF  x12
145C:  MOVLW  F5
145E:  MOVWF  x11
1460:  MOVLB  0
1462:  RCALL  138A
.................... 
....................    //debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U",
....................      // packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen,
....................      // packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1],
....................      // packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3],
....................      // packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]);
.................... 
....................     if ( packet.HardwareType != HW_ETHERNET     ||
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  ||
....................          packet.ProtocolLen != sizeof(IP_ADDR) )
1464:  MOVLB  2
1466:  DECFSZ xF5,W
1468:  BRA    147A
146A:  MOVF   xF6,F
146C:  BNZ   147A
146E:  MOVF   xF9,W
1470:  SUBLW  06
1472:  BNZ   147A
1474:  MOVF   xFA,W
1476:  SUBLW  04
1478:  BZ    1480
....................          return FALSE;
147A:  MOVLW  00
147C:  MOVWF  01
147E:  BRA    1522
.................... 
....................     if ( packet.Operation == ARP_OPERATION_RESP )
1480:  MOVF   xFB,W
1482:  SUBLW  02
1484:  BNZ   1496
1486:  MOVF   xFC,F
1488:  BNZ   1496
....................         *opCode = ARP_REPLY;
148A:  MOVFF  2F4,FEA
148E:  MOVFF  2F3,FE9
1492:  CLRF   FEF
1494:  BRA    14BE
....................     else if ( packet.Operation == ARP_OPERATION_REQ )
1496:  DECFSZ xFB,W
1498:  BRA    14AC
149A:  MOVF   xFC,F
149C:  BNZ   14AC
....................         *opCode = ARP_REQUEST;
149E:  MOVFF  2F4,FEA
14A2:  MOVFF  2F3,FE9
14A6:  MOVLW  01
14A8:  MOVWF  FEF
14AA:  BRA    14BE
....................     else
....................     {
....................         *opCode = ARP_UNKNOWN;
14AC:  MOVFF  2F4,FEA
14B0:  MOVFF  2F3,FE9
14B4:  MOVLW  02
14B6:  MOVWF  FEF
....................         return FALSE;
14B8:  MOVLW  00
14BA:  MOVWF  01
14BC:  BRA    1522
....................     }
.................... 
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val)
14BE:  MOVF   1D,W
14C0:  MOVLB  3
14C2:  SUBWF  x0D,W
14C4:  BNZ   151C
14C6:  MOVF   1E,W
14C8:  SUBWF  x0E,W
14CA:  BNZ   151C
14CC:  MOVF   1F,W
14CE:  SUBWF  x0F,W
14D0:  BNZ   151C
14D2:  MOVF   20,W
14D4:  SUBWF  x10,W
14D6:  BNZ   151C
....................     {
....................         remote->MACAddr     = packet.SenderMACAddr;
14D8:  MOVLB  2
14DA:  MOVFF  2F1,FE9
14DE:  MOVFF  2F2,FEA
14E2:  MOVLW  02
14E4:  MOVWF  FE2
14E6:  MOVLW  FD
14E8:  MOVWF  FE1
14EA:  MOVLW  06
14EC:  MOVWF  01
14EE:  MOVFF  FE6,FEE
14F2:  DECFSZ 01,F
14F4:  BRA    14EE
....................         remote->IPAddr      = packet.SenderIPAddr;
14F6:  MOVLW  06
14F8:  ADDWF  xF1,W
14FA:  MOVWF  FE9
14FC:  MOVLW  00
14FE:  ADDWFC xF2,W
1500:  MOVWF  FEA
1502:  MOVFF  303,FEF
1506:  MOVFF  304,FEC
150A:  MOVFF  305,FEC
150E:  MOVFF  306,FEC
....................         return TRUE;
1512:  MOVLW  01
1514:  MOVWF  01
1516:  BRA    1522
....................     }
1518:  BRA    1522
151A:  MOVLB  3
....................     else
....................         return FALSE;
151C:  MOVLW  00
151E:  MOVWF  01
1520:  MOVLB  2
1522:  MOVLB  0
1524:  GOTO   1AE2 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           remote  - Remote node info
....................  *                  opCode  - ARP op code to send
....................  *
....................  * Output:          TRUE - The ARP packet was generated properly
....................  *               FALSE - Unable to allocate a TX buffer
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode)
.................... {
....................     ARP_PACKET packet;
.................... 
....................    BUFFER MyTxBuffer;
....................    MyTxBuffer = MACGetTxBuffer(TRUE);
*
1946:  MOVLW  01
1948:  MOVLB  3
194A:  MOVWF  x6F
194C:  MOVLB  0
194E:  RCALL  1528
1950:  MOVFF  01,310
....................    
....................    // Do not respond if there is no room to generate the ARP reply
....................    if(MyTxBuffer == INVALID_BUFFER)
1954:  MOVLB  3
1956:  INCFSZ x10,W
1958:  BRA    1960
....................       return FALSE;
195A:  MOVLW  00
195C:  MOVWF  01
195E:  BRA    1ABA
.................... 
....................    MACSetTxBuffer(MyTxBuffer, 0);
1960:  MOVFF  310,388
1964:  CLRF   x8A
1966:  CLRF   x89
1968:  MOVLB  0
196A:  RCALL  1550
....................    
....................    
....................     packet.HardwareType             = HW_ETHERNET;
196C:  MOVLB  2
196E:  CLRF   xF5
1970:  MOVLW  01
1972:  MOVWF  xF4
....................     packet.Protocol                 = ARP_IP;
1974:  MOVLW  08
1976:  MOVWF  xF7
1978:  CLRF   xF6
....................     packet.MACAddrLen               = sizeof(MAC_ADDR);
197A:  MOVLW  06
197C:  MOVWF  xF8
....................     packet.ProtocolLen              = sizeof(IP_ADDR);
197E:  MOVLW  04
1980:  MOVWF  xF9
.................... 
....................     if ( opCode == ARP_REQUEST )
1982:  DECFSZ xF3,W
1984:  BRA    199E
....................     {
....................         packet.Operation            = ARP_OPERATION_REQ;
1986:  CLRF   xFB
1988:  MOVLW  01
198A:  MOVWF  xFA
....................         packet.TargetMACAddr.v[0]   = 0xff;
198C:  MOVLB  3
198E:  SETF   x06
....................         packet.TargetMACAddr.v[1]   = 0xff;
1990:  SETF   x07
....................         packet.TargetMACAddr.v[2]   = 0xff;
1992:  SETF   x08
....................         packet.TargetMACAddr.v[3]   = 0xff;
1994:  SETF   x09
....................         packet.TargetMACAddr.v[4]   = 0xff;
1996:  SETF   x0A
....................         packet.TargetMACAddr.v[5]   = 0xff;
1998:  SETF   x0B
....................     }
199A:  BRA    19C0
199C:  MOVLB  2
....................     else
....................     {
....................         packet.Operation            = ARP_OPERATION_RESP;
199E:  CLRF   xFB
19A0:  MOVLW  02
19A2:  MOVWF  xFA
....................         packet.TargetMACAddr        = remote->MACAddr;
19A4:  MOVFF  2F1,FE1
19A8:  MOVFF  2F2,FE2
19AC:  MOVLW  03
19AE:  MOVWF  FEA
19B0:  MOVLW  06
19B2:  MOVWF  FE9
19B4:  MOVWF  01
19B6:  MOVFF  FE6,FEE
19BA:  DECFSZ 01,F
19BC:  BRA    19B6
19BE:  MOVLB  3
....................     }
.................... 
....................     packet.SenderMACAddr = AppConfig.MyMACAddr;
19C0:  MOVLW  02
19C2:  MOVWF  FEA
19C4:  MOVLW  FC
19C6:  MOVWF  FE9
19C8:  CLRF   FE2
19CA:  MOVLW  21
19CC:  MOVWF  FE1
19CE:  MOVLW  06
19D0:  MOVWF  01
19D2:  MOVFF  FE6,FEE
19D6:  DECFSZ 01,F
19D8:  BRA    19D2
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr;
19DA:  MOVFF  20,305
19DE:  MOVFF  1F,304
19E2:  MOVFF  1E,303
19E6:  MOVFF  1D,302
.................... 
.................... 
....................     // Check to see if target is on same subnet, if not, find Gateway MAC.
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway.
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val)
19EA:  MOVLW  06
19EC:  MOVLB  2
19EE:  ADDWF  xF1,W
19F0:  MOVWF  FE9
19F2:  MOVLW  00
19F4:  ADDWFC xF2,W
19F6:  MOVWF  FEA
19F8:  MOVFF  FEF,00
19FC:  MOVFF  FEC,01
1A00:  MOVFF  FEC,02
1A04:  MOVFF  FEC,03
1A08:  MOVF   00,W
1A0A:  MOVLB  3
1A0C:  XORWF  x02,W
1A0E:  MOVWF  x11
1A10:  MOVF   01,W
1A12:  XORWF  x03,W
1A14:  MOVWF  x12
1A16:  MOVF   02,W
1A18:  XORWF  x04,W
1A1A:  MOVWF  x13
1A1C:  MOVF   03,W
1A1E:  XORWF  x05,W
1A20:  MOVWF  x14
1A22:  MOVF   x11,W
1A24:  ANDWF  27,W
1A26:  MOVWF  00
1A28:  MOVF   x12,W
1A2A:  ANDWF  28,W
1A2C:  MOVWF  01
1A2E:  MOVF   x13,W
1A30:  ANDWF  29,W
1A32:  MOVWF  02
1A34:  MOVF   x14,W
1A36:  ANDWF  2A,W
1A38:  MOVWF  03
1A3A:  MOVF   00,F
1A3C:  BNZ   1A4A
1A3E:  MOVF   01,F
1A40:  BNZ   1A4A
1A42:  MOVF   02,F
1A44:  BNZ   1A4A
1A46:  MOVF   03,F
1A48:  BZ    1A5C
....................     {
....................       packet.TargetIPAddr = AppConfig.MyGateway;
1A4A:  MOVFF  2E,30F
1A4E:  MOVFF  2D,30E
1A52:  MOVFF  2C,30D
1A56:  MOVFF  2B,30C
....................     }
1A5A:  BRA    1A7C
....................     else
....................         packet.TargetIPAddr             = remote->IPAddr;
1A5C:  MOVLW  06
1A5E:  MOVLB  2
1A60:  ADDWF  xF1,W
1A62:  MOVWF  FE9
1A64:  MOVLW  00
1A66:  ADDWFC xF2,W
1A68:  MOVWF  FEA
1A6A:  MOVFF  FEF,30C
1A6E:  MOVFF  FEC,30D
1A72:  MOVFF  FEC,30E
1A76:  MOVFF  FEC,30F
1A7A:  MOVLB  3
.................... 
....................     SwapARPPacket(&packet);
1A7C:  MOVLW  02
1A7E:  MOVWF  x12
1A80:  MOVLW  F4
1A82:  MOVWF  x11
1A84:  MOVLB  0
1A86:  RCALL  138A
.................... 
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet));
1A88:  MOVLW  03
1A8A:  MOVLB  3
1A8C:  MOVWF  x8D
1A8E:  MOVLW  06
1A90:  MOVWF  x8C
1A92:  MOVWF  x8E
1A94:  CLRF   x90
1A96:  MOVLW  1C
1A98:  MOVWF  x8F
1A9A:  MOVLB  0
1A9C:  RCALL  1652
.................... 
....................     //MACPutArray((int8*)&packet, sizeof(packet));
....................     MACPutArray(&packet, sizeof(ARP_PACKET));
1A9E:  MOVLW  02
1AA0:  MOVLB  3
1AA2:  MOVWF  x94
1AA4:  MOVLW  F4
1AA6:  MOVWF  x93
1AA8:  CLRF   x96
1AAA:  MOVLW  1C
1AAC:  MOVWF  x95
1AAE:  MOVLB  0
1AB0:  RCALL  160C
.................... 
....................     MACFlush();
1AB2:  RCALL  171A
....................    
....................    return TRUE;
1AB4:  MOVLW  01
1AB6:  MOVWF  01
1AB8:  MOVLB  3
1ABA:  MOVLB  0
1ABC:  GOTO   1B38 (RETURN)
.................... }
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           p   - ARP packet to be swapped.
....................  *
....................  * Output:          None
....................  *
....................  * Side Effects:    None
....................  *
....................  * Overview:        None
....................  *
....................  * Note:            None
....................  ********************************************************************/
.................... static void SwapARPPacket(ARP_PACKET *p)
.................... {
....................     p->HardwareType     = swaps(p->HardwareType);
*
138A:  MOVFF  311,01
138E:  MOVFF  312,314
1392:  MOVFF  01,313
1396:  MOVFF  311,FE9
139A:  MOVFF  312,FEA
139E:  MOVFF  FEC,38F
13A2:  MOVF   FED,F
13A4:  MOVFF  FEF,38E
13A8:  MOVLB  0
13AA:  RCALL  1230
13AC:  MOVFF  314,FEA
13B0:  MOVFF  313,FE9
13B4:  MOVFF  02,FEC
13B8:  MOVF   FED,F
13BA:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol);
13BE:  MOVLW  02
13C0:  MOVLB  3
13C2:  ADDWF  x11,W
13C4:  MOVWF  01
13C6:  MOVLW  00
13C8:  ADDWFC x12,W
13CA:  MOVWF  03
13CC:  MOVFF  01,313
13D0:  MOVWF  x14
13D2:  MOVLW  02
13D4:  ADDWF  x11,W
13D6:  MOVWF  FE9
13D8:  MOVLW  00
13DA:  ADDWFC x12,W
13DC:  MOVWF  FEA
13DE:  MOVFF  FEC,38F
13E2:  MOVF   FED,F
13E4:  MOVFF  FEF,38E
13E8:  MOVLB  0
13EA:  RCALL  1230
13EC:  MOVFF  314,FEA
13F0:  MOVFF  313,FE9
13F4:  MOVFF  02,FEC
13F8:  MOVF   FED,F
13FA:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation);
13FE:  MOVLW  06
1400:  MOVLB  3
1402:  ADDWF  x11,W
1404:  MOVWF  01
1406:  MOVLW  00
1408:  ADDWFC x12,W
140A:  MOVWF  03
140C:  MOVFF  01,313
1410:  MOVWF  x14
1412:  MOVLW  06
1414:  ADDWF  x11,W
1416:  MOVWF  FE9
1418:  MOVLW  00
141A:  ADDWFC x12,W
141C:  MOVWF  FEA
141E:  MOVFF  FEC,38F
1422:  MOVF   FED,F
1424:  MOVFF  FEF,38E
1428:  MOVLB  0
142A:  RCALL  1230
142C:  MOVFF  314,FEA
1430:  MOVFF  313,FE9
1434:  MOVFF  02,FEC
1438:  MOVF   FED,F
143A:  MOVFF  01,FEF
143E:  RETURN 0
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    #include "tcpip/http.c"
.................... //////////////////////////////////////////////////////////////////////////////
.................... ///
.................... ///                              HTTP.C
.................... ///
.................... /// Simple webserver for the Microchip TCP/IP stack.
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES
.................... ///
.................... /// **** CONFIGURATION ****
.................... ///
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c
.................... ///        in your application.  Defining this to be true will cause
.................... ///        the stack to include the HTTP portion and execute the init
.................... ///        and process any HTTP tasks.
.................... ///
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP
.................... ///        connections.
.................... ///
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the
.................... ///        HTTP server.  You probably will be fine with just 1.  The
.................... ///        more sockets you use the more RAM is used to hold buffers
.................... ///        and state configuration.
.................... ///
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several
.................... ///        buffers.  This limits the size of your GET or POST requests
.................... ///        and all CGI POST data:
.................... ///            If using GET, then max amount of cgi data is this value
.................... ///            minus everything else on the initial GET command (which
.................... ///            also includes the filename).  I believe the max specified
.................... ///            by W3C is 255.
.................... ///            If using POST, then this is the maximum size for one
.................... ///            key=value pair (including the '=' sign).
.................... ///        These values do not inlude any escape characters.
.................... ///
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE.
.................... ///
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have
.................... ///      two escape characters after the %.  An example of each:
.................... ///         If FALSE: %A
.................... ///         If TRUE: %0A
.................... ///
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third
.................... ///      parameter which is the content-type of the requested page.
.................... ///
.................... /// **** HOW IT WORKS ****
.................... ///
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will
.................... /// then listen for GET or POST requests.  When it gets a GET or POST
.................... /// request it passes the page request to the callback function
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or
.................... /// a pointer to the constant memory area that holds the page in program
.................... /// memory.  If it was a POST request it waits until the HTTP header is
.................... /// done and then saves the POST data into a buffer, and passes the
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will
.................... /// parse the CGI post data and act upon it.  When done, the HTTP
.................... /// server then responds by sending the page.  If the page is to have
.................... /// variable data, it can be represented by an escape code - %0 or %1
.................... /// for example.  When the HTTP stack sees such an escape code it calls
.................... /// the callback function http_format_char() to format the escape code
.................... /// into the needed variable data (such as ADC readings).  After the
.................... /// HTTP stack is done sending the request it will close the port.
.................... /// If the page didn't exist in program memory it will send a 404 File
.................... /// not found error.  If there was a problem/timeout parsing the request
.................... /// the HTTP stack will send a 500 Internal Server Error response.
.................... ///
.................... /// **** CALL BACK FUNCTIONS ****
.................... ///
.................... /// Your main application must provide the following callback functions to
.................... /// fill application dependent needs:
.................... ///
.................... /// http_get_page(char *file);
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else,
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph.
.................... ///    A call-back function provided by your application that finds the
.................... ///    required file.  If the file exists, returns address to page in
.................... ///    program memory.  If it doesn't exist, returns 0.
.................... ///
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else,
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph.
.................... ///    A call-back function provided by your application that finds the
.................... ///    required file.  If the file exists, saves value to retAddress.  If
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the
.................... ///    content-type (text/html, text/xml, etc).
.................... ///
.................... /// http_exec_cgi(int32 file, char *key, char *val);
.................... ///    A call-back function provided by your application that processes incoming
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is
.................... ///    the file address as returned by http_get_page().
.................... ///
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... ///    Given an escaped character in the program memory HTTP file, convert to
.................... ///    variable data.  id is the escaped character, *str is where to save the
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str.
.................... ///    Returns the number of bytes written to *str.  file is
.................... ///    the file address as returned by http_get_page().
.................... ///
.................... /// **** LIMITATIONS ****
.................... ///
.................... /// When creating web pages with forms, keep your form names (keys) simple
.................... /// because the HTTP stack does not format the escape characters.  For example,
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord".
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving
.................... /// the value, but not the key.  Therefore keep your keys simple.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// * Author         Date           Comment
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.................... ///
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST
.................... ///
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix
.................... ///                                 many bugs.  The biggest bug is that
.................... ///                                 it can send pages and receive CGI that
.................... ///                                 is larger than 1 TCP packet.  Also
.................... ///                                 added the HTTP_USE_CHUNKS,
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #include "tcpip/http.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ///                                                                     ///
.................... ///                              HTTP.H                                 ///
.................... ///                                                                     ///
.................... /// Simple webserver for the Microchip TCP/IP stack.                    ///
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       ///
.................... ///                                                                     ///
.................... /// See HTTP.C for documenation                                         ///
.................... ///                                                                     ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef HTTP_USE_CHUNKS
.................... #define HTTP_USE_CHUNKS   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_USE_CONTENT_TYPE
.................... #define HTTP_USE_CONTENT_TYPE   FALSE
.................... #endif
.................... 
.................... #ifndef HTTP_PORT
.................... #define HTTP_PORT             80
.................... #endif
.................... 
.................... #ifndef HTTP_NUM_SOCKETS
.................... #define HTTP_NUM_SOCKETS      1
.................... #endif
.................... 
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE
.................... #define HTTP_GET_PARAM_MAX_SIZE  254
.................... #endif
.................... 
.................... void HTTP_Init(void);
.................... void HTTP_Task(void);
.................... 
.................... //**** CALLBACKS START ******///
.................... 
.................... /// the following three functions are callbacks and
.................... /// must be written in your main application!!!  see the documentation above
.................... /// for more help.
.................... 
.................... #if HTTP_USE_CONTENT_TYPE
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr);
.................... #else
....................  int32 http_get_page(char *file_str);
.................... #endif
.................... 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret);
.................... void http_exec_cgi(int32 file, char *key, char *val);
.................... 
.................... //**** CALLBACKS END ******///
.................... 
.................... 
.................... //#define debug_http   debug_printf
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u)
.................... 
.................... const char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>";
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>";
.................... 
.................... //key=val pair string, & delimited
.................... void http_parse_cgi_str(int32 file, char *cgistr);
.................... 
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET};
.................... 
.................... enum {
....................    HTTP_DISABLED = 0xFF,
....................    HTTP_IGNORE,
....................    HTTP_LISTEN_WAIT,
....................    HTTP_CONNECTED,
....................    HTTP_GET_HEADERS,
....................    HTTP_GET_POST,
....................    HTTP_GET_POST_CONTINUE,
....................    HTTP_SEND_RESPONSE,
....................    HTTP_SEND_RESPONSE_CONTINUE,
....................    HTTP_CLOSE,
....................    HTTP_CLOSE_WAITING,
....................    HTTP_CLOSED
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE};
.................... 
.................... //strips out any escape characters that the HTTP client may have inserted.
.................... // (+ is replaced with space)
.................... // (%xx is replaced with character representation of xx)
.................... char * http_escape_chars(char *str)
.................... {
....................    char *ostr;
....................    char new[3];
....................    char c;
....................    char val;
.................... 
....................    new[2]=0;
*
46BE:  MOVLB  3
46C0:  CLRF   x07
.................... 
....................    ostr = str;
46C2:  MOVFF  302,304
46C6:  MOVFF  301,303
.................... 
....................    while((c=*str) != 0)
46CA:  MOVFF  302,FEA
46CE:  MOVFF  301,FE9
46D2:  MOVFF  FEF,308
46D6:  MOVF   x08,F
46D8:  BZ    4792
....................    {
....................       if (c=='+')
46DA:  MOVF   x08,W
46DC:  SUBLW  2B
46DE:  BNZ   46F4
....................          *str++=' ';
46E0:  MOVFF  302,FEA
46E4:  MOVF   x01,W
46E6:  INCF   x01,F
46E8:  BTFSC  FD8.2
46EA:  INCF   x02,F
46EC:  MOVWF  FE9
46EE:  MOVLW  20
46F0:  MOVWF  FEF
46F2:  BRA    478E
....................       else if (c=='%')
46F4:  MOVF   x08,W
46F6:  SUBLW  25
46F8:  BNZ   4788
....................       {
....................          memcpy(new, str + 1, 2);
46FA:  MOVLW  01
46FC:  ADDWF  x01,W
46FE:  MOVWF  x0A
4700:  MOVLW  00
4702:  ADDWFC x02,W
4704:  MOVWF  FE2
4706:  MOVFF  30A,FE1
470A:  MOVFF  FE6,305
470E:  MOVFF  FE6,306
....................          val = strtoul(new, 0, 16);
4712:  MOVLW  03
4714:  MOVWF  x0B
4716:  MOVLW  05
4718:  MOVWF  x0A
471A:  CLRF   x0D
471C:  CLRF   x0C
471E:  MOVLW  10
4720:  MOVWF  x0E
4722:  MOVLB  0
4724:  BRA    41FE
4726:  MOVFF  01,309
....................          *str++ = val;
472A:  MOVLB  3
472C:  MOVFF  302,FEA
4730:  MOVF   x01,W
4732:  INCF   x01,F
4734:  BTFSC  FD8.2
4736:  INCF   x02,F
4738:  MOVWF  FE9
473A:  MOVFF  309,FEF
....................          memmove(str, str + 2, strlen(str) - 1);
473E:  MOVLW  02
4740:  ADDWF  x01,W
4742:  MOVWF  x0A
4744:  MOVLW  00
4746:  ADDWFC x02,W
4748:  MOVWF  x0B
474A:  MOVFF  302,31E
474E:  MOVFF  301,31D
4752:  MOVLB  0
4754:  RCALL  4050
4756:  MOVFF  02,30D
475A:  MOVFF  01,30C
475E:  MOVLW  01
4760:  MOVLB  3
4762:  SUBWF  x0C,F
4764:  MOVLW  00
4766:  SUBWFB x0D,F
4768:  MOVFF  302,30F
476C:  MOVFF  301,30E
4770:  MOVFF  30B,311
4774:  MOVFF  30A,310
4778:  MOVFF  30D,313
477C:  MOVFF  30C,312
4780:  MOVLB  0
4782:  BRA    45E0
....................       }
4784:  BRA    478E
4786:  MOVLB  3
....................       else
....................          str++;
4788:  INCF   x01,F
478A:  BTFSC  FD8.2
478C:  INCF   x02,F
478E:  MOVLB  3
4790:  BRA    46CA
....................    }
.................... 
....................    return(ostr);
4792:  MOVFF  303,01
4796:  MOVFF  304,02
479A:  MOVLB  0
479C:  RETURN 0
.................... }
.................... 
.................... void http_parse_cgi_string(int32 file, char *ptr)
.................... {
....................    char *pKey, *pValue, c;
.................... 
....................    pKey=ptr;
*
4CB2:  MOVFF  2FB,2FD
4CB6:  MOVFF  2FA,2FC
....................    pValue=0;
4CBA:  MOVLB  2
4CBC:  CLRF   xFF
4CBE:  CLRF   xFE
.................... 
....................    while(TRUE)
....................    {
....................       c = *ptr;
4CC0:  MOVFF  2FB,FEA
4CC4:  MOVFF  2FA,FE9
4CC8:  MOVFF  FEF,300
....................       if ((c=='&') || (c==0))
4CCC:  MOVLB  3
4CCE:  MOVF   x00,W
4CD0:  SUBLW  26
4CD2:  BZ    4CD8
4CD4:  MOVF   x00,F
4CD6:  BNZ   4D38
....................       {
....................          *ptr=0;
4CD8:  MOVFF  2FB,FEA
4CDC:  MOVLB  2
4CDE:  MOVFF  2FA,FE9
4CE2:  CLRF   FEF
....................          http_escape_chars(pKey);
4CE4:  MOVFF  2FD,302
4CE8:  MOVFF  2FC,301
4CEC:  MOVLB  0
4CEE:  RCALL  46BE
....................          http_escape_chars(pValue);
4CF0:  MOVFF  2FF,302
4CF4:  MOVFF  2FE,301
4CF8:  RCALL  46BE
....................          http_exec_cgi(file, pKey, pValue);
4CFA:  MOVFF  2F9,304
4CFE:  MOVFF  2F8,303
4D02:  MOVFF  2F7,302
4D06:  MOVFF  2F6,301
4D0A:  MOVFF  2FD,306
4D0E:  MOVFF  2FC,305
4D12:  MOVFF  2FF,308
4D16:  MOVFF  2FE,307
4D1A:  BRA    4B8C
....................          pKey=ptr+1;
4D1C:  MOVLW  01
4D1E:  MOVLB  2
4D20:  ADDWF  xFA,W
4D22:  MOVWF  xFC
4D24:  MOVLW  00
4D26:  ADDWFC xFB,W
4D28:  MOVWF  xFD
....................          pValue=0;
4D2A:  CLRF   xFF
4D2C:  CLRF   xFE
....................          if (c==0)
4D2E:  MOVLB  3
4D30:  MOVF   x00,F
4D32:  BNZ   4D36
....................             break;
4D34:  BRA    4D64
....................       }
4D36:  BRA    4D58
....................       else if (c=='=')
4D38:  MOVF   x00,W
4D3A:  SUBLW  3D
4D3C:  BNZ   4D58
....................       {
....................          *ptr=0;
4D3E:  MOVFF  2FB,FEA
4D42:  MOVLB  2
4D44:  MOVFF  2FA,FE9
4D48:  CLRF   FEF
....................          pValue=ptr+1;
4D4A:  MOVLW  01
4D4C:  ADDWF  xFA,W
4D4E:  MOVWF  xFE
4D50:  MOVLW  00
4D52:  ADDWFC xFB,W
4D54:  MOVWF  xFF
4D56:  MOVLB  3
....................       }
....................       ptr++;
4D58:  MOVLB  2
4D5A:  INCF   xFA,F
4D5C:  BTFSC  FD8.2
4D5E:  INCF   xFB,F
4D60:  BRA    4CC0
4D62:  MOVLB  3
....................    }
4D64:  MOVLB  0
4D66:  RETURN 0
.................... }
.................... 
.................... int8 _httpPutcSocket;
.................... 
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket)
.................... 
.................... void set_tcp_http_putc(int8 newSocket)
.................... {
....................    _httpPutcSocket=newSocket;
*
5084:  MOVFF  2FE,71
5088:  GOTO   5BA8 (RETURN)
.................... }
.................... 
.................... int tcp_http_putc(char c)
.................... {
....................    return(TCPPut(_httpPutcSocket,c));
*
535C:  MOVFF  71,31D
5360:  MOVFF  31C,31E
5364:  BRA    521A
5366:  MOVF   01,W
5368:  RETURN 0
.................... }
.................... 
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS];
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS];
.................... 
.................... #if HTTP_USE_CHUNKS
.................... void TCPPutFileChunkStart(int16 count)
.................... {
....................    printf(tcp_http_putc, "%04LX\r\n", count);
.................... }
.................... 
.................... void TCPPutFileChunkStop(void)
.................... {
....................    tcp_http_putc('\r');
....................    tcp_http_putc('\n');
.................... }
.................... #else
....................  #define TCPPutFileChunkStart(x)
....................  #define TCPPutFileChunkStop()
.................... #endif
.................... 
.................... typedef enum
.................... {
....................    TCP_PUT_CONST_EC_FINISH = 0,
....................    TCP_PUT_CONST_EC_CONTINUE,
....................    TCP_PUT_CONST_EC_ESCAPE
.................... } TCP_PUT_CONST_EC;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileVarChunk(ptr)
.................... //
.................... // send a chunked response from ram
.................... //
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated
.................... //          with the continue position before exit.
.................... //
.................... // Returns a status code:
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr)
.................... //because of a compiler error i had to make this double pointer an int16, when
.................... //it should be a char.
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr)
.................... {
....................    int16 txLeft, n;
....................    char *ptr, ec;
.................... 
....................    ptr=*retPtr;
*
55A6:  MOVFF  301,FEA
55AA:  MOVLB  3
55AC:  MOVFF  300,FE9
55B0:  MOVFF  FEC,307
55B4:  MOVF   FED,F
55B6:  MOVFF  FEF,306
.................... 
....................    n=strlen(ptr);
55BA:  MOVFF  307,31E
55BE:  MOVFF  306,31D
55C2:  MOVLB  0
55C4:  CALL   4050
55C8:  MOVFF  02,305
55CC:  MOVFF  01,304
.................... 
....................    if (!n)
55D0:  MOVLB  3
55D2:  MOVF   x04,W
55D4:  IORWF  x05,W
55D6:  BNZ   55DE
....................       return(TCP_PUT_CONST_EC_FINISH);
55D8:  MOVLW  00
55DA:  MOVWF  01
55DC:  BRA    565A
.................... 
....................    txLeft = tcp_http_tx_left();
55DE:  MOVFF  71,30C
55E2:  MOVLB  0
55E4:  RCALL  54AE
55E6:  MOVFF  02,303
55EA:  MOVFF  01,302
.................... 
....................   #if HTTP_USE_CHUNKS
....................    if (txLeft > 8)
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars
....................    else
....................       return(TCP_PUT_CONST_EC_CONTINUE);
....................   #else
....................    if (!txLeft)
55EE:  MOVLB  3
55F0:  MOVF   x02,W
55F2:  IORWF  x03,W
55F4:  BNZ   55FC
....................       return(TCP_PUT_CONST_EC_CONTINUE);
55F6:  MOVLW  01
55F8:  MOVWF  01
55FA:  BRA    565A
....................   #endif
.................... 
....................    if (n > txLeft)
55FC:  MOVF   x03,W
55FE:  SUBWF  x05,W
5600:  BNC   5610
5602:  BNZ   560A
5604:  MOVF   x04,W
5606:  SUBWF  x02,W
5608:  BC    5610
....................    {
....................       ec = TCP_PUT_CONST_EC_CONTINUE;
560A:  MOVLW  01
560C:  MOVWF  x08
....................    }
560E:  BRA    561A
....................    else
....................    {
....................       txLeft = n;
5610:  MOVFF  305,303
5614:  MOVFF  304,302
....................       ec = TCP_PUT_CONST_EC_FINISH;
5618:  CLRF   x08
....................    }
.................... 
....................    TCPPutFileChunkStart(txLeft);
.................... 
....................    while (txLeft--)
561A:  MOVFF  303,03
561E:  MOVF   x02,W
5620:  BTFSC  FD8.2
5622:  DECF   x03,F
5624:  DECF   x02,F
5626:  IORWF  03,W
5628:  BZ    5644
....................    {
....................       tcp_http_putc(*ptr++);
562A:  MOVFF  307,FEA
562E:  MOVF   x06,W
5630:  INCF   x06,F
5632:  BTFSC  FD8.2
5634:  INCF   x07,F
5636:  MOVWF  FE9
5638:  MOVFF  FEF,31C
563C:  MOVLB  0
563E:  RCALL  535C
5640:  MOVLB  3
5642:  BRA    561A
....................    }
.................... 
....................    TCPPutFileChunkStop();
.................... 
....................    *retPtr=ptr;
5644:  MOVFF  301,FEA
5648:  MOVFF  300,FE9
564C:  MOVFF  307,FEC
5650:  MOVF   FED,F
5652:  MOVFF  306,FEF
.................... 
....................    return(ec);
5656:  MOVFF  308,01
565A:  MOVLB  0
565C:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileParseConst(addy, n, doSend)
.................... //
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence,
.................... // n chars or an end of file
.................... //
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address
.................... //        will be updated for the next call.
.................... //
.................... // n - max number of chars to read from file.  will save the total number
.................... //    of chars passed to this pointer.
.................... //
.................... // doSend - if TRUE, then send data to TCP socket
.................... //
.................... // returns the last char read
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend)
*
567C:  MOVLB  3
567E:  CLRF   x14
5680:  CLRF   x13
5682:  BSF    x1B.0
.................... {
....................    char stopC, checkC;
....................    int16 fileSize = 0, max;
....................    int32 addy;
....................    int1 premature = TRUE;
.................... 
....................    max = *n;
5684:  MOVFF  30F,FEA
5688:  MOVFF  30E,FE9
568C:  MOVFF  FEC,316
5690:  MOVF   FED,F
5692:  MOVFF  FEF,315
....................    addy = *retAddy;
5696:  MOVFF  30D,FEA
569A:  MOVFF  30C,FE9
569E:  MOVFF  FEF,317
56A2:  MOVFF  FEC,318
56A6:  MOVFF  FEC,319
56AA:  MOVFF  FEC,31A
.................... 
....................    while (TRUE)
....................    {
....................       read_program_memory(addy++, &stopC, 1);
56AE:  MOVFF  31A,31F
56B2:  MOVFF  319,02
56B6:  MOVFF  318,01
56BA:  MOVFF  317,00
56BE:  MOVLW  01
56C0:  ADDWF  x17,F
56C2:  BTFSC  FD8.0
56C4:  INCF   x18,F
56C6:  BTFSC  FD8.2
56C8:  INCF   x19,F
56CA:  BTFSC  FD8.2
56CC:  INCF   x1A,F
56CE:  MOVFF  02,31E
56D2:  MOVFF  01,31D
56D6:  MOVFF  00,31C
56DA:  MOVFF  02,FF8
56DE:  MOVFF  01,FF7
56E2:  MOVFF  00,FF6
56E6:  MOVLW  03
56E8:  MOVWF  FEA
56EA:  MOVLW  11
56EC:  MOVWF  FE9
56EE:  CLRF   x21
56F0:  MOVLW  01
56F2:  MOVWF  x20
56F4:  MOVLB  0
56F6:  RCALL  565E
....................       if (stopC == '%')
56F8:  MOVLB  3
56FA:  MOVF   x11,W
56FC:  SUBLW  25
56FE:  BNZ   577E
....................       {
....................          read_program_memory(addy++, &checkC, 1);
5700:  MOVFF  31A,31F
5704:  MOVFF  319,02
5708:  MOVFF  318,01
570C:  MOVFF  317,00
5710:  MOVLW  01
5712:  ADDWF  x17,F
5714:  BTFSC  FD8.0
5716:  INCF   x18,F
5718:  BTFSC  FD8.2
571A:  INCF   x19,F
571C:  BTFSC  FD8.2
571E:  INCF   x1A,F
5720:  MOVFF  02,31E
5724:  MOVFF  01,31D
5728:  MOVFF  00,31C
572C:  MOVFF  02,FF8
5730:  MOVFF  01,FF7
5734:  MOVFF  00,FF6
5738:  MOVLW  03
573A:  MOVWF  FEA
573C:  MOVLW  12
573E:  MOVWF  FE9
5740:  CLRF   x21
5742:  MOVLW  01
5744:  MOVWF  x20
5746:  MOVLB  0
5748:  RCALL  565E
....................          if (checkC == '%')
574A:  MOVLB  3
574C:  MOVF   x12,W
574E:  SUBLW  25
5750:  BNZ   577A
....................          {
....................             if (fileSize < max)
5752:  MOVF   x14,W
5754:  SUBWF  x16,W
5756:  BNC   5776
5758:  BNZ   5760
575A:  MOVF   x15,W
575C:  SUBWF  x13,W
575E:  BC    5776
....................             {
....................                if (doSend)
5760:  MOVF   x10,F
5762:  BZ    576E
....................                   tcp_http_putc('%');
5764:  MOVLW  25
5766:  MOVWF  x1C
5768:  MOVLB  0
576A:  RCALL  535C
576C:  MOVLB  3
....................                fileSize++;
576E:  INCF   x13,F
5770:  BTFSC  FD8.2
5772:  INCF   x14,F
....................             }
5774:  BRA    5778
....................             else
....................                break;
5776:  BRA    57B0
....................          }
5778:  BRA    577C
....................          else
....................             break;   //ESCAPE
577A:  BRA    57B0
....................       }
577C:  BRA    57AE
....................       else if (stopC)
577E:  MOVF   x11,F
5780:  BZ    57AA
....................       {
....................          if (fileSize < max)
5782:  MOVF   x14,W
5784:  SUBWF  x16,W
5786:  BNC   57A6
5788:  BNZ   5790
578A:  MOVF   x15,W
578C:  SUBWF  x13,W
578E:  BC    57A6
....................          {
....................             if (doSend)
5790:  MOVF   x10,F
5792:  BZ    579E
....................                tcp_http_putc(stopC);
5794:  MOVFF  311,31C
5798:  MOVLB  0
579A:  RCALL  535C
579C:  MOVLB  3
....................             fileSize++;
579E:  INCF   x13,F
57A0:  BTFSC  FD8.2
57A2:  INCF   x14,F
....................          }
57A4:  BRA    57A8
....................          else
....................             break;
57A6:  BRA    57B0
....................       }
57A8:  BRA    57AE
....................       else
....................       {
....................          premature = FALSE;
57AA:  BCF    x1B.0
....................          break;   //EOF (stopC == 0)
57AC:  BRA    57B0
....................       }
57AE:  BRA    56AE
....................    }
.................... 
....................    if (premature)
57B0:  BTFSS  x1B.0
57B2:  BRA    57C4
....................       addy--;
57B4:  MOVLW  FF
57B6:  ADDWF  x17,F
57B8:  BTFSS  FD8.0
57BA:  ADDWF  x18,F
57BC:  BTFSS  FD8.0
57BE:  ADDWF  x19,F
57C0:  BTFSS  FD8.0
57C2:  ADDWF  x1A,F
.................... 
....................    *n = fileSize;
57C4:  MOVFF  30F,FEA
57C8:  MOVFF  30E,FE9
57CC:  MOVFF  314,FEC
57D0:  MOVF   FED,F
57D2:  MOVFF  313,FEF
....................    *retAddy = addy;
57D6:  MOVFF  30D,FEA
57DA:  MOVFF  30C,FE9
57DE:  MOVFF  317,FEF
57E2:  MOVFF  318,FEC
57E6:  MOVFF  319,FEC
57EA:  MOVFF  31A,FEC
.................... 
....................    return(stopC);
57EE:  MOVFF  311,01
57F2:  MOVLB  0
57F4:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //
.................... // TCPPutFileConstChunk(*addy)
.................... //
.................... // send a chunked response from constant memory
.................... //
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address
.................... //        will be updated for the next call.
.................... //
.................... // returns a response:
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue
.................... //                            from this position on next call.
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file.
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy)
57F6:  MOVLB  3
57F8:  CLRF   x08
57FA:  CLRF   x07
.................... {
....................    char stopC;
....................    int32 addy;
....................    int16 fileSize = 0, txLeft;
....................    TCP_PUT_CONST_EC ec;
.................... 
....................    txLeft = tcp_http_tx_left();
57FC:  MOVFF  71,30C
5800:  MOVLB  0
5802:  RCALL  54AE
5804:  MOVFF  02,30A
5808:  MOVFF  01,309
.................... 
....................  #if HTTP_USE_CHUNKS
....................    if (txLeft > 8)
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars
....................    else
....................       return(TCP_PUT_CONST_EC_CONTINUE);
....................  #else
....................    if (!txLeft)
580C:  MOVLB  3
580E:  MOVF   x09,W
5810:  IORWF  x0A,W
5812:  BNZ   581A
....................       return(TCP_PUT_CONST_EC_CONTINUE);
5814:  MOVLW  01
5816:  MOVWF  01
5818:  BRA    58B2
....................  #endif
.................... 
....................    addy = *retAddy;
581A:  MOVFF  301,FEA
581E:  MOVFF  300,FE9
5822:  MOVFF  FEF,303
5826:  MOVFF  FEC,304
582A:  MOVFF  FEC,305
582E:  MOVFF  FEC,306
.................... 
....................    fileSize = 0xFFFF;
5832:  SETF   x08
5834:  SETF   x07
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE);
5836:  MOVLW  03
5838:  MOVWF  x0D
583A:  MOVWF  x0C
583C:  MOVWF  x0F
583E:  MOVLW  07
5840:  MOVWF  x0E
5842:  CLRF   x10
5844:  MOVLB  0
5846:  RCALL  567C
5848:  MOVFF  01,302
.................... 
....................    if (!fileSize && (stopC!='%'))
584C:  MOVLB  3
584E:  MOVF   x07,W
5850:  IORWF  x08,W
5852:  BNZ   5860
5854:  MOVF   x02,W
5856:  SUBLW  25
5858:  BZ    5860
....................       return(TCP_PUT_CONST_EC_FINISH);
585A:  MOVLW  00
585C:  MOVWF  01
585E:  BRA    58B2
.................... 
....................    //TODO: optimize
....................    if (fileSize > txLeft)
5860:  MOVF   x0A,W
5862:  SUBWF  x08,W
5864:  BNC   587C
5866:  BNZ   586E
5868:  MOVF   x07,W
586A:  SUBWF  x09,W
586C:  BC    587C
....................    {
....................       fileSize = txLeft;
586E:  MOVFF  30A,308
5872:  MOVFF  309,307
.................... //      if (stopC == '%')
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE;
.................... //      else
....................          ec = TCP_PUT_CONST_EC_CONTINUE;
5876:  MOVLW  01
5878:  MOVWF  x0B
....................    }
587A:  BRA    5894
....................    else
....................    {
....................       if (stopC == '%')
587C:  MOVF   x02,W
587E:  SUBLW  25
5880:  BNZ   5888
....................          ec = TCP_PUT_CONST_EC_ESCAPE;
5882:  MOVLW  02
5884:  MOVWF  x0B
5886:  BRA    5894
....................       else if (stopC)
5888:  MOVF   x02,F
588A:  BZ    5892
....................          ec = TCP_PUT_CONST_EC_CONTINUE;
588C:  MOVLW  01
588E:  MOVWF  x0B
5890:  BRA    5894
....................       else
....................          ec = TCP_PUT_CONST_EC_FINISH;
5892:  CLRF   x0B
....................    }
.................... 
....................    TCPPutFileChunkStart(fileSize);
.................... 
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE);
5894:  MOVFF  301,30D
5898:  MOVFF  300,30C
589C:  MOVLW  03
589E:  MOVWF  x0F
58A0:  MOVLW  07
58A2:  MOVWF  x0E
58A4:  MOVLW  01
58A6:  MOVWF  x10
58A8:  MOVLB  0
58AA:  RCALL  567C
.................... 
....................    TCPPutFileChunkStop();
.................... 
....................    return(ec);
58AC:  MOVLB  3
58AE:  MOVFF  30B,01
58B2:  MOVLB  0
58B4:  GOTO   5DB0 (RETURN)
.................... }
.................... 
.................... int TCPPutFileConstGetEscape(int32 addy)
.................... {
.................... #if HTTP_USE_DOUBLE_ESCAPE
....................    char str[3];
....................    int ret;
.................... 
....................    read_program_memory(addy, &str[0], 2);
....................    str[2] = 0;
....................    ret = strtol(str, 0, 16);
.................... #else
....................    char ret;
....................    read_program_memory(addy, &ret, 1);
58B8:  MOVFF  304,FF8
58BC:  MOVFF  303,FF7
58C0:  MOVFF  302,FF6
58C4:  MOVLW  03
58C6:  MOVWF  FEA
58C8:  MOVLW  06
58CA:  MOVWF  FE9
58CC:  MOVLB  3
58CE:  CLRF   x21
58D0:  MOVLW  01
58D2:  MOVWF  x20
58D4:  MOVLB  0
58D6:  RCALL  565E
.................... #endif
.................... 
....................    return(ret);
58D8:  MOVLB  3
58DA:  MOVFF  306,01
58DE:  MOVLB  0
58E0:  GOTO   5DE4 (RETURN)
.................... }
.................... 
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType)
.................... {
....................    static char str[40];
....................    int8 socket;
....................    char ec;
....................    int escaped;
.................... 
....................    static enum
....................    {
....................       HTTP_PUT_FILE_INIT = 0,
....................       HTTP_PUT_FILE_CONTINUE,
....................       HTTP_PUT_FILE_CHUNK_END,
....................       HTTP_PUT_FILE_DONE
....................    } status;
.................... 
....................    socket=http_socket[which];
*
5B8A:  CLRF   03
5B8C:  MOVLB  2
5B8E:  MOVF   xF2,W
5B90:  ADDLW  6E
5B92:  MOVWF  FE9
5B94:  MOVLW  00
5B96:  ADDWFC 03,W
5B98:  MOVWF  FEA
5B9A:  MOVFF  FEF,2FB
.................... 
....................    set_tcp_http_putc(socket);
5B9E:  MOVFF  2FB,2FE
5BA2:  MOVLB  0
5BA4:  GOTO   5084
.................... 
....................    if (lastHTTPPutConstPos[which] == 0)
5BA8:  MOVLB  2
5BAA:  MOVF   xF2,W
5BAC:  MULLW  04
5BAE:  MOVF   FF3,W
5BB0:  CLRF   03
5BB2:  ADDLW  72
5BB4:  MOVWF  FE9
5BB6:  MOVLW  00
5BB8:  ADDWFC 03,W
5BBA:  MOVWF  FEA
5BBC:  MOVFF  FEF,2FE
5BC0:  MOVFF  FEC,2FF
5BC4:  MOVFF  FEC,300
5BC8:  MOVFF  FEC,301
5BCC:  MOVF   xFE,F
5BCE:  BTFSS  FD8.2
5BD0:  BRA    5D1E
5BD2:  MOVF   xFF,F
5BD4:  BTFSS  FD8.2
5BD6:  BRA    5D1E
5BD8:  MOVLB  3
5BDA:  MOVF   x00,F
5BDC:  BTFSC  FD8.2
5BDE:  BRA    5BE4
5BE0:  MOVLB  2
5BE2:  BRA    5D1E
5BE4:  MOVF   x01,F
5BE6:  BTFSC  FD8.2
5BE8:  BRA    5BEE
5BEA:  MOVLB  2
5BEC:  BRA    5D1E
....................    {
....................       lastHTTPPutVarPos[which] = 0;
5BEE:  CLRF   03
5BF0:  MOVLB  2
5BF2:  MOVFF  2F2,02
5BF6:  BCF    FD8.0
5BF8:  RLCF   02,F
5BFA:  RLCF   03,F
5BFC:  MOVF   02,W
5BFE:  ADDLW  76
5C00:  MOVWF  FE9
5C02:  MOVLW  00
5C04:  ADDWFC 03,W
5C06:  MOVWF  FEA
5C08:  CLRF   FEC
5C0A:  MOVF   FED,F
5C0C:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file;
5C0E:  MOVF   xF2,W
5C10:  MULLW  04
5C12:  MOVF   FF3,W
5C14:  CLRF   03
5C16:  ADDLW  72
5C18:  MOVWF  FE9
5C1A:  MOVLW  00
5C1C:  ADDWFC 03,W
5C1E:  MOVWF  FEA
5C20:  MOVFF  2F5,FEF
5C24:  MOVFF  2F6,FEC
5C28:  MOVFF  2F7,FEC
5C2C:  MOVFF  2F8,FEC
....................       status = HTTP_PUT_FILE_CONTINUE;
5C30:  MOVLW  01
5C32:  MOVLB  0
5C34:  MOVWF  x78
.................... 
....................     #if HTTP_USE_CHUNKS
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode);
....................     #else
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode);
5C36:  MOVLW  70
5C38:  MOVWF  FF6
5C3A:  MOVLW  01
5C3C:  MOVWF  FF7
5C3E:  MOVLW  09
5C40:  MOVLB  2
5C42:  MOVWF  xFE
5C44:  MOVLB  0
5C46:  GOTO   536A
5C4A:  MOVLW  10
5C4C:  MOVWF  FE9
5C4E:  MOVFF  2F4,2FF
5C52:  MOVFF  2F3,2FE
5C56:  GOTO   5394
5C5A:  MOVLW  20
5C5C:  MOVLB  3
5C5E:  MOVWF  x1C
5C60:  MOVLB  0
5C62:  CALL   535C
....................     #endif
.................... 
....................       switch(errorCode)
5C66:  MOVLB  2
5C68:  MOVF   xF3,W
5C6A:  MOVWF  00
5C6C:  MOVF   xF4,W
5C6E:  MOVWF  03
5C70:  MOVF   03,W
5C72:  BNZ   5C7E
5C74:  MOVLW  C8
5C76:  SUBWF  00,W
5C78:  MOVLB  0
5C7A:  BZ    5CA0
5C7C:  MOVLB  2
5C7E:  MOVLW  01
5C80:  SUBWF  03,W
5C82:  BNZ   5C8E
5C84:  MOVLW  94
5C86:  SUBWF  00,W
5C88:  MOVLB  0
5C8A:  BZ    5CBA
5C8C:  MOVLB  2
5C8E:  MOVLW  01
5C90:  SUBWF  03,W
5C92:  BNZ   5C9E
5C94:  MOVLW  F4
5C96:  SUBWF  00,W
5C98:  MOVLB  0
5C9A:  BZ    5CC8
5C9C:  MOVLB  2
5C9E:  BRA    5CD8
....................       {
....................          case 200:
....................             printf(tcp_http_putc,"OK");
5CA0:  MOVLW  4F
5CA2:  MOVLB  3
5CA4:  MOVWF  x1C
5CA6:  MOVLB  0
5CA8:  CALL   535C
5CAC:  MOVLW  4B
5CAE:  MOVLB  3
5CB0:  MOVWF  x1C
5CB2:  MOVLB  0
5CB4:  CALL   535C
....................             break;
5CB8:  BRA    5CDA
....................          case 404:
....................             printf(tcp_http_putc,"Not found");
5CBA:  MOVLW  7E
5CBC:  MOVWF  FF6
5CBE:  MOVLW  01
5CC0:  MOVWF  FF7
5CC2:  CALL   5468
....................             break;
5CC6:  BRA    5CDA
....................          case 500:
....................             printf(tcp_http_putc,"Server Error");
5CC8:  MOVLW  88
5CCA:  MOVWF  FF6
5CCC:  MOVLW  01
5CCE:  MOVWF  FF7
5CD0:  CALL   5468
....................             break;
5CD4:  BRA    5CDA
5CD6:  MOVLB  2
....................          default:
....................             break;
5CD8:  MOVLB  0
....................       }
.................... 
....................       printf(tcp_http_putc, "\r\nContent-Type: ");
5CDA:  MOVLW  96
5CDC:  MOVWF  FF6
5CDE:  MOVLW  01
5CE0:  MOVWF  FF7
5CE2:  CALL   5468
....................       if (contentType)
5CE6:  MOVLB  2
5CE8:  MOVF   xF9,W
5CEA:  IORWF  xFA,W
5CEC:  BZ    5D02
....................          printf(tcp_http_putc, "%s", contentType);
5CEE:  MOVFF  2FA,FEA
5CF2:  MOVFF  2F9,FE9
5CF6:  MOVLB  0
5CF8:  GOTO   5488
5CFC:  MOVLB  0
5CFE:  BRA    5D10
5D00:  MOVLB  2
....................       else
....................          printf(tcp_http_putc,"text/html");
5D02:  MOVLW  A8
5D04:  MOVWF  FF6
5D06:  MOVLW  01
5D08:  MOVWF  FF7
5D0A:  MOVLB  0
5D0C:  CALL   5468
.................... 
....................     #if HTTP_USE_CHUNKS
....................       printf(tcp_http_putc, "\r\nConnection: close");
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked");
....................     #endif
.................... 
....................       printf(tcp_http_putc, "\r\n\r\n");
5D10:  MOVLW  B2
5D12:  MOVWF  FF6
5D14:  MOVLW  01
5D16:  MOVWF  FF7
5D18:  CALL   5468
5D1C:  MOVLB  2
....................    }
.................... 
....................    if (lastHTTPPutVarPos[which])
5D1E:  CLRF   03
5D20:  MOVFF  2F2,02
5D24:  BCF    FD8.0
5D26:  RLCF   02,F
5D28:  RLCF   03,F
5D2A:  MOVF   02,W
5D2C:  ADDLW  76
5D2E:  MOVWF  FE9
5D30:  MOVLW  00
5D32:  ADDWFC 03,W
5D34:  MOVWF  FEA
5D36:  MOVF   FEF,F
5D38:  BZ    5D84
....................    {
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]);
5D3A:  CLRF   03
5D3C:  MOVFF  2F2,02
5D40:  BCF    FD8.0
5D42:  RLCF   02,F
5D44:  RLCF   03,F
5D46:  MOVF   02,W
5D48:  ADDLW  76
5D4A:  MOVWF  01
5D4C:  MOVLW  00
5D4E:  ADDWFC 03,F
5D50:  MOVFF  01,2FE
5D54:  MOVFF  03,2FF
5D58:  MOVFF  03,301
5D5C:  MOVFF  01,300
5D60:  MOVLB  0
5D62:  RCALL  55A6
....................       lastHTTPPutVarPos[which] = 0;
5D64:  CLRF   03
5D66:  MOVLB  2
5D68:  MOVFF  2F2,02
5D6C:  BCF    FD8.0
5D6E:  RLCF   02,F
5D70:  RLCF   03,F
5D72:  MOVF   02,W
5D74:  ADDLW  76
5D76:  MOVWF  FE9
5D78:  MOVLW  00
5D7A:  ADDWFC 03,W
5D7C:  MOVWF  FEA
5D7E:  CLRF   FEC
5D80:  MOVF   FED,F
5D82:  CLRF   FEF
....................    }
.................... 
....................    if (status == HTTP_PUT_FILE_CONTINUE)
5D84:  MOVLB  0
5D86:  DECFSZ x78,W
5D88:  BRA    5EDC
....................    {
....................       do {
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]);
5D8A:  MOVLB  2
5D8C:  MOVF   xF2,W
5D8E:  MULLW  04
5D90:  MOVF   FF3,W
5D92:  CLRF   03
5D94:  ADDLW  72
5D96:  MOVWF  01
5D98:  MOVLW  00
5D9A:  ADDWFC 03,F
5D9C:  MOVFF  01,2FE
5DA0:  MOVFF  03,2FF
5DA4:  MOVFF  03,301
5DA8:  MOVFF  01,300
5DAC:  MOVLB  0
5DAE:  BRA    57F6
5DB0:  MOVFF  01,2FC
.................... 
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE)
5DB4:  MOVLB  2
5DB6:  MOVF   xFC,W
5DB8:  SUBLW  02
5DBA:  BTFSS  FD8.2
5DBC:  BRA    5ECA
....................          {
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]);
5DBE:  MOVF   xF2,W
5DC0:  MULLW  04
5DC2:  MOVF   FF3,W
5DC4:  CLRF   03
5DC6:  ADDLW  72
5DC8:  MOVWF  FE9
5DCA:  MOVLW  00
5DCC:  ADDWFC 03,W
5DCE:  MOVWF  FEA
5DD0:  MOVFF  FEF,302
5DD4:  MOVFF  FEC,303
5DD8:  MOVFF  FEC,304
5DDC:  MOVFF  FEC,305
5DE0:  MOVLB  0
5DE2:  BRA    58B8
5DE4:  MOVFF  01,2FD
....................            #if HTTP_USE_DOUBLE_ESCAPE
....................             lastHTTPPutConstPos[which] += 2;
....................            #else
....................             lastHTTPPutConstPos[which] += 1;
5DE8:  MOVLB  2
5DEA:  MOVF   xF2,W
5DEC:  MULLW  04
5DEE:  MOVF   FF3,W
5DF0:  CLRF   03
5DF2:  ADDLW  72
5DF4:  MOVWF  FE9
5DF6:  MOVLW  00
5DF8:  ADDWFC 03,W
5DFA:  MOVWF  FEA
5DFC:  MOVLW  01
5DFE:  ADDWF  FEF,W
5E00:  MOVWF  00
5E02:  MOVLW  00
5E04:  ADDWFC FEC,W
5E06:  MOVWF  01
5E08:  MOVLW  00
5E0A:  ADDWFC FEC,W
5E0C:  MOVWF  02
5E0E:  MOVLW  00
5E10:  ADDWFC FEC,W
5E12:  MOVF   FED,F
5E14:  MOVF   FED,F
5E16:  MOVF   FED,F
5E18:  MOVFF  00,FEF
5E1C:  MOVFF  01,FEC
5E20:  MOVFF  02,FEC
5E24:  MOVWF  FEC
....................            #endif
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1);
5E26:  MOVFF  2F8,301
5E2A:  MOVFF  2F7,300
5E2E:  MOVFF  2F6,2FF
5E32:  MOVFF  2F5,2FE
5E36:  MOVFF  2FD,302
5E3A:  MOVLW  01
5E3C:  MOVLB  3
5E3E:  MOVWF  x04
5E40:  MOVLW  3C
5E42:  MOVWF  x03
5E44:  MOVLW  27
5E46:  MOVWF  x05
5E48:  MOVLB  0
5E4A:  BRA    5A94
....................             lastHTTPPutVarPos[which] = &str[0];
5E4C:  CLRF   03
5E4E:  MOVLB  2
5E50:  MOVFF  2F2,02
5E54:  BCF    FD8.0
5E56:  RLCF   02,F
5E58:  RLCF   03,F
5E5A:  MOVF   02,W
5E5C:  ADDLW  76
5E5E:  MOVWF  FE9
5E60:  MOVLW  00
5E62:  ADDWFC 03,W
5E64:  MOVWF  FEA
5E66:  MOVLW  01
5E68:  MOVWF  FEC
5E6A:  MOVF   FED,F
5E6C:  MOVLW  3C
5E6E:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]);
5E70:  CLRF   03
5E72:  MOVFF  2F2,02
5E76:  BCF    FD8.0
5E78:  RLCF   02,F
5E7A:  RLCF   03,F
5E7C:  MOVF   02,W
5E7E:  ADDLW  76
5E80:  MOVWF  01
5E82:  MOVLW  00
5E84:  ADDWFC 03,F
5E86:  MOVFF  01,2FE
5E8A:  MOVFF  03,2FF
5E8E:  MOVFF  03,301
5E92:  MOVFF  01,300
5E96:  MOVLB  0
5E98:  CALL   55A6
5E9C:  MOVFF  01,2FC
....................             if (ec == TCP_PUT_CONST_EC_FINISH)
5EA0:  MOVLB  2
5EA2:  MOVF   xFC,F
5EA4:  BNZ   5EC6
....................                lastHTTPPutVarPos[which] = 0;
5EA6:  CLRF   03
5EA8:  MOVFF  2F2,02
5EAC:  BCF    FD8.0
5EAE:  RLCF   02,F
5EB0:  RLCF   03,F
5EB2:  MOVF   02,W
5EB4:  ADDLW  76
5EB6:  MOVWF  FE9
5EB8:  MOVLW  00
5EBA:  ADDWFC 03,W
5EBC:  MOVWF  FEA
5EBE:  CLRF   FEC
5EC0:  MOVF   FED,F
5EC2:  CLRF   FEF
5EC4:  BRA    5EC8
....................             else
....................                break;
5EC6:  BRA    5EDA
....................          }
5EC8:  BRA    5ED8
....................          else
....................          {
....................             if (ec == TCP_PUT_CONST_EC_FINISH)
5ECA:  MOVF   xFC,F
5ECC:  BNZ   5ED6
....................                status = HTTP_PUT_FILE_CHUNK_END;
5ECE:  MOVLW  02
5ED0:  MOVLB  0
5ED2:  MOVWF  x78
5ED4:  MOVLB  2
....................             break;
5ED6:  BRA    5EDA
....................          }
....................       } while (TRUE);
5ED8:  BRA    5D8C
5EDA:  MOVLB  0
....................    }
.................... 
....................    if (status == HTTP_PUT_FILE_CHUNK_END)
5EDC:  MOVF   x78,W
5EDE:  SUBLW  02
5EE0:  BNZ   5EE6
....................    {
....................      #if HTTP_USE_CHUNKS
....................       if (tcp_http_tx_left() > 8)
....................       {
....................          TCPPutFileChunkStart(0);
....................          TCPPutFileChunkStop();
....................          status = HTTP_PUT_FILE_DONE;
....................       }
....................      #else
....................       status = HTTP_PUT_FILE_DONE;
5EE2:  MOVLW  03
5EE4:  MOVWF  x78
....................      #endif
....................    }
.................... 
.................... 
....................    TCPFlush(socket);
5EE6:  MOVFF  2FB,323
5EEA:  CALL   508C
.................... 
....................    return(status == HTTP_PUT_FILE_DONE);
5EEE:  MOVF   x78,W
5EF0:  SUBLW  03
5EF2:  BZ    5EF8
5EF4:  MOVLW  00
5EF6:  BRA    5EFA
5EF8:  MOVLW  01
5EFA:  MOVWF  01
5EFC:  RETURN 0
.................... }
.................... 
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack
.................... void HTTP_Init(void) {
....................    int8 i;
....................    debug_http("\r\nHTTP OPENING");
....................    if (HTTP_PORT != 0)
....................    {
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++)
*
100A:  MOVLB  2
100C:  CLRF   xE0
100E:  MOVF   xE0,F
1010:  BNZ   106E
....................       {
....................          http_socket[i]=TCPListen(HTTP_PORT);
1012:  CLRF   03
1014:  MOVF   xE0,W
1016:  ADDLW  6E
1018:  MOVWF  01
101A:  MOVLW  00
101C:  ADDWFC 03,F
101E:  MOVFF  01,2E1
1022:  MOVFF  03,2E2
1026:  CLRF   xE4
1028:  MOVLW  50
102A:  MOVWF  xE3
102C:  MOVLB  0
102E:  BRA    0F1E
1030:  MOVFF  2E2,FEA
1034:  MOVFF  2E1,FE9
1038:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]);
....................          if (http_socket[i]!=INVALID_SOCKET)
103C:  CLRF   03
103E:  MOVLB  2
1040:  MOVF   xE0,W
1042:  ADDLW  6E
1044:  MOVWF  FE9
1046:  MOVLW  00
1048:  ADDWFC 03,W
104A:  MOVWF  FEA
104C:  MOVF   FEF,W
104E:  SUBLW  FE
1050:  BZ    106A
....................          {
....................             http_state[i]=HTTP_LISTEN_WAIT;
1052:  BCF    FD8.0
1054:  RLCF   xE0,W
1056:  CLRF   03
1058:  ADDLW  6F
105A:  MOVWF  FE9
105C:  MOVLW  00
105E:  ADDWFC 03,W
1060:  MOVWF  FEA
1062:  MOVLW  01
1064:  MOVWF  FEC
1066:  MOVF   FED,F
1068:  MOVWF  FEF
....................          }
106A:  INCF   xE0,F
106C:  BRA    100E
....................       }
....................    }
....................    else
....................    {
....................       debug_http("\r\nHTTP DISABLED");
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++)
....................       {
....................             http_state[i]=HTTP_DISABLED;
....................       }
....................    }
106E:  MOVLB  0
1070:  GOTO   1086 (RETURN)
.................... }
.................... 
.................... void HTTP_Task(void) {
....................    static char tokens_header[]=" ";
....................    static char tokens_get[]="?";
....................    static char http_get_str[]="GET";
....................    static char http_post_str[]="POST";
....................    static char http_len_str[]="Content-Length:";
....................    //static char http_keepalive_str[]="keep-alive";
....................    //static char http_connection_str[]="Connection";
.................... 
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE];
.................... 
....................    static int8 i[HTTP_NUM_SOCKETS];
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0};
....................    static int32 http_page_req[HTTP_NUM_SOCKETS];
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0};
....................    static int16 http_timer[HTTP_NUM_SOCKETS];
....................  #if HTTP_USE_CONTENT_TYPE
....................    static char contentType[HTTP_NUM_SOCKETS][12];
....................  #endif
.................... 
....................    int1 doneSend, postContinue;
.................... 
....................    char c, *pKey, *pValue;
....................    int8 hs, currSocket;
.................... 
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++)
*
600E:  MOVLB  2
6010:  CLRF   xEC
6012:  MOVF   xEC,F
6014:  BTFSS  FD8.2
6016:  GOTO   6C62
....................    {
....................       if (http_state[hs]==HTTP_DISABLED)
601A:  BCF    FD8.0
601C:  RLCF   xEC,W
601E:  CLRF   03
6020:  ADDLW  6F
6022:  MOVWF  FE9
6024:  MOVLW  00
6026:  ADDWFC 03,W
6028:  MOVWF  FEA
602A:  MOVFF  FEC,2EF
602E:  MOVF   FED,F
6030:  MOVFF  FEF,2EE
6034:  INCFSZ xEE,W
6036:  BRA    6040
6038:  MOVF   xEF,F
603A:  BNZ   6040
....................          return;
603C:  GOTO   6C62
.................... 
....................       currSocket=http_socket[hs];
6040:  CLRF   03
6042:  MOVF   xEC,W
6044:  ADDLW  6E
6046:  MOVWF  FE9
6048:  MOVLW  00
604A:  ADDWFC 03,W
604C:  MOVWF  FEA
604E:  MOVFF  FEF,2ED
.................... 
....................       if (!TCPIsConnected(currSocket))
6052:  MOVFF  2ED,2EE
6056:  MOVLB  0
6058:  CALL   3E16
605C:  MOVF   01,F
605E:  BNZ   607C
....................          http_state[hs]=HTTP_LISTEN_WAIT;
6060:  BCF    FD8.0
6062:  MOVLB  2
6064:  RLCF   xEC,W
6066:  CLRF   03
6068:  ADDLW  6F
606A:  MOVWF  FE9
606C:  MOVLW  00
606E:  ADDWFC 03,W
6070:  MOVWF  FEA
6072:  MOVLW  01
6074:  MOVWF  FEC
6076:  MOVF   FED,F
6078:  MOVWF  FEF
607A:  MOVLB  0
.................... 
....................       switch(http_state[hs])
607C:  BCF    FD8.0
607E:  MOVLB  2
6080:  RLCF   xEC,W
6082:  CLRF   03
6084:  ADDLW  6F
6086:  MOVWF  FE9
6088:  MOVLW  00
608A:  ADDWFC 03,W
608C:  MOVWF  FEA
608E:  MOVF   FEF,W
6090:  MOVWF  00
6092:  MOVF   FEE,F
6094:  MOVF   FED,W
6096:  MOVWF  03
6098:  MOVLW  01
609A:  SUBWF  03,W
609C:  BNZ   60A8
609E:  MOVLW  01
60A0:  SUBWF  00,W
60A2:  MOVLB  0
60A4:  BZ    6156
60A6:  MOVLB  2
60A8:  MOVLW  01
60AA:  SUBWF  03,W
60AC:  BNZ   60B8
60AE:  MOVLW  02
60B0:  SUBWF  00,W
60B2:  MOVLB  0
60B4:  BZ    6166
60B6:  MOVLB  2
60B8:  MOVLW  01
60BA:  SUBWF  03,W
60BC:  BNZ   60CA
60BE:  MOVLW  03
60C0:  SUBWF  00,W
60C2:  MOVLB  0
60C4:  BTFSC  FD8.2
60C6:  BRA    620C
60C8:  MOVLB  2
60CA:  MOVLW  01
60CC:  SUBWF  03,W
60CE:  BNZ   60DC
60D0:  MOVLW  04
60D2:  SUBWF  00,W
60D4:  MOVLB  0
60D6:  BTFSC  FD8.2
60D8:  BRA    6684
60DA:  MOVLB  2
60DC:  MOVLW  01
60DE:  SUBWF  03,W
60E0:  BNZ   60EE
60E2:  MOVLW  05
60E4:  SUBWF  00,W
60E6:  MOVLB  0
60E8:  BTFSC  FD8.2
60EA:  BRA    66E2
60EC:  MOVLB  2
60EE:  MOVLW  01
60F0:  SUBWF  03,W
60F2:  BNZ   6102
60F4:  MOVLW  06
60F6:  SUBWF  00,W
60F8:  MOVLB  0
60FA:  BTFSC  FD8.2
60FC:  GOTO   6990
6100:  MOVLB  2
6102:  MOVLW  01
6104:  SUBWF  03,W
6106:  BNZ   6116
6108:  MOVLW  07
610A:  SUBWF  00,W
610C:  MOVLB  0
610E:  BTFSC  FD8.2
6110:  GOTO   69C8
6114:  MOVLB  2
6116:  MOVLW  01
6118:  SUBWF  03,W
611A:  BNZ   612A
611C:  MOVLW  08
611E:  SUBWF  00,W
6120:  MOVLB  0
6122:  BTFSC  FD8.2
6124:  GOTO   6B04
6128:  MOVLB  2
612A:  MOVLW  01
612C:  SUBWF  03,W
612E:  BNZ   613E
6130:  MOVLW  09
6132:  SUBWF  00,W
6134:  MOVLB  0
6136:  BTFSC  FD8.2
6138:  GOTO   6B4E
613C:  MOVLB  2
613E:  MOVLW  01
6140:  SUBWF  03,W
6142:  BNZ   6152
6144:  MOVLW  0A
6146:  SUBWF  00,W
6148:  MOVLB  0
614A:  BTFSC  FD8.2
614C:  GOTO   6C56
6150:  MOVLB  2
6152:  GOTO   6C58
....................       {
....................          case HTTP_LISTEN_WAIT:
....................             if (!TCPIsConnected(currSocket))
6156:  MOVFF  2ED,2EE
615A:  CALL   3E16
615E:  MOVF   01,F
6160:  BNZ   6166
....................                break;
6162:  GOTO   6C5A
....................             debug_http("HTTP %U CONNECTED\r\n", hs);
.................... 
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header
....................          case HTTP_CONNECTED:
....................             debug_http("HTTP %U LISTENING\r\n", hs);
....................             buffer[hs][0]=0;
6166:  MOVLB  2
6168:  MOVF   xEC,W
616A:  MULLW  FE
616C:  MOVF   FF3,W
616E:  CLRF   xEF
6170:  MOVWF  xEE
6172:  MOVLW  79
6174:  ADDWF  xEE,W
6176:  MOVWF  FE9
6178:  MOVLW  01
617A:  ADDWFC xEF,W
617C:  MOVWF  FEA
617E:  CLRF   FEF
....................             i[hs]=0;
6180:  CLRF   03
6182:  MOVF   xEC,W
6184:  ADDLW  83
6186:  MOVWF  FE9
6188:  MOVLW  00
618A:  ADDWFC 03,W
618C:  MOVWF  FEA
618E:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS;
6190:  BCF    FD8.0
6192:  RLCF   xEC,W
6194:  CLRF   03
6196:  ADDLW  6F
6198:  MOVWF  FE9
619A:  MOVLW  00
619C:  ADDWFC 03,W
619E:  MOVWF  FEA
61A0:  MOVLW  01
61A2:  MOVWF  FEC
61A4:  MOVF   FED,F
61A6:  MOVLW  03
61A8:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
61AA:  BCF    FD8.0
61AC:  RLCF   xEC,W
61AE:  CLRF   03
61B0:  ADDLW  7B
61B2:  MOVWF  01
61B4:  MOVLW  02
61B6:  ADDWFC 03,F
61B8:  MOVFF  01,2EE
61BC:  MOVFF  03,2EF
61C0:  MOVLB  0
61C2:  CALL   24E4
61C6:  MOVFF  2EF,FEA
61CA:  MOVFF  2EE,FE9
61CE:  MOVFF  02,FEC
61D2:  MOVF   FED,F
61D4:  MOVFF  01,FEF
....................             http_page_req[hs]=0;
61D8:  MOVLB  2
61DA:  MOVF   xEC,W
61DC:  MULLW  04
61DE:  MOVF   FF3,W
61E0:  CLRF   03
61E2:  ADDLW  77
61E4:  MOVWF  FE9
61E6:  MOVLW  02
61E8:  ADDWFC 03,W
61EA:  MOVWF  FEA
61EC:  CLRF   FEF
61EE:  CLRF   FEC
61F0:  CLRF   FEC
61F2:  CLRF   FEC
....................             http_post_len[hs]=0;
61F4:  BCF    FD8.0
61F6:  RLCF   xEC,W
61F8:  CLRF   03
61FA:  ADDLW  85
61FC:  MOVWF  FE9
61FE:  MOVLW  00
6200:  ADDWFC 03,W
6202:  MOVWF  FEA
6204:  CLRF   FEC
6206:  MOVF   FED,F
6208:  CLRF   FEF
620A:  MOVLB  0
....................             //http_got_headers[hs]=FALSE;
....................             //http_isKeepAlive[hs]=FALSE;
.................... 
....................          case HTTP_GET_HEADERS:
....................             postContinue=FALSE;
620C:  MOVLB  2
620E:  BCF    xE6.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c))
6210:  MOVFF  2ED,2EE
6214:  MOVLB  0
6216:  CALL   3E40
621A:  MOVF   01,F
621C:  BTFSC  FD8.2
621E:  BRA    6588
6220:  MOVFF  2ED,2EE
6224:  MOVLW  02
6226:  MOVLB  2
6228:  MOVWF  xF0
622A:  MOVLW  E7
622C:  MOVWF  xEF
622E:  MOVLB  0
6230:  CALL   3E6C
6234:  MOVF   01,F
6236:  BTFSC  FD8.2
6238:  BRA    6588
....................             {
....................                //http_got_headers[hs]=TRUE;
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) )
623A:  MOVLB  2
623C:  MOVF   xE7,W
623E:  SUBLW  1F
6240:  BC    628C
6242:  CLRF   03
6244:  MOVF   xEC,W
6246:  ADDLW  83
6248:  MOVWF  FE9
624A:  MOVLW  00
624C:  ADDWFC 03,W
624E:  MOVWF  FEA
6250:  MOVF   FEF,W
6252:  SUBLW  FB
6254:  BNC   628C
....................                {
....................                   buffer[hs][i[hs]++]=c;
6256:  MOVF   xEC,W
6258:  MULLW  FE
625A:  MOVF   FF3,W
625C:  CLRF   xEF
625E:  MOVWF  xEE
6260:  CLRF   03
6262:  MOVF   xEC,W
6264:  ADDLW  83
6266:  MOVWF  FE9
6268:  MOVLW  00
626A:  ADDWFC 03,W
626C:  MOVWF  FEA
626E:  MOVF   FEF,W
6270:  INCF   FEF,F
6272:  CLRF   03
6274:  ADDWF  xEE,W
6276:  MOVWF  01
6278:  MOVF   xEF,W
627A:  ADDWFC 03,F
627C:  MOVF   01,W
627E:  ADDLW  79
6280:  MOVWF  FE9
6282:  MOVLW  01
6284:  ADDWFC 03,W
6286:  MOVWF  FEA
6288:  MOVFF  2E7,FEF
....................                }
....................                if (c=='\n')
628C:  MOVF   xE7,W
628E:  SUBLW  0A
6290:  BTFSS  FD8.2
6292:  BRA    6584
....................                {
....................                   buffer[hs][i[hs]]=0;
6294:  MOVF   xEC,W
6296:  MULLW  FE
6298:  MOVF   FF3,W
629A:  CLRF   xEF
629C:  MOVWF  xEE
629E:  CLRF   03
62A0:  MOVF   xEC,W
62A2:  ADDLW  83
62A4:  MOVWF  FE9
62A6:  MOVLW  00
62A8:  ADDWFC 03,W
62AA:  MOVWF  FEA
62AC:  CLRF   03
62AE:  MOVF   FEF,W
62B0:  ADDWF  xEE,W
62B2:  MOVWF  01
62B4:  MOVF   xEF,W
62B6:  ADDWFC 03,F
62B8:  MOVF   01,W
62BA:  ADDLW  79
62BC:  MOVWF  FE9
62BE:  MOVLW  01
62C0:  ADDWFC 03,W
62C2:  MOVWF  FEA
62C4:  CLRF   FEF
....................                   if (
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) &&
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 )
62C6:  MOVF   xEC,W
62C8:  MULLW  FE
62CA:  MOVF   FF3,W
62CC:  CLRF   xEF
62CE:  MOVWF  xEE
62D0:  MOVLW  79
62D2:  ADDWF  xEE,W
62D4:  MOVWF  01
62D6:  MOVLW  01
62D8:  ADDWFC xEF,W
62DA:  MOVWF  03
62DC:  MOVFF  01,2F0
62E0:  MOVWF  xF1
62E2:  MOVWF  xF3
62E4:  MOVFF  01,2F2
62E8:  CLRF   xF5
62EA:  MOVLW  7B
62EC:  MOVWF  xF4
62EE:  MOVLB  0
62F0:  CALL   4088
62F4:  MOVFF  02,2E9
62F8:  MOVFF  01,2E8
62FC:  MOVLB  2
62FE:  MOVF   xE8,F
6300:  BNZ   6308
6302:  MOVF   xE9,F
6304:  BTFSC  FD8.2
6306:  BRA    6504
6308:  CLRF   xF3
630A:  CLRF   xF2
630C:  CLRF   xF5
630E:  MOVLW  7B
6310:  MOVWF  xF4
6312:  MOVLB  0
6314:  CALL   4088
6318:  MOVFF  02,2EB
631C:  MOVFF  01,2EA
6320:  MOVLB  2
6322:  MOVF   xEA,F
6324:  BNZ   632C
6326:  MOVF   xEB,F
6328:  BTFSC  FD8.2
632A:  BRA    6504
....................                      )
....................                   {
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue);
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) )
632C:  MOVFF  2E9,2EF
6330:  MOVFF  2E8,2EE
6334:  CLRF   xF1
6336:  MOVLW  7F
6338:  MOVWF  xF0
633A:  MOVLB  0
633C:  CALL   413C
6340:  MOVLB  2
6342:  CLRF   xEF
6344:  MOVFF  01,2EE
6348:  BTFSC  01.7
634A:  DECF   xEF,F
634C:  MOVF   xEE,F
634E:  BNZ   6354
6350:  MOVF   xEF,F
6352:  BZ    6382
6354:  MOVFF  2E9,2EF
6358:  MOVFF  2E8,2EE
635C:  MOVLW  01
635E:  MOVWF  xF1
6360:  MOVLW  64
6362:  MOVWF  xF0
6364:  MOVLB  0
6366:  CALL   413C
636A:  MOVLB  2
636C:  CLRF   xEF
636E:  MOVFF  01,2EE
6372:  BTFSC  01.7
6374:  DECF   xEF,F
6376:  MOVF   xEE,F
6378:  BTFSS  FD8.2
637A:  BRA    648E
637C:  MOVF   xEF,F
637E:  BTFSS  FD8.2
6380:  BRA    648E
....................                      {
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ?
6382:  MOVFF  2EB,2F3
6386:  MOVFF  2EA,2F2
638A:  CLRF   xF5
638C:  MOVLW  7D
638E:  MOVWF  xF4
6390:  MOVLB  0
6392:  CALL   4088
6396:  MOVFF  02,2EB
639A:  MOVFF  01,2EA
....................                         http_escape_chars(pValue);
639E:  MOVFF  2EB,302
63A2:  MOVFF  2EA,301
63A6:  CALL   46BE
....................                        #if HTTP_USE_CONTENT_TYPE
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]);
....................                        #else
....................                         http_page_req[hs] = http_get_page(pValue);
63AA:  MOVLB  2
63AC:  MOVF   xEC,W
63AE:  MULLW  04
63B0:  MOVF   FF3,W
63B2:  CLRF   03
63B4:  ADDLW  77
63B6:  MOVWF  01
63B8:  MOVLW  02
63BA:  ADDWFC 03,F
63BC:  MOVFF  01,2EE
63C0:  MOVFF  03,2EF
63C4:  MOVFF  2EB,2F1
63C8:  MOVFF  2EA,2F0
63CC:  MOVLB  0
63CE:  GOTO   4892
63D2:  MOVFF  2EF,FEA
63D6:  MOVFF  2EE,FE9
63DA:  MOVFF  00,FEF
63DE:  MOVFF  01,FEC
63E2:  MOVFF  02,FEC
63E6:  MOVFF  03,FEC
....................                        #endif
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]);
....................                         pValue=strtok(0, tokens_get);
63EA:  MOVLB  2
63EC:  CLRF   xF3
63EE:  CLRF   xF2
63F0:  CLRF   xF5
63F2:  MOVLW  7D
63F4:  MOVWF  xF4
63F6:  MOVLB  0
63F8:  CALL   4088
63FC:  MOVFF  02,2EB
6400:  MOVFF  01,2EA
....................                         if (pValue)
6404:  MOVLB  2
6406:  MOVF   xEA,W
6408:  IORWF  xEB,W
640A:  BZ    643E
....................                            http_parse_cgi_string(http_page_req[hs], pValue);
640C:  MOVF   xEC,W
640E:  MULLW  04
6410:  MOVF   FF3,W
6412:  CLRF   03
6414:  ADDLW  77
6416:  MOVWF  FE9
6418:  MOVLW  02
641A:  ADDWFC 03,W
641C:  MOVWF  FEA
641E:  MOVFF  FEF,2F6
6422:  MOVFF  FEC,2F7
6426:  MOVFF  FEC,2F8
642A:  MOVFF  FEC,2F9
642E:  MOVFF  2EB,2FB
6432:  MOVFF  2EA,2FA
6436:  MOVLB  0
6438:  CALL   4CB2
643C:  MOVLB  2
.................... 
....................                         if (strcmp(pKey, http_get_str)==0)
643E:  MOVFF  2E9,2EF
6442:  MOVFF  2E8,2EE
6446:  CLRF   xF1
6448:  MOVLW  7F
644A:  MOVWF  xF0
644C:  MOVLB  0
644E:  CALL   413C
6452:  MOVLB  2
6454:  CLRF   xEF
6456:  MOVFF  01,2EE
645A:  BTFSC  01.7
645C:  DECF   xEF,F
645E:  MOVF   xEE,F
6460:  BNZ   647A
6462:  MOVF   xEF,F
6464:  BNZ   647A
....................                            http_cmd[hs]=HTTP_REQ_GET;
6466:  CLRF   03
6468:  MOVF   xEC,W
646A:  ADDLW  84
646C:  MOVWF  FE9
646E:  MOVLW  00
6470:  ADDWFC 03,W
6472:  MOVWF  FEA
6474:  MOVLW  01
6476:  MOVWF  FEF
6478:  BRA    648C
....................                         else
....................                            http_cmd[hs]=HTTP_REQ_POST;
647A:  CLRF   03
647C:  MOVF   xEC,W
647E:  ADDLW  84
6480:  MOVWF  FE9
6482:  MOVLW  00
6484:  ADDWFC 03,W
6486:  MOVWF  FEA
6488:  MOVLW  02
648A:  MOVWF  FEF
....................                      }
648C:  BRA    6502
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST
648E:  CLRF   03
6490:  MOVF   xEC,W
6492:  ADDLW  84
6494:  MOVWF  FE9
6496:  MOVLW  00
6498:  ADDWFC 03,W
649A:  MOVWF  FEA
649C:  MOVF   FEF,F
649E:  BZ    6502
....................                      {
....................                         //if you want to parse HTTP headers, do it here.
....................                         //pKey and pVal hold the individual headers.
.................... 
....................                         //this driver only parses the Content-Length header.
....................                         if (strcmp(pKey, http_len_str)==0)
64A0:  MOVFF  2E9,2EF
64A4:  MOVFF  2E8,2EE
64A8:  MOVLW  01
64AA:  MOVWF  xF1
64AC:  MOVLW  69
64AE:  MOVWF  xF0
64B0:  MOVLB  0
64B2:  CALL   413C
64B6:  MOVLB  2
64B8:  CLRF   xEF
64BA:  MOVFF  01,2EE
64BE:  BTFSC  01.7
64C0:  DECF   xEF,F
64C2:  MOVF   xEE,F
64C4:  BNZ   6502
64C6:  MOVF   xEF,F
64C8:  BNZ   6502
....................                         {
....................                            http_post_len[hs]=atol(pValue);
64CA:  BCF    FD8.0
64CC:  RLCF   xEC,W
64CE:  CLRF   03
64D0:  ADDLW  85
64D2:  MOVWF  01
64D4:  MOVLW  00
64D6:  ADDWFC 03,F
64D8:  MOVFF  01,2EE
64DC:  MOVFF  03,2EF
64E0:  MOVFF  2EB,2F1
64E4:  MOVFF  2EA,2F0
64E8:  MOVLB  0
64EA:  GOTO   4DBE
64EE:  MOVFF  2EF,FEA
64F2:  MOVFF  2EE,FE9
64F6:  MOVFF  02,FEC
64FA:  MOVF   FED,F
64FC:  MOVFF  01,FEF
6500:  MOVLB  2
....................                         }
....................                      }
....................                   }
6502:  BRA    6574
....................                   else if (i[hs] == 0)
6504:  CLRF   03
6506:  MOVF   xEC,W
6508:  ADDLW  83
650A:  MOVWF  FE9
650C:  MOVLW  00
650E:  ADDWFC 03,W
6510:  MOVWF  FEA
6512:  MOVF   FEF,F
6514:  BNZ   6574
....................                   {
....................                      //got a double \r\n
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs);
....................                      if (http_cmd[hs] == HTTP_REQ_POST)
6516:  CLRF   03
6518:  MOVF   xEC,W
651A:  ADDLW  84
651C:  MOVWF  FE9
651E:  MOVLW  00
6520:  ADDWFC 03,W
6522:  MOVWF  FEA
6524:  MOVF   FEF,W
6526:  SUBLW  02
6528:  BNZ   6548
....................                      {
....................                         http_state[hs]=HTTP_GET_POST;
652A:  BCF    FD8.0
652C:  RLCF   xEC,W
652E:  CLRF   03
6530:  ADDLW  6F
6532:  MOVWF  FE9
6534:  MOVLW  00
6536:  ADDWFC 03,W
6538:  MOVWF  FEA
653A:  MOVLW  01
653C:  MOVWF  FEC
653E:  MOVF   FED,F
6540:  MOVLW  04
6542:  MOVWF  FEF
....................                         postContinue=TRUE;
6544:  BSF    xE6.1
....................                      }
6546:  BRA    656E
....................                      else
....................                      {
....................                         http_state[hs]=HTTP_SEND_RESPONSE;
6548:  BCF    FD8.0
654A:  RLCF   xEC,W
654C:  CLRF   03
654E:  ADDLW  6F
6550:  MOVWF  FE9
6552:  MOVLW  00
6554:  ADDWFC 03,W
6556:  MOVWF  FEA
6558:  MOVLW  01
655A:  MOVWF  FEC
655C:  MOVF   FED,F
655E:  MOVLW  06
6560:  MOVWF  FEF
....................                         TCPDiscard(currSocket);
6562:  MOVFF  2ED,2F1
6566:  MOVLB  0
6568:  CALL   4F9A
656C:  MOVLB  2
....................                      }
....................                      break;   //break out of read from ethernet loop
656E:  MOVLB  0
6570:  BRA    6588
6572:  MOVLB  2
....................                   }
....................                   i[hs]=0;
6574:  CLRF   03
6576:  MOVF   xEC,W
6578:  ADDLW  83
657A:  MOVWF  FE9
657C:  MOVLW  00
657E:  ADDWFC 03,W
6580:  MOVWF  FEA
6582:  CLRF   FEF
....................                }
6584:  BRA    6210
6586:  MOVLB  0
....................             }
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20)
6588:  CALL   24E4
658C:  MOVFF  02,2EF
6590:  MOVFF  01,2EE
6594:  BCF    FD8.0
6596:  MOVLB  2
6598:  RLCF   xEC,W
659A:  CLRF   03
659C:  ADDLW  7B
659E:  MOVWF  FE9
65A0:  MOVLW  02
65A2:  ADDWFC 03,W
65A4:  MOVWF  FEA
65A6:  MOVFF  FEC,03
65AA:  MOVF   FED,F
65AC:  MOVFF  FEF,01
65B0:  MOVF   02,W
65B2:  SUBWF  03,W
65B4:  BNC   65BE
65B6:  BNZ   65C2
65B8:  MOVF   01,W
65BA:  SUBWF  xEE,W
65BC:  BNC   65C2
65BE:  MOVLW  00
65C0:  BRA    65C4
65C2:  MOVLW  01
65C4:  CLRF   03
65C6:  IORWF  03,W
65C8:  BZ    660C
65CA:  BCF    FD8.0
65CC:  RLCF   xEC,W
65CE:  CLRF   03
65D0:  ADDLW  7B
65D2:  MOVWF  FE9
65D4:  MOVLW  02
65D6:  ADDWFC 03,W
65D8:  MOVWF  FEA
65DA:  MOVFF  FEC,03
65DE:  MOVF   FED,F
65E0:  MOVF   FEF,W
65E2:  SUBLW  FF
65E4:  MOVWF  xEE
65E6:  MOVLW  FF
65E8:  SUBFWB 03,W
65EA:  MOVWF  xEF
65EC:  MOVLB  0
65EE:  CALL   24E4
65F2:  MOVF   01,W
65F4:  MOVLB  2
65F6:  ADDWF  xEE,F
65F8:  MOVF   02,W
65FA:  ADDWFC xEF,F
65FC:  MOVLW  01
65FE:  ADDWF  xEE,W
6600:  MOVWF  01
6602:  MOVLW  00
6604:  ADDWFC xEF,W
6606:  MOVWF  03
6608:  MOVF   01,W
660A:  BRA    6640
660C:  MOVLB  0
660E:  CALL   24E4
6612:  MOVFF  02,2EF
6616:  MOVFF  01,2EE
661A:  BCF    FD8.0
661C:  MOVLB  2
661E:  RLCF   xEC,W
6620:  CLRF   03
6622:  ADDLW  7B
6624:  MOVWF  FE9
6626:  MOVLW  02
6628:  ADDWFC 03,W
662A:  MOVWF  FEA
662C:  MOVFF  FEC,03
6630:  MOVF   FED,F
6632:  MOVF   FEF,W
6634:  SUBWF  01,W
6636:  MOVWF  00
6638:  MOVF   03,W
663A:  SUBWFB 02,W
663C:  MOVWF  03
663E:  MOVF   00,W
6640:  SUBLW  C8
6642:  BC    6678
....................             {
....................                //if (http_got_headers[hs])
....................                //{
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs);
....................                   http_page_req[hs]=0xFFFFFFFF;
6644:  MOVF   xEC,W
6646:  MULLW  04
6648:  MOVF   FF3,W
664A:  CLRF   03
664C:  ADDLW  77
664E:  MOVWF  FE9
6650:  MOVLW  02
6652:  ADDWFC 03,W
6654:  MOVWF  FEA
6656:  SETF   FEF
6658:  SETF   FEC
665A:  SETF   FEC
665C:  SETF   FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE;
665E:  BCF    FD8.0
6660:  RLCF   xEC,W
6662:  CLRF   03
6664:  ADDLW  6F
6666:  MOVWF  FE9
6668:  MOVLW  00
666A:  ADDWFC 03,W
666C:  MOVWF  FEA
666E:  MOVLW  01
6670:  MOVWF  FEC
6672:  MOVF   FED,F
6674:  MOVLW  06
6676:  MOVWF  FEF
....................                //}
....................                //else
....................                //{
....................                //   http_state[hs]=HTTP_CLOSE;
....................                //}
....................             }
....................             if (!postContinue)
6678:  BTFSC  xE6.1
667A:  BRA    6682
....................                break;
667C:  MOVLB  0
667E:  BRA    6C5A
6680:  MOVLB  2
6682:  MOVLB  0
.................... 
....................          case HTTP_GET_POST:
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]);
....................             http_state[hs]=HTTP_GET_POST_CONTINUE;
6684:  BCF    FD8.0
6686:  MOVLB  2
6688:  RLCF   xEC,W
668A:  CLRF   03
668C:  ADDLW  6F
668E:  MOVWF  FE9
6690:  MOVLW  00
6692:  ADDWFC 03,W
6694:  MOVWF  FEA
6696:  MOVLW  01
6698:  MOVWF  FEC
669A:  MOVF   FED,F
669C:  MOVLW  05
669E:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
66A0:  BCF    FD8.0
66A2:  RLCF   xEC,W
66A4:  CLRF   03
66A6:  ADDLW  7B
66A8:  MOVWF  01
66AA:  MOVLW  02
66AC:  ADDWFC 03,F
66AE:  MOVFF  01,2EE
66B2:  MOVFF  03,2EF
66B6:  MOVLB  0
66B8:  CALL   24E4
66BC:  MOVFF  2EF,FEA
66C0:  MOVFF  2EE,FE9
66C4:  MOVFF  02,FEC
66C8:  MOVF   FED,F
66CA:  MOVFF  01,FEF
....................             i[hs]=0;
66CE:  CLRF   03
66D0:  MOVLB  2
66D2:  MOVF   xEC,W
66D4:  ADDLW  83
66D6:  MOVWF  FE9
66D8:  MOVLW  00
66DA:  ADDWFC 03,W
66DC:  MOVWF  FEA
66DE:  CLRF   FEF
66E0:  MOVLB  0
.................... 
....................          case HTTP_GET_POST_CONTINUE:
....................             while (
....................                      TCPIsGetReady(currSocket) &&
....................                      TCPGet(currSocket, &c) &&
....................                      (http_post_len[hs] != 0)
....................                   )
66E2:  MOVFF  2ED,2EE
66E6:  CALL   3E40
66EA:  MOVF   01,F
66EC:  BTFSC  FD8.2
66EE:  BRA    689C
66F0:  MOVFF  2ED,2EE
66F4:  MOVLW  02
66F6:  MOVLB  2
66F8:  MOVWF  xF0
66FA:  MOVLW  E7
66FC:  MOVWF  xEF
66FE:  MOVLB  0
6700:  CALL   3E6C
6704:  MOVF   01,F
6706:  BTFSC  FD8.2
6708:  BRA    689C
670A:  BCF    FD8.0
670C:  MOVLB  2
670E:  RLCF   xEC,W
6710:  CLRF   03
6712:  ADDLW  85
6714:  MOVWF  FE9
6716:  MOVLW  00
6718:  ADDWFC 03,W
671A:  MOVWF  FEA
671C:  MOVFF  FEC,2EF
6720:  MOVF   FED,F
6722:  MOVFF  FEF,2EE
6726:  MOVF   xEE,F
6728:  BNZ   6734
672A:  MOVF   xEF,F
672C:  BTFSS  FD8.2
672E:  BRA    6734
6730:  MOVLB  0
6732:  BRA    689C
....................             {
....................                http_post_len[hs] -= 1;
6734:  BCF    FD8.0
6736:  RLCF   xEC,W
6738:  CLRF   03
673A:  ADDLW  85
673C:  MOVWF  FE9
673E:  MOVLW  00
6740:  ADDWFC 03,W
6742:  MOVWF  FEA
6744:  MOVLW  01
6746:  SUBWF  FEF,W
6748:  MOVWF  00
674A:  MOVLW  00
674C:  SUBWFB FEC,W
674E:  MOVWF  03
6750:  MOVF   00,W
6752:  MOVF   FED,F
6754:  MOVWF  FEF
6756:  MOVFF  03,FEC
.................... 
....................                if (c!='&')
675A:  MOVF   xE7,W
675C:  SUBLW  26
675E:  BZ    6796
....................                {
....................                   buffer[hs][i[hs]++]=c;
6760:  MOVF   xEC,W
6762:  MULLW  FE
6764:  MOVF   FF3,W
6766:  CLRF   xEF
6768:  MOVWF  xEE
676A:  CLRF   03
676C:  MOVF   xEC,W
676E:  ADDLW  83
6770:  MOVWF  FE9
6772:  MOVLW  00
6774:  ADDWFC 03,W
6776:  MOVWF  FEA
6778:  MOVF   FEF,W
677A:  INCF   FEF,F
677C:  CLRF   03
677E:  ADDWF  xEE,W
6780:  MOVWF  01
6782:  MOVF   xEF,W
6784:  ADDWFC 03,F
6786:  MOVF   01,W
6788:  ADDLW  79
678A:  MOVWF  FE9
678C:  MOVLW  01
678E:  ADDWFC 03,W
6790:  MOVWF  FEA
6792:  MOVFF  2E7,FEF
....................                }
.................... 
....................                if ( (c=='&') || (http_post_len[hs] == 0) )
6796:  MOVF   xE7,W
6798:  SUBLW  26
679A:  BZ    67BE
679C:  BCF    FD8.0
679E:  RLCF   xEC,W
67A0:  CLRF   03
67A2:  ADDLW  85
67A4:  MOVWF  FE9
67A6:  MOVLW  00
67A8:  ADDWFC 03,W
67AA:  MOVWF  FEA
67AC:  MOVFF  FEC,2EF
67B0:  MOVF   FED,F
67B2:  MOVFF  FEF,2EE
67B6:  MOVF   xEE,F
67B8:  BNZ   6898
67BA:  MOVF   xEF,F
67BC:  BNZ   6898
....................                {
....................                   buffer[hs][i[hs]]=0;
67BE:  MOVF   xEC,W
67C0:  MULLW  FE
67C2:  MOVF   FF3,W
67C4:  CLRF   xEF
67C6:  MOVWF  xEE
67C8:  CLRF   03
67CA:  MOVF   xEC,W
67CC:  ADDLW  83
67CE:  MOVWF  FE9
67D0:  MOVLW  00
67D2:  ADDWFC 03,W
67D4:  MOVWF  FEA
67D6:  CLRF   03
67D8:  MOVF   FEF,W
67DA:  ADDWF  xEE,W
67DC:  MOVWF  01
67DE:  MOVF   xEF,W
67E0:  ADDWFC 03,F
67E2:  MOVF   01,W
67E4:  ADDLW  79
67E6:  MOVWF  FE9
67E8:  MOVLW  01
67EA:  ADDWFC 03,W
67EC:  MOVWF  FEA
67EE:  CLRF   FEF
.................... 
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]);
.................... 
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]);
67F0:  MOVF   xEC,W
67F2:  MULLW  04
67F4:  MOVF   FF3,W
67F6:  CLRF   03
67F8:  ADDLW  77
67FA:  MOVWF  FE9
67FC:  MOVLW  02
67FE:  ADDWFC 03,W
6800:  MOVWF  FEA
6802:  MOVFF  FEF,2F6
6806:  MOVFF  FEC,2F7
680A:  MOVFF  FEC,2F8
680E:  MOVFF  FEC,2F9
6812:  MOVF   xEC,W
6814:  MULLW  FE
6816:  MOVF   FF3,W
6818:  CLRF   xF3
681A:  MOVWF  xF2
681C:  MOVLW  79
681E:  ADDWF  xF2,W
6820:  MOVWF  01
6822:  MOVLW  01
6824:  ADDWFC xF3,W
6826:  MOVWF  03
6828:  MOVFF  01,2F4
682C:  MOVWF  xF5
682E:  MOVWF  xFB
6830:  MOVFF  01,2FA
6834:  MOVLB  0
6836:  CALL   4CB2
....................                   if (http_post_len[hs] == 0)
683A:  BCF    FD8.0
683C:  MOVLB  2
683E:  RLCF   xEC,W
6840:  CLRF   03
6842:  ADDLW  85
6844:  MOVWF  FE9
6846:  MOVLW  00
6848:  ADDWFC 03,W
684A:  MOVWF  FEA
684C:  MOVFF  FEC,2EF
6850:  MOVF   FED,F
6852:  MOVFF  FEF,2EE
6856:  MOVF   xEE,F
6858:  BNZ   6888
685A:  MOVF   xEF,F
685C:  BNZ   6888
....................                   {
....................                      http_state[hs]=HTTP_SEND_RESPONSE;
685E:  BCF    FD8.0
6860:  RLCF   xEC,W
6862:  CLRF   03
6864:  ADDLW  6F
6866:  MOVWF  FE9
6868:  MOVLW  00
686A:  ADDWFC 03,W
686C:  MOVWF  FEA
686E:  MOVLW  01
6870:  MOVWF  FEC
6872:  MOVF   FED,F
6874:  MOVLW  06
6876:  MOVWF  FEF
....................                      TCPDiscard(currSocket);
6878:  MOVFF  2ED,2F1
687C:  MOVLB  0
687E:  CALL   4F9A
....................                      break;
6882:  BRA    689C
....................                   }
6884:  BRA    689A
6886:  MOVLB  2
....................                   else
....................                      i[hs]=0;
6888:  CLRF   03
688A:  MOVF   xEC,W
688C:  ADDLW  83
688E:  MOVWF  FE9
6890:  MOVLW  00
6892:  ADDWFC 03,W
6894:  MOVWF  FEA
6896:  CLRF   FEF
6898:  MOVLB  0
....................                }
689A:  BRA    66E2
....................             }
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20)
689C:  CALL   24E4
68A0:  MOVFF  02,2EF
68A4:  MOVFF  01,2EE
68A8:  BCF    FD8.0
68AA:  MOVLB  2
68AC:  RLCF   xEC,W
68AE:  CLRF   03
68B0:  ADDLW  7B
68B2:  MOVWF  FE9
68B4:  MOVLW  02
68B6:  ADDWFC 03,W
68B8:  MOVWF  FEA
68BA:  MOVFF  FEC,03
68BE:  MOVF   FED,F
68C0:  MOVFF  FEF,01
68C4:  MOVF   02,W
68C6:  SUBWF  03,W
68C8:  BNC   68D2
68CA:  BNZ   68D6
68CC:  MOVF   01,W
68CE:  SUBWF  xEE,W
68D0:  BNC   68D6
68D2:  MOVLW  00
68D4:  BRA    68D8
68D6:  MOVLW  01
68D8:  CLRF   03
68DA:  IORWF  03,W
68DC:  BZ    6920
68DE:  BCF    FD8.0
68E0:  RLCF   xEC,W
68E2:  CLRF   03
68E4:  ADDLW  7B
68E6:  MOVWF  FE9
68E8:  MOVLW  02
68EA:  ADDWFC 03,W
68EC:  MOVWF  FEA
68EE:  MOVFF  FEC,03
68F2:  MOVF   FED,F
68F4:  MOVF   FEF,W
68F6:  SUBLW  FF
68F8:  MOVWF  xEE
68FA:  MOVLW  FF
68FC:  SUBFWB 03,W
68FE:  MOVWF  xEF
6900:  MOVLB  0
6902:  CALL   24E4
6906:  MOVF   01,W
6908:  MOVLB  2
690A:  ADDWF  xEE,F
690C:  MOVF   02,W
690E:  ADDWFC xEF,F
6910:  MOVLW  01
6912:  ADDWF  xEE,W
6914:  MOVWF  01
6916:  MOVLW  00
6918:  ADDWFC xEF,W
691A:  MOVWF  03
691C:  MOVF   01,W
691E:  BRA    6954
6920:  MOVLB  0
6922:  CALL   24E4
6926:  MOVFF  02,2EF
692A:  MOVFF  01,2EE
692E:  BCF    FD8.0
6930:  MOVLB  2
6932:  RLCF   xEC,W
6934:  CLRF   03
6936:  ADDLW  7B
6938:  MOVWF  FE9
693A:  MOVLW  02
693C:  ADDWFC 03,W
693E:  MOVWF  FEA
6940:  MOVFF  FEC,03
6944:  MOVF   FED,F
6946:  MOVF   FEF,W
6948:  SUBWF  01,W
694A:  MOVWF  00
694C:  MOVF   03,W
694E:  SUBWFB 02,W
6950:  MOVWF  03
6952:  MOVF   00,W
6954:  SUBLW  C8
6956:  BC    698C
....................             {
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs);
....................                http_page_req[hs]=0xFFFFFFFF;
6958:  MOVF   xEC,W
695A:  MULLW  04
695C:  MOVF   FF3,W
695E:  CLRF   03
6960:  ADDLW  77
6962:  MOVWF  FE9
6964:  MOVLW  02
6966:  ADDWFC 03,W
6968:  MOVWF  FEA
696A:  SETF   FEF
696C:  SETF   FEC
696E:  SETF   FEC
6970:  SETF   FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE;
6972:  BCF    FD8.0
6974:  RLCF   xEC,W
6976:  CLRF   03
6978:  ADDLW  6F
697A:  MOVWF  FE9
697C:  MOVLW  00
697E:  ADDWFC 03,W
6980:  MOVWF  FEA
6982:  MOVLW  01
6984:  MOVWF  FEC
6986:  MOVF   FED,F
6988:  MOVLW  06
698A:  MOVWF  FEF
....................             }
....................             break;
698C:  MOVLB  0
698E:  BRA    6C5A
.................... 
....................          case HTTP_SEND_RESPONSE:
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs);
....................             lastHTTPPutConstPos[hs]=0;
6990:  MOVLB  2
6992:  MOVF   xEC,W
6994:  MULLW  04
6996:  MOVF   FF3,W
6998:  CLRF   03
699A:  ADDLW  72
699C:  MOVWF  FE9
699E:  MOVLW  00
69A0:  ADDWFC 03,W
69A2:  MOVWF  FEA
69A4:  CLRF   FEF
69A6:  CLRF   FEC
69A8:  CLRF   FEC
69AA:  CLRF   FEC
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE;
69AC:  BCF    FD8.0
69AE:  RLCF   xEC,W
69B0:  CLRF   03
69B2:  ADDLW  6F
69B4:  MOVWF  FE9
69B6:  MOVLW  00
69B8:  ADDWFC 03,W
69BA:  MOVWF  FEA
69BC:  MOVLW  01
69BE:  MOVWF  FEC
69C0:  MOVF   FED,F
69C2:  MOVLW  07
69C4:  MOVWF  FEF
69C6:  MOVLB  0
.................... 
....................          case HTTP_SEND_RESPONSE_CONTINUE:
....................             TCPDiscard(currSocket);
69C8:  MOVFF  2ED,2F1
69CC:  CALL   4F9A
....................             if (TCPIsPutReady(currSocket))
69D0:  MOVFF  2ED,311
69D4:  CALL   4FE8
69D8:  MOVF   01,F
69DA:  BTFSC  FD8.2
69DC:  BRA    6B02
....................             {
....................                debug_http("\r\nPUTTING HTTP SEG\r\n");
....................                if (http_page_req[hs]==0xFFFFFFFF)
69DE:  MOVLB  2
69E0:  MOVF   xEC,W
69E2:  MULLW  04
69E4:  MOVF   FF3,W
69E6:  CLRF   03
69E8:  ADDLW  77
69EA:  MOVWF  FE9
69EC:  MOVLW  02
69EE:  ADDWFC 03,W
69F0:  MOVWF  FEA
69F2:  MOVFF  FEF,2EE
69F6:  MOVFF  FEC,2EF
69FA:  MOVFF  FEC,2F0
69FE:  MOVFF  FEC,2F1
6A02:  INCFSZ xEE,W
6A04:  BRA    6A4A
6A06:  INCFSZ xEF,W
6A08:  BRA    6A4A
6A0A:  INCFSZ xF0,W
6A0C:  BRA    6A4A
6A0E:  INCFSZ xF1,W
6A10:  BRA    6A4A
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0);
6A12:  MOVLW  01
6A14:  MOVWF  03
6A16:  MOVLW  26
6A18:  MOVWF  xEE
6A1A:  MOVFF  03,2EF
6A1E:  MOVFF  2EC,2F2
6A22:  MOVLW  01
6A24:  MOVWF  xF4
6A26:  MOVLW  F4
6A28:  MOVWF  xF3
6A2A:  CLRF   xF8
6A2C:  CLRF   xF7
6A2E:  MOVFF  03,2F6
6A32:  MOVFF  2EE,2F5
6A36:  CLRF   xFA
6A38:  CLRF   xF9
6A3A:  MOVLB  0
6A3C:  CALL   5B8A
6A40:  MOVLB  2
6A42:  BCF    xE6.0
6A44:  BTFSC  01.0
6A46:  BSF    xE6.0
6A48:  BRA    6AE2
....................                else if (http_page_req[hs])
....................                 #if HTTP_USE_CONTENT_TYPE
6A4A:  MOVF   xEC,W
6A4C:  MULLW  04
6A4E:  MOVF   FF3,W
6A50:  CLRF   03
6A52:  ADDLW  77
6A54:  MOVWF  FE9
6A56:  MOVLW  02
6A58:  ADDWFC 03,W
6A5A:  MOVWF  FEA
6A5C:  MOVF   FEF,F
6A5E:  BNZ   6A6C
6A60:  MOVF   FEC,F
6A62:  BNZ   6A6C
6A64:  MOVF   FEC,F
6A66:  BNZ   6A6C
6A68:  MOVF   FEC,F
6A6A:  BZ    6AAC
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]);
....................                 #else
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0);
6A6C:  MOVF   xEC,W
6A6E:  MULLW  04
6A70:  MOVF   FF3,W
6A72:  CLRF   03
6A74:  ADDLW  77
6A76:  MOVWF  FE9
6A78:  MOVLW  02
6A7A:  ADDWFC 03,W
6A7C:  MOVWF  FEA
6A7E:  MOVFF  FEF,2F5
6A82:  MOVFF  FEC,2F6
6A86:  MOVFF  FEC,2F7
6A8A:  MOVFF  FEC,2F8
6A8E:  MOVFF  2EC,2F2
6A92:  CLRF   xF4
6A94:  MOVLW  C8
6A96:  MOVWF  xF3
6A98:  CLRF   xFA
6A9A:  CLRF   xF9
6A9C:  MOVLB  0
6A9E:  CALL   5B8A
6AA2:  MOVLB  2
6AA4:  BCF    xE6.0
6AA6:  BTFSC  01.0
6AA8:  BSF    xE6.0
....................                 #endif
6AAA:  BRA    6AE2
....................                else
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0);
6AAC:  MOVLW  00
6AAE:  MOVWF  03
6AB0:  MOVLW  E2
6AB2:  MOVWF  xEE
6AB4:  MOVFF  03,2EF
6AB8:  MOVFF  2EC,2F2
6ABC:  MOVLW  01
6ABE:  MOVWF  xF4
6AC0:  MOVLW  94
6AC2:  MOVWF  xF3
6AC4:  CLRF   xF8
6AC6:  CLRF   xF7
6AC8:  MOVFF  03,2F6
6ACC:  MOVFF  2EE,2F5
6AD0:  CLRF   xFA
6AD2:  CLRF   xF9
6AD4:  MOVLB  0
6AD6:  CALL   5B8A
6ADA:  MOVLB  2
6ADC:  BCF    xE6.0
6ADE:  BTFSC  01.0
6AE0:  BSF    xE6.0
.................... 
....................                if (doneSend)
6AE2:  BTFSS  xE6.0
6AE4:  BRA    6B00
....................                {
....................                   //if (http_isKeepAlive[hs])
....................                   //   http_state[hs]=HTTP_CONNECTED;
....................                   //else
....................                   //   http_state[hs]=HTTP_CLOSE;
....................                   http_state[hs] = HTTP_CLOSE;
6AE6:  BCF    FD8.0
6AE8:  RLCF   xEC,W
6AEA:  CLRF   03
6AEC:  ADDLW  6F
6AEE:  MOVWF  FE9
6AF0:  MOVLW  00
6AF2:  ADDWFC 03,W
6AF4:  MOVWF  FEA
6AF6:  MOVLW  01
6AF8:  MOVWF  FEC
6AFA:  MOVF   FED,F
6AFC:  MOVLW  08
6AFE:  MOVWF  FEF
6B00:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs);
....................                }
....................             }
....................             /*else
....................             {
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n",
....................                      TCB[currSocket].RemoteWindow,
....................                      TCB[currSocket].TxBuffer,
....................                      TCB[currSocket].Flags.bIsPutReady
....................                   );
....................                delay_ms(100);
....................             }*/
....................             break;
6B02:  BRA    6C5A
.................... 
....................          case HTTP_CLOSE:
....................             //since we set connection: close in the header, the client
....................             //should automatically close.  but after so many seconds we
....................             //shall kill the connection
....................             http_state[hs]=HTTP_CLOSE_WAITING;
6B04:  BCF    FD8.0
6B06:  MOVLB  2
6B08:  RLCF   xEC,W
6B0A:  CLRF   03
6B0C:  ADDLW  6F
6B0E:  MOVWF  FE9
6B10:  MOVLW  00
6B12:  ADDWFC 03,W
6B14:  MOVWF  FEA
6B16:  MOVLW  01
6B18:  MOVWF  FEC
6B1A:  MOVF   FED,F
6B1C:  MOVLW  09
6B1E:  MOVWF  FEF
....................             http_timer[hs]=TickGet();
6B20:  BCF    FD8.0
6B22:  RLCF   xEC,W
6B24:  CLRF   03
6B26:  ADDLW  7B
6B28:  MOVWF  01
6B2A:  MOVLW  02
6B2C:  ADDWFC 03,F
6B2E:  MOVFF  01,2EE
6B32:  MOVFF  03,2EF
6B36:  MOVLB  0
6B38:  CALL   24E4
6B3C:  MOVFF  2EF,FEA
6B40:  MOVFF  2EE,FE9
6B44:  MOVFF  02,FEC
6B48:  MOVF   FED,F
6B4A:  MOVFF  01,FEF
.................... 
....................          case HTTP_CLOSE_WAITING:
....................             TCPDiscard(currSocket);
6B4E:  MOVFF  2ED,2F1
6B52:  CALL   4F9A
....................             if (  TCPIsPutReady(currSocket) ||
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5))
6B56:  MOVFF  2ED,311
6B5A:  CALL   4FE8
6B5E:  MOVF   01,F
6B60:  BNZ   6C2E
6B62:  CALL   24E4
6B66:  MOVFF  02,2EF
6B6A:  MOVFF  01,2EE
6B6E:  BCF    FD8.0
6B70:  MOVLB  2
6B72:  RLCF   xEC,W
6B74:  CLRF   03
6B76:  ADDLW  7B
6B78:  MOVWF  FE9
6B7A:  MOVLW  02
6B7C:  ADDWFC 03,W
6B7E:  MOVWF  FEA
6B80:  MOVFF  FEC,03
6B84:  MOVF   FED,F
6B86:  MOVFF  FEF,01
6B8A:  MOVF   02,W
6B8C:  SUBWF  03,W
6B8E:  BNC   6B98
6B90:  BNZ   6B9C
6B92:  MOVF   01,W
6B94:  SUBWF  xEE,W
6B96:  BNC   6B9C
6B98:  MOVLW  00
6B9A:  BRA    6B9E
6B9C:  MOVLW  01
6B9E:  CLRF   03
6BA0:  IORWF  03,W
6BA2:  BZ    6BE6
6BA4:  BCF    FD8.0
6BA6:  RLCF   xEC,W
6BA8:  CLRF   03
6BAA:  ADDLW  7B
6BAC:  MOVWF  FE9
6BAE:  MOVLW  02
6BB0:  ADDWFC 03,W
6BB2:  MOVWF  FEA
6BB4:  MOVFF  FEC,03
6BB8:  MOVF   FED,F
6BBA:  MOVF   FEF,W
6BBC:  SUBLW  FF
6BBE:  MOVWF  xEE
6BC0:  MOVLW  FF
6BC2:  SUBFWB 03,W
6BC4:  MOVWF  xEF
6BC6:  MOVLB  0
6BC8:  CALL   24E4
6BCC:  MOVF   01,W
6BCE:  MOVLB  2
6BD0:  ADDWF  xEE,F
6BD2:  MOVF   02,W
6BD4:  ADDWFC xEF,F
6BD6:  MOVLW  01
6BD8:  ADDWF  xEE,W
6BDA:  MOVWF  01
6BDC:  MOVLW  00
6BDE:  ADDWFC xEF,W
6BE0:  MOVWF  03
6BE2:  MOVF   01,W
6BE4:  BRA    6C16
6BE6:  MOVLB  0
6BE8:  CALL   24E4
6BEC:  MOVFF  02,2EF
6BF0:  BCF    FD8.0
6BF2:  MOVLB  2
6BF4:  RLCF   xEC,W
6BF6:  CLRF   03
6BF8:  ADDLW  7B
6BFA:  MOVWF  FE9
6BFC:  MOVLW  02
6BFE:  ADDWFC 03,W
6C00:  MOVWF  FEA
6C02:  MOVFF  FEC,03
6C06:  MOVF   FED,F
6C08:  MOVF   FEF,W
6C0A:  SUBWF  01,W
6C0C:  MOVWF  00
6C0E:  MOVF   03,W
6C10:  SUBWFB 02,W
6C12:  MOVWF  03
6C14:  MOVF   00,W
6C16:  MOVWF  xEE
6C18:  MOVFF  03,2EF
6C1C:  MOVF   xEF,F
6C1E:  BTFSC  FD8.2
6C20:  BRA    6C26
6C22:  MOVLB  0
6C24:  BRA    6C2E
6C26:  MOVF   xEE,W
6C28:  SUBLW  32
6C2A:  BC    6C52
6C2C:  MOVLB  0
....................                )
....................             {
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs);
....................                TCPDisconnect(currSocket);
6C2E:  MOVFF  2ED,2EE
6C32:  GOTO   5EFE
....................                http_state[hs]=HTTP_CLOSED;
6C36:  BCF    FD8.0
6C38:  MOVLB  2
6C3A:  RLCF   xEC,W
6C3C:  CLRF   03
6C3E:  ADDLW  6F
6C40:  MOVWF  FE9
6C42:  MOVLW  00
6C44:  ADDWFC 03,W
6C46:  MOVWF  FEA
6C48:  MOVLW  01
6C4A:  MOVWF  FEC
6C4C:  MOVF   FED,F
6C4E:  MOVLW  0A
6C50:  MOVWF  FEF
....................             }
....................             break;
6C52:  MOVLB  0
6C54:  BRA    6C5A
6C56:  MOVLB  2
.................... 
....................          case HTTP_CLOSED: //do nothing until socket actually closes
....................          default:
....................             break;
6C58:  MOVLB  0
....................       }
6C5A:  MOVLB  2
6C5C:  INCF   xEC,F
6C5E:  GOTO   6012
....................    }
6C62:  MOVLB  0
6C64:  GOTO   6E1C (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #if STACK_USE_HTTP2
....................    #include "tcpip/http2.c"
.................... #endif
.................... 
.................... #if STACK_USE_MPFS
....................    #include "tcpip/mpfs.c"
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    #include "tcpip/smtp.c"
.................... #endif
.................... 
.................... #if STACK_USE_DNS
....................    #include "tcpip/dns.c"
.................... #endif
.................... 
.................... #if STACK_USE_ANNOUNCE
....................    #include "tcpip/announce.h"
....................    #include "tcpip/announce.c"
.................... #endif
.................... 
.................... #if STACK_USE_SNMP
....................    #include "tcpip/snmp.c"
.................... #endif
.................... 
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h
.................... 
.................... /*
....................  * Stack FSM states.
....................  */
.................... typedef enum _SM_STACK
.................... {
....................     SM_STACK_IDLE=0,
....................     SM_STACK_MAC,
....................     SM_STACK_IP,
....................     SM_STACK_ICMP,
....................     SM_STACK_ICMP_REPLY,
....................     SM_STACK_ARP,
....................     SM_STACK_TCP,
....................     SM_STACK_UDP
.................... } SM_STACK;
.................... 
.................... static SM_STACK smStack;
.................... 
.................... NODE_INFO remoteNode;
.................... 
.................... 
.................... /*********************************************************************
....................  * Function:        void StackInit(void)
....................  *
....................  * PreCondition:    None
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack and its componets are initialized
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This function must be called before any of the
....................  *                  stack or its component routines are used.
....................  *
....................  ********************************************************************/
.................... void StackInit(void)
.................... {
....................     smStack                     = SM_STACK_IDLE;
*
1074:  MOVLB  2
1076:  CLRF   x7D
.................... 
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP
....................     /*
....................      * If DHCP or IP Gleaning is enabled,
....................      * startup in Config Mode.
....................      */
....................     AppConfig.Flags.bInConfigMode = TRUE;
.................... #endif
.................... 
....................    TickInit();
1078:  MOVLB  0
107A:  GOTO   07BE
.................... 
.................... #if STACK_USE_MAC
....................     MACInit();
107E:  BRA    0ACC
.................... #endif
.................... 
.................... #if STACK_USE_ARP
....................     ARPInit();
1080:  BRA    0C9A
.................... #endif
.................... 
.................... #if STACK_USE_UDP
....................     UDPInit();
.................... #endif
.................... 
.................... #if STACK_USE_TCP
....................     TCPInit();
1082:  BRA    0DDE
.................... #endif
.................... 
.................... #if STACK_USE_DHCP
....................    DHCPReset();
.................... #endif
.................... 
.................... #if STACK_USE_PPP
....................    ppp_init();
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    TelnetInit();
.................... #endif
.................... 
.................... #if STACK_USE_SMTP
....................    SMTPInit();
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    HTTP_Init();
1084:  BRA    100A
.................... #endif
1086:  GOTO   6F76 (RETURN)
.................... }
.................... 
.................... /*
.................... #if STACK_USE_MCPENC
.................... #if MAC_TX_BUFFER_COUNT > 1
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val)
.................... #else
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val)
.................... #endif
.................... #else
....................  #define DebugDisplayVals()
.................... #endif
.................... */
.................... 
.................... #define DebugDisplayVals()
.................... 
.................... /*********************************************************************
....................  * Function:        void StackTask(void)
....................  *
....................  * PreCondition:    StackInit() is already called.
....................  *
....................  * Input:           None
....................  *
....................  * Output:          Stack FSM is executed.
....................  *
....................  * Side Effects:    None
....................  *
....................  * Note:            This FSM checks for new incoming packets,
....................  *                  and routes it to appropriate stack components.
....................  *                  It also performs timed operations.
....................  *
....................  *                  This function must be called periodically to
....................  *                  ensure timely responses.
....................  *
....................  ********************************************************************/
.................... void StackTask(void)
*
6C68:  MOVLB  2
6C6A:  BCF    xE5.0
.................... {
....................     static WORD dataCount;
.................... 
.................... #if STACK_USE_ICMP
....................     static BYTE data[MAX_ICMP_DATA_LEN];
....................     static WORD ICMPId;
....................     static WORD ICMPSeq;
.................... #endif
....................     IP_ADDR tempLocalIP;
.................... 
.................... 
....................     union
....................     {
....................         BYTE MACFrameType;
....................         BYTE IPFrameType;
.................... #if STACK_USE_ICMP
....................         ICMP_CODE ICMPCode;
.................... #endif
....................     } type;
.................... 
.................... 
....................     BOOL lbContinue=FALSE;
.................... 
....................     do
....................     {
....................         lbContinue = FALSE;
6C6C:  BCF    xE5.0
....................         switch(smStack)
6C6E:  MOVF   x7D,W
6C70:  ADDLW  F9
6C72:  BTFSC  FD8.0
6C74:  BRA    6E0E
6C76:  ADDLW  07
6C78:  MOVLB  0
6C7A:  GOTO   6E20
....................         {
....................         case SM_STACK_IDLE:
....................         case SM_STACK_MAC:
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) )
6C7E:  MOVLW  02
6C80:  MOVLB  2
6C82:  MOVWF  xE7
6C84:  MOVLW  7E
6C86:  MOVWF  xE6
6C88:  MOVLW  02
6C8A:  MOVWF  xE9
6C8C:  MOVLW  E4
6C8E:  MOVWF  xE8
6C90:  MOVLB  0
6C92:  GOTO   1246
6C96:  MOVF   01,F
6C98:  BNZ   6CA0
....................             {
....................                 #if STACK_USE_DHCP
....................                     // Normally, an application would not include  DHCP module
....................                     // if it is not enabled. But in case some one wants to disable
....................                     // DHCP module at run-time, remember to not clear our IP
....................                     // address if link is removed.
....................                     if ( !DHCPIsDisabled() )
....................                     {
....................                         if ( !MACIsLinked() )
....................                         {
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul;
....................                             AppConfig.Flags.bInConfigMode = TRUE;
....................                             DHCPReset();
....................                         }
....................                     }
....................                 #endif
....................                 break;
6C9A:  MOVLB  2
6C9C:  BRA    6E0E
6C9E:  MOVLB  0
....................             }
.................... 
.................... //            debug_stack("\r\nMAC GET ");
.................... 
....................             lbContinue = TRUE;
6CA0:  MOVLB  2
6CA2:  BSF    xE5.0
....................             if ( type.MACFrameType == MAC_IP ) {
6CA4:  MOVF   xE4,F
6CA6:  BNZ   6CAE
....................                 smStack = SM_STACK_IP;
6CA8:  MOVLW  02
6CAA:  MOVWF  x7D
.................... //                debug_stack("IP ");
....................             }
6CAC:  BRA    6CC2
....................             else if ( type.MACFrameType == MAC_ARP ) {
6CAE:  MOVF   xE4,W
6CB0:  SUBLW  06
6CB2:  BNZ   6CBA
....................                 smStack = SM_STACK_ARP;
6CB4:  MOVLW  05
6CB6:  MOVWF  x7D
.................... //                debug_stack("ARP ");
....................             }
6CB8:  BRA    6CC2
....................             else {
....................                 MACDiscardRx();
6CBA:  MOVLB  0
6CBC:  CALL   1164
6CC0:  MOVLB  2
.................... //                debug_stack("DISCARD");
....................             }
....................             break;
6CC2:  BRA    6E0E
.................... 
....................         case SM_STACK_ARP:
.................... #if STACK_USE_ARP
....................             if ( ARPProcess() ) {
6CC4:  GOTO   1AC0
6CC8:  MOVF   01,F
6CCA:  BZ    6CD2
....................                 smStack = SM_STACK_IDLE;
6CCC:  MOVLB  2
6CCE:  CLRF   x7D
6CD0:  MOVLB  0
....................             }
.................... #else
....................             smStack = SM_STACK_IDLE;
.................... #endif
....................             break;
6CD2:  MOVLB  2
6CD4:  BRA    6E0E
.................... 
....................         case SM_STACK_IP:
....................             if ( IPGetHeader(&tempLocalIP,
....................                              &remoteNode,
....................                              &type.IPFrameType,
....................                              &dataCount) )
6CD6:  MOVLW  02
6CD8:  MOVLB  2
6CDA:  MOVWF  xE7
6CDC:  MOVLW  E0
6CDE:  MOVWF  xE6
6CE0:  MOVLW  02
6CE2:  MOVWF  xE9
6CE4:  MOVLW  7E
6CE6:  MOVWF  xE8
6CE8:  MOVLW  02
6CEA:  MOVWF  xEB
6CEC:  MOVLW  E4
6CEE:  MOVWF  xEA
6CF0:  MOVLW  02
6CF2:  MOVWF  xED
6CF4:  MOVLW  88
6CF6:  MOVWF  xEC
6CF8:  MOVLB  0
6CFA:  GOTO   1D9A
6CFE:  MOVF   01,F
6D00:  BZ    6D2C
....................             {
....................                 lbContinue = TRUE;
6D02:  MOVLB  2
6D04:  BSF    xE5.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP )
6D06:  DECFSZ xE4,W
6D08:  BRA    6D10
....................                 {
....................                     smStack = SM_STACK_ICMP;
6D0A:  MOVLW  03
6D0C:  MOVWF  x7D
.................... //                    debug_stack("ICMP ");
.................... #if STACK_USE_IP_GLEANING
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled())
....................                     {
....................                         /*
....................                          * Accoriding to "IP Gleaning" procedure,
....................                          * when we receive an ICMP packet with a valid
....................                          * IP address while we are still in configuration
....................                          * mode, accept that address as ours and conclude
....................                          * configuration mode.
....................                          */
....................                         if( tempLocalIP.Val != 0xffffffff )
....................                         {
....................                             AppConfig.Flags.bInConfigMode = FALSE;
....................                             AppConfig.MyIPAddr = tempLocalIP;
....................                             myDHCPBindCount--;
....................                         }
....................                     }
.................... #endif
....................                 }
.................... 
.................... #if STACK_USE_TCP
6D0E:  BRA    6D28
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) {
6D10:  MOVF   xE4,W
6D12:  SUBLW  06
6D14:  BNZ   6D1C
....................                     smStack = SM_STACK_TCP;
6D16:  MOVLW  06
6D18:  MOVWF  x7D
....................                     debug_stack("TCP ");
....................                 }
.................... #endif
.................... 
.................... #if STACK_USE_UDP
6D1A:  BRA    6D28
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) {
....................                     smStack = SM_STACK_UDP;
.................... //                    debug_stack("UDP ");
....................                 }
.................... #endif
.................... 
....................                 else
....................                 {
....................                     lbContinue = FALSE;
6D1C:  BCF    xE5.0
....................                     MACDiscardRx();
6D1E:  MOVLB  0
6D20:  CALL   1164
.................... 
....................                     smStack = SM_STACK_IDLE;
6D24:  MOVLB  2
6D26:  CLRF   x7D
.................... //                    debug_stack("UNKOWN-IP1 ");
....................                 }
....................             }
6D28:  BRA    6D34
6D2A:  MOVLB  0
....................             else
....................             {
....................                 MACDiscardRx();
6D2C:  CALL   1164
....................                 smStack = SM_STACK_IDLE;
6D30:  MOVLB  2
6D32:  CLRF   x7D
.................... //                debug_stack("UNKOWN-IP2 ");
....................             }
....................             break;
6D34:  BRA    6E0E
.................... 
.................... #if STACK_USE_UDP
....................         case SM_STACK_UDP:
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) )
....................             {
.................... //                debug_stack("\r\nUDP PROCESSED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
....................             }
....................             break;
.................... #endif
.................... 
.................... #if STACK_USE_TCP
....................         case SM_STACK_TCP:
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) )
6D36:  MOVLW  02
6D38:  MOVLB  2
6D3A:  MOVWF  xE7
6D3C:  MOVLW  7E
6D3E:  MOVWF  xE6
6D40:  MOVLW  02
6D42:  MOVWF  xE9
6D44:  MOVLW  E0
6D46:  MOVWF  xE8
6D48:  MOVFF  289,2EB
6D4C:  MOVFF  288,2EA
6D50:  MOVLB  0
6D52:  GOTO   3548
6D56:  MOVF   01,F
6D58:  BZ    6D60
....................             {
....................                 debug_stack("\r\nTCP PROCESSED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
6D5A:  MOVLB  2
6D5C:  CLRF   x7D
6D5E:  MOVLB  0
....................             }
....................             break;
6D60:  MOVLB  2
6D62:  BRA    6E0E
.................... #endif
.................... 
....................         case SM_STACK_ICMP:
....................             smStack = SM_STACK_IDLE;
6D64:  MOVLB  2
6D66:  CLRF   x7D
.................... 
.................... #if STACK_USE_ICMP
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) )
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) )
6D68:  MOVF   x89,F
6D6A:  BNZ   6DBA
6D6C:  MOVF   x88,W
6D6E:  SUBLW  48
6D70:  BNC   6DBA
....................             {
....................                 if ( ICMPGet(&type.ICMPCode,
....................                              data,
....................                              (BYTE*)&dataCount,
....................                              &ICMPId,
....................                              &ICMPSeq) )
6D72:  MOVLW  02
6D74:  MOVWF  xE7
6D76:  MOVLW  88
6D78:  MOVWF  xE6
6D7A:  MOVLW  02
6D7C:  MOVWF  xE9
6D7E:  MOVLW  E4
6D80:  MOVWF  xE8
6D82:  MOVLW  02
6D84:  MOVWF  xEB
6D86:  MOVLW  8A
6D88:  MOVWF  xEA
6D8A:  MOVFF  2E7,2ED
6D8E:  MOVFF  2E6,2EC
6D92:  MOVLW  02
6D94:  MOVWF  xEF
6D96:  MOVLW  CA
6D98:  MOVWF  xEE
6D9A:  MOVLW  02
6D9C:  MOVWF  xF1
6D9E:  MOVLW  CC
6DA0:  MOVWF  xF0
6DA2:  MOVLB  0
6DA4:  GOTO   37B2
6DA8:  MOVF   01,F
6DAA:  BZ    6DBC
....................                 {
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST )
6DAC:  MOVLB  2
6DAE:  MOVF   xE4,W
6DB0:  SUBLW  08
6DB2:  BNZ   6DBA
....................                     {
.................... //                        debug_stack("\r\nICMP PROCESSED");
....................                         lbContinue = TRUE;
6DB4:  BSF    xE5.0
....................                         smStack = SM_STACK_ICMP_REPLY;
6DB6:  MOVLW  04
6DB8:  MOVWF  x7D
6DBA:  MOVLB  0
....................                     }
....................                 }
....................             }
....................             DebugDisplayVals();
.................... #endif
....................             MACDiscardRx();
6DBC:  CALL   1164
....................             break;
6DC0:  MOVLB  2
6DC2:  BRA    6E0E
.................... 
.................... #if STACK_USE_ICMP
....................         case SM_STACK_ICMP_REPLY:
....................             if ( ICMPIsTxReady() )
6DC4:  MOVLW  01
6DC6:  MOVLB  3
6DC8:  MOVWF  x6F
6DCA:  MOVLB  0
6DCC:  CALL   25F2
6DD0:  MOVF   01,F
6DD2:  BZ    6E08
....................             {
....................                 ICMPPut(&remoteNode,
....................                         ICMP_ECHO_REPLY,
....................                         data,
....................                         (BYTE)dataCount,
....................                         ICMPId,
....................                         ICMPSeq);
6DD4:  MOVLW  02
6DD6:  MOVLB  2
6DD8:  MOVWF  xE7
6DDA:  MOVLW  7E
6DDC:  MOVWF  xE6
6DDE:  CLRF   xE8
6DE0:  MOVLW  02
6DE2:  MOVWF  xEA
6DE4:  MOVLW  8A
6DE6:  MOVWF  xE9
6DE8:  MOVFF  288,2EB
6DEC:  MOVFF  2CB,2ED
6DF0:  MOVFF  2CA,2EC
6DF4:  MOVFF  2CD,2EF
6DF8:  MOVFF  2CC,2EE
6DFC:  MOVLB  0
6DFE:  GOTO   3882
.................... 
.................... //                debug_stack("\r\nICMP REPLIED");
....................                 DebugDisplayVals();
....................                 smStack = SM_STACK_IDLE;
6E02:  MOVLB  2
6E04:  CLRF   x7D
6E06:  MOVLB  0
....................             }
....................             break;
6E08:  MOVLB  2
6E0A:  BRA    6E0E
6E0C:  MOVLB  2
.................... #endif
.................... 
....................         }
.................... 
....................     } while( lbContinue );
6E0E:  BTFSC  xE5.0
6E10:  BRA    6C6C
.................... 
.................... #if STACK_USE_SMTP
....................    SMTPTask();
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_TCP
....................     // Perform timed TCP FSM.
....................     TCPTick();
6E12:  MOVLB  0
6E14:  GOTO   399C
.................... #endif
.................... 
.................... #if STACK_USE_TELNET
....................    TelnetTask();
.................... #endif
.................... 
.................... #if STACK_USE_HTTP
....................    HTTP_Task();
6E18:  GOTO   600E
.................... #endif
.................... 
.................... 
.................... #if STACK_USE_DHCP
6E1C:  GOTO   7018 (RETURN)
....................     /*
....................      * DHCP must be called all the time even after IP configuration is
....................      * discovered.
....................      * DHCP has to account lease expiration time and renew the configuration
....................      * time.
....................      */
....................     DHCPTask();
.................... 
....................     if ( DHCPIsBound() )
....................         AppConfig.Flags.bInConfigMode = FALSE;
.................... 
.................... #endif
.................... 
.................... 
.................... }
.................... 
.................... /******************************************************************************/
.................... 
.................... /*********************  PAGINA WEB A MOSTRAR **********************************/
.................... /* Página principal INDEX (/) */
.................... const char  HTML_INDEX_PAGE[]="
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000>
.................... 
.................... <center><H1>BeepControl </H1></center>
.................... <BR><center><H2>Dashboard</H2></CENTER>
.................... 
.................... 
.................... <FORM METHOD=GET>
.................... <P>LCD: <INPUT TYPE=\"text\" NAME=\"lcd\" size=20 maxlength=16>
.................... <input type=\"submit\" value=\"Enviar texto\">
.................... </FORM>
.................... 
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM1\" value=\"A\">
.................... <input type=\"submit\" name=\"CM1\" value=\"C\">
.................... <input type=\"submit\" name=\"CM1\" value=\"AC\">
.................... </FORM>
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM2\" value=\"A\">
.................... <input type=\"submit\" name=\"CM2\" value=\"C\">
.................... <input type=\"submit\" name=\"CM2\" value=\"AC\">
.................... </FORM>
.................... <FORM METHOD=GET>
.................... <input type=\"submit\" name=\"CM3\" value=\"A\">
.................... <input type=\"submit\" name=\"CM3\" value=\"C\">
.................... <input type=\"submit\" name=\"CM3\" value=\"AC\">
.................... </FORM>
.................... </BODY></HTML>
.................... ";
.................... 
.................... /* Elección de MAC. No puede haber 2 dispositivos con misma MAC en una misma red
....................    Microchip Vendor ID  MAC: 00.04.A3.xx.xx.xx.  */
.................... void MACAddrInit(void) {
....................    MY_MAC_BYTE1=0;
*
077A:  CLRF   21
....................    MY_MAC_BYTE2=0x04;
077C:  MOVLW  04
077E:  MOVWF  22
....................    MY_MAC_BYTE3=0xA3;
0780:  MOVLW  A3
0782:  MOVWF  23
....................    MY_MAC_BYTE4=0x06;
0784:  MOVLW  06
0786:  MOVWF  24
....................    MY_MAC_BYTE5=0x07;
0788:  MOVLW  07
078A:  MOVWF  25
....................    MY_MAC_BYTE6=0x08;
078C:  MOVLW  08
078E:  MOVWF  26
0790:  GOTO   6F6E (RETURN)
.................... }
.................... 
.................... void IPAddrInit(void) {
....................    //Elección de la dirección IP. 
....................    MY_IP_BYTE1=192;
0794:  MOVLW  C0
0796:  MOVWF  1D
....................    MY_IP_BYTE2=168;
0798:  MOVLW  A8
079A:  MOVWF  1E
....................    MY_IP_BYTE3=1;
079C:  MOVLW  01
079E:  MOVWF  1F
....................    MY_IP_BYTE4=15;
07A0:  MOVLW  0F
07A2:  MOVWF  20
.................... 
....................    //Elección de la dirección de puerta de enlace. 
....................    MY_GATE_BYTE1=192;
07A4:  MOVLW  C0
07A6:  MOVWF  2B
....................    MY_GATE_BYTE2=168;
07A8:  MOVLW  A8
07AA:  MOVWF  2C
....................    MY_GATE_BYTE3=1;
07AC:  MOVLW  01
07AE:  MOVWF  2D
....................    MY_GATE_BYTE4=1;
07B0:  MOVWF  2E
.................... 
....................    //Elección de la máscara de red.Si no se indica nada se tomará 255.255.255.0
....................    MY_MASK_BYTE1=255;
07B2:  SETF   27
....................    MY_MASK_BYTE2=255;
07B4:  SETF   28
....................    MY_MASK_BYTE3=255;
07B6:  SETF   29
....................    MY_MASK_BYTE4=0;
07B8:  CLRF   2A
07BA:  GOTO   6F72 (RETURN)
.................... }
.................... 
.................... void moveServo(int16 puerto,int16 tiempo){
.................... unsigned int i;
....................    for(i=0;i<60;i++){ 
*
49C2:  MOVLB  3
49C4:  CLRF   x16
49C6:  MOVF   x16,W
49C8:  SUBLW  3B
49CA:  BNC   4A58
....................       output_toggle(puerto);
49CC:  MOVFF  312,317
49D0:  MOVLW  0F
49D2:  MOVWF  x19
49D4:  MOVLW  80
49D6:  MOVWF  x18
49D8:  MOVLB  0
49DA:  BRA    496A
49DC:  MOVLW  00
49DE:  BTFSS  01.0
49E0:  MOVLW  01
49E2:  MOVFF  312,317
49E6:  MOVLB  3
49E8:  MOVWF  x18
49EA:  MOVLW  0F
49EC:  MOVWF  x1A
49EE:  MOVLW  89
49F0:  MOVWF  x19
49F2:  MOVLB  0
49F4:  RCALL  4928
49F6:  MOVFF  312,317
49FA:  MOVLB  3
49FC:  CLRF   x18
49FE:  MOVLW  0F
4A00:  MOVWF  x1A
4A02:  MOVLW  92
4A04:  MOVWF  x19
4A06:  MOVLB  0
4A08:  RCALL  4928
....................       delay_us(tiempo);
4A0A:  MOVFF  315,317
4A0E:  MOVLB  3
4A10:  INCF   x17,F
4A12:  DECF   x17,F
4A14:  BTFSC  FD8.2
4A16:  BRA    4A22
4A18:  SETF   x18
4A1A:  MOVLB  0
4A1C:  RCALL  49A2
4A1E:  MOVLB  3
4A20:  BRA    4A12
4A22:  MOVFF  314,318
4A26:  MOVLB  0
4A28:  RCALL  49A2
....................       output_low(puerto);
4A2A:  MOVFF  312,317
4A2E:  MOVLB  3
4A30:  CLRF   x18
4A32:  MOVLW  0F
4A34:  MOVWF  x1A
4A36:  MOVLW  89
4A38:  MOVWF  x19
4A3A:  MOVLB  0
4A3C:  RCALL  4928
4A3E:  MOVFF  312,317
4A42:  MOVLB  3
4A44:  CLRF   x18
4A46:  MOVLW  0F
4A48:  MOVWF  x1A
4A4A:  MOVLW  92
4A4C:  MOVWF  x19
4A4E:  MOVLB  0
4A50:  RCALL  4928
4A52:  MOVLB  3
4A54:  INCF   x16,F
4A56:  BRA    49C6
....................     }
4A58:  MOVLB  0
4A5A:  RETURN 0
.................... }
.................... 
.................... void servoAccion(int servo, int accion)   //180 Degree
4A5C:  MOVLW  7C
4A5E:  MOVLB  3
4A60:  MOVWF  x0D
4A62:  MOVLW  10
4A64:  MOVWF  x0C
4A66:  MOVLW  01
4A68:  MOVWF  x0F
4A6A:  MOVLW  64
4A6C:  MOVWF  x0E
4A6E:  MOVLW  08
4A70:  MOVWF  x11
4A72:  MOVLW  66
4A74:  MOVWF  x10
.................... {
.................... int16 puerto = PIN_C0;
.................... int16 tiempoCerrar = 356;
.................... int16 tiempoAbrir = 2150;
.................... 
.................... switch(servo){
4A76:  MOVF   x0A,W
4A78:  XORLW  01
4A7A:  MOVLB  0
4A7C:  BZ    4A88
4A7E:  XORLW  03
4A80:  BZ    4A96
4A82:  XORLW  01
4A84:  BZ    4AA4
4A86:  BRA    4AB0
....................    case 1:
....................       puerto = PIN_C0; break;
4A88:  MOVLW  7C
4A8A:  MOVLB  3
4A8C:  MOVWF  x0D
4A8E:  MOVLW  10
4A90:  MOVWF  x0C
4A92:  MOVLB  0
4A94:  BRA    4AB0
....................    case 2:
....................       puerto = PIN_C1; break;
4A96:  MOVLW  7C
4A98:  MOVLB  3
4A9A:  MOVWF  x0D
4A9C:  MOVLW  11
4A9E:  MOVWF  x0C
4AA0:  MOVLB  0
4AA2:  BRA    4AB0
....................    case 3:
....................       puerto = PIN_C2; break;
4AA4:  MOVLW  7C
4AA6:  MOVLB  3
4AA8:  MOVWF  x0D
4AAA:  MOVLW  12
4AAC:  MOVWF  x0C
4AAE:  MOVLB  0
.................... }
.................... 
.................... output_low(puerto); //Me aseguro que este apagado
4AB0:  MOVFF  30C,317
4AB4:  MOVLB  3
4AB6:  CLRF   x18
4AB8:  MOVLW  0F
4ABA:  MOVWF  x1A
4ABC:  MOVLW  89
4ABE:  MOVWF  x19
4AC0:  MOVLB  0
4AC2:  RCALL  4928
4AC4:  MOVFF  30C,317
4AC8:  MOVLB  3
4ACA:  CLRF   x18
4ACC:  MOVLW  0F
4ACE:  MOVWF  x1A
4AD0:  MOVLW  92
4AD2:  MOVWF  x19
4AD4:  MOVLB  0
4AD6:  RCALL  4928
.................... 
.................... switch(accion){
4AD8:  MOVLB  3
4ADA:  MOVF   x0B,W
4ADC:  XORLW  00
4ADE:  MOVLB  0
4AE0:  BZ    4AEC
4AE2:  XORLW  01
4AE4:  BZ    4B00
4AE6:  XORLW  03
4AE8:  BZ    4B14
4AEA:  BRA    4B62
....................    case 0: //Cerrar
....................       moveServo(puerto,tiempoCerrar);
4AEC:  MOVFF  30D,313
4AF0:  MOVFF  30C,312
4AF4:  MOVFF  30F,315
4AF8:  MOVFF  30E,314
4AFC:  RCALL  49C2
....................       break;
4AFE:  BRA    4B62
....................    case 1: //Abrir 180 grados
....................       moveServo(puerto,tiempoAbrir);
4B00:  MOVFF  30D,313
4B04:  MOVFF  30C,312
4B08:  MOVFF  311,315
4B0C:  MOVFF  310,314
4B10:  RCALL  49C2
....................       break;
4B12:  BRA    4B62
....................    case 2: //Abre y cierra
....................       moveServo(puerto,tiempoCerrar); //Me aseguro que se cierre
4B14:  MOVFF  30D,313
4B18:  MOVFF  30C,312
4B1C:  MOVFF  30F,315
4B20:  MOVFF  30E,314
4B24:  RCALL  49C2
....................       moveServo(puerto,tiempoAbrir); //Lo abro
4B26:  MOVFF  30D,313
4B2A:  MOVFF  30C,312
4B2E:  MOVFF  311,315
4B32:  MOVFF  310,314
4B36:  RCALL  49C2
....................       delay_ms(1000); //Espero un segundo en maquina virtual, en no virtual es 3000 ms
4B38:  MOVLW  04
4B3A:  MOVLB  3
4B3C:  MOVWF  x12
4B3E:  MOVLW  FA
4B40:  MOVWF  x13
4B42:  MOVLB  0
4B44:  CALL   04E2
4B48:  MOVLB  3
4B4A:  DECFSZ x12,F
4B4C:  BRA    4B3E
....................       moveServo(puerto,tiempoCerrar); //Lo cierro
4B4E:  MOVFF  30D,313
4B52:  MOVFF  30C,312
4B56:  MOVFF  30F,315
4B5A:  MOVFF  30E,314
4B5E:  MOVLB  0
4B60:  RCALL  49C2
....................       break;
....................       }
4B62:  RETURN 0
.................... }
.................... 
.................... 
.................... /***************************  FUNCIÓN GET PAGE   ******************************/
.................... /* Esta función devuelve la posición de memoria donde se encuentra la página web 
.................... a mostrar. En este caso se trata de una web con 2 páginas. Una principal index(/) 
.................... y una secundaria(/lecturas)                                                   */
.................... 
.................... int32 http_get_page(char *file_str) {
*
4892:  MOVLB  2
4894:  CLRF   xF5
4896:  CLRF   xF4
4898:  CLRF   xF3
489A:  CLRF   xF2
....................    int32 file_loc=0;
....................    static char index[]="/";
....................  
....................    
....................    //printf(lcd_putc,"\fRequest %s ",file_str);      //Muestra en lcd solicitud
.................... 
....................    /* Busca la posición de memoria donde se encuentra la página solicitada */
....................    if (stricmp(file_str,index)==0)                 //Si es la principal...
489C:  MOVFF  2F1,30B
48A0:  MOVFF  2F0,30A
48A4:  MOVLW  02
48A6:  MOVLB  3
48A8:  MOVWF  x0D
48AA:  MOVLW  CE
48AC:  MOVWF  x0C
48AE:  MOVLB  0
48B0:  RCALL  479E
48B2:  MOVLB  2
48B4:  CLRF   xF7
48B6:  MOVFF  01,2F6
48BA:  BTFSC  01.7
48BC:  DECF   xF7,F
48BE:  MOVF   xF6,F
48C0:  BNZ   48D6
48C2:  MOVF   xF7,F
48C4:  BNZ   48D6
....................       file_loc=label_address(HTML_INDEX_PAGE);     //...toma su posición en la memoria
48C6:  MOVLW  01
48C8:  MOVWF  03
48CA:  MOVLW  B8
48CC:  MOVWF  xF2
48CE:  MOVFF  03,2F3
48D2:  CLRF   xF4
48D4:  CLRF   xF5
.................... 
....................    return(file_loc);
48D6:  MOVFF  2F2,00
48DA:  MOVFF  2F3,01
48DE:  MOVFF  2F4,02
48E2:  MOVFF  2F5,03
48E6:  MOVLB  0
48E8:  GOTO   63D2 (RETURN)
.................... }
.................... 
.................... /**************************  FUNCIÓN FORMAT CHAR  *****************************/
.................... /* Con  la función http_format_char  interconectamos las variables virtuales de 
.................... la página web con las variables del programa del PIC. Se encarga de enviar los 
.................... cambios producidos en la aplicación del PIC y reflejarlos en la aplicación web. 
.................... Muestra,por tanto, las lectura obtenidas por el PIC y las representa en la 
.................... aplicación de la página web      
.................... 
.................... %0 es la variable virtual para representar el valor de la lectura del canal 
.................... analógico
.................... %1 es la variable virtual para representar el valor de la lectura del bit 0 del 
.................... puerto E.
.................... */
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret) {
*
5A94:  MOVLB  3
5A96:  CLRF   x1A
....................    char new_str[20];
....................    int8 len=0;
....................    int8 AD0;
....................    int8 RE0;
.................... 
....................    *str=0;
5A98:  MOVFF  304,FEA
5A9C:  MOVFF  303,FE9
5AA0:  CLRF   FEF
.................... 
....................    switch(id) {
5AA2:  MOVF   x02,W
5AA4:  XORLW  30
5AA6:  MOVLB  0
5AA8:  BZ    5AB0
5AAA:  XORLW  01
5AAC:  BZ    5B10
5AAE:  BRA    5B46
....................       case '0':
....................          set_adc_channel(0);
5AB0:  MOVLW  00
5AB2:  MOVWF  01
5AB4:  MOVF   FC2,W
5AB6:  ANDLW  C3
5AB8:  IORWF  01,W
5ABA:  MOVWF  FC2
....................          delay_us(100);
5ABC:  MOVLW  A6
5ABE:  MOVWF  00
5AC0:  DECFSZ 00,F
5AC2:  BRA    5AC0
5AC4:  NOP   
....................          AD0=read_adc();
5AC6:  BSF    FC2.1
5AC8:  BTFSC  FC2.1
5ACA:  BRA    5AC8
5ACC:  MOVFF  FC4,31B
....................          sprintf(new_str,"0x%X",AD0);
5AD0:  MOVLW  03
5AD2:  MOVWF  x7A
5AD4:  MOVLW  06
5AD6:  MOVWF  x79
5AD8:  MOVLW  30
5ADA:  MOVLB  3
5ADC:  MOVWF  x23
5ADE:  MOVLB  0
5AE0:  RCALL  58E4
5AE2:  MOVLW  78
5AE4:  MOVLB  3
5AE6:  MOVWF  x23
5AE8:  MOVLB  0
5AEA:  RCALL  58E4
5AEC:  MOVFF  31B,31D
5AF0:  MOVLW  37
5AF2:  MOVLB  3
5AF4:  MOVWF  x1E
5AF6:  MOVLB  0
5AF8:  BRA    5902
....................          len=strlen(new_str);
5AFA:  MOVLW  03
5AFC:  MOVLB  3
5AFE:  MOVWF  x1E
5B00:  MOVLW  06
5B02:  MOVWF  x1D
5B04:  MOVLB  0
5B06:  CALL   4050
5B0A:  MOVFF  01,31A
....................       break;
5B0E:  BRA    5B4C
....................       case '1':
....................          RE0=bit_test(porte,0);
5B10:  MOVLB  3
5B12:  CLRF   x1C
5B14:  BTFSC  F84.0
5B16:  INCF   x1C,F
....................          sprintf(new_str,"%d",RE0);
5B18:  MOVLW  03
5B1A:  MOVLB  0
5B1C:  MOVWF  x7A
5B1E:  MOVLW  06
5B20:  MOVWF  x79
5B22:  MOVFF  31C,31D
5B26:  MOVLW  18
5B28:  MOVLB  3
5B2A:  MOVWF  x1E
5B2C:  MOVLB  0
5B2E:  BRA    594A
....................          len=strlen(new_str);
5B30:  MOVLW  03
5B32:  MOVLB  3
5B34:  MOVWF  x1E
5B36:  MOVLW  06
5B38:  MOVWF  x1D
5B3A:  MOVLB  0
5B3C:  CALL   4050
5B40:  MOVFF  01,31A
....................       break;  
5B44:  BRA    5B4C
....................       default:
....................       len=0;
5B46:  MOVLB  3
5B48:  CLRF   x1A
5B4A:  MOVLB  0
....................    }
.................... 
....................    if (len)strncpy(str, new_str, max_ret);
5B4C:  MOVLB  3
5B4E:  MOVF   x1A,F
5B50:  BZ    5B72
5B52:  MOVFF  304,31E
5B56:  MOVFF  303,31D
5B5A:  MOVLW  03
5B5C:  MOVWF  x20
5B5E:  MOVLW  06
5B60:  MOVWF  x1F
5B62:  CLRF   x22
5B64:  MOVFF  305,321
5B68:  MOVLB  0
5B6A:  BRA    5A0C
5B6C:  MOVLB  0
5B6E:  BRA    5B7E
5B70:  MOVLB  3
....................    else  *str=0;
5B72:  MOVFF  304,FEA
5B76:  MOVFF  303,FE9
5B7A:  CLRF   FEF
5B7C:  MOVLB  0
....................    
....................    return(len);
5B7E:  MOVLB  3
5B80:  MOVF   x1A,W
5B82:  MOVWF  01
5B84:  MOVLB  0
5B86:  GOTO   5E4C (RETURN)
.................... }
.................... 
.................... /***************************  FUNCIÓN EXEC CGI   ******************************/
.................... /* Con la función http_exec_cgi interconectamos las variables virtuales de la 
.................... página web con las variables del programa del PIC. Se encarga de recibir 
.................... los cambios producidos en la aplicación web y reflejarlos en el hardware del PIC. 
.................... Ejecuta, por tanto, la acción elegida según el valor de la variable virtual recibida 
.................... de la página web
.................... 
.................... key es la variable virtual que viene de la pagina web
.................... val es el valor de una variable virtual de la página web
.................... file es la dirección de la página web devuelta por http__page ()
.................... 
.................... */
.................... 
.................... void http_exec_cgi(int32 file, char *key, char *val) {
*
4B8C:  MOVLB  3
4B8E:  CLRF   x09
....................    static char boton1_key[]="CM1";
....................    static char boton2_key[]="CM2";
....................    static char boton3_key[]="CM3";
....................    static char lcd_key[]="lcd";
....................    int accionServo = 0;
....................    
....................    //Para ver en la pantalla los valores recibidos
....................   /*
....................    printf(lcd_putc,"\fCGI FILE=%LD", file);
....................    printf(lcd_putc,"\nKEY=%S", key);
....................    printf(lcd_putc,"\nVAL=%S", val);
....................   */
....................    
....................    switch (val){
4B90:  MOVLW  B8
4B92:  MOVWF  FF6
4B94:  MOVLW  04
4B96:  MOVWF  FF7
4B98:  MOVFF  308,FEA
4B9C:  MOVFF  307,FE9
4BA0:  BRA    48EC
4BA2:  MOVF   01,W
4BA4:  BZ    4BB0
4BA6:  XORLW  01
4BA8:  BZ    4BB8
4BAA:  XORLW  03
4BAC:  BZ    4BC2
4BAE:  BRA    4BCA
....................    case "C": accionServo = 0; break;
4BB0:  MOVLB  3
4BB2:  CLRF   x09
4BB4:  MOVLB  0
4BB6:  BRA    4BCA
....................    case "A": accionServo = 1; break;
4BB8:  MOVLW  01
4BBA:  MOVLB  3
4BBC:  MOVWF  x09
4BBE:  MOVLB  0
4BC0:  BRA    4BCA
....................    case "AC": accionServo = 2; break;
4BC2:  MOVLW  02
4BC4:  MOVLB  3
4BC6:  MOVWF  x09
4BC8:  MOVLB  0
....................    }
.................... 
.................... 
....................    /* Se ejecutará al recibir un request a CM1 */
....................    if (stricmp(key,boton1_key)==0) {
4BCA:  MOVFF  306,30B
4BCE:  MOVFF  305,30A
4BD2:  MOVLW  02
4BD4:  MOVLB  3
4BD6:  MOVWF  x0D
4BD8:  MOVLW  D0
4BDA:  MOVWF  x0C
4BDC:  MOVLB  0
4BDE:  RCALL  479E
4BE0:  MOVLB  3
4BE2:  CLRF   x0B
4BE4:  MOVFF  01,30A
4BE8:  BTFSC  01.7
4BEA:  DECF   x0B,F
4BEC:  MOVF   x0A,F
4BEE:  BNZ   4C02
4BF0:  MOVF   x0B,F
4BF2:  BNZ   4C02
....................       servoAccion(1,accionServo);
4BF4:  MOVLW  01
4BF6:  MOVWF  x0A
4BF8:  MOVFF  309,30B
4BFC:  MOVLB  0
4BFE:  RCALL  4A5C
4C00:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a CM2 */
....................    if (stricmp(key,boton2_key)==0) {
4C02:  MOVFF  306,30B
4C06:  MOVFF  305,30A
4C0A:  MOVLW  02
4C0C:  MOVWF  x0D
4C0E:  MOVLW  D4
4C10:  MOVWF  x0C
4C12:  MOVLB  0
4C14:  RCALL  479E
4C16:  MOVLB  3
4C18:  CLRF   x0B
4C1A:  MOVFF  01,30A
4C1E:  BTFSC  01.7
4C20:  DECF   x0B,F
4C22:  MOVF   x0A,F
4C24:  BNZ   4C38
4C26:  MOVF   x0B,F
4C28:  BNZ   4C38
....................       servoAccion(2,accionServo);
4C2A:  MOVLW  02
4C2C:  MOVWF  x0A
4C2E:  MOVFF  309,30B
4C32:  MOVLB  0
4C34:  RCALL  4A5C
4C36:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a CM3 */
....................    if (stricmp(key,boton3_key)==0) {
4C38:  MOVFF  306,30B
4C3C:  MOVFF  305,30A
4C40:  MOVLW  02
4C42:  MOVWF  x0D
4C44:  MOVLW  D8
4C46:  MOVWF  x0C
4C48:  MOVLB  0
4C4A:  RCALL  479E
4C4C:  MOVLB  3
4C4E:  CLRF   x0B
4C50:  MOVFF  01,30A
4C54:  BTFSC  01.7
4C56:  DECF   x0B,F
4C58:  MOVF   x0A,F
4C5A:  BNZ   4C6E
4C5C:  MOVF   x0B,F
4C5E:  BNZ   4C6E
....................       servoAccion(3,accionServo);
4C60:  MOVLW  03
4C62:  MOVWF  x0A
4C64:  MOVFF  309,30B
4C68:  MOVLB  0
4C6A:  RCALL  4A5C
4C6C:  MOVLB  3
....................    }
....................    /* Se ejecutará al recibir un request a lcd */
....................    if (stricmp(key,lcd_key)==0) {
4C6E:  MOVFF  306,30B
4C72:  MOVFF  305,30A
4C76:  MOVLW  02
4C78:  MOVWF  x0D
4C7A:  MOVLW  DC
4C7C:  MOVWF  x0C
4C7E:  MOVLB  0
4C80:  RCALL  479E
4C82:  MOVLB  3
4C84:  CLRF   x0B
4C86:  MOVFF  01,30A
4C8A:  BTFSC  01.7
4C8C:  DECF   x0B,F
4C8E:  MOVF   x0A,F
4C90:  BNZ   4CAC
4C92:  MOVF   x0B,F
4C94:  BNZ   4CAC
....................       printf(lcd_putc,"\f%s",val);  //Muestra en el lcd el texto recibido
4C96:  MOVLW  0C
4C98:  MOVWF  x0C
4C9A:  MOVLB  0
4C9C:  CALL   06E6
4CA0:  MOVFF  308,FEA
4CA4:  MOVFF  307,FE9
4CA8:  BRA    4B64
4CAA:  MOVLB  3
....................    }
4CAC:  MOVLB  0
4CAE:  GOTO   4D1C (RETURN)
.................... }
.................... 
.................... /************************** FUNCIÓN PRINCIPAL *********************************/
.................... void main(void) {
*
6E48:  CLRF   FF8
6E4A:  BCF    FD0.7
6E4C:  BSF    0B.7
6E4E:  CLRF   54
6E50:  CLRF   53
6E52:  CLRF   55
6E54:  CLRF   56
6E56:  CLRF   x7A
6E58:  CLRF   x79
6E5A:  MOVF   FC1,W
6E5C:  ANDLW  C0
6E5E:  IORLW  0F
6E60:  MOVWF  FC1
6E62:  MOVLW  07
6E64:  MOVWF  FB4
6E66:  BCF    5B.1
6E68:  BRA    6ECA
6E6A:  DATA 02,00
6E6C:  DATA 05,00
6E6E:  DATA 00,04
6E70:  DATA 40,5D
6E72:  DATA 00,01
6E74:  DATA 80,04
6E76:  DATA 0A,40
6E78:  DATA 64,00
6E7A:  DATA 03,80
6E7C:  DATA FE,00
6E7E:  DATA 01,01
6E80:  DATA 00,78
6E82:  DATA 00,07
6E84:  DATA 00,7B
6E86:  DATA 20,00
6E88:  DATA 3F,00
6E8A:  DATA 47,45
6E8C:  DATA 54,05
6E8E:  DATA C0,00
6E90:  DATA 28,41
6E92:  DATA 3C,00
6E94:  DATA 14,80
6E96:  DATA 50,4F
6E98:  DATA 53,54
6E9A:  DATA 00,43
6E9C:  DATA 6F,6E
6E9E:  DATA 74,65
6EA0:  DATA 6E,74
6EA2:  DATA 2D,4C
6EA4:  DATA 65,6E
6EA6:  DATA 67,74
6EA8:  DATA 68,3A
6EAA:  DATA FF,C0
6EAC:  DATA 00,07
6EAE:  DATA C0,00
6EB0:  DATA 46,42
6EB2:  DATA 88,00
6EB4:  DATA 12,80
6EB6:  DATA 2F,00
6EB8:  DATA 43,4D
6EBA:  DATA 31,00
6EBC:  DATA 43,4D
6EBE:  DATA 32,00
6EC0:  DATA 43,4D
6EC2:  DATA 33,00
6EC4:  DATA 6C,63
6EC6:  DATA 64,00
6EC8:  DATA 00,00
6ECA:  MOVLW  00
6ECC:  MOVWF  FF8
6ECE:  MOVLW  6E
6ED0:  MOVWF  FF7
6ED2:  MOVLW  6A
6ED4:  MOVWF  FF6
6ED6:  TBLRD*+
6ED8:  MOVF   FF5,W
6EDA:  MOVWF  00
6EDC:  XORLW  00
6EDE:  BZ    6F06
6EE0:  TBLRD*+
6EE2:  MOVF   FF5,W
6EE4:  MOVWF  01
6EE6:  BTFSC  FE8.7
6EE8:  BRA    6EF4
6EEA:  ANDLW  3F
6EEC:  MOVWF  FEA
6EEE:  TBLRD*+
6EF0:  MOVFF  FF5,FE9
6EF4:  BTFSC  01.6
6EF6:  TBLRD*+
6EF8:  BTFSS  01.6
6EFA:  TBLRD*+
6EFC:  MOVFF  FF5,FEE
6F00:  DCFSNZ 00,F
6F02:  BRA    6ED6
6F04:  BRA    6EF8
6F06:  CLRF   FF8
....................    /* Habilitación y configuración del canal analógico 0 */
....................    setup_adc(ADC_CLOCK_INTERNAL);
6F08:  MOVF   FC0,W
6F0A:  ANDLW  C0
6F0C:  IORLW  07
6F0E:  MOVWF  FC0
6F10:  BCF    FC0.7
6F12:  BSF    FC2.0
....................    setup_adc_ports(AN0);
6F14:  MOVF   FC1,W
6F16:  ANDLW  C0
6F18:  IORLW  0E
6F1A:  MOVWF  FC1
....................    set_adc_channel(0);
6F1C:  MOVLW  00
6F1E:  MOVWF  01
6F20:  MOVF   FC2,W
6F22:  ANDLW  C3
6F24:  IORWF  01,W
6F26:  MOVWF  FC2
....................    delay_ms(1);
6F28:  MOVLW  01
6F2A:  MOVLB  3
6F2C:  MOVWF  x13
6F2E:  MOVLB  0
6F30:  CALL   04E2
....................    
....................    /*Reset de las salidas */
....................    output_low(PIN_C0);
6F34:  BCF    F94.0
6F36:  BCF    F8B.0
....................    output_low(PIN_C1);
6F38:  BCF    F94.1
6F3A:  BCF    F8B.1
....................    output_low(PIN_C2);
6F3C:  BCF    F94.2
6F3E:  BCF    F8B.2
....................     
....................    /* Inicialización del lcd */
....................    lcd_init();
6F40:  GOTO   05FE
....................    printf(lcd_putc,"\fBeepControl");   //Mensaje de inicio en lcd 
6F44:  MOVLW  C0
6F46:  MOVWF  FF6
6F48:  MOVLW  04
6F4A:  MOVWF  FF7
6F4C:  GOTO   0758
....................    delay_ms(1000);
6F50:  MOVLW  04
6F52:  MOVLB  2
6F54:  MOVWF  xE0
6F56:  MOVLW  FA
6F58:  MOVLB  3
6F5A:  MOVWF  x13
6F5C:  MOVLB  0
6F5E:  CALL   04E2
6F62:  MOVLB  2
6F64:  DECFSZ xE0,F
6F66:  BRA    6F56
....................   
....................    /* Inicialización del Stack */
....................    MACAddrInit(); //Se asigna la dirección MAC elegida 
6F68:  MOVLB  0
6F6A:  GOTO   077A
....................    IPAddrInit();  //Se asigna IP, mascara de red y puerta de enlace elegidos
6F6E:  GOTO   0794
....................    StackInit();   //Inicializa el stack
6F72:  GOTO   1074
....................    
....................    /* Muestra la IP elegida en lcd */
....................    printf(lcd_putc,"\nIP: %u.%u.%u.%u:%u", MY_IP_BYTE1, MY_IP_BYTE2, MY_IP_BYTE3, MY_IP_BYTE4,HTTP_SOCKET);
6F76:  MOVLW  CE
6F78:  MOVWF  FF6
6F7A:  MOVLW  04
6F7C:  MOVWF  FF7
6F7E:  MOVLW  05
6F80:  MOVLB  2
6F82:  MOVWF  xE0
6F84:  MOVLB  0
6F86:  GOTO   108A
6F8A:  MOVFF  1D,2E0
6F8E:  MOVLW  1B
6F90:  MOVLB  2
6F92:  MOVWF  xE1
6F94:  MOVLB  0
6F96:  CALL   10E2
6F9A:  MOVLW  2E
6F9C:  MOVLB  3
6F9E:  MOVWF  x0C
6FA0:  MOVLB  0
6FA2:  CALL   06E6
6FA6:  MOVFF  1E,2E0
6FAA:  MOVLW  1B
6FAC:  MOVLB  2
6FAE:  MOVWF  xE1
6FB0:  MOVLB  0
6FB2:  CALL   10E2
6FB6:  MOVLW  2E
6FB8:  MOVLB  3
6FBA:  MOVWF  x0C
6FBC:  MOVLB  0
6FBE:  CALL   06E6
6FC2:  MOVFF  1F,2E0
6FC6:  MOVLW  1B
6FC8:  MOVLB  2
6FCA:  MOVWF  xE1
6FCC:  MOVLB  0
6FCE:  CALL   10E2
6FD2:  MOVLW  2E
6FD4:  MOVLB  3
6FD6:  MOVWF  x0C
6FD8:  MOVLB  0
6FDA:  CALL   06E6
6FDE:  MOVFF  20,2E0
6FE2:  MOVLW  1B
6FE4:  MOVLB  2
6FE6:  MOVWF  xE1
6FE8:  MOVLB  0
6FEA:  CALL   10E2
6FEE:  MOVLW  3A
6FF0:  MOVLB  3
6FF2:  MOVWF  x0C
6FF4:  MOVLB  0
6FF6:  CALL   06E6
6FFA:  MOVLW  50
6FFC:  MOVLB  2
6FFE:  MOVWF  xE0
7000:  MOVLW  1B
7002:  MOVWF  xE1
7004:  MOVLB  0
7006:  CALL   10E2
....................    delay_ms(10);
700A:  MOVLW  0A
700C:  MOVLB  3
700E:  MOVWF  x13
7010:  MOVLB  0
7012:  CALL   04E2
....................    while(TRUE) {
....................    StackTask();
7016:  BRA    6C68
7018:  BRA    7016
....................       }
.................... }
701A:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   PLL12 CPUDIV4 USBDIV HS FCMEN IESO
   Word  2: 1E26   PUT BROWNOUT VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: A00F   NOWRT NOWRTC WRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
